-- Generated by Hastlayer (hastlayer.com) at <date and time removed for approval testing> for the following hardware entry points: 
-- * System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)

-- VHDL libraries necessary for the generated code to work. These libraries are included here instead of being managed separately in the Hardware Framework so they can be more easily updated.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package TypeConversion is
    function SmartResize(input: unsigned; size: natural) return unsigned;
    function SmartResize(input: signed; size: natural) return signed;
    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned;
end TypeConversion;
        
package body TypeConversion is

    -- The .NET behavior is different than that of resize() ("To create a larger vector, the new [leftmost] bit 
    -- positions are filled with the sign bit(ARG'LEFT). When truncating, the sign bit is retained along with the 
    -- rightmost part.") when casting to a smaller type: "If the source type is larger than the destination type, 
    -- then the source value is truncated by discarding its "extra" most significant bits. The result is then 
    -- treated as a value of the destination type." Thus we need to simply truncate when casting down. See:
    -- https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions
    function SmartResize(input: unsigned; size: natural) return unsigned is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            -- Resize() is supposed to work with little endian numbers: "When truncating, the sign bit is retained
            -- along with the rightmost part." for signed numbers and "When truncating, the leftmost bits are 
            -- dropped." for unsigned ones. See: http://www.csee.umbc.edu/portal/help/VHDL/numeric_std.vhdl
            return resize(input, size);
        end if;
    end SmartResize;

    function SmartResize(input: signed; size: natural) return signed is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            return resize(input, size);
        end if;
    end SmartResize;

    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned is
        variable result: unsigned(size - 1 downto 0);
    begin
        if (input >= 0) then
            return resize(unsigned(input), size);
        else 
            result := (others => '1');
            result(input'LENGTH - 1 downto 0) := unsigned(input);
            return result;
        end if;
    end ToUnsignedAndExpand;

end TypeConversion;


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
        
package SimpleMemory is
    -- Data conversion functions:
    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned;
        
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector;
    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean;
        
    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed;
end SimpleMemory;
        
package body SimpleMemory is

    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertUInt32ToStdLogicVector;
    
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned is
    begin
        return unsigned(input);
    end ConvertStdLogicVectorToUInt32;
    
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector is 
    begin
        case input is
            when true => return X"FFFFFFFF";
            when false => return X"00000000";
            when others => return X"00000000";
        end case;
    end ConvertBooleanToStdLogicVector;

    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean is 
    begin
        -- In .NET a false is all zeros while a true is at least one 1 bit (or more), so using the same logic here.
        return not(input = X"00000000");
    end ConvertStdLogicVectorToBoolean;

    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertInt32ToStdLogicVector;

    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed is
    begin
        return signed(input);
    end ConvertStdLogicVectorToInt32;

end SimpleMemory;

-- Hast_IP, logic generated from the input .NET assemblies starts here.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library work;
use work.TypeConversion.all;
library work;
use work.SimpleMemory.all;

entity Hast_IP is 
    port(
        \DataIn\: In std_logic_vector(31 downto 0);
        \DataOut\: Out std_logic_vector(31 downto 0);
        \CellIndex\: Out integer;
        \ReadEnable\: Out boolean;
        \WriteEnable\: Out boolean;
        \ReadsDone\: In boolean;
        \WritesDone\: In boolean;
        \MemberId\: In integer;
        \Reset\: In std_logic;
        \Started\: In boolean;
        \Finished\: Out boolean;
        \Clock\: In std_logic
    );
    -- (Hast_IP ID removed for approval testing.)
    -- (Date and time removed for approval testing.)
    -- Generated by Hastlayer - hastlayer.com
end Hast_IP;

architecture Imp of Hast_IP is 
    -- This IP was generated by Hastlayer from .NET code to mimic the original logic. Note the following:
    -- * For each member (methods, functions) in .NET a state machine was generated. Each state machine's name corresponds to 
    --   the original member's name.
    -- * Inputs and outputs are passed between state machines as shared objects.
    -- * There are operations that take multiple clock cycles like interacting with the memory and long-running arithmetic operations 
    --   (modulo, division, multiplication). These are awaited in subsequent states but be aware that some states can take more 
    --   than one clock cycle to produce their output.
    -- * The ExternalInvocationProxy process dispatches invocations that were started from the outside to the state machines.
    -- * The InternalInvocationProxy processes dispatch invocations between state machines.

    -- Custom inter-dependent type declarations start
    type \unsigned32_Array\ is array (integer range <>) of unsigned(31 downto 0);
    type \Lombiq.Arithmetics.BitMask\ is record 
        \IsNull\: boolean;
        \Size\: unsigned(15 downto 0);
        \SegmentCount\: unsigned(15 downto 0);
        \Segments\: \unsigned32_Array\(0 to 0);
    end record;
    type \Lombiq.Arithmetics.PositEnvironment\ is record 
        \IsNull\: boolean;
        \MaximumExponentSize\: unsigned(7 downto 0);
        \Size\: unsigned(15 downto 0);
        \Useed\: unsigned(31 downto 0);
        \FirstRegimeBitIndex\: unsigned(15 downto 0);
        \SignBitMask\: \Lombiq.Arithmetics.BitMask\;
        \FirstRegimeBitBitMask\: \Lombiq.Arithmetics.BitMask\;
        \EmptyBitMask\: \Lombiq.Arithmetics.BitMask\;
        \MaxValueBitMask\: \Lombiq.Arithmetics.BitMask\;
        \MinValueBitMask\: \Lombiq.Arithmetics.BitMask\;
        \NaNBitMask\: \Lombiq.Arithmetics.BitMask\;
        \QuireSize\: unsigned(31 downto 0);
    end record;
    type \Lombiq.Arithmetics.Posit\ is record 
        \IsNull\: boolean;
        \_environment\: \Lombiq.Arithmetics.PositEnvironment\;
        \PositBits\: \Lombiq.Arithmetics.BitMask\;
    end record;
    -- Custom inter-dependent type declarations end


    -- System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._States\ is (
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_1\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_2\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_3\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_6\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_7\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_8\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_9\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_10\);
    -- Signals:
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0);
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.Out.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).value.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit).left.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit).right.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit)._Started.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit)._Started.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Finished.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory().return.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.In.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Finished.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit)._Finished.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit).return.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit)._Finished.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit).return.0\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory().0 declarations start
    -- State machine states:
    type \PositCalculator::EnvironmentFactory().0._States\ is (
        \PositCalculator::EnvironmentFactory().0._State_0\, 
        \PositCalculator::EnvironmentFactory().0._State_1\, 
        \PositCalculator::EnvironmentFactory().0._State_2\, 
        \PositCalculator::EnvironmentFactory().0._State_3\);
    -- Signals:
    Signal \PositCalculator::EnvironmentFactory().0._Finished\: boolean := false;
    Signal \PositCalculator::EnvironmentFactory().0.return\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.Out.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).size.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).maximumExponentSize.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\: boolean := false;
    Signal \PositCalculator::EnvironmentFactory().0._Started\: boolean := false;
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.In.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory().0 declarations end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::.ctor(UInt32,UInt16).0._States\ is (
        \BitMask::.ctor(UInt32,UInt16).0._State_0\, 
        \BitMask::.ctor(UInt32,UInt16).0._State_1\, 
        \BitMask::.ctor(UInt32,UInt16).0._State_2\, 
        \BitMask::.ctor(UInt32,UInt16).0._State_3\, 
        \BitMask::.ctor(UInt32,UInt16).0._State_4\, 
        \BitMask::.ctor(UInt32,UInt16).0._State_5\);
    -- Signals:
    Signal \BitMask::.ctor(UInt32,UInt16).0._Finished\: boolean := false;
    Signal \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt32,UInt16).0._Started\: boolean := false;
    Signal \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16).0 declarations end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::.ctor(UInt32[],UInt16).0._States\ is (
        \BitMask::.ctor(UInt32[],UInt16).0._State_0\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_1\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_2\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_3\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_4\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_5\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_6\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_7\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_8\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_9\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_10\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_11\);
    -- Signals:
    Signal \BitMask::.ctor(UInt32[],UInt16).0._Finished\: boolean := false;
    Signal \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::.ctor(UInt32[],UInt16).0._Started\: boolean := false;
    Signal \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16).0 declarations end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean).0 declarations start
    -- State machine states:
    type \BitMask::.ctor(UInt16,Boolean).0._States\ is (
        \BitMask::.ctor(UInt16,Boolean).0._State_0\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_1\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_2\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_3\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_4\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_5\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_6\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_7\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_8\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_9\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_10\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_11\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_12\);
    -- Signals:
    Signal \BitMask::.ctor(UInt16,Boolean).0._Finished\: boolean := false;
    Signal \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt16,Boolean).0._Started\: boolean := false;
    Signal \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\: boolean := false;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean).0 declarations end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask::.ctor(BitMask).0._States\ is (
        \BitMask::.ctor(BitMask).0._State_0\, 
        \BitMask::.ctor(BitMask).0._State_1\, 
        \BitMask::.ctor(BitMask).0._State_2\);
    -- Signals:
    Signal \BitMask::.ctor(BitMask).0._Finished\: boolean := false;
    Signal \BitMask::.ctor(BitMask).0.this.parameter.Out\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(BitMask).0.source.parameter.Out\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(BitMask).0._Started\: boolean := false;
    Signal \BitMask::.ctor(BitMask).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(BitMask).0.source.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::FromImmutableArray(UInt32[],UInt16).0._States\ is (
        \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_0\, 
        \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_1\, 
        \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_2\, 
        \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_3\);
    -- Signals:
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\: boolean := false;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\: boolean := false;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.In\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::SetOne(UInt16).0._States\ is (
        \BitMask::SetOne(UInt16).0._State_0\, 
        \BitMask::SetOne(UInt16).0._State_1\, 
        \BitMask::SetOne(UInt16).0._State_2\, 
        \BitMask::SetOne(UInt16).0._State_3\, 
        \BitMask::SetOne(UInt16).0._State_4\, 
        \BitMask::SetOne(UInt16).0._State_5\, 
        \BitMask::SetOne(UInt16).0._State_6\, 
        \BitMask::SetOne(UInt16).0._State_7\, 
        \BitMask::SetOne(UInt16).0._State_8\, 
        \BitMask::SetOne(UInt16).0._State_9\, 
        \BitMask::SetOne(UInt16).0._State_10\, 
        \BitMask::SetOne(UInt16).0._State_11\, 
        \BitMask::SetOne(UInt16).0._State_12\);
    -- Signals:
    Signal \BitMask::SetOne(UInt16).0._Finished\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0._Started\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.index.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::SetZero(UInt16).0._States\ is (
        \BitMask::SetZero(UInt16).0._State_0\, 
        \BitMask::SetZero(UInt16).0._State_1\, 
        \BitMask::SetZero(UInt16).0._State_2\, 
        \BitMask::SetZero(UInt16).0._State_3\, 
        \BitMask::SetZero(UInt16).0._State_4\, 
        \BitMask::SetZero(UInt16).0._State_5\, 
        \BitMask::SetZero(UInt16).0._State_6\, 
        \BitMask::SetZero(UInt16).0._State_7\, 
        \BitMask::SetZero(UInt16).0._State_8\, 
        \BitMask::SetZero(UInt16).0._State_9\, 
        \BitMask::SetZero(UInt16).0._State_10\, 
        \BitMask::SetZero(UInt16).0._State_11\, 
        \BitMask::SetZero(UInt16).0._State_12\);
    -- Signals:
    Signal \BitMask::SetZero(UInt16).0._Finished\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0._Started\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.index.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask::op_Equality(BitMask,BitMask).0._States\ is (
        \BitMask::op_Equality(BitMask,BitMask).0._State_0\, 
        \BitMask::op_Equality(BitMask,BitMask).0._State_1\, 
        \BitMask::op_Equality(BitMask,BitMask).0._State_2\, 
        \BitMask::op_Equality(BitMask,BitMask).0._State_3\, 
        \BitMask::op_Equality(BitMask,BitMask).0._State_4\, 
        \BitMask::op_Equality(BitMask,BitMask).0._State_5\, 
        \BitMask::op_Equality(BitMask,BitMask).0._State_6\, 
        \BitMask::op_Equality(BitMask,BitMask).0._State_7\, 
        \BitMask::op_Equality(BitMask,BitMask).0._State_8\, 
        \BitMask::op_Equality(BitMask,BitMask).0._State_9\);
    -- Signals:
    Signal \BitMask::op_Equality(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \BitMask::op_Equality(BitMask,BitMask).0.return\: boolean := false;
    Signal \BitMask::op_Equality(BitMask,BitMask).0._Started\: boolean := false;
    Signal \BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask::op_LessThan(BitMask,BitMask).0._States\ is (
        \BitMask::op_LessThan(BitMask,BitMask).0._State_0\, 
        \BitMask::op_LessThan(BitMask,BitMask).0._State_1\, 
        \BitMask::op_LessThan(BitMask,BitMask).0._State_2\, 
        \BitMask::op_LessThan(BitMask,BitMask).0._State_3\, 
        \BitMask::op_LessThan(BitMask,BitMask).0._State_4\, 
        \BitMask::op_LessThan(BitMask,BitMask).0._State_5\, 
        \BitMask::op_LessThan(BitMask,BitMask).0._State_6\, 
        \BitMask::op_LessThan(BitMask,BitMask).0._State_7\);
    -- Signals:
    Signal \BitMask::op_LessThan(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \BitMask::op_LessThan(BitMask,BitMask).0.return\: boolean := false;
    Signal \BitMask::op_LessThan(BitMask,BitMask).0._Started\: boolean := false;
    Signal \BitMask::op_LessThan(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_LessThan(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._States\ is (
        \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_0\, 
        \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_1\, 
        \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_2\, 
        \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_3\);
    -- Signals:
    Signal \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return\: boolean := false;
    Signal \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\: boolean := false;
    Signal \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask).return.0\: boolean := false;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0 declarations start
    -- State machine states:
    type \BitMask::op_Addition(BitMask,UInt32).0._States\ is (
        \BitMask::op_Addition(BitMask,UInt32).0._State_0\, 
        \BitMask::op_Addition(BitMask,UInt32).0._State_1\, 
        \BitMask::op_Addition(BitMask,UInt32).0._State_2\, 
        \BitMask::op_Addition(BitMask,UInt32).0._State_3\, 
        \BitMask::op_Addition(BitMask,UInt32).0._State_4\);
    -- Signals:
    Signal \BitMask::op_Addition(BitMask,UInt32).0._Finished\: boolean := false;
    Signal \BitMask::op_Addition(BitMask,UInt32).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \BitMask::op_Addition(BitMask,UInt32).0._Started\: boolean := false;
    Signal \BitMask::op_Addition(BitMask,UInt32).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Addition(BitMask,UInt32).0.right.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0 declarations start
    -- State machine states:
    type \BitMask::op_Subtraction(BitMask,UInt32).0._States\ is (
        \BitMask::op_Subtraction(BitMask,UInt32).0._State_0\, 
        \BitMask::op_Subtraction(BitMask,UInt32).0._State_1\, 
        \BitMask::op_Subtraction(BitMask,UInt32).0._State_2\, 
        \BitMask::op_Subtraction(BitMask,UInt32).0._State_3\, 
        \BitMask::op_Subtraction(BitMask,UInt32).0._State_4\);
    -- Signals:
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0._Finished\: boolean := false;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0._Started\: boolean := false;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.right.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask::op_Addition(BitMask,BitMask).0._States\ is (
        \BitMask::op_Addition(BitMask,BitMask).0._State_0\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_1\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_2\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_3\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_4\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_5\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_6\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_7\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_8\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_9\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_10\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_11\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_12\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_13\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_14\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_15\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_16\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_17\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_18\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_19\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_20\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_21\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_22\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_23\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_24\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_25\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_26\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_27\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_28\, 
        \BitMask::op_Addition(BitMask,BitMask).0._State_29\);
    -- Signals:
    Signal \BitMask::op_Addition(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \BitMask::op_Addition(BitMask,BitMask).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::op_Addition(BitMask,BitMask).0._Started\: boolean := false;
    Signal \BitMask::op_Addition(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Addition(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask::op_Subtraction(BitMask,BitMask).0._States\ is (
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_0\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_1\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_2\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_3\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_4\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_5\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_6\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_7\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_8\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_9\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_10\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_11\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_12\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_13\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_14\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_15\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_16\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_17\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_18\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_19\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_20\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_21\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_22\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_23\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_24\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_25\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_26\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_27\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_28\, 
        \BitMask::op_Subtraction(BitMask,BitMask).0._State_29\);
    -- Signals:
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0._Started\: boolean := false;
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask::op_BitwiseAnd(BitMask,BitMask).0._States\ is (
        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_0\, 
        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_1\, 
        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\, 
        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_3\, 
        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_4\, 
        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_5\, 
        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\, 
        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_7\, 
        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_8\, 
        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_9\);
    -- Signals:
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\: boolean := false;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\: boolean := false;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\: boolean := false;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\: boolean := false;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask::op_OnesComplement(BitMask).0._States\ is (
        \BitMask::op_OnesComplement(BitMask).0._State_0\, 
        \BitMask::op_OnesComplement(BitMask).0._State_1\, 
        \BitMask::op_OnesComplement(BitMask).0._State_2\, 
        \BitMask::op_OnesComplement(BitMask).0._State_3\, 
        \BitMask::op_OnesComplement(BitMask).0._State_4\, 
        \BitMask::op_OnesComplement(BitMask).0._State_5\);
    -- Signals:
    Signal \BitMask::op_OnesComplement(BitMask).0._Finished\: boolean := false;
    Signal \BitMask::op_OnesComplement(BitMask).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::op_OnesComplement(BitMask).0._Started\: boolean := false;
    Signal \BitMask::op_OnesComplement(BitMask).0.input.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0 declarations start
    -- State machine states:
    type \BitMask::op_RightShift(BitMask,Int32).0._States\ is (
        \BitMask::op_RightShift(BitMask,Int32).0._State_0\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_1\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_2\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_3\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_4\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_5\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_6\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_7\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_8\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_9\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_10\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_11\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_12\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_13\, 
        \BitMask::op_RightShift(BitMask,Int32).0._State_14\);
    -- Signals:
    Signal \BitMask::op_RightShift(BitMask,Int32).0._Finished\: boolean := false;
    Signal \BitMask::op_RightShift(BitMask,Int32).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::op_RightShift(BitMask,Int32).0._Started\: boolean := false;
    Signal \BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0 declarations start
    -- State machine states:
    type \BitMask::op_LeftShift(BitMask,Int32).0._States\ is (
        \BitMask::op_LeftShift(BitMask,Int32).0._State_0\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_1\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_2\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_3\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_4\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_5\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_6\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_7\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_8\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_9\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_10\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_11\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_12\, 
        \BitMask::op_LeftShift(BitMask,Int32).0._State_13\);
    -- Signals:
    Signal \BitMask::op_LeftShift(BitMask,Int32).0._Finished\: boolean := false;
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::op_LeftShift(BitMask,Int32).0._Started\: boolean := false;
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0 declarations end


    -- System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition().0 declarations start
    -- State machine states:
    type \BitMask::GetMostSignificantOnePosition().0._States\ is (
        \BitMask::GetMostSignificantOnePosition().0._State_0\, 
        \BitMask::GetMostSignificantOnePosition().0._State_1\, 
        \BitMask::GetMostSignificantOnePosition().0._State_2\, 
        \BitMask::GetMostSignificantOnePosition().0._State_3\, 
        \BitMask::GetMostSignificantOnePosition().0._State_4\, 
        \BitMask::GetMostSignificantOnePosition().0._State_5\, 
        \BitMask::GetMostSignificantOnePosition().0._State_6\, 
        \BitMask::GetMostSignificantOnePosition().0._State_7\, 
        \BitMask::GetMostSignificantOnePosition().0._State_8\, 
        \BitMask::GetMostSignificantOnePosition().0._State_9\);
    -- Signals:
    Signal \BitMask::GetMostSignificantOnePosition().0._Finished\: boolean := false;
    Signal \BitMask::GetMostSignificantOnePosition().0.return\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::GetMostSignificantOnePosition().0._Started\: boolean := false;
    Signal \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    -- System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::GetTwosComplement(UInt16).0._States\ is (
        \BitMask::GetTwosComplement(UInt16).0._State_0\, 
        \BitMask::GetTwosComplement(UInt16).0._State_1\, 
        \BitMask::GetTwosComplement(UInt16).0._State_2\, 
        \BitMask::GetTwosComplement(UInt16).0._State_3\, 
        \BitMask::GetTwosComplement(UInt16).0._State_4\, 
        \BitMask::GetTwosComplement(UInt16).0._State_5\, 
        \BitMask::GetTwosComplement(UInt16).0._State_6\, 
        \BitMask::GetTwosComplement(UInt16).0._State_7\);
    -- Signals:
    Signal \BitMask::GetTwosComplement(UInt16).0._Finished\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask).input.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask)._Started.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0._Started\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0 declarations end


    -- System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::LengthOfRunOfBits(UInt16).0._States\ is (
        \BitMask::LengthOfRunOfBits(UInt16).0._State_0\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_1\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_2\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_3\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_4\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_5\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_6\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_7\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_8\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_9\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_10\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_11\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_12\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_13\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_14\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_15\);
    -- Signals:
    Signal \BitMask::LengthOfRunOfBits(UInt16).0._Finished\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.return\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0._Started\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits().0 declarations start
    -- State machine states:
    type \BitMask::GetLowest32Bits().0._States\ is (
        \BitMask::GetLowest32Bits().0._State_0\, 
        \BitMask::GetLowest32Bits().0._State_1\, 
        \BitMask::GetLowest32Bits().0._State_2\);
    -- Signals:
    Signal \BitMask::GetLowest32Bits().0._Finished\: boolean := false;
    Signal \BitMask::GetLowest32Bits().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask::GetLowest32Bits().0._Started\: boolean := false;
    Signal \BitMask::GetLowest32Bits().0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    -- System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits().0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \Posit::.ctor(PositEnvironment,BitMask).0._States\ is (
        \Posit::.ctor(PositEnvironment,BitMask).0._State_0\, 
        \Posit::.ctor(PositEnvironment,BitMask).0._State_1\, 
        \Posit::.ctor(PositEnvironment,BitMask).0._State_2\, 
        \Posit::.ctor(PositEnvironment,BitMask).0._State_3\);
    -- Signals:
    Signal \Posit::.ctor(PositEnvironment,BitMask).0._Finished\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.Out\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0._Started\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.In\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.bits.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0 declarations start
    -- State machine states:
    type \Posit::.ctor(PositEnvironment,UInt32).0._States\ is (
        \Posit::.ctor(PositEnvironment,UInt32).0._State_0\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_1\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_2\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_3\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_4\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_5\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_6\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_7\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_8\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_9\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_10\);
    -- Signals:
    Signal \Posit::.ctor(PositEnvironment,UInt32).0._Finished\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.Out\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0._Started\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.In\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.value.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32).0 declarations start
    -- State machine states:
    type \Posit::.ctor(PositEnvironment,Int32).0._States\ is (
        \Posit::.ctor(PositEnvironment,Int32).0._State_0\, 
        \Posit::.ctor(PositEnvironment,Int32).0._State_1\, 
        \Posit::.ctor(PositEnvironment,Int32).0._State_2\, 
        \Posit::.ctor(PositEnvironment,Int32).0._State_3\);
    -- Signals:
    Signal \Posit::.ctor(PositEnvironment,Int32).0._Finished\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.Out\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.Out.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).value.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,Int32).0._Started\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.In\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.value.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.In.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Finished.0\: boolean := false;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0 declarations start
    -- State machine states:
    type \Posit::IsPositive().0._States\ is (
        \Posit::IsPositive().0._State_0\, 
        \Posit::IsPositive().0._State_1\, 
        \Posit::IsPositive().0._State_2\, 
        \Posit::IsPositive().0._State_3\, 
        \Posit::IsPositive().0._State_4\, 
        \Posit::IsPositive().0._State_5\, 
        \Posit::IsPositive().0._State_6\);
    -- Signals:
    Signal \Posit::IsPositive().0._Finished\: boolean := false;
    Signal \Posit::IsPositive().0.return\: boolean := false;
    Signal \Posit::IsPositive().0.Posit::get_SignBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\: boolean := false;
    Signal \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::IsPositive().0.Posit::get_EmptyBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\: boolean := false;
    Signal \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::IsPositive().0._Started\: boolean := false;
    Signal \Posit::IsPositive().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsPositive().0.Posit::get_SignBitMask()._Finished.0\: boolean := false;
    Signal \Posit::IsPositive().0.Posit::get_SignBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\: boolean := false;
    Signal \Posit::IsPositive().0.Posit::get_EmptyBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask).return.0\: boolean := false;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0 declarations start
    -- State machine states:
    type \Posit::IsNaN().0._States\ is (
        \Posit::IsNaN().0._State_0\, 
        \Posit::IsNaN().0._State_1\, 
        \Posit::IsNaN().0._State_2\, 
        \Posit::IsNaN().0._State_3\, 
        \Posit::IsNaN().0._State_4\);
    -- Signals:
    Signal \Posit::IsNaN().0._Finished\: boolean := false;
    Signal \Posit::IsNaN().0.return\: boolean := false;
    Signal \Posit::IsNaN().0.Posit::get_NaNBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\: boolean := false;
    Signal \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::IsNaN().0._Started\: boolean := false;
    Signal \Posit::IsNaN().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsNaN().0.Posit::get_NaNBitMask()._Finished.0\: boolean := false;
    Signal \Posit::IsNaN().0.Posit::get_NaNBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask).return.0\: boolean := false;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsZero().0 declarations start
    -- State machine states:
    type \Posit::IsZero().0._States\ is (
        \Posit::IsZero().0._State_0\, 
        \Posit::IsZero().0._State_1\, 
        \Posit::IsZero().0._State_2\, 
        \Posit::IsZero().0._State_3\, 
        \Posit::IsZero().0._State_4\);
    -- Signals:
    Signal \Posit::IsZero().0._Finished\: boolean := false;
    Signal \Posit::IsZero().0.return\: boolean := false;
    Signal \Posit::IsZero().0.Posit::get_EmptyBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\: boolean := false;
    Signal \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::IsZero().0._Started\: boolean := false;
    Signal \Posit::IsZero().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\: boolean := false;
    Signal \Posit::IsZero().0.Posit::get_EmptyBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask).return.0\: boolean := false;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsZero().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0 declarations start
    -- State machine states:
    type \Posit::EncodeRegimeBits(Int32).0._States\ is (
        \Posit::EncodeRegimeBits(Int32).0._State_0\, 
        \Posit::EncodeRegimeBits(Int32).0._State_1\, 
        \Posit::EncodeRegimeBits(Int32).0._State_2\, 
        \Posit::EncodeRegimeBits(Int32).0._State_3\, 
        \Posit::EncodeRegimeBits(Int32).0._State_4\, 
        \Posit::EncodeRegimeBits(Int32).0._State_5\, 
        \Posit::EncodeRegimeBits(Int32).0._State_6\, 
        \Posit::EncodeRegimeBits(Int32).0._State_7\, 
        \Posit::EncodeRegimeBits(Int32).0._State_8\, 
        \Posit::EncodeRegimeBits(Int32).0._State_9\, 
        \Posit::EncodeRegimeBits(Int32).0._State_10\, 
        \Posit::EncodeRegimeBits(Int32).0._State_11\, 
        \Posit::EncodeRegimeBits(Int32).0._State_12\);
    -- Signals:
    Signal \Posit::EncodeRegimeBits(Int32).0._Finished\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32).right.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32)._Started.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0._Started\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32)._Finished.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._States\ is (
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_0\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_1\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_2\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_3\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_4\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_5\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_6\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_8\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_9\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_10\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_11\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_12\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_15\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_16\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_17\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_19\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_20\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_21\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_22\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_23\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_24\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_27\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_28\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_29\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_30\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_31\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_32\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_33\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_35\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_37\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_38\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_39\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_40\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_41\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_42\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_43\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_44\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_45\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_47\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_48\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_49\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_50\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_51\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_52\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_53\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_54\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_55\);
    -- Signals:
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit.parameter.In\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).return.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0 declarations start
    -- State machine states:
    type \Posit::GetRegimeKValue().0._States\ is (
        \Posit::GetRegimeKValue().0._State_0\, 
        \Posit::GetRegimeKValue().0._State_1\, 
        \Posit::GetRegimeKValue().0._State_2\, 
        \Posit::GetRegimeKValue().0._State_3\, 
        \Posit::GetRegimeKValue().0._State_4\, 
        \Posit::GetRegimeKValue().0._State_5\, 
        \Posit::GetRegimeKValue().0._State_6\, 
        \Posit::GetRegimeKValue().0._State_7\, 
        \Posit::GetRegimeKValue().0._State_8\, 
        \Posit::GetRegimeKValue().0._State_9\, 
        \Posit::GetRegimeKValue().0._State_10\, 
        \Posit::GetRegimeKValue().0._State_11\, 
        \Posit::GetRegimeKValue().0._State_12\, 
        \Posit::GetRegimeKValue().0._State_13\, 
        \Posit::GetRegimeKValue().0._State_14\, 
        \Posit::GetRegimeKValue().0._State_15\, 
        \Posit::GetRegimeKValue().0._State_16\, 
        \Posit::GetRegimeKValue().0._State_17\);
    -- Signals:
    Signal \Posit::GetRegimeKValue().0._Finished\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::GetRegimeKValue().0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0._Started\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask).return.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0 declarations start
    -- State machine states:
    type \Posit::ExponentSize().0._States\ is (
        \Posit::ExponentSize().0._State_0\, 
        \Posit::ExponentSize().0._State_1\, 
        \Posit::ExponentSize().0._State_2\, 
        \Posit::ExponentSize().0._State_3\, 
        \Posit::ExponentSize().0._State_4\, 
        \Posit::ExponentSize().0._State_5\, 
        \Posit::ExponentSize().0._State_6\, 
        \Posit::ExponentSize().0._State_7\, 
        \Posit::ExponentSize().0._State_8\, 
        \Posit::ExponentSize().0._State_9\, 
        \Posit::ExponentSize().0._State_10\, 
        \Posit::ExponentSize().0._State_11\, 
        \Posit::ExponentSize().0._State_12\);
    -- Signals:
    Signal \Posit::ExponentSize().0._Finished\: boolean := false;
    Signal \Posit::ExponentSize().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::ExponentSize().0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::ExponentSize().0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\: boolean := false;
    Signal \Posit::ExponentSize().0._Started\: boolean := false;
    Signal \Posit::ExponentSize().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::ExponentSize().0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0 declarations start
    -- State machine states:
    type \Posit::GetExponentValue().0._States\ is (
        \Posit::GetExponentValue().0._State_0\, 
        \Posit::GetExponentValue().0._State_1\, 
        \Posit::GetExponentValue().0._State_2\, 
        \Posit::GetExponentValue().0._State_3\, 
        \Posit::GetExponentValue().0._State_4\, 
        \Posit::GetExponentValue().0._State_5\, 
        \Posit::GetExponentValue().0._State_6\, 
        \Posit::GetExponentValue().0._State_7\, 
        \Posit::GetExponentValue().0._State_8\, 
        \Posit::GetExponentValue().0._State_9\, 
        \Posit::GetExponentValue().0._State_10\, 
        \Posit::GetExponentValue().0._State_11\, 
        \Posit::GetExponentValue().0._State_12\, 
        \Posit::GetExponentValue().0._State_13\, 
        \Posit::GetExponentValue().0._State_14\, 
        \Posit::GetExponentValue().0._State_15\, 
        \Posit::GetExponentValue().0._State_16\);
    -- Signals:
    Signal \Posit::GetExponentValue().0._Finished\: boolean := false;
    Signal \Posit::GetExponentValue().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::GetExponentValue().0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.Posit::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.Posit::ExponentSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0._Started\: boolean := false;
    Signal \Posit::GetExponentValue().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.Posit::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::GetExponentValue().0.Posit::ExponentSize()._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.Posit::ExponentSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0 declarations start
    -- State machine states:
    type \Posit::FractionSize().0._States\ is (
        \Posit::FractionSize().0._State_0\, 
        \Posit::FractionSize().0._State_1\, 
        \Posit::FractionSize().0._State_2\, 
        \Posit::FractionSize().0._State_3\, 
        \Posit::FractionSize().0._State_4\, 
        \Posit::FractionSize().0._State_5\, 
        \Posit::FractionSize().0._State_6\, 
        \Posit::FractionSize().0._State_7\, 
        \Posit::FractionSize().0._State_8\, 
        \Posit::FractionSize().0._State_9\, 
        \Posit::FractionSize().0._State_10\, 
        \Posit::FractionSize().0._State_11\, 
        \Posit::FractionSize().0._State_12\);
    -- Signals:
    Signal \Posit::FractionSize().0._Finished\: boolean := false;
    Signal \Posit::FractionSize().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::FractionSize().0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::FractionSize().0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\: boolean := false;
    Signal \Posit::FractionSize().0._Started\: boolean := false;
    Signal \Posit::FractionSize().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::FractionSize().0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0 declarations start
    -- State machine states:
    type \Posit::FractionWithHiddenBit().0._States\ is (
        \Posit::FractionWithHiddenBit().0._State_0\, 
        \Posit::FractionWithHiddenBit().0._State_1\, 
        \Posit::FractionWithHiddenBit().0._State_2\, 
        \Posit::FractionWithHiddenBit().0._State_3\, 
        \Posit::FractionWithHiddenBit().0._State_4\, 
        \Posit::FractionWithHiddenBit().0._State_5\, 
        \Posit::FractionWithHiddenBit().0._State_6\, 
        \Posit::FractionWithHiddenBit().0._State_7\, 
        \Posit::FractionWithHiddenBit().0._State_8\, 
        \Posit::FractionWithHiddenBit().0._State_9\, 
        \Posit::FractionWithHiddenBit().0._State_10\, 
        \Posit::FractionWithHiddenBit().0._State_11\, 
        \Posit::FractionWithHiddenBit().0._State_12\, 
        \Posit::FractionWithHiddenBit().0._State_13\, 
        \Posit::FractionWithHiddenBit().0._State_14\, 
        \Posit::FractionWithHiddenBit().0._State_15\);
    -- Signals:
    Signal \Posit::FractionWithHiddenBit().0._Finished\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.Posit::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0._Started\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.Posit::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0 declarations end


    -- System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte).0 declarations start
    -- State machine states:
    type \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._States\ is (
        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_0\, 
        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_1\, 
        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_2\);
    -- Signals:
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Finished\: boolean := false;
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Started\: boolean := false;
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte).0 declarations end


    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 declarations start
    -- State machine states:
    type \Posit::op_Addition(Posit,Posit).0._States\ is (
        \Posit::op_Addition(Posit,Posit).0._State_0\, 
        \Posit::op_Addition(Posit,Posit).0._State_1\, 
        \Posit::op_Addition(Posit,Posit).0._State_2\, 
        \Posit::op_Addition(Posit,Posit).0._State_3\, 
        \Posit::op_Addition(Posit,Posit).0._State_4\, 
        \Posit::op_Addition(Posit,Posit).0._State_5\, 
        \Posit::op_Addition(Posit,Posit).0._State_6\, 
        \Posit::op_Addition(Posit,Posit).0._State_7\, 
        \Posit::op_Addition(Posit,Posit).0._State_8\, 
        \Posit::op_Addition(Posit,Posit).0._State_9\, 
        \Posit::op_Addition(Posit,Posit).0._State_10\, 
        \Posit::op_Addition(Posit,Posit).0._State_11\, 
        \Posit::op_Addition(Posit,Posit).0._State_12\, 
        \Posit::op_Addition(Posit,Posit).0._State_13\, 
        \Posit::op_Addition(Posit,Posit).0._State_14\, 
        \Posit::op_Addition(Posit,Posit).0._State_15\, 
        \Posit::op_Addition(Posit,Posit).0._State_16\, 
        \Posit::op_Addition(Posit,Posit).0._State_17\, 
        \Posit::op_Addition(Posit,Posit).0._State_18\, 
        \Posit::op_Addition(Posit,Posit).0._State_19\, 
        \Posit::op_Addition(Posit,Posit).0._State_20\, 
        \Posit::op_Addition(Posit,Posit).0._State_21\, 
        \Posit::op_Addition(Posit,Posit).0._State_22\, 
        \Posit::op_Addition(Posit,Posit).0._State_23\, 
        \Posit::op_Addition(Posit,Posit).0._State_24\, 
        \Posit::op_Addition(Posit,Posit).0._State_25\, 
        \Posit::op_Addition(Posit,Posit).0._State_26\, 
        \Posit::op_Addition(Posit,Posit).0._State_27\, 
        \Posit::op_Addition(Posit,Posit).0._State_28\, 
        \Posit::op_Addition(Posit,Posit).0._State_29\, 
        \Posit::op_Addition(Posit,Posit).0._State_30\, 
        \Posit::op_Addition(Posit,Posit).0._State_31\, 
        \Posit::op_Addition(Posit,Posit).0._State_32\, 
        \Posit::op_Addition(Posit,Posit).0._State_33\, 
        \Posit::op_Addition(Posit,Posit).0._State_34\, 
        \Posit::op_Addition(Posit,Posit).0._State_35\, 
        \Posit::op_Addition(Posit,Posit).0._State_36\, 
        \Posit::op_Addition(Posit,Posit).0._State_37\, 
        \Posit::op_Addition(Posit,Posit).0._State_38\, 
        \Posit::op_Addition(Posit,Posit).0._State_39\, 
        \Posit::op_Addition(Posit,Posit).0._State_40\, 
        \Posit::op_Addition(Posit,Posit).0._State_41\, 
        \Posit::op_Addition(Posit,Posit).0._State_42\, 
        \Posit::op_Addition(Posit,Posit).0._State_43\, 
        \Posit::op_Addition(Posit,Posit).0._State_44\, 
        \Posit::op_Addition(Posit,Posit).0._State_45\, 
        \Posit::op_Addition(Posit,Posit).0._State_46\, 
        \Posit::op_Addition(Posit,Posit).0._State_47\, 
        \Posit::op_Addition(Posit,Posit).0._State_48\, 
        \Posit::op_Addition(Posit,Posit).0._State_49\, 
        \Posit::op_Addition(Posit,Posit).0._State_50\, 
        \Posit::op_Addition(Posit,Posit).0._State_51\, 
        \Posit::op_Addition(Posit,Posit).0._State_52\, 
        \Posit::op_Addition(Posit,Posit).0._State_53\, 
        \Posit::op_Addition(Posit,Posit).0._State_54\, 
        \Posit::op_Addition(Posit,Posit).0._State_55\, 
        \Posit::op_Addition(Posit,Posit).0._State_56\, 
        \Posit::op_Addition(Posit,Posit).0._State_57\, 
        \Posit::op_Addition(Posit,Posit).0._State_58\, 
        \Posit::op_Addition(Posit,Posit).0._State_59\, 
        \Posit::op_Addition(Posit,Posit).0._State_60\, 
        \Posit::op_Addition(Posit,Posit).0._State_61\, 
        \Posit::op_Addition(Posit,Posit).0._State_62\, 
        \Posit::op_Addition(Posit,Posit).0._State_63\, 
        \Posit::op_Addition(Posit,Posit).0._State_64\, 
        \Posit::op_Addition(Posit,Posit).0._State_65\, 
        \Posit::op_Addition(Posit,Posit).0._State_66\, 
        \Posit::op_Addition(Posit,Posit).0._State_67\, 
        \Posit::op_Addition(Posit,Posit).0._State_68\, 
        \Posit::op_Addition(Posit,Posit).0._State_69\, 
        \Posit::op_Addition(Posit,Posit).0._State_70\, 
        \Posit::op_Addition(Posit,Posit).0._State_71\, 
        \Posit::op_Addition(Posit,Posit).0._State_72\, 
        \Posit::op_Addition(Posit,Posit).0._State_73\, 
        \Posit::op_Addition(Posit,Posit).0._State_74\, 
        \Posit::op_Addition(Posit,Posit).0._State_75\, 
        \Posit::op_Addition(Posit,Posit).0._State_76\, 
        \Posit::op_Addition(Posit,Posit).0._State_77\, 
        \Posit::op_Addition(Posit,Posit).0._State_78\, 
        \Posit::op_Addition(Posit,Posit).0._State_79\, 
        \Posit::op_Addition(Posit,Posit).0._State_80\, 
        \Posit::op_Addition(Posit,Posit).0._State_81\, 
        \Posit::op_Addition(Posit,Posit).0._State_82\, 
        \Posit::op_Addition(Posit,Posit).0._State_83\, 
        \Posit::op_Addition(Posit,Posit).0._State_84\, 
        \Posit::op_Addition(Posit,Posit).0._State_85\, 
        \Posit::op_Addition(Posit,Posit).0._State_86\, 
        \Posit::op_Addition(Posit,Posit).0._State_87\, 
        \Posit::op_Addition(Posit,Posit).0._State_88\, 
        \Posit::op_Addition(Posit,Posit).0._State_89\, 
        \Posit::op_Addition(Posit,Posit).0._State_90\, 
        \Posit::op_Addition(Posit,Posit).0._State_91\, 
        \Posit::op_Addition(Posit,Posit).0._State_92\, 
        \Posit::op_Addition(Posit,Posit).0._State_93\, 
        \Posit::op_Addition(Posit,Posit).0._State_94\, 
        \Posit::op_Addition(Posit,Posit).0._State_95\, 
        \Posit::op_Addition(Posit,Posit).0._State_96\, 
        \Posit::op_Addition(Posit,Posit).0._State_97\, 
        \Posit::op_Addition(Posit,Posit).0._State_98\, 
        \Posit::op_Addition(Posit,Posit).0._State_99\, 
        \Posit::op_Addition(Posit,Posit).0._State_100\, 
        \Posit::op_Addition(Posit,Posit).0._State_101\, 
        \Posit::op_Addition(Posit,Posit).0._State_102\, 
        \Posit::op_Addition(Posit,Posit).0._State_103\, 
        \Posit::op_Addition(Posit,Posit).0._State_104\, 
        \Posit::op_Addition(Posit,Posit).0._State_105\, 
        \Posit::op_Addition(Posit,Posit).0._State_106\, 
        \Posit::op_Addition(Posit,Posit).0._State_107\, 
        \Posit::op_Addition(Posit,Posit).0._State_108\, 
        \Posit::op_Addition(Posit,Posit).0._State_109\, 
        \Posit::op_Addition(Posit,Posit).0._State_110\, 
        \Posit::op_Addition(Posit,Posit).0._State_111\, 
        \Posit::op_Addition(Posit,Posit).0._State_112\, 
        \Posit::op_Addition(Posit,Posit).0._State_113\, 
        \Posit::op_Addition(Posit,Posit).0._State_114\, 
        \Posit::op_Addition(Posit,Posit).0._State_115\, 
        \Posit::op_Addition(Posit,Posit).0._State_116\, 
        \Posit::op_Addition(Posit,Posit).0._State_117\, 
        \Posit::op_Addition(Posit,Posit).0._State_118\, 
        \Posit::op_Addition(Posit,Posit).0._State_119\, 
        \Posit::op_Addition(Posit,Posit).0._State_120\, 
        \Posit::op_Addition(Posit,Posit).0._State_121\, 
        \Posit::op_Addition(Posit,Posit).0._State_122\, 
        \Posit::op_Addition(Posit,Posit).0._State_123\, 
        \Posit::op_Addition(Posit,Posit).0._State_124\, 
        \Posit::op_Addition(Posit,Posit).0._State_125\, 
        \Posit::op_Addition(Posit,Posit).0._State_126\, 
        \Posit::op_Addition(Posit,Posit).0._State_127\, 
        \Posit::op_Addition(Posit,Posit).0._State_128\, 
        \Posit::op_Addition(Posit,Posit).0._State_129\, 
        \Posit::op_Addition(Posit,Posit).0._State_130\, 
        \Posit::op_Addition(Posit,Posit).0._State_131\, 
        \Posit::op_Addition(Posit,Posit).0._State_132\, 
        \Posit::op_Addition(Posit,Posit).0._State_133\, 
        \Posit::op_Addition(Posit,Posit).0._State_134\, 
        \Posit::op_Addition(Posit,Posit).0._State_135\, 
        \Posit::op_Addition(Posit,Posit).0._State_136\, 
        \Posit::op_Addition(Posit,Posit).0._State_137\, 
        \Posit::op_Addition(Posit,Posit).0._State_138\, 
        \Posit::op_Addition(Posit,Posit).0._State_139\, 
        \Posit::op_Addition(Posit,Posit).0._State_140\);
    -- Signals:
    Signal \Posit::op_Addition(Posit,Posit).0._Finished\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.return\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0._Started\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.left.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.right.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit).return.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 declarations end


    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 declarations start
    -- State machine states:
    type \Posit::op_UnaryNegation(Posit).0._States\ is (
        \Posit::op_UnaryNegation(Posit).0._State_0\, 
        \Posit::op_UnaryNegation(Posit).0._State_1\, 
        \Posit::op_UnaryNegation(Posit).0._State_2\, 
        \Posit::op_UnaryNegation(Posit).0._State_3\, 
        \Posit::op_UnaryNegation(Posit).0._State_4\, 
        \Posit::op_UnaryNegation(Posit).0._State_5\, 
        \Posit::op_UnaryNegation(Posit).0._State_6\, 
        \Posit::op_UnaryNegation(Posit).0._State_7\, 
        \Posit::op_UnaryNegation(Posit).0._State_8\, 
        \Posit::op_UnaryNegation(Posit).0._State_9\, 
        \Posit::op_UnaryNegation(Posit).0._State_10\);
    -- Signals:
    Signal \Posit::op_UnaryNegation(Posit).0._Finished\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0.return\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::IsZero().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0._Started\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0.x.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Finished.0\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().return.0\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Finished.0\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::IsZero().return.0\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 declarations end


    -- System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0 declarations start
    -- State machine states:
    type \Posit::op_Explicit(Posit).0._States\ is (
        \Posit::op_Explicit(Posit).0._State_0\, 
        \Posit::op_Explicit(Posit).0._State_1\, 
        \Posit::op_Explicit(Posit).0._State_2\, 
        \Posit::op_Explicit(Posit).0._State_3\, 
        \Posit::op_Explicit(Posit).0._State_4\, 
        \Posit::op_Explicit(Posit).0._State_5\, 
        \Posit::op_Explicit(Posit).0._State_6\, 
        \Posit::op_Explicit(Posit).0._State_7\, 
        \Posit::op_Explicit(Posit).0._State_8\, 
        \Posit::op_Explicit(Posit).0._State_9\, 
        \Posit::op_Explicit(Posit).0._State_10\, 
        \Posit::op_Explicit(Posit).0._State_11\, 
        \Posit::op_Explicit(Posit).0._State_12\, 
        \Posit::op_Explicit(Posit).0._State_13\, 
        \Posit::op_Explicit(Posit).0._State_14\, 
        \Posit::op_Explicit(Posit).0._State_15\, 
        \Posit::op_Explicit(Posit).0._State_16\, 
        \Posit::op_Explicit(Posit).0._State_17\, 
        \Posit::op_Explicit(Posit).0._State_18\, 
        \Posit::op_Explicit(Posit).0._State_19\, 
        \Posit::op_Explicit(Posit).0._State_20\, 
        \Posit::op_Explicit(Posit).0._State_21\, 
        \Posit::op_Explicit(Posit).0._State_22\, 
        \Posit::op_Explicit(Posit).0._State_23\);
    -- Signals:
    Signal \Posit::op_Explicit(Posit).0._Finished\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.Posit::GetExponentValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0._Started\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.x.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().return.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.Posit::GetExponentValue().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::op_Explicit(Posit).0.Posit::IsPositive().return.0\: boolean := false;
    -- System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask().0 declarations start
    -- State machine states:
    type \Posit::get_SignBitMask().0._States\ is (
        \Posit::get_SignBitMask().0._State_0\, 
        \Posit::get_SignBitMask().0._State_1\, 
        \Posit::get_SignBitMask().0._State_2\);
    -- Signals:
    Signal \Posit::get_SignBitMask().0._Finished\: boolean := false;
    Signal \Posit::get_SignBitMask().0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::get_SignBitMask().0._Started\: boolean := false;
    Signal \Posit::get_SignBitMask().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask().0 declarations start
    -- State machine states:
    type \Posit::get_FirstRegimeBitBitMask().0._States\ is (
        \Posit::get_FirstRegimeBitBitMask().0._State_0\, 
        \Posit::get_FirstRegimeBitBitMask().0._State_1\, 
        \Posit::get_FirstRegimeBitBitMask().0._State_2\);
    -- Signals:
    Signal \Posit::get_FirstRegimeBitBitMask().0._Finished\: boolean := false;
    Signal \Posit::get_FirstRegimeBitBitMask().0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::get_FirstRegimeBitBitMask().0._Started\: boolean := false;
    Signal \Posit::get_FirstRegimeBitBitMask().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask().0 declarations start
    -- State machine states:
    type \Posit::get_EmptyBitMask().0._States\ is (
        \Posit::get_EmptyBitMask().0._State_0\, 
        \Posit::get_EmptyBitMask().0._State_1\, 
        \Posit::get_EmptyBitMask().0._State_2\);
    -- Signals:
    Signal \Posit::get_EmptyBitMask().0._Finished\: boolean := false;
    Signal \Posit::get_EmptyBitMask().0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::get_EmptyBitMask().0._Started\: boolean := false;
    Signal \Posit::get_EmptyBitMask().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask().0 declarations start
    -- State machine states:
    type \Posit::get_NaNBitMask().0._States\ is (
        \Posit::get_NaNBitMask().0._State_0\, 
        \Posit::get_NaNBitMask().0._State_1\, 
        \Posit::get_NaNBitMask().0._State_2\);
    -- Signals:
    Signal \Posit::get_NaNBitMask().0._Finished\: boolean := false;
    Signal \Posit::get_NaNBitMask().0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::get_NaNBitMask().0._Started\: boolean := false;
    Signal \Posit::get_NaNBitMask().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask().0 declarations end


    -- System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0 declarations start
    -- State machine states:
    type \PositEnvironment::.ctor(Byte,Byte).0._States\ is (
        \PositEnvironment::.ctor(Byte,Byte).0._State_0\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_1\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_2\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_3\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_4\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_5\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_6\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_7\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_8\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_9\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_10\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_11\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_12\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_13\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_14\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_15\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_16\);
    -- Signals:
    Signal \PositEnvironment::.ctor(Byte,Byte).0._Finished\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.Out\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0._Started\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.In\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.size.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0 declarations end


    -- System.Void Hast::ExternalInvocationProxy() declarations start
    -- Signals:
    Signal \FinishedInternal\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Finished.0\: boolean := false;
    -- System.Void Hast::ExternalInvocationProxy() declarations end


    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations start
    type \InternalInvocationProxy_boolean_Array\ is array (integer range <>) of boolean;
    type \Hast::InternalInvocationProxy()._RunningStates\ is (
        WaitingForStarted, 
        WaitingForFinished, 
        AfterFinished);
    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations end

begin 

    -- System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\: \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._States\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.environment\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\: \Lombiq.Arithmetics.Posit\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.right\: \Lombiq.Arithmetics.Posit\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0);
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.0\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\: boolean := false;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.1\: \Lombiq.Arithmetics.Posit\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.2\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit)._Started.0\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit)._Started.0\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\ := to_unsigned(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ := to_signed(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\ := to_signed(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\ := false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\ := to_signed(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.2\ := to_signed(0, 32);
            else 
                case \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ is 
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\ = true) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\ = true) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\ <= true;
                        else 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- PositEnvironment environment;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit posit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit right;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int number;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(0, 32), 32);
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\ := ConvertStdLogicVectorToUInt32(\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- environment = PositCalculator.EnvironmentFactory ();
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory()
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\ <= true;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory()
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\ = \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Finished.0\) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.0\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory().return.0\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.environment\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- posit = new Posit (environment, 1);
                            -- 
                            -- Initializing record fields to their defaults.
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\.\IsNull\ := false;
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32)
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.Out.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.Out.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.environment\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).value.parameter.Out.0\ <= to_signed(1, 32);
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\ <= true;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32)
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\ = \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Finished.0\) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.In.0\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.environment\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- right = posit;
                            -- 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.right\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 1;
                            -- 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ := to_signed(1, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((long)num2 < (long)((ulong)num)) {
                            -- 	posit = Posit.op_Addition (posit, right);
                            -- 	num2 = num2 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_6\ => 
                        -- Repeated state of the while loop which was started in state \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\.
                        -- The while loop's condition:
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\ := SmartResize(\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\, 64) < signed((SmartResize(\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\, 64)));
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	posit = Posit.op_Addition (posit, right);
                            -- 	num2 = num2 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- posit = Posit.op_Addition (posit, right);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit)
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit).left.parameter.Out.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit).right.parameter.Out.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.right\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit)._Started.0\ <= true;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_8\;
                        else 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2897
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_7\ => 
                        -- State after the while loop which was started in state \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- number = Posit.op_Explicit (posit);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit)
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit).x.parameter.Out.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit)._Started.0\ <= true;
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit)
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit)._Started.0\ = \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit)._Finished.0\) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit)._Started.0\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.1\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit).return.0\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = num2 + 1;
                            -- 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ + to_signed(1, 32);
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\;
                            -- Returning to the repeated state of the while loop which was started in state \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\ if the loop wasn't exited with a state change.
                            if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ = \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_8\) then 
                                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit)
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit)._Started.0\ = \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit)._Finished.0\) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit)._Started.0\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.2\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit).return.0\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteInt32 (0, number);
                            -- 
                            -- Begin SimpleMemory write.
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(0, 32), 32);
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertInt32ToStdLogicVector(\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\);
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_10\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory().0 state machine start
    \PositCalculator::EnvironmentFactory().0._StateMachine\: process (\Clock\) 
        Variable \PositCalculator::EnvironmentFactory().0._State\: \PositCalculator::EnvironmentFactory().0._States\ := \PositCalculator::EnvironmentFactory().0._State_0\;
        Variable \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\: \Lombiq.Arithmetics.PositEnvironment\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PositCalculator::EnvironmentFactory().0._Finished\ <= false;
                \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).size.parameter.Out.0\ <= to_unsigned(0, 8);
                \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(0, 8);
                \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\ <= false;
                \PositCalculator::EnvironmentFactory().0._State\ := \PositCalculator::EnvironmentFactory().0._State_0\;
            else 
                case \PositCalculator::EnvironmentFactory().0._State\ is 
                    when \PositCalculator::EnvironmentFactory().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PositCalculator::EnvironmentFactory().0._Started\ = true) then 
                            \PositCalculator::EnvironmentFactory().0._State\ := \PositCalculator::EnvironmentFactory().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::EnvironmentFactory().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PositCalculator::EnvironmentFactory().0._Started\ = true) then 
                            \PositCalculator::EnvironmentFactory().0._Finished\ <= true;
                        else 
                            \PositCalculator::EnvironmentFactory().0._Finished\ <= false;
                            \PositCalculator::EnvironmentFactory().0._State\ := \PositCalculator::EnvironmentFactory().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::EnvironmentFactory().0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- PositEnvironment objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30 = new PositEnvironment (32, 3);
                        -- 
                        -- Initializing record fields to their defaults.
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\IsNull\ := false;
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\MaximumExponentSize\ := to_unsigned(0, 8);
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\Size\ := to_unsigned(0, 16);
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\Useed\ := to_unsigned(0, 32);
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\FirstRegimeBitIndex\ := to_unsigned(0, 16);
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\QuireSize\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte)
                        \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.Out.0\ <= \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\;
                        \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).size.parameter.Out.0\ <= to_unsigned(32, 8);
                        \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(3, 8);
                        \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\ <= true;
                        \PositCalculator::EnvironmentFactory().0._State\ := \PositCalculator::EnvironmentFactory().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::EnvironmentFactory().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte)
                        if (\PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\ = \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Finished.0\) then 
                            \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\ <= false;
                            \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\ := \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30;
                            -- 
                            \PositCalculator::EnvironmentFactory().0.return\ <= \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\;
                            \PositCalculator::EnvironmentFactory().0._State\ := \PositCalculator::EnvironmentFactory().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory().0 state machine end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16).0 state machine start
    \BitMask::.ctor(UInt32,UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::.ctor(UInt32,UInt16).0._State\: \BitMask::.ctor(UInt32,UInt16).0._States\ := \BitMask::.ctor(UInt32,UInt16).0._State_0\;
        Variable \BitMask::.ctor(UInt32,UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::.ctor(UInt32,UInt16).0.segment\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt32,UInt16).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::.ctor(UInt32,UInt16).0.conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.remainderOperand7b0652594777fabbf172a4e3c9a34a4bf5fd0e7010623bf804790c3a6823a071\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.3\: boolean := false;
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.5\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::.ctor(UInt32,UInt16).0._Finished\ <= false;
                \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_0\;
                \BitMask::.ctor(UInt32,UInt16).0.segment\ := to_unsigned(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.size\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt32,UInt16).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::.ctor(UInt32,UInt16).0.conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.remainderOperand7b0652594777fabbf172a4e3c9a34a4bf5fd0e7010623bf804790c3a6823a071\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.3\ := false;
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.4\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.5\ := to_unsigned(0, 16);
            else 
                case \BitMask::.ctor(UInt32,UInt16).0._State\ is 
                    when \BitMask::.ctor(UInt32,UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::.ctor(UInt32,UInt16).0._Started\ = true) then 
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32,UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::.ctor(UInt32,UInt16).0._Started\ = true) then 
                            \BitMask::.ctor(UInt32,UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::.ctor(UInt32,UInt16).0._Finished\ <= false;
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\ <= \BitMask::.ctor(UInt32,UInt16).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32,UInt16).0._State_2\ => 
                        \BitMask::.ctor(UInt32,UInt16).0.this\ := \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\;
                        \BitMask::.ctor(UInt32,UInt16).0.segment\ := \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\;
                        \BitMask::.ctor(UInt32,UInt16).0.size\ := \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = size;
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.this\.\Size\ := \BitMask::.ctor(UInt32,UInt16).0.size\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- System.Int32 remainderOperand7b0652594777fabbf172a4e3c9a34a4bf5fd0e7010623bf804790c3a6823a071;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand7b0652594777fabbf172a4e3c9a34a4bf5fd0e7010623bf804790c3a6823a071 = (System.Int32)(size);
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.remainderOperand7b0652594777fabbf172a4e3c9a34a4bf5fd0e7010623bf804790c3a6823a071\ := signed(SmartResize((\BitMask::.ctor(UInt32,UInt16).0.size\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- if ((System.Int32)(remainderOperand7b0652594777fabbf172a4e3c9a34a4bf5fd0e7010623bf804790c3a6823a071 - remainderOperand7b0652594777fabbf172a4e3c9a34a4bf5fd0e7010623bf804790c3a6823a071 / 32 * 32) == 0) {
                        -- 	conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078 = 0;
                        -- }
                        -- else {
                        -- 	conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078 = 1;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ := \BitMask::.ctor(UInt32,UInt16).0.remainderOperand7b0652594777fabbf172a4e3c9a34a4bf5fd0e7010623bf804790c3a6823a071\ / to_signed(32, 32);
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.1\ := SmartResize(\BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ * to_signed(32, 32), 32);
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.2\ := \BitMask::.ctor(UInt32,UInt16).0.remainderOperand7b0652594777fabbf172a4e3c9a34a4bf5fd0e7010623bf804790c3a6823a071\ - \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.1\;
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.3\ := (\BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.2\) = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt32,UInt16).0._State_4\ and ends in state \BitMask::.ctor(UInt32,UInt16).0._State_4\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt32,UInt16).0._State_5\ and ends in state \BitMask::.ctor(UInt32,UInt16).0._State_5\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt32,UInt16).0._State_3\.

                        if (\BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.3\) then 
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_4\;
                        else 
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7907
                    when \BitMask::.ctor(UInt32,UInt16).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt32,UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = (ushort)(size >> 5 + conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078);
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.4\ := signed(SmartResize(shift_right(\BitMask::.ctor(UInt32,UInt16).0.size\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.5\ := SmartResize(unsigned(\BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.4\ + \BitMask::.ctor(UInt32,UInt16).0.conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078\), 16);
                        \BitMask::.ctor(UInt32,UInt16).0.this\.\SegmentCount\ := (\BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.5\);
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- array [0] = segment;
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.array\(to_integer(to_signed(0, 32))) := \BitMask::.ctor(UInt32,UInt16).0.segment\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = array;
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.this\.\Segments\ := \BitMask::.ctor(UInt32,UInt16).0.array\;
                        \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.5542
                    when \BitMask::.ctor(UInt32,UInt16).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt32,UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078 = 0;
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32,UInt16).0._State_2\.
                        if (\BitMask::.ctor(UInt32,UInt16).0._State\ = \BitMask::.ctor(UInt32,UInt16).0._State_4\) then 
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32,UInt16).0._State_5\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt32,UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078 = 1;
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.conditional28b670b95e438dccb7165bc8a73dda0e9d23d98a5b06ada29fd5a5861ced6078\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32,UInt16).0._State_2\.
                        if (\BitMask::.ctor(UInt32,UInt16).0._State\ = \BitMask::.ctor(UInt32,UInt16).0._State_5\) then 
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16).0 state machine end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16).0 state machine start
    \BitMask::.ctor(UInt32[],UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::.ctor(UInt32[],UInt16).0._State\: \BitMask::.ctor(UInt32[],UInt16).0._States\ := \BitMask::.ctor(UInt32[],UInt16).0._State_0\;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.segments\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::.ctor(UInt32[],UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.flag\: boolean := false;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::.ctor(UInt32[],UInt16).0.conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.remainderOperande96c712ca3272aa24fa474b957f1a0b013d574890d4aa1f330c742b2b7ffa225\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.4\: boolean := false;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.5\: boolean := false;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::.ctor(UInt32[],UInt16).0._Finished\ <= false;
                \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\ <= (others => to_unsigned(0, 32));
                \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_0\;
                \BitMask::.ctor(UInt32[],UInt16).0.segments\ := (others => to_unsigned(0, 32));
                \BitMask::.ctor(UInt32[],UInt16).0.size\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt32[],UInt16).0.num\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt32[],UInt16).0.flag\ := false;
                \BitMask::.ctor(UInt32[],UInt16).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::.ctor(UInt32[],UInt16).0.conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.0\ := false;
                \BitMask::.ctor(UInt32[],UInt16).0.conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.remainderOperande96c712ca3272aa24fa474b957f1a0b013d574890d4aa1f330c742b2b7ffa225\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.3\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.4\ := false;
                \BitMask::.ctor(UInt32[],UInt16).0.conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.5\ := false;
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.6\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.7\ := to_unsigned(0, 16);
            else 
                case \BitMask::.ctor(UInt32[],UInt16).0._State\ is 
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._Started\ = true) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._Started\ = true) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::.ctor(UInt32[],UInt16).0._Finished\ <= false;
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\ <= \BitMask::.ctor(UInt32[],UInt16).0.this\;
                        \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_2\ => 
                        \BitMask::.ctor(UInt32[],UInt16).0.this\ := \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\;
                        \BitMask::.ctor(UInt32[],UInt16).0.segments\ := \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\;
                        \BitMask::.ctor(UInt32[],UInt16).0.size\ := \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 32;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.num\ := to_unsigned(32, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((System.Int32)(size) < 32) {
                        -- 	conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732 = 32;
                        -- }
                        -- else {
                        -- 	conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732 = size;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.0\ := signed(SmartResize((\BitMask::.ctor(UInt32[],UInt16).0.size\), 32)) < to_signed(32, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_4\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_4\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_5\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_5\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt32[],UInt16).0._State_3\.

                        if (\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.0\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_4\;
                        else 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.this\.\Size\ := \BitMask::.ctor(UInt32[],UInt16).0.conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- System.Int32 remainderOperande96c712ca3272aa24fa474b957f1a0b013d574890d4aa1f330c742b2b7ffa225;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperande96c712ca3272aa24fa474b957f1a0b013d574890d4aa1f330c742b2b7ffa225 = (System.Int32)(size);
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.remainderOperande96c712ca3272aa24fa474b957f1a0b013d574890d4aa1f330c742b2b7ffa225\ := signed(SmartResize((\BitMask::.ctor(UInt32[],UInt16).0.size\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- if ((System.Int32)(remainderOperande96c712ca3272aa24fa474b957f1a0b013d574890d4aa1f330c742b2b7ffa225 - remainderOperande96c712ca3272aa24fa474b957f1a0b013d574890d4aa1f330c742b2b7ffa225 / 32 * 32) == 0) {
                        -- 	conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5 = 0;
                        -- }
                        -- else {
                        -- 	conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5 = 1;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.1\ := \BitMask::.ctor(UInt32[],UInt16).0.remainderOperande96c712ca3272aa24fa474b957f1a0b013d574890d4aa1f330c742b2b7ffa225\ / to_signed(32, 32);
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.2\ := SmartResize(\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.1\ * to_signed(32, 32), 32);
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.3\ := \BitMask::.ctor(UInt32[],UInt16).0.remainderOperande96c712ca3272aa24fa474b957f1a0b013d574890d4aa1f330c742b2b7ffa225\ - \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.2\;
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.4\ := (\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.3\) = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_7\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_7\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_8\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_8\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt32[],UInt16).0._State_6\.

                        if (\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.4\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_7\;
                        else 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7907
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732 = 32;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732 = 32;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732\ := to_unsigned(32, 16);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_2\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_4\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_5\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732 = size;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732 = size;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.conditionala10eefb2c7e3640611afc1d10a6c14734637879b187d1eb439f9a6ebef3c3732\ := \BitMask::.ctor(UInt32[],UInt16).0.size\;
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_2\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_5\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_6\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((System.Int32)(size) > 32) {
                        -- 	conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9 = (ushort)(size >> 5 + conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5);
                        -- }
                        -- else {
                        -- 	conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9 = 1;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.5\ := signed(SmartResize((\BitMask::.ctor(UInt32[],UInt16).0.size\), 32)) > to_signed(32, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_10\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_10\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_11\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_11\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt32[],UInt16).0._State_9\.

                        if (\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.5\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_10\;
                        else 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_7\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5 = 0;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_3\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_7\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_8\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5 = 1;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_3\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_8\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_9\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.this\.\SegmentCount\ := \BitMask::.ctor(UInt32[],UInt16).0.conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag = false;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.flag\ := False;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = segments;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.this\.\Segments\ := \BitMask::.ctor(UInt32[],UInt16).0.segments\;
                        \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_10\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9 = (ushort)(size >> 5 + conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9 = (ushort)(size >> 5 + conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5);
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.6\ := signed(SmartResize(shift_right(\BitMask::.ctor(UInt32[],UInt16).0.size\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.7\ := SmartResize(unsigned(\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.6\ + \BitMask::.ctor(UInt32[],UInt16).0.conditionalab19ef8cf118996f96dcd54264f3cb7bfc26be5dc637930f1d472ff9cb9ae3f5\), 16);
                        \BitMask::.ctor(UInt32[],UInt16).0.conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9\ := (\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.7\);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_6\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_10\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5542
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_11\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9 = 1;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.conditionalca3d25fb4462d1c80ecabb910d7ada6b7dcaaf74fdf035273f5753748c4b2df9\ := to_unsigned(1, 16);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_6\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_11\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16).0 state machine end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean).0 state machine start
    \BitMask::.ctor(UInt16,Boolean).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::.ctor(UInt16,Boolean).0._State\: \BitMask::.ctor(UInt16,Boolean).0._States\ := \BitMask::.ctor(UInt16,Boolean).0._State_0\;
        Variable \BitMask::.ctor(UInt16,Boolean).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::.ctor(UInt16,Boolean).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt16,Boolean).0.allOne\: boolean := false;
        Variable \BitMask::.ctor(UInt16,Boolean).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::.ctor(UInt16,Boolean).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt16,Boolean).0.remainderOperandc10586ceb05625ab6a6ccbc7d884bcf7a821b92e70893cc85b1992982585883d\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.3\: boolean := false;
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.5\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.7\: boolean := false;
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt16,Boolean).0.conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.9\: boolean := false;
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::.ctor(UInt16,Boolean).0._Finished\ <= false;
                \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_0\;
                \BitMask::.ctor(UInt16,Boolean).0.size\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt16,Boolean).0.allOne\ := false;
                \BitMask::.ctor(UInt16,Boolean).0.num\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::.ctor(UInt16,Boolean).0.num2\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt16,Boolean).0.remainderOperandc10586ceb05625ab6a6ccbc7d884bcf7a821b92e70893cc85b1992982585883d\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.0\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.3\ := false;
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.4\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.5\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.6\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.7\ := false;
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.8\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt16,Boolean).0.conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615\ := to_unsigned(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.9\ := false;
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.11\ := to_unsigned(0, 32);
            else 
                case \BitMask::.ctor(UInt16,Boolean).0._State\ is 
                    when \BitMask::.ctor(UInt16,Boolean).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::.ctor(UInt16,Boolean).0._Started\ = true) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::.ctor(UInt16,Boolean).0._Started\ = true) then 
                            \BitMask::.ctor(UInt16,Boolean).0._Finished\ <= true;
                        else 
                            \BitMask::.ctor(UInt16,Boolean).0._Finished\ <= false;
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\ <= \BitMask::.ctor(UInt16,Boolean).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_2\ => 
                        \BitMask::.ctor(UInt16,Boolean).0.this\ := \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\;
                        \BitMask::.ctor(UInt16,Boolean).0.size\ := \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\;
                        \BitMask::.ctor(UInt16,Boolean).0.allOne\ := \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- System.Int32 remainderOperandc10586ceb05625ab6a6ccbc7d884bcf7a821b92e70893cc85b1992982585883d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperandc10586ceb05625ab6a6ccbc7d884bcf7a821b92e70893cc85b1992982585883d = (System.Int32)(size);
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.remainderOperandc10586ceb05625ab6a6ccbc7d884bcf7a821b92e70893cc85b1992982585883d\ := signed(SmartResize((\BitMask::.ctor(UInt16,Boolean).0.size\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(remainderOperandc10586ceb05625ab6a6ccbc7d884bcf7a821b92e70893cc85b1992982585883d - remainderOperandc10586ceb05625ab6a6ccbc7d884bcf7a821b92e70893cc85b1992982585883d / 32 * 32);
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.0\ := \BitMask::.ctor(UInt16,Boolean).0.remainderOperandc10586ceb05625ab6a6ccbc7d884bcf7a821b92e70893cc85b1992982585883d\ / to_signed(32, 32);
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.1\ := SmartResize(\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.0\ * to_signed(32, 32), 32);
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.2\ := \BitMask::.ctor(UInt16,Boolean).0.remainderOperandc10586ceb05625ab6a6ccbc7d884bcf7a821b92e70893cc85b1992982585883d\ - \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.1\;
                        \BitMask::.ctor(UInt16,Boolean).0.num\ := (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.2\);
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num == 0) {
                        -- 	conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 0;
                        -- }
                        -- else {
                        -- 	conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 1;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.3\ := \BitMask::.ctor(UInt16,Boolean).0.num\ = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt16,Boolean).0._State_4\ and ends in state \BitMask::.ctor(UInt16,Boolean).0._State_4\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt16,Boolean).0._State_5\ and ends in state \BitMask::.ctor(UInt16,Boolean).0._State_5\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt16,Boolean).0._State_3\.

                        if (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.3\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_4\;
                        else 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7907
                    when \BitMask::.ctor(UInt16,Boolean).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = (ushort)(size >> 5 + conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e);
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.4\ := signed(SmartResize(shift_right(\BitMask::.ctor(UInt16,Boolean).0.size\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.5\ := SmartResize(unsigned(\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.4\ + \BitMask::.ctor(UInt16,Boolean).0.conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e\), 16);
                        \BitMask::.ctor(UInt16,Boolean).0.this\.\SegmentCount\ := (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.5\);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = size;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.this\.\Size\ := \BitMask::.ctor(UInt16,Boolean).0.size\;
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- if (allOne) {
                        -- 	num2 = 0;
                        -- 	while ((System.Int32)(num2) < (System.Int32)((System.Int32)(@this.SegmentCount) - 1)) {
                        -- 		array [(int)num2] = 4294967295u;
                        -- 		num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 	}
                        -- 	uint conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- 	if (num > 0) {
                        -- 		conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 1u << num - 1u;
                        -- 	}
                        -- 	else {
                        -- 		conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 4294967295u;
                        -- 	}
                        -- 	array [(int)num2] = conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt16,Boolean).0._State_7\ and ends in state \BitMask::.ctor(UInt16,Boolean).0._State_10\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt16,Boolean).0._State_6\.

                        if (\BitMask::.ctor(UInt16,Boolean).0.allOne\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_7\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5542
                    when \BitMask::.ctor(UInt16,Boolean).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt16,Boolean).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 0;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_2\.
                        if (\BitMask::.ctor(UInt16,Boolean).0._State\ = \BitMask::.ctor(UInt16,Boolean).0._State_4\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_5\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt16,Boolean).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 1;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_2\.
                        if (\BitMask::.ctor(UInt16,Boolean).0._State\ = \BitMask::.ctor(UInt16,Boolean).0._State_5\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_6\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = array;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.this\.\Segments\ := \BitMask::.ctor(UInt16,Boolean).0.array\;
                        \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_7\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt16,Boolean).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = 0;
                        -- 	while ((System.Int32)(num2) < (System.Int32)((System.Int32)(@this.SegmentCount) - 1)) {
                        -- 		array [(int)num2] = 4294967295u;
                        -- 		num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 	}
                        -- 	uint conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- 	if (num > 0) {
                        -- 		conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 1u << num - 1u;
                        -- 	}
                        -- 	else {
                        -- 		conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 4294967295u;
                        -- 	}
                        -- 	array [(int)num2] = conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((System.Int32)(num2) < (System.Int32)((System.Int32)(@this.SegmentCount) - 1)) {
                        -- 	array [(int)num2] = 4294967295u;
                        -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_8\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_7\.
                        -- The while loop's condition:
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.6\ := signed(SmartResize((\BitMask::.ctor(UInt16,Boolean).0.this\.\SegmentCount\), 32)) - to_signed(1, 32);
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.7\ := signed(SmartResize((\BitMask::.ctor(UInt16,Boolean).0.num2\), 32)) < (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.6\);
                        if (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.7\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	array [(int)num2] = 4294967295u;
                            -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array [(int)num2] = 4294967295u;
                            -- 
                            -- Since the integer literal 4294967295 was out of the VHDL integer range it was substituted with a binary literal (11111111111111111111111111111111).
                            \BitMask::.ctor(UInt16,Boolean).0.array\(to_integer(signed(SmartResize(\BitMask::.ctor(UInt16,Boolean).0.num2\, 32)))) := "11111111111111111111111111111111";
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (System.UInt16)((System.Int32)(num2) + 1);
                            -- 
                            \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.8\ := SmartResize(unsigned(signed(SmartResize((\BitMask::.ctor(UInt16,Boolean).0.num2\), 32)) + to_signed(1, 32)), 16);
                            \BitMask::.ctor(UInt16,Boolean).0.num2\ := (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.8\);
                        else 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8922
                    when \BitMask::.ctor(UInt16,Boolean).0._State_9\ => 
                        -- State after the while loop which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 0) {
                        -- 	conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 1u << num - 1u;
                        -- }
                        -- else {
                        -- 	conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 4294967295u;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.9\ := \BitMask::.ctor(UInt16,Boolean).0.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt16,Boolean).0._State_11\ and ends in state \BitMask::.ctor(UInt16,Boolean).0._State_11\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt16,Boolean).0._State_12\ and ends in state \BitMask::.ctor(UInt16,Boolean).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt16,Boolean).0._State_10\.

                        if (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.9\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_11\;
                        else 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \BitMask::.ctor(UInt16,Boolean).0._State_10\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num2] = conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.array\(to_integer(signed(SmartResize(\BitMask::.ctor(UInt16,Boolean).0.num2\, 32)))) := \BitMask::.ctor(UInt16,Boolean).0.conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615\;
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_3\.
                        if (\BitMask::.ctor(UInt16,Boolean).0._State\ = \BitMask::.ctor(UInt16,Boolean).0._State_10\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_11\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt16,Boolean).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 1u << num - 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 1u << num - 1u;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.10\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(\BitMask::.ctor(UInt16,Boolean).0.num\, 5))));
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.11\ := \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.10\ - to_unsigned(1, 32);
                        \BitMask::.ctor(UInt16,Boolean).0.conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615\ := \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.11\;
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_9\.
                        if (\BitMask::.ctor(UInt16,Boolean).0._State\ = \BitMask::.ctor(UInt16,Boolean).0._State_11\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \BitMask::.ctor(UInt16,Boolean).0._State_12\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt16,Boolean).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 4294967295u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 4294967295u;
                        -- 
                        -- Since the integer literal 4294967295 was out of the VHDL integer range it was substituted with a binary literal (11111111111111111111111111111111).
                        \BitMask::.ctor(UInt16,Boolean).0.conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615\ := "11111111111111111111111111111111";
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_9\.
                        if (\BitMask::.ctor(UInt16,Boolean).0._State\ = \BitMask::.ctor(UInt16,Boolean).0._State_12\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean).0 state machine end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask::.ctor(BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::.ctor(BitMask).0._State\: \BitMask::.ctor(BitMask).0._States\ := \BitMask::.ctor(BitMask).0._State_0\;
        Variable \BitMask::.ctor(BitMask).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::.ctor(BitMask).0.source\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::.ctor(BitMask).0._Finished\ <= false;
                \BitMask::.ctor(BitMask).0._State\ := \BitMask::.ctor(BitMask).0._State_0\;
            else 
                case \BitMask::.ctor(BitMask).0._State\ is 
                    when \BitMask::.ctor(BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::.ctor(BitMask).0._Started\ = true) then 
                            \BitMask::.ctor(BitMask).0._State\ := \BitMask::.ctor(BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::.ctor(BitMask).0._Started\ = true) then 
                            \BitMask::.ctor(BitMask).0._Finished\ <= true;
                        else 
                            \BitMask::.ctor(BitMask).0._Finished\ <= false;
                            \BitMask::.ctor(BitMask).0._State\ := \BitMask::.ctor(BitMask).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \BitMask::.ctor(BitMask).0.this.parameter.Out\ <= \BitMask::.ctor(BitMask).0.this\;
                        \BitMask::.ctor(BitMask).0.source.parameter.Out\ <= \BitMask::.ctor(BitMask).0.source\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(BitMask).0._State_2\ => 
                        \BitMask::.ctor(BitMask).0.this\ := \BitMask::.ctor(BitMask).0.this.parameter.In\;
                        \BitMask::.ctor(BitMask).0.source\ := \BitMask::.ctor(BitMask).0.source.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = 32;
                        -- 
                        \BitMask::.ctor(BitMask).0.this\.\Size\ := to_unsigned(32, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = 1;
                        -- 
                        \BitMask::.ctor(BitMask).0.this\.\SegmentCount\ := to_unsigned(1, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = source.Segments;
                        -- 
                        \BitMask::.ctor(BitMask).0.this\.\Segments\ := \BitMask::.ctor(BitMask).0.source\.\Segments\;
                        \BitMask::.ctor(BitMask).0._State\ := \BitMask::.ctor(BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16).0 state machine start
    \BitMask::FromImmutableArray(UInt32[],UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\: \BitMask::FromImmutableArray(UInt32[],UInt16).0._States\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_0\;
        Variable \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::FromImmutableArray(UInt32[],UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\ <= false;
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\ <= (others => to_unsigned(0, 32));
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_0\;
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments\ := (others => to_unsigned(0, 32));
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.size\ := to_unsigned(0, 16);
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\ := (others => to_unsigned(0, 32));
            else 
                case \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ is 
                    when \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ = true) then 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ = true) then 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\ <= false;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_2\ => 
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.In\;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.size\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- System.Array.Copy (segments, array, 1);
                        -- 
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments\(0 to 0);
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b = new BitMask (array, size);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\.\IsNull\ := false;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\.\Size\ := to_unsigned(0, 16);
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.size\;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b;
                            -- 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.return\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0 state machine start
    \BitMask::SetOne(UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::SetOne(UInt16).0._State\: \BitMask::SetOne(UInt16).0._States\ := \BitMask::SetOne(UInt16).0._State_0\;
        Variable \BitMask::SetOne(UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::SetOne(UInt16).0.index\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::SetOne(UInt16).0.flag\: boolean := false;
        Variable \BitMask::SetOne(UInt16).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::SetOne(UInt16).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.index2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.flag2\: boolean := false;
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::SetOne(UInt16).0.remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.9\: boolean := false;
        Variable \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.return.0\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::SetOne(UInt16).0._Finished\ <= false;
                \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_0\;
                \BitMask::SetOne(UInt16).0.index\ := to_unsigned(0, 16);
                \BitMask::SetOne(UInt16).0.flag\ := false;
                \BitMask::SetOne(UInt16).0.num\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.index2\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.flag2\ := false;
                \BitMask::SetOne(UInt16).0.binaryOperationResult.0\ := false;
                \BitMask::SetOne(UInt16).0.remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.3\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.4\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.9\ := false;
                \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\ := (others => to_unsigned(0, 32));
                \BitMask::SetOne(UInt16).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.11\ := to_unsigned(0, 32);
            else 
                case \BitMask::SetOne(UInt16).0._State\ is 
                    when \BitMask::SetOne(UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::SetOne(UInt16).0._Started\ = true) then 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::SetOne(UInt16).0._Started\ = true) then 
                            \BitMask::SetOne(UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::SetOne(UInt16).0._Finished\ <= false;
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_2\ => 
                        \BitMask::SetOne(UInt16).0.this\ := \BitMask::SetOne(UInt16).0.this.parameter.In\;
                        \BitMask::SetOne(UInt16).0.index\ := \BitMask::SetOne(UInt16).0.index.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int index2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (System.Int32)(index) > 32;
                        -- 
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.0\ := signed(SmartResize((\BitMask::SetOne(UInt16).0.index\), 32)) > to_signed(32, 32);
                        \BitMask::SetOne(UInt16).0.flag\ := \BitMask::SetOne(UInt16).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- else {
                        -- 	System.Int32 remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175;
                        -- 	remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175 = (System.Int32)(index);
                        -- 	num = (int)(remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175 - remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175 / 32 * 32);
                        -- 	index2 = index >> 5;
                        -- 	System.UInt32 remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935;
                        -- 	remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 = @this.Segments [index2] >> num;
                        -- 	flag2 = remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 - remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 / 2u * 2u == 0u;
                        -- 	if (flag2) {
                        -- 		uint[] array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444;
                        -- 		array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 = new uint[1];
                        -- 		System.Array.Copy (@this.Segments, array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 1);
                        -- 		array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 [index2] = @this.Segments [index2] | 1u << num;
                        -- 		result = BitMask.FromImmutableArray (array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 32);
                        -- 	}
                        -- 	else {
                        -- 		result = new BitMask (@this);
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::SetOne(UInt16).0._State_4\ and ends in state \BitMask::SetOne(UInt16).0._State_5\.
                        --     * The false branch starts in state \BitMask::SetOne(UInt16).0._State_6\ and ends in state \BitMask::SetOne(UInt16).0._State_8\.
                        --     * Execution after either branch will continue in the following state: \BitMask::SetOne(UInt16).0._State_3\.

                        if (\BitMask::SetOne(UInt16).0.flag\) then 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_4\;
                        else 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \BitMask::SetOne(UInt16).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::SetOne(UInt16).0.return\ <= \BitMask::SetOne(UInt16).0.result\;
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::SetOne(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::SetOne(UInt16).0.result\.\IsNull\ := false;
                        \BitMask::SetOne(UInt16).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::SetOne(UInt16).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::SetOne(UInt16).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::SetOne(UInt16).0.result\;
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::SetOne(UInt16).0.this\;
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::SetOne(UInt16).0.result\ := \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::SetOne(UInt16).0.this\ := \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_2\.
                            if (\BitMask::SetOne(UInt16).0._State\ = \BitMask::SetOne(UInt16).0._State_5\) then 
                                \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask::SetOne(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	System.Int32 remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175;
                        -- 	remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175 = (System.Int32)(index);
                        -- 	num = (int)(remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175 - remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175 / 32 * 32);
                        -- 	index2 = index >> 5;
                        -- 	System.UInt32 remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935;
                        -- 	remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 = @this.Segments [index2] >> num;
                        -- 	flag2 = remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 - remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 / 2u * 2u == 0u;
                        -- 	if (flag2) {
                        -- 		uint[] array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444;
                        -- 		array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 = new uint[1];
                        -- 		System.Array.Copy (@this.Segments, array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 1);
                        -- 		array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 [index2] = @this.Segments [index2] | 1u << num;
                        -- 		result = BitMask.FromImmutableArray (array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 32);
                        -- 	}
                        -- 	else {
                        -- 		result = new BitMask (@this);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- System.Int32 remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175 = (System.Int32)(index);
                        -- 
                        \BitMask::SetOne(UInt16).0.remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175\ := signed(SmartResize((\BitMask::SetOne(UInt16).0.index\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175 - remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175 / 32 * 32);
                        -- 
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.1\ := \BitMask::SetOne(UInt16).0.remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175\ / to_signed(32, 32);
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.2\ := SmartResize(\BitMask::SetOne(UInt16).0.binaryOperationResult.1\ * to_signed(32, 32), 32);
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.3\ := \BitMask::SetOne(UInt16).0.remainderOperand02b877f8c6d625171f8a4cd5c813d2ae4ea452fa67ec30bf31fbe1b788bc7175\ - \BitMask::SetOne(UInt16).0.binaryOperationResult.2\;
                        \BitMask::SetOne(UInt16).0.num\ := (\BitMask::SetOne(UInt16).0.binaryOperationResult.3\);
                        -- The following section was transformed from the .NET statement below:
                        -- index2 = index >> 5;
                        -- 
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.4\ := signed(SmartResize(shift_right(\BitMask::SetOne(UInt16).0.index\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::SetOne(UInt16).0.index2\ := \BitMask::SetOne(UInt16).0.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- System.UInt32 remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 = @this.Segments [index2] >> num;
                        -- 
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.5\ := shift_right(\BitMask::SetOne(UInt16).0.this\.\Segments\(to_integer(\BitMask::SetOne(UInt16).0.index2\)), to_integer(unsigned(SmartResize(unsigned(\BitMask::SetOne(UInt16).0.num\), 5) and "11111")));
                        \BitMask::SetOne(UInt16).0.remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935\ := \BitMask::SetOne(UInt16).0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 - remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 / 2u * 2u == 0u;
                        -- 
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.9928
                    when \BitMask::SetOne(UInt16).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.6\ := \BitMask::SetOne(UInt16).0.remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935\ / to_unsigned(2, 32);
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.7\ := SmartResize(\BitMask::SetOne(UInt16).0.binaryOperationResult.6\ * to_unsigned(2, 32), 32);
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.8\ := \BitMask::SetOne(UInt16).0.remainderOperand735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935\ - \BitMask::SetOne(UInt16).0.binaryOperationResult.7\;
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.9\ := \BitMask::SetOne(UInt16).0.binaryOperationResult.8\ = to_unsigned(0, 32);
                        \BitMask::SetOne(UInt16).0.flag2\ := \BitMask::SetOne(UInt16).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	uint[] array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444;
                        -- 	array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 = new uint[1];
                        -- 	System.Array.Copy (@this.Segments, array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 1);
                        -- 	array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 [index2] = @this.Segments [index2] | 1u << num;
                        -- 	result = BitMask.FromImmutableArray (array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 32);
                        -- }
                        -- else {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::SetOne(UInt16).0._State_9\ and ends in state \BitMask::SetOne(UInt16).0._State_10\.
                        --     * The false branch starts in state \BitMask::SetOne(UInt16).0._State_11\ and ends in state \BitMask::SetOne(UInt16).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \BitMask::SetOne(UInt16).0._State_8\.

                        if (\BitMask::SetOne(UInt16).0.flag2\) then 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_9\;
                        else 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7907
                    when \BitMask::SetOne(UInt16).0._State_8\ => 
                        -- State after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_7\.
                        -- Going to the state after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_2\.
                        if (\BitMask::SetOne(UInt16).0._State\ = \BitMask::SetOne(UInt16).0._State_8\) then 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_9\ => 
                        -- True branch of the if-else started in state \BitMask::SetOne(UInt16).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint[] array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444;
                        -- 	array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 = new uint[1];
                        -- 	System.Array.Copy (@this.Segments, array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 1);
                        -- 	array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 [index2] = @this.Segments [index2] | 1u << num;
                        -- 	result = BitMask.FromImmutableArray (array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 = new uint[1];
                        -- 
                        \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- System.Array.Copy (@this.Segments, array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 1);
                        -- 
                        \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\ := \BitMask::SetOne(UInt16).0.this\.\Segments\(0 to 0);
                        -- The following section was transformed from the .NET statement below:
                        -- array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 [index2] = @this.Segments [index2] | 1u << num;
                        -- 
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.10\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(\BitMask::SetOne(UInt16).0.num\, 5))));
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.11\ := \BitMask::SetOne(UInt16).0.this\.\Segments\(to_integer(\BitMask::SetOne(UInt16).0.index2\)) or \BitMask::SetOne(UInt16).0.binaryOperationResult.10\;
                        \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\(to_integer(\BitMask::SetOne(UInt16).0.index2\)) := \BitMask::SetOne(UInt16).0.binaryOperationResult.11\;
                        -- The following section was transformed from the .NET statement below:
                        -- result = BitMask.FromImmutableArray (array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\;
                        \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0.2386
                    when \BitMask::SetOne(UInt16).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        if (\BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::SetOne(UInt16).0.return.0\ := \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\;
                            \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\ := \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\;
                            \BitMask::SetOne(UInt16).0.result\ := \BitMask::SetOne(UInt16).0.return.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_7\.
                            if (\BitMask::SetOne(UInt16).0._State\ = \BitMask::SetOne(UInt16).0._State_10\) then 
                                \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_8\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_11\ => 
                        -- False branch of the if-else started in state \BitMask::SetOne(UInt16).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::SetOne(UInt16).0.result\.\IsNull\ := false;
                        \BitMask::SetOne(UInt16).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::SetOne(UInt16).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::SetOne(UInt16).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::SetOne(UInt16).0.result\;
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::SetOne(UInt16).0.this\;
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::SetOne(UInt16).0.result\ := \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::SetOne(UInt16).0.this\ := \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_7\.
                            if (\BitMask::SetOne(UInt16).0._State\ = \BitMask::SetOne(UInt16).0._State_12\) then 
                                \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_8\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0 state machine start
    \BitMask::SetZero(UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::SetZero(UInt16).0._State\: \BitMask::SetZero(UInt16).0._States\ := \BitMask::SetZero(UInt16).0._State_0\;
        Variable \BitMask::SetZero(UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::SetZero(UInt16).0.index\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::SetZero(UInt16).0.flag\: boolean := false;
        Variable \BitMask::SetZero(UInt16).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::SetZero(UInt16).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.index2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.flag2\: boolean := false;
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask::SetZero(UInt16).0.remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.10\: boolean := false;
        Variable \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.return.0\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::SetZero(UInt16).0._Finished\ <= false;
                \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_0\;
                \BitMask::SetZero(UInt16).0.index\ := to_unsigned(0, 16);
                \BitMask::SetZero(UInt16).0.flag\ := false;
                \BitMask::SetZero(UInt16).0.num\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.index2\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.flag2\ := false;
                \BitMask::SetZero(UInt16).0.binaryOperationResult.0\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.1\ := false;
                \BitMask::SetZero(UInt16).0.remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.3\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.4\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.5\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.9\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.10\ := false;
                \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\ := (others => to_unsigned(0, 32));
                \BitMask::SetZero(UInt16).0.binaryOperationResult.11\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.12\ := to_unsigned(0, 32);
            else 
                case \BitMask::SetZero(UInt16).0._State\ is 
                    when \BitMask::SetZero(UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::SetZero(UInt16).0._Started\ = true) then 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::SetZero(UInt16).0._Started\ = true) then 
                            \BitMask::SetZero(UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::SetZero(UInt16).0._Finished\ <= false;
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_2\ => 
                        \BitMask::SetZero(UInt16).0.this\ := \BitMask::SetZero(UInt16).0.this.parameter.In\;
                        \BitMask::SetZero(UInt16).0.index\ := \BitMask::SetZero(UInt16).0.index.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int index2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (System.Int32)(index) > (System.Int32)((System.Int32)(@this.SegmentCount) * 32);
                        -- 
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\BitMask::SetZero(UInt16).0.this\.\SegmentCount\), 32)) * to_signed(32, 32), 32);
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.1\ := signed(SmartResize((\BitMask::SetZero(UInt16).0.index\), 32)) > (\BitMask::SetZero(UInt16).0.binaryOperationResult.0\);
                        \BitMask::SetZero(UInt16).0.flag\ := \BitMask::SetZero(UInt16).0.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- else {
                        -- 	System.Int32 remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14;
                        -- 	remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14 = (System.Int32)(index);
                        -- 	num = (int)(remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14 - remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14 / 32 * 32);
                        -- 	index2 = index >> 5;
                        -- 	System.UInt32 remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a;
                        -- 	remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a = @this.Segments [index2] >> num;
                        -- 	flag2 = remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a - remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a / 2u * 2u == 1u;
                        -- 	if (flag2) {
                        -- 		uint[] array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b;
                        -- 		array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b = new uint[1];
                        -- 		System.Array.Copy (@this.Segments, array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, 1);
                        -- 		array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b [index2] = @this.Segments [index2] & ~1u << num;
                        -- 		result = BitMask.FromImmutableArray (array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, @this.Size);
                        -- 	}
                        -- 	else {
                        -- 		result = new BitMask (@this);
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::SetZero(UInt16).0._State_4\ and ends in state \BitMask::SetZero(UInt16).0._State_5\.
                        --     * The false branch starts in state \BitMask::SetZero(UInt16).0._State_6\ and ends in state \BitMask::SetZero(UInt16).0._State_8\.
                        --     * Execution after either branch will continue in the following state: \BitMask::SetZero(UInt16).0._State_3\.

                        if (\BitMask::SetZero(UInt16).0.flag\) then 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_4\;
                        else 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3755
                    when \BitMask::SetZero(UInt16).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::SetZero(UInt16).0.return\ <= \BitMask::SetZero(UInt16).0.result\;
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::SetZero(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::SetZero(UInt16).0.result\.\IsNull\ := false;
                        \BitMask::SetZero(UInt16).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::SetZero(UInt16).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::SetZero(UInt16).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.result\;
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.this\;
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::SetZero(UInt16).0.result\ := \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::SetZero(UInt16).0.this\ := \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_2\.
                            if (\BitMask::SetZero(UInt16).0._State\ = \BitMask::SetZero(UInt16).0._State_5\) then 
                                \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask::SetZero(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	System.Int32 remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14;
                        -- 	remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14 = (System.Int32)(index);
                        -- 	num = (int)(remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14 - remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14 / 32 * 32);
                        -- 	index2 = index >> 5;
                        -- 	System.UInt32 remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a;
                        -- 	remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a = @this.Segments [index2] >> num;
                        -- 	flag2 = remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a - remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a / 2u * 2u == 1u;
                        -- 	if (flag2) {
                        -- 		uint[] array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b;
                        -- 		array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b = new uint[1];
                        -- 		System.Array.Copy (@this.Segments, array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, 1);
                        -- 		array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b [index2] = @this.Segments [index2] & ~1u << num;
                        -- 		result = BitMask.FromImmutableArray (array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, @this.Size);
                        -- 	}
                        -- 	else {
                        -- 		result = new BitMask (@this);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- System.Int32 remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14 = (System.Int32)(index);
                        -- 
                        \BitMask::SetZero(UInt16).0.remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14\ := signed(SmartResize((\BitMask::SetZero(UInt16).0.index\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14 - remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14 / 32 * 32);
                        -- 
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.2\ := \BitMask::SetZero(UInt16).0.remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14\ / to_signed(32, 32);
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.3\ := SmartResize(\BitMask::SetZero(UInt16).0.binaryOperationResult.2\ * to_signed(32, 32), 32);
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.4\ := \BitMask::SetZero(UInt16).0.remainderOperand799ecd8708e27433ebc3e6acc93a15db1a86431c1f2093f5abe99390f839be14\ - \BitMask::SetZero(UInt16).0.binaryOperationResult.3\;
                        \BitMask::SetZero(UInt16).0.num\ := (\BitMask::SetZero(UInt16).0.binaryOperationResult.4\);
                        -- The following section was transformed from the .NET statement below:
                        -- index2 = index >> 5;
                        -- 
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.5\ := signed(SmartResize(shift_right(\BitMask::SetZero(UInt16).0.index\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::SetZero(UInt16).0.index2\ := \BitMask::SetZero(UInt16).0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- System.UInt32 remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a = @this.Segments [index2] >> num;
                        -- 
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.6\ := shift_right(\BitMask::SetZero(UInt16).0.this\.\Segments\(to_integer(\BitMask::SetZero(UInt16).0.index2\)), to_integer(unsigned(SmartResize(unsigned(\BitMask::SetZero(UInt16).0.num\), 5) and "11111")));
                        \BitMask::SetZero(UInt16).0.remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a\ := \BitMask::SetZero(UInt16).0.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a - remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a / 2u * 2u == 1u;
                        -- 
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.9928
                    when \BitMask::SetZero(UInt16).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.7\ := \BitMask::SetZero(UInt16).0.remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a\ / to_unsigned(2, 32);
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.8\ := SmartResize(\BitMask::SetZero(UInt16).0.binaryOperationResult.7\ * to_unsigned(2, 32), 32);
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.9\ := \BitMask::SetZero(UInt16).0.remainderOperandb861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a\ - \BitMask::SetZero(UInt16).0.binaryOperationResult.8\;
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.10\ := \BitMask::SetZero(UInt16).0.binaryOperationResult.9\ = to_unsigned(1, 32);
                        \BitMask::SetZero(UInt16).0.flag2\ := \BitMask::SetZero(UInt16).0.binaryOperationResult.10\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	uint[] array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b;
                        -- 	array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b = new uint[1];
                        -- 	System.Array.Copy (@this.Segments, array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, 1);
                        -- 	array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b [index2] = @this.Segments [index2] & ~1u << num;
                        -- 	result = BitMask.FromImmutableArray (array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, @this.Size);
                        -- }
                        -- else {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::SetZero(UInt16).0._State_9\ and ends in state \BitMask::SetZero(UInt16).0._State_10\.
                        --     * The false branch starts in state \BitMask::SetZero(UInt16).0._State_11\ and ends in state \BitMask::SetZero(UInt16).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \BitMask::SetZero(UInt16).0._State_8\.

                        if (\BitMask::SetZero(UInt16).0.flag2\) then 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_9\;
                        else 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7907
                    when \BitMask::SetZero(UInt16).0._State_8\ => 
                        -- State after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_7\.
                        -- Going to the state after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_2\.
                        if (\BitMask::SetZero(UInt16).0._State\ = \BitMask::SetZero(UInt16).0._State_8\) then 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_9\ => 
                        -- True branch of the if-else started in state \BitMask::SetZero(UInt16).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint[] array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b;
                        -- 	array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b = new uint[1];
                        -- 	System.Array.Copy (@this.Segments, array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, 1);
                        -- 	array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b [index2] = @this.Segments [index2] & ~1u << num;
                        -- 	result = BitMask.FromImmutableArray (array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, @this.Size);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b = new uint[1];
                        -- 
                        \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- System.Array.Copy (@this.Segments, array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, 1);
                        -- 
                        \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\ := \BitMask::SetZero(UInt16).0.this\.\Segments\(0 to 0);
                        -- The following section was transformed from the .NET statement below:
                        -- array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b [index2] = @this.Segments [index2] & ~1u << num;
                        -- 
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.11\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(\BitMask::SetZero(UInt16).0.num\, 5))));
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.12\ := \BitMask::SetZero(UInt16).0.this\.\Segments\(to_integer(\BitMask::SetZero(UInt16).0.index2\)) and not(\BitMask::SetZero(UInt16).0.binaryOperationResult.11\);
                        \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\(to_integer(\BitMask::SetZero(UInt16).0.index2\)) := \BitMask::SetZero(UInt16).0.binaryOperationResult.12\;
                        -- The following section was transformed from the .NET statement below:
                        -- result = BitMask.FromImmutableArray (array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, @this.Size);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\;
                        \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.this\.\Size\;
                        \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                    when \BitMask::SetZero(UInt16).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        if (\BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::SetZero(UInt16).0.return.0\ := \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\;
                            \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\ := \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\;
                            \BitMask::SetZero(UInt16).0.result\ := \BitMask::SetZero(UInt16).0.return.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_7\.
                            if (\BitMask::SetZero(UInt16).0._State\ = \BitMask::SetZero(UInt16).0._State_10\) then 
                                \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_8\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_11\ => 
                        -- False branch of the if-else started in state \BitMask::SetZero(UInt16).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::SetZero(UInt16).0.result\.\IsNull\ := false;
                        \BitMask::SetZero(UInt16).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::SetZero(UInt16).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::SetZero(UInt16).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.result\;
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.this\;
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::SetZero(UInt16).0.result\ := \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::SetZero(UInt16).0.this\ := \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_7\.
                            if (\BitMask::SetZero(UInt16).0._State\ = \BitMask::SetZero(UInt16).0._State_12\) then 
                                \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_8\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask::op_Equality(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::op_Equality(BitMask,BitMask).0._State\: \BitMask::op_Equality(BitMask,BitMask).0._States\ := \BitMask::op_Equality(BitMask,BitMask).0._State_0\;
        Variable \BitMask::op_Equality(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Equality(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Equality(BitMask,BitMask).0.flag\: boolean := false;
        Variable \BitMask::op_Equality(BitMask,BitMask).0.result\: boolean := false;
        Variable \BitMask::op_Equality(BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Equality(BitMask,BitMask).0.flag2\: boolean := false;
        Variable \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.2\: boolean := false;
        Variable \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::op_Equality(BitMask,BitMask).0._Finished\ <= false;
                \BitMask::op_Equality(BitMask,BitMask).0.return\ <= false;
                \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_0\;
                \BitMask::op_Equality(BitMask,BitMask).0.flag\ := false;
                \BitMask::op_Equality(BitMask,BitMask).0.result\ := false;
                \BitMask::op_Equality(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \BitMask::op_Equality(BitMask,BitMask).0.flag2\ := false;
                \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.0\ := false;
                \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.1\ := false;
                \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.2\ := false;
                \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.3\ := to_unsigned(0, 16);
            else 
                case \BitMask::op_Equality(BitMask,BitMask).0._State\ is 
                    when \BitMask::op_Equality(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::op_Equality(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Equality(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::op_Equality(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_Equality(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \BitMask::op_Equality(BitMask,BitMask).0._Finished\ <= false;
                            \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Equality(BitMask,BitMask).0._State_2\ => 
                        \BitMask::op_Equality(BitMask,BitMask).0.left\ := \BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\;
                        \BitMask::op_Equality(BitMask,BitMask).0.right\ := \BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = 1 != (System.Int32)(right.SegmentCount);
                        -- 
                        \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.0\ := to_signed(1, 32) /= signed(SmartResize((\BitMask::op_Equality(BitMask,BitMask).0.right\.\SegmentCount\), 32));
                        \BitMask::op_Equality(BitMask,BitMask).0.flag\ := \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = false;
                        -- }
                        -- else {
                        -- 	num = 0;
                        -- 	while ((System.Int32)(num) < (System.Int32)(left.SegmentCount)) {
                        -- 		flag2 = left.Segments [(int)num] != right.Segments [(int)num];
                        -- 		if (flag2) {
                        -- 			result = false;
                        -- 			return result;
                        -- 		}
                        -- 		num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 	}
                        -- 	result = true;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Equality(BitMask,BitMask).0._State_4\ and ends in state \BitMask::op_Equality(BitMask,BitMask).0._State_4\.
                        --     * The false branch starts in state \BitMask::op_Equality(BitMask,BitMask).0._State_5\ and ends in state \BitMask::op_Equality(BitMask,BitMask).0._State_7\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Equality(BitMask,BitMask).0._State_3\.

                        if (\BitMask::op_Equality(BitMask,BitMask).0.flag\) then 
                            \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_4\;
                        else 
                            \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \BitMask::op_Equality(BitMask,BitMask).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::op_Equality(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::op_Equality(BitMask,BitMask).0.return\ <= \BitMask::op_Equality(BitMask,BitMask).0.result\;
                        \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Equality(BitMask,BitMask).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::op_Equality(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = false;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = false;
                        -- 
                        \BitMask::op_Equality(BitMask,BitMask).0.result\ := False;
                        -- Going to the state after the if-else which was started in state \BitMask::op_Equality(BitMask,BitMask).0._State_2\.
                        if (\BitMask::op_Equality(BitMask,BitMask).0._State\ = \BitMask::op_Equality(BitMask,BitMask).0._State_4\) then 
                            \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Equality(BitMask,BitMask).0._State_5\ => 
                        -- False branch of the if-else started in state \BitMask::op_Equality(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- 	while ((System.Int32)(num) < (System.Int32)(left.SegmentCount)) {
                        -- 		flag2 = left.Segments [(int)num] != right.Segments [(int)num];
                        -- 		if (flag2) {
                        -- 			result = false;
                        -- 			return result;
                        -- 		}
                        -- 		num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 	}
                        -- 	result = true;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \BitMask::op_Equality(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((System.Int32)(num) < (System.Int32)(left.SegmentCount)) {
                        -- 	flag2 = left.Segments [(int)num] != right.Segments [(int)num];
                        -- 	if (flag2) {
                        -- 		result = false;
                        -- 		return result;
                        -- 	}
                        -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Equality(BitMask,BitMask).0._State_6\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::op_Equality(BitMask,BitMask).0._State_5\.
                        -- The while loop's condition:
                        \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.1\ := signed(SmartResize((\BitMask::op_Equality(BitMask,BitMask).0.num\), 32)) < signed(SmartResize((\BitMask::op_Equality(BitMask,BitMask).0.left\.\SegmentCount\), 32));
                        if (\BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag2 = left.Segments [(int)num] != right.Segments [(int)num];
                            -- 	if (flag2) {
                            -- 		result = false;
                            -- 		return result;
                            -- 	}
                            -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = left.Segments [(int)num] != right.Segments [(int)num];
                            -- 
                            \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.2\ := \BitMask::op_Equality(BitMask,BitMask).0.left\.\Segments\(to_integer(signed(SmartResize(\BitMask::op_Equality(BitMask,BitMask).0.num\, 32)))) /= \BitMask::op_Equality(BitMask,BitMask).0.right\.\Segments\(to_integer(signed(SmartResize(\BitMask::op_Equality(BitMask,BitMask).0.num\, 32))));
                            \BitMask::op_Equality(BitMask,BitMask).0.flag2\ := \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag2) {
                            -- 	result = false;
                            -- 	return result;
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \BitMask::op_Equality(BitMask,BitMask).0._State_9\ and ends in state \BitMask::op_Equality(BitMask,BitMask).0._State_9\.
                            --     * Execution after either branch will continue in the following state: \BitMask::op_Equality(BitMask,BitMask).0._State_8\.

                            if (\BitMask::op_Equality(BitMask,BitMask).0.flag2\) then 
                                \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_9\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_8\;
                            end if;
                        else 
                            \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5361
                    when \BitMask::op_Equality(BitMask,BitMask).0._State_7\ => 
                        -- State after the while loop which was started in state \BitMask::op_Equality(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = true;
                        -- 
                        \BitMask::op_Equality(BitMask,BitMask).0.result\ := True;
                        -- Going to the state after the if-else which was started in state \BitMask::op_Equality(BitMask,BitMask).0._State_2\.
                        if (\BitMask::op_Equality(BitMask,BitMask).0._State\ = \BitMask::op_Equality(BitMask,BitMask).0._State_7\) then 
                            \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Equality(BitMask,BitMask).0._State_8\ => 
                        -- State after the if-else which was started in state \BitMask::op_Equality(BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 
                        \BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.3\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_Equality(BitMask,BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_Equality(BitMask,BitMask).0.num\ := (\BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.3\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::op_Equality(BitMask,BitMask).0._State_5\ if the loop wasn't exited with a state change.
                        if (\BitMask::op_Equality(BitMask,BitMask).0._State\ = \BitMask::op_Equality(BitMask,BitMask).0._State_8\) then 
                            \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \BitMask::op_Equality(BitMask,BitMask).0._State_9\ => 
                        -- True branch of the if-else started in state \BitMask::op_Equality(BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = false;
                        -- 	return result;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = false;
                        -- 
                        \BitMask::op_Equality(BitMask,BitMask).0.result\ := False;
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::op_Equality(BitMask,BitMask).0.return\ <= \BitMask::op_Equality(BitMask,BitMask).0.result\;
                        \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_1\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_Equality(BitMask,BitMask).0._State_6\.
                        if (\BitMask::op_Equality(BitMask,BitMask).0._State\ = \BitMask::op_Equality(BitMask,BitMask).0._State_9\) then 
                            \BitMask::op_Equality(BitMask,BitMask).0._State\ := \BitMask::op_Equality(BitMask,BitMask).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask::op_LessThan(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::op_LessThan(BitMask,BitMask).0._State\: \BitMask::op_LessThan(BitMask,BitMask).0._States\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_0\;
        Variable \BitMask::op_LessThan(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_LessThan(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_LessThan(BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_LessThan(BitMask,BitMask).0.flag\: boolean := false;
        Variable \BitMask::op_LessThan(BitMask,BitMask).0.result\: boolean := false;
        Variable \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.3\: boolean := false;
        Variable \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::op_LessThan(BitMask,BitMask).0._Finished\ <= false;
                \BitMask::op_LessThan(BitMask,BitMask).0.return\ <= false;
                \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_0\;
                \BitMask::op_LessThan(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \BitMask::op_LessThan(BitMask,BitMask).0.flag\ := false;
                \BitMask::op_LessThan(BitMask,BitMask).0.result\ := false;
                \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.0\ := false;
                \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.3\ := false;
                \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.4\ := to_unsigned(0, 16);
            else 
                case \BitMask::op_LessThan(BitMask,BitMask).0._State\ is 
                    when \BitMask::op_LessThan(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::op_LessThan(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_LessThan(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::op_LessThan(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_LessThan(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \BitMask::op_LessThan(BitMask,BitMask).0._Finished\ <= false;
                            \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_LessThan(BitMask,BitMask).0._State_2\ => 
                        \BitMask::op_LessThan(BitMask,BitMask).0.left\ := \BitMask::op_LessThan(BitMask,BitMask).0.left.parameter.In\;
                        \BitMask::op_LessThan(BitMask,BitMask).0.right\ := \BitMask::op_LessThan(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1;
                        -- 
                        \BitMask::op_LessThan(BitMask,BitMask).0.num\ := to_unsigned(1, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((System.Int32)(num) <= (System.Int32)(left.SegmentCount)) {
                        -- 	flag = left.Segments [(int)((System.Int32)(left.SegmentCount) - (System.Int32)(num))] < right.Segments [(int)((System.Int32)(left.SegmentCount) - (System.Int32)(num))];
                        -- 	if (flag) {
                        -- 		result = true;
                        -- 		return result;
                        -- 	}
                        -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_LessThan(BitMask,BitMask).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::op_LessThan(BitMask,BitMask).0._State_2\.
                        -- The while loop's condition:
                        \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.0\ := signed(SmartResize((\BitMask::op_LessThan(BitMask,BitMask).0.num\), 32)) <= signed(SmartResize((\BitMask::op_LessThan(BitMask,BitMask).0.left\.\SegmentCount\), 32));
                        if (\BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag = left.Segments [(int)((System.Int32)(left.SegmentCount) - (System.Int32)(num))] < right.Segments [(int)((System.Int32)(left.SegmentCount) - (System.Int32)(num))];
                            -- 	if (flag) {
                            -- 		result = true;
                            -- 		return result;
                            -- 	}
                            -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag = left.Segments [(int)((System.Int32)(left.SegmentCount) - (System.Int32)(num))] < right.Segments [(int)((System.Int32)(left.SegmentCount) - (System.Int32)(num))];
                            -- 
                            \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.1\ := signed(SmartResize((\BitMask::op_LessThan(BitMask,BitMask).0.left\.\SegmentCount\), 32)) - signed(SmartResize((\BitMask::op_LessThan(BitMask,BitMask).0.num\), 32));
                            \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.2\ := signed(SmartResize((\BitMask::op_LessThan(BitMask,BitMask).0.left\.\SegmentCount\), 32)) - signed(SmartResize((\BitMask::op_LessThan(BitMask,BitMask).0.num\), 32));
                            \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_5\;
                        else 
                            \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8922
                    when \BitMask::op_LessThan(BitMask,BitMask).0._State_4\ => 
                        -- State after the while loop which was started in state \BitMask::op_LessThan(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = false;
                        -- 
                        \BitMask::op_LessThan(BitMask,BitMask).0.result\ := False;
                        -- The following section was transformed from the .NET statement below:
                        -- return false;
                        -- 
                        \BitMask::op_LessThan(BitMask,BitMask).0.return\ <= False;
                        \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_LessThan(BitMask,BitMask).0._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.3\ := \BitMask::op_LessThan(BitMask,BitMask).0.left\.\Segments\(to_integer((\BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.1\))) < \BitMask::op_LessThan(BitMask,BitMask).0.right\.\Segments\(to_integer((\BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.2\)));
                        \BitMask::op_LessThan(BitMask,BitMask).0.flag\ := \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = true;
                        -- 	return result;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_LessThan(BitMask,BitMask).0._State_7\ and ends in state \BitMask::op_LessThan(BitMask,BitMask).0._State_7\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_LessThan(BitMask,BitMask).0._State_6\.

                        if (\BitMask::op_LessThan(BitMask,BitMask).0.flag\) then 
                            \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_7\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \BitMask::op_LessThan(BitMask,BitMask).0._State_6\ => 
                        -- State after the if-else which was started in state \BitMask::op_LessThan(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 
                        \BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.4\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_LessThan(BitMask,BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_LessThan(BitMask,BitMask).0.num\ := (\BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.4\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::op_LessThan(BitMask,BitMask).0._State_2\ if the loop wasn't exited with a state change.
                        if (\BitMask::op_LessThan(BitMask,BitMask).0._State\ = \BitMask::op_LessThan(BitMask,BitMask).0._State_6\) then 
                            \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \BitMask::op_LessThan(BitMask,BitMask).0._State_7\ => 
                        -- True branch of the if-else started in state \BitMask::op_LessThan(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = true;
                        -- 	return result;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = true;
                        -- 
                        \BitMask::op_LessThan(BitMask,BitMask).0.result\ := True;
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::op_LessThan(BitMask,BitMask).0.return\ <= \BitMask::op_LessThan(BitMask,BitMask).0.result\;
                        \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_1\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_LessThan(BitMask,BitMask).0._State_5\.
                        if (\BitMask::op_LessThan(BitMask,BitMask).0._State\ = \BitMask::op_LessThan(BitMask,BitMask).0._State_7\) then 
                            \BitMask::op_LessThan(BitMask,BitMask).0._State\ := \BitMask::op_LessThan(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\: \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._States\ := \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_0\;
        Variable \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return.0\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\ <= false;
                \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return\ <= false;
                \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask)._Started.0\ <= false;
                \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ := \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_0\;
                \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return.0\ := false;
            else 
                case \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ is 
                    when \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ := \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\ <= false;
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ := \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_2\ => 
                        \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left\ := \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left.parameter.In\;
                        \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right\ := \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return !BitMask.op_LessThan (left, right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask).left.parameter.Out.0\ <= \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left\;
                        \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask).right.parameter.Out.0\ <= \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right\;
                        \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask)._Started.0\ <= true;
                        \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ := \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.1002
                    when \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask)._Started.0\ = \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask)._Finished.0\) then 
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask)._Started.0\ <= false;
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return.0\ := \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask).return.0\;
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return\ <= not(\BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return.0\);
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ := \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0 state machine start
    \BitMask::op_Addition(BitMask,UInt32).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::op_Addition(BitMask,UInt32).0._State\: \BitMask::op_Addition(BitMask,UInt32).0._States\ := \BitMask::op_Addition(BitMask,UInt32).0._State_0\;
        Variable \BitMask::op_Addition(BitMask,UInt32).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Addition(BitMask,UInt32).0.right\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Addition(BitMask,UInt32).0.return.0\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::op_Addition(BitMask,UInt32).0._Finished\ <= false;
                \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                \BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask::op_Addition(BitMask,UInt32).0._State_0\;
                \BitMask::op_Addition(BitMask,UInt32).0.right\ := to_unsigned(0, 32);
            else 
                case \BitMask::op_Addition(BitMask,UInt32).0._State\ is 
                    when \BitMask::op_Addition(BitMask,UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::op_Addition(BitMask,UInt32).0._Started\ = true) then 
                            \BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask::op_Addition(BitMask,UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::op_Addition(BitMask,UInt32).0._Started\ = true) then 
                            \BitMask::op_Addition(BitMask,UInt32).0._Finished\ <= true;
                        else 
                            \BitMask::op_Addition(BitMask,UInt32).0._Finished\ <= false;
                            \BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask::op_Addition(BitMask,UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,UInt32).0._State_2\ => 
                        \BitMask::op_Addition(BitMask,UInt32).0.left\ := \BitMask::op_Addition(BitMask,UInt32).0.left.parameter.In\;
                        \BitMask::op_Addition(BitMask,UInt32).0.right\ := \BitMask::op_Addition(BitMask,UInt32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7 = new BitMask (right, left.Size);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\.\IsNull\ := false;
                        \BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\.\Size\ := to_unsigned(0, 16);
                        \BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\;
                        \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= \BitMask::op_Addition(BitMask,UInt32).0.right\;
                        \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= \BitMask::op_Addition(BitMask,UInt32).0.left\.\Size\;
                        \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask::op_Addition(BitMask,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\ := \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return BitMask.op_Addition (left, objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \BitMask::op_Addition(BitMask,UInt32).0.left\;
                            \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\;
                            \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask::op_Addition(BitMask,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,UInt32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \BitMask::op_Addition(BitMask,UInt32).0.return.0\ := \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \BitMask::op_Addition(BitMask,UInt32).0.return\ <= \BitMask::op_Addition(BitMask,UInt32).0.return.0\;
                            \BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask::op_Addition(BitMask,UInt32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0 state machine start
    \BitMask::op_Subtraction(BitMask,UInt32).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::op_Subtraction(BitMask,UInt32).0._State\: \BitMask::op_Subtraction(BitMask,UInt32).0._States\ := \BitMask::op_Subtraction(BitMask,UInt32).0._State_0\;
        Variable \BitMask::op_Subtraction(BitMask,UInt32).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Subtraction(BitMask,UInt32).0.right\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Subtraction(BitMask,UInt32).0.return.0\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::op_Subtraction(BitMask,UInt32).0._Finished\ <= false;
                \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                \BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask::op_Subtraction(BitMask,UInt32).0._State_0\;
                \BitMask::op_Subtraction(BitMask,UInt32).0.right\ := to_unsigned(0, 32);
            else 
                case \BitMask::op_Subtraction(BitMask,UInt32).0._State\ is 
                    when \BitMask::op_Subtraction(BitMask,UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::op_Subtraction(BitMask,UInt32).0._Started\ = true) then 
                            \BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask::op_Subtraction(BitMask,UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::op_Subtraction(BitMask,UInt32).0._Started\ = true) then 
                            \BitMask::op_Subtraction(BitMask,UInt32).0._Finished\ <= true;
                        else 
                            \BitMask::op_Subtraction(BitMask,UInt32).0._Finished\ <= false;
                            \BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask::op_Subtraction(BitMask,UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,UInt32).0._State_2\ => 
                        \BitMask::op_Subtraction(BitMask,UInt32).0.left\ := \BitMask::op_Subtraction(BitMask,UInt32).0.left.parameter.In\;
                        \BitMask::op_Subtraction(BitMask,UInt32).0.right\ := \BitMask::op_Subtraction(BitMask,UInt32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b = new BitMask (1u, left.Size);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\.\IsNull\ := false;
                        \BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\.\Size\ := to_unsigned(0, 16);
                        \BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\;
                        \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(1, 32);
                        \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= \BitMask::op_Subtraction(BitMask,UInt32).0.left\.\Size\;
                        \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask::op_Subtraction(BitMask,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\ := \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return BitMask.op_Subtraction (left, objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\ <= \BitMask::op_Subtraction(BitMask,UInt32).0.left\;
                            \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\ <= \BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\;
                            \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= true;
                            \BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask::op_Subtraction(BitMask,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,UInt32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\) then 
                            \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                            \BitMask::op_Subtraction(BitMask,UInt32).0.return.0\ := \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask).return.0\;
                            \BitMask::op_Subtraction(BitMask,UInt32).0.return\ <= \BitMask::op_Subtraction(BitMask,UInt32).0.return.0\;
                            \BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask::op_Subtraction(BitMask,UInt32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask::op_Addition(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::op_Addition(BitMask,BitMask).0._State\: \BitMask::op_Addition(BitMask,BitMask).0._States\ := \BitMask::op_Addition(BitMask,BitMask).0._State_0\;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.flag\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.flag2\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::op_Addition(BitMask,BitMask).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.flag3\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.flag4\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.flag5\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.flag6\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.2\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.3\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.4\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.9\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.11\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.14\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.15\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.16\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.18\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.19\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.20\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.21\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.22\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.23\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.24\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.25\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.26\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.27\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.29\: boolean := false;
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.30\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.31\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::op_Addition(BitMask,BitMask).0._Finished\ <= false;
                \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_0\;
                \BitMask::op_Addition(BitMask,BitMask).0.flag\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.flag2\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \BitMask::op_Addition(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                \BitMask::op_Addition(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::op_Addition(BitMask,BitMask).0.num3\ := to_unsigned(0, 16);
                \BitMask::op_Addition(BitMask,BitMask).0.flag3\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.flag4\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.b\ := to_unsigned(0, 8);
                \BitMask::op_Addition(BitMask,BitMask).0.flag5\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.flag6\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.0\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.1\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.2\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383\ := to_unsigned(0, 16);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.3\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.4\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.9\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.11\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.12\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.13\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.14\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.15\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.16\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83\ := to_signed(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb\ := to_signed(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d\ := to_signed(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.17\ := to_signed(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.18\ := to_unsigned(0, 8);
                \BitMask::op_Addition(BitMask,BitMask).0.remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d\ := to_signed(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.19\ := to_signed(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.20\ := to_signed(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.21\ := to_signed(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.22\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.23\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.24\ := to_unsigned(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.25\ := to_signed(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.26\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.27\ := to_unsigned(0, 16);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.28\ := to_signed(0, 32);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.29\ := false;
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.30\ := to_unsigned(0, 16);
                \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.31\ := to_unsigned(0, 16);
            else 
                case \BitMask::op_Addition(BitMask,BitMask).0._State\ is 
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \BitMask::op_Addition(BitMask,BitMask).0._Finished\ <= false;
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_2\ => 
                        \BitMask::op_Addition(BitMask,BitMask).0.left\ := \BitMask::op_Addition(BitMask,BitMask).0.left.parameter.In\;
                        \BitMask::op_Addition(BitMask,BitMask).0.right\ := \BitMask::op_Addition(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (System.Int32)(left.SegmentCount) == 0 || (System.Int32)(right.SegmentCount) == 0;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.0\ := signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.left\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.1\ := signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.right\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.2\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.0\ or \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.1\;
                        \BitMask::op_Addition(BitMask,BitMask).0.flag\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = left;
                        -- }
                        -- else {
                        -- 	flag2 = false;
                        -- 	num = 0;
                        -- 	num2 = 0;
                        -- 	array = new uint[1];
                        -- 	num3 = 0;
                        -- 	ushort conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383;
                        -- 	if ((System.Int32)(left.Size) > (System.Int32)(right.Size)) {
                        -- 		conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383 = left.Size;
                        -- 	}
                        -- 	else {
                        -- 		conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383 = right.Size;
                        -- 	}
                        -- 	while ((System.Int32)(num3) < (System.Int32)(conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383)) {
                        -- 		System.UInt32 remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67;
                        -- 		remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 = left.Segments [(int)num] >> (int)num2;
                        -- 		flag3 = remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 - remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 / 2u * 2u == 1u;
                        -- 		System.UInt32 remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f;
                        -- 		remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f = right.Segments [(int)num] >> (int)num2;
                        -- 		flag4 = (System.Int32)(num3) < (System.Int32)(right.Size) && remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f - remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f / 2u * 2u == 1u;
                        -- 		int conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83;
                        -- 		if (flag3) {
                        -- 			conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- 		}
                        -- 		int conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb;
                        -- 		if (flag4) {
                        -- 			conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- 		}
                        -- 		int conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d;
                        -- 		if (flag2) {
                        -- 			conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- 		}
                        -- 		b = (byte)(conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 + conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb + conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d);
                        -- 		System.Int32 remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d;
                        -- 		remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d = (System.Int32)(b);
                        -- 		flag5 = (System.Int32)(remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d - remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d / 2 * 2) == 1;
                        -- 		if (flag5) {
                        -- 			array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 		}
                        -- 		flag2 = b >> 1 == 1;
                        -- 		num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 		flag6 = num2 >> 5 == 1;
                        -- 		if (flag6) {
                        -- 			num2 = 0;
                        -- 			num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 		}
                        -- 		num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_4\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_4\.
                        --     * The false branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_5\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_29\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Addition(BitMask,BitMask).0._State_3\.

                        if (\BitMask::op_Addition(BitMask,BitMask).0.flag\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_4\;
                        else 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6502
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.return\ <= \BitMask::op_Addition(BitMask,BitMask).0.result\;
                        \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.result\ := \BitMask::op_Addition(BitMask,BitMask).0.left\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_2\.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_4\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_5\ => 
                        -- False branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag2 = false;
                        -- 	num = 0;
                        -- 	num2 = 0;
                        -- 	array = new uint[1];
                        -- 	num3 = 0;
                        -- 	ushort conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383;
                        -- 	if ((System.Int32)(left.Size) > (System.Int32)(right.Size)) {
                        -- 		conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383 = left.Size;
                        -- 	}
                        -- 	else {
                        -- 		conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383 = right.Size;
                        -- 	}
                        -- 	while ((System.Int32)(num3) < (System.Int32)(conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383)) {
                        -- 		System.UInt32 remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67;
                        -- 		remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 = left.Segments [(int)num] >> (int)num2;
                        -- 		flag3 = remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 - remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 / 2u * 2u == 1u;
                        -- 		System.UInt32 remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f;
                        -- 		remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f = right.Segments [(int)num] >> (int)num2;
                        -- 		flag4 = (System.Int32)(num3) < (System.Int32)(right.Size) && remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f - remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f / 2u * 2u == 1u;
                        -- 		int conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83;
                        -- 		if (flag3) {
                        -- 			conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- 		}
                        -- 		int conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb;
                        -- 		if (flag4) {
                        -- 			conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- 		}
                        -- 		int conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d;
                        -- 		if (flag2) {
                        -- 			conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- 		}
                        -- 		b = (byte)(conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 + conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb + conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d);
                        -- 		System.Int32 remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d;
                        -- 		remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d = (System.Int32)(b);
                        -- 		flag5 = (System.Int32)(remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d - remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d / 2 * 2) == 1;
                        -- 		if (flag5) {
                        -- 			array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 		}
                        -- 		flag2 = b >> 1 == 1;
                        -- 		num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 		flag6 = num2 >> 5 == 1;
                        -- 		if (flag6) {
                        -- 			num2 = 0;
                        -- 			num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 		}
                        -- 		num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = false;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.flag2\ := False;
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.num3\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((System.Int32)(left.Size) > (System.Int32)(right.Size)) {
                        -- 	conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383 = left.Size;
                        -- }
                        -- else {
                        -- 	conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383 = right.Size;
                        -- }
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.3\ := signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.left\.\Size\), 32)) > signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.right\.\Size\), 32));

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_7\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_7\.
                        --     * The false branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_8\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_8\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Addition(BitMask,BitMask).0._State_6\.

                        if (\BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.3\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_7\;
                        else 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_6\ => 
                        -- State after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- while ((System.Int32)(num3) < (System.Int32)(conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383)) {
                        -- 	System.UInt32 remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67;
                        -- 	remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 = left.Segments [(int)num] >> (int)num2;
                        -- 	flag3 = remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 - remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 / 2u * 2u == 1u;
                        -- 	System.UInt32 remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f;
                        -- 	remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f = right.Segments [(int)num] >> (int)num2;
                        -- 	flag4 = (System.Int32)(num3) < (System.Int32)(right.Size) && remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f - remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f / 2u * 2u == 1u;
                        -- 	int conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83;
                        -- 	if (flag3) {
                        -- 		conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- 	}
                        -- 	int conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb;
                        -- 	if (flag4) {
                        -- 		conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- 	}
                        -- 	int conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d;
                        -- 	if (flag2) {
                        -- 		conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- 	}
                        -- 	b = (byte)(conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 + conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb + conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d);
                        -- 	System.Int32 remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d;
                        -- 	remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d = (System.Int32)(b);
                        -- 	flag5 = (System.Int32)(remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d - remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d / 2 * 2) == 1;
                        -- 	if (flag5) {
                        -- 		array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 	}
                        -- 	flag2 = b >> 1 == 1;
                        -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 	flag6 = num2 >> 5 == 1;
                        -- 	if (flag6) {
                        -- 		num2 = 0;
                        -- 		num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 	}
                        -- 	num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_7\ => 
                        -- True branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383 = left.Size;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383 = left.Size;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383\ := \BitMask::op_Addition(BitMask,BitMask).0.left\.\Size\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_5\.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_7\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_8\ => 
                        -- False branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383 = right.Size;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383 = right.Size;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383\ := \BitMask::op_Addition(BitMask,BitMask).0.right\.\Size\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_5\.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_8\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_6\.
                        -- The while loop's condition:
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.4\ := signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.num3\), 32)) < signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.conditionala4f5ece0ed46944a790884ff6873c6f6f8b62421196a4e23cda671fc24f3b383\), 32));
                        if (\BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	System.UInt32 remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67;
                            -- 	remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 = left.Segments [(int)num] >> (int)num2;
                            -- 	flag3 = remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 - remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 / 2u * 2u == 1u;
                            -- 	System.UInt32 remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f;
                            -- 	remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f = right.Segments [(int)num] >> (int)num2;
                            -- 	flag4 = (System.Int32)(num3) < (System.Int32)(right.Size) && remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f - remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f / 2u * 2u == 1u;
                            -- 	int conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83;
                            -- 	if (flag3) {
                            -- 		conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                            -- 	}
                            -- 	int conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb;
                            -- 	if (flag4) {
                            -- 		conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                            -- 	}
                            -- 	int conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d;
                            -- 	if (flag2) {
                            -- 		conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                            -- 	}
                            -- 	b = (byte)(conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 + conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb + conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d);
                            -- 	System.Int32 remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d;
                            -- 	remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d = (System.Int32)(b);
                            -- 	flag5 = (System.Int32)(remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d - remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d / 2 * 2) == 1;
                            -- 	if (flag5) {
                            -- 		array [(int)num] = array [(int)num] + 1u << (int)num2;
                            -- 	}
                            -- 	flag2 = b >> 1 == 1;
                            -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                            -- 	flag6 = num2 >> 5 == 1;
                            -- 	if (flag6) {
                            -- 		num2 = 0;
                            -- 		num = (System.UInt16)((System.Int32)(num) + 1);
                            -- 	}
                            -- 	num3 = (System.UInt16)((System.Int32)(num3) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- System.UInt32 remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 = left.Segments [(int)num] >> (int)num2;
                            -- 
                            \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.5\ := shift_right(\BitMask::op_Addition(BitMask,BitMask).0.left\.\Segments\(to_integer(signed(SmartResize(\BitMask::op_Addition(BitMask,BitMask).0.num\, 32)))), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask::op_Addition(BitMask,BitMask).0.num2\, 32)), 5) and "11111")));
                            \BitMask::op_Addition(BitMask,BitMask).0.remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 - remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 / 2u * 2u == 1u;
                            -- 
                            \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.6\ := \BitMask::op_Addition(BitMask,BitMask).0.remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67\ / to_unsigned(2, 32);
                            \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.7\ := SmartResize(\BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.6\ * to_unsigned(2, 32), 32);
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_11\;
                        else 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6996
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_10\ => 
                        -- State after the while loop which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::op_Addition(BitMask,BitMask).0.result\.\IsNull\ := false;
                        \BitMask::op_Addition(BitMask,BitMask).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::op_Addition(BitMask,BitMask).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::op_Addition(BitMask,BitMask).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask::op_Addition(BitMask,BitMask).0.result\;
                        \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::op_Addition(BitMask,BitMask).0.array\;
                        \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_29\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.8\ := \BitMask::op_Addition(BitMask,BitMask).0.remainderOperande2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67\ - \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.7\;
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.9\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.8\ = to_unsigned(1, 32);
                        \BitMask::op_Addition(BitMask,BitMask).0.flag3\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- System.UInt32 remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f = right.Segments [(int)num] >> (int)num2;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.10\ := shift_right(\BitMask::op_Addition(BitMask,BitMask).0.right\.\Segments\(to_integer(signed(SmartResize(\BitMask::op_Addition(BitMask,BitMask).0.num\, 32)))), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask::op_Addition(BitMask,BitMask).0.num2\, 32)), 5) and "11111")));
                        \BitMask::op_Addition(BitMask,BitMask).0.remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.10\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = (System.Int32)(num3) < (System.Int32)(right.Size) && remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f - remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f / 2u * 2u == 1u;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.8293
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_12\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.11\ := signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.num3\), 32)) < signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.right\.\Size\), 32));
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.12\ := \BitMask::op_Addition(BitMask,BitMask).0.remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f\ / to_unsigned(2, 32);
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.13\ := SmartResize(\BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.12\ * to_unsigned(2, 32), 32);
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.14\ := \BitMask::op_Addition(BitMask,BitMask).0.remainderOperand7285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f\ - \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.13\;
                        \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0.7766
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_13\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.15\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.14\ = to_unsigned(1, 32);
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.16\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.11\ and \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.15\;
                        \BitMask::op_Addition(BitMask,BitMask).0.flag4\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.16\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- }
                        -- else {
                        -- 	conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_15\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_15\.
                        --     * The false branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_16\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_16\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Addition(BitMask,BitMask).0._State_14\.

                        if (\BitMask::op_Addition(BitMask,BitMask).0.flag3\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_15\;
                        else 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3751
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_14\ => 
                        -- State after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- }
                        -- else {
                        -- 	conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_18\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_18\.
                        --     * The false branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_19\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_19\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Addition(BitMask,BitMask).0._State_17\.

                        if (\BitMask::op_Addition(BitMask,BitMask).0.flag4\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_18\;
                        else 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_15\ => 
                        -- True branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_13\.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_15\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_16\ => 
                        -- False branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_13\.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_16\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_17\ => 
                        -- State after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- }
                        -- else {
                        -- 	conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_21\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_21\.
                        --     * The false branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_22\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_22\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Addition(BitMask,BitMask).0._State_20\.

                        if (\BitMask::op_Addition(BitMask,BitMask).0.flag2\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_21\;
                        else 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_18\ => 
                        -- True branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_14\.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_18\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_19\ => 
                        -- False branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_14\.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_19\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_20\ => 
                        -- State after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = (byte)(conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 + conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb + conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d);
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.17\ := \BitMask::op_Addition(BitMask,BitMask).0.conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83\ + \BitMask::op_Addition(BitMask,BitMask).0.conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb\;
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.18\ := SmartResize(unsigned(\BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.17\ + \BitMask::op_Addition(BitMask,BitMask).0.conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d\), 8);
                        \BitMask::op_Addition(BitMask,BitMask).0.b\ := (\BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.18\);
                        -- The following section was transformed from the .NET statement below:
                        -- System.Int32 remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d = (System.Int32)(b);
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d\ := signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.b\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- flag5 = (System.Int32)(remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d - remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d / 2 * 2) == 1;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.19\ := \BitMask::op_Addition(BitMask,BitMask).0.remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d\ / to_signed(2, 32);
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.20\ := SmartResize(\BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.19\ * to_signed(2, 32), 32);
                        \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_23\;
                        -- Clock cycles needed to complete this state (approximation): 0.8312
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_21\ => 
                        -- True branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_17\.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_21\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_22\ => 
                        -- False branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_17\.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_22\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_23\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.21\ := \BitMask::op_Addition(BitMask,BitMask).0.remainderOperanda82c55b06568a0177e75d3fc93c13b761096b89c60c646cceaae6379f879376d\ - \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.20\;
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.22\ := (\BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.21\) = to_signed(1, 32);
                        \BitMask::op_Addition(BitMask,BitMask).0.flag5\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.22\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag5) {
                        -- 	array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_25\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_25\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Addition(BitMask,BitMask).0._State_24\.

                        if (\BitMask::op_Addition(BitMask,BitMask).0.flag5\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_25\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5907
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_24\ => 
                        -- State after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_23\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = b >> 1 == 1;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.25\ := signed(SmartResize(shift_right(\BitMask::op_Addition(BitMask,BitMask).0.b\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111"))), 32));
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.26\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.25\ = to_signed(1, 32);
                        \BitMask::op_Addition(BitMask,BitMask).0.flag2\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.26\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.27\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_Addition(BitMask,BitMask).0.num2\ := (\BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.27\);
                        -- The following section was transformed from the .NET statement below:
                        -- flag6 = num2 >> 5 == 1;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0.8293
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_25\ => 
                        -- True branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_23\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.23\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask::op_Addition(BitMask,BitMask).0.num2\, 32)), 5))));
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.24\ := \BitMask::op_Addition(BitMask,BitMask).0.array\(to_integer(signed(SmartResize(\BitMask::op_Addition(BitMask,BitMask).0.num\, 32)))) + \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.23\;
                        \BitMask::op_Addition(BitMask,BitMask).0.array\(to_integer(signed(SmartResize(\BitMask::op_Addition(BitMask,BitMask).0.num\, 32)))) := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.24\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_23\.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_25\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_26\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.28\ := signed(SmartResize(shift_right(\BitMask::op_Addition(BitMask,BitMask).0.num2\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.29\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.28\ = to_signed(1, 32);
                        \BitMask::op_Addition(BitMask,BitMask).0.flag6\ := \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.29\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag6) {
                        -- 	num2 = 0;
                        -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Addition(BitMask,BitMask).0._State_28\ and ends in state \BitMask::op_Addition(BitMask,BitMask).0._State_28\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Addition(BitMask,BitMask).0._State_27\.

                        if (\BitMask::op_Addition(BitMask,BitMask).0.flag6\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_28\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5137
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_27\ => 
                        -- State after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.31\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.num3\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_Addition(BitMask,BitMask).0.num3\ := (\BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.31\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_6\ if the loop wasn't exited with a state change.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_27\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_28\ => 
                        -- True branch of the if-else started in state \BitMask::op_Addition(BitMask,BitMask).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = 0;
                        -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 
                        \BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.30\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_Addition(BitMask,BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_Addition(BitMask,BitMask).0.num\ := (\BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.30\);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_26\.
                        if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_28\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \BitMask::op_Addition(BitMask,BitMask).0._State_29\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::op_Addition(BitMask,BitMask).0.result\ := \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask::op_Addition(BitMask,BitMask).0.array\ := \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::op_Addition(BitMask,BitMask).0._State_2\.
                            if (\BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask::op_Addition(BitMask,BitMask).0._State_29\) then 
                                \BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask::op_Addition(BitMask,BitMask).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask::op_Subtraction(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0._State\: \BitMask::op_Subtraction(BitMask,BitMask).0._States\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_0\;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.flag\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.flag2\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.flag3\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.flag4\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.flag5\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.flag6\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.2\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.3\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.4\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.9\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.11\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.14\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.15\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.16\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.19\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.20\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.21\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.22\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.23\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.24\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.25\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.26\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.27\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.28\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.29\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.30\: boolean := false;
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.31\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.32\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::op_Subtraction(BitMask,BitMask).0._Finished\ <= false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_0\;
                \BitMask::op_Subtraction(BitMask,BitMask).0.flag\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.flag2\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \BitMask::op_Subtraction(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                \BitMask::op_Subtraction(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::op_Subtraction(BitMask,BitMask).0.num3\ := to_unsigned(0, 16);
                \BitMask::op_Subtraction(BitMask,BitMask).0.flag3\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.flag4\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.b\ := to_unsigned(0, 8);
                \BitMask::op_Subtraction(BitMask,BitMask).0.flag5\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.flag6\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.0\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.1\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.2\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc\ := to_unsigned(0, 16);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.3\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.4\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.9\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.11\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.12\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.13\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.14\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.15\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.16\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b\ := to_signed(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041\ := to_signed(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026\ := to_signed(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.17\ := to_signed(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.18\ := to_signed(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.19\ := to_unsigned(0, 8);
                \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae\ := to_signed(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.20\ := to_signed(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.21\ := to_signed(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.22\ := to_signed(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.23\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.24\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.25\ := to_unsigned(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.26\ := to_signed(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.27\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.28\ := to_unsigned(0, 16);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.29\ := to_signed(0, 32);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.30\ := false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.31\ := to_unsigned(0, 16);
                \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.32\ := to_unsigned(0, 16);
            else 
                case \BitMask::op_Subtraction(BitMask,BitMask).0._State\ is 
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._Finished\ <= false;
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_2\ => 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.left\ := \BitMask::op_Subtraction(BitMask,BitMask).0.left.parameter.In\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0.right\ := \BitMask::op_Subtraction(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (System.Int32)(left.SegmentCount) == 0 || (System.Int32)(right.SegmentCount) == 0;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.0\ := signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.left\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.1\ := signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.right\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.2\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.0\ or \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.1\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0.flag\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = left;
                        -- }
                        -- else {
                        -- 	flag2 = false;
                        -- 	num = 0;
                        -- 	num2 = 0;
                        -- 	array = new uint[1];
                        -- 	num3 = 0;
                        -- 	ushort conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc;
                        -- 	if ((System.Int32)(left.Size) > (System.Int32)(right.Size)) {
                        -- 		conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc = left.Size;
                        -- 	}
                        -- 	else {
                        -- 		conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc = right.Size;
                        -- 	}
                        -- 	while ((System.Int32)(num3) < (System.Int32)(conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc)) {
                        -- 		System.UInt32 remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c;
                        -- 		remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c = left.Segments [(int)num] >> (int)num2;
                        -- 		flag3 = remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c - remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c / 2u * 2u == 1u;
                        -- 		System.UInt32 remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2;
                        -- 		remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 = right.Segments [(int)num] >> (int)num2;
                        -- 		flag4 = (System.Int32)(num3) < (System.Int32)(right.Size) && remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 - remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 / 2u * 2u == 1u;
                        -- 		int conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b;
                        -- 		if (flag3) {
                        -- 			conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- 		}
                        -- 		int conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041;
                        -- 		if (flag4) {
                        -- 			conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- 		}
                        -- 		int conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026;
                        -- 		if (flag2) {
                        -- 			conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- 		}
                        -- 		b = (byte)(2 + conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b - conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 - conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026);
                        -- 		System.Int32 remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae;
                        -- 		remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae = (System.Int32)(b);
                        -- 		flag5 = (System.Int32)(remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae - remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae / 2 * 2) == 1;
                        -- 		if (flag5) {
                        -- 			array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 		}
                        -- 		flag2 = b >> 1 == 0;
                        -- 		num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 		flag6 = num2 >> 5 == 1;
                        -- 		if (flag6) {
                        -- 			num2 = 0;
                        -- 			num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 		}
                        -- 		num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_4\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_4\.
                        --     * The false branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_5\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_29\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Subtraction(BitMask,BitMask).0._State_3\.

                        if (\BitMask::op_Subtraction(BitMask,BitMask).0.flag\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_4\;
                        else 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6502
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.return\ <= \BitMask::op_Subtraction(BitMask,BitMask).0.result\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.result\ := \BitMask::op_Subtraction(BitMask,BitMask).0.left\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_2\.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_4\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_5\ => 
                        -- False branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag2 = false;
                        -- 	num = 0;
                        -- 	num2 = 0;
                        -- 	array = new uint[1];
                        -- 	num3 = 0;
                        -- 	ushort conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc;
                        -- 	if ((System.Int32)(left.Size) > (System.Int32)(right.Size)) {
                        -- 		conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc = left.Size;
                        -- 	}
                        -- 	else {
                        -- 		conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc = right.Size;
                        -- 	}
                        -- 	while ((System.Int32)(num3) < (System.Int32)(conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc)) {
                        -- 		System.UInt32 remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c;
                        -- 		remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c = left.Segments [(int)num] >> (int)num2;
                        -- 		flag3 = remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c - remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c / 2u * 2u == 1u;
                        -- 		System.UInt32 remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2;
                        -- 		remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 = right.Segments [(int)num] >> (int)num2;
                        -- 		flag4 = (System.Int32)(num3) < (System.Int32)(right.Size) && remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 - remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 / 2u * 2u == 1u;
                        -- 		int conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b;
                        -- 		if (flag3) {
                        -- 			conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- 		}
                        -- 		int conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041;
                        -- 		if (flag4) {
                        -- 			conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- 		}
                        -- 		int conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026;
                        -- 		if (flag2) {
                        -- 			conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- 		}
                        -- 		b = (byte)(2 + conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b - conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 - conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026);
                        -- 		System.Int32 remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae;
                        -- 		remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae = (System.Int32)(b);
                        -- 		flag5 = (System.Int32)(remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae - remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae / 2 * 2) == 1;
                        -- 		if (flag5) {
                        -- 			array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 		}
                        -- 		flag2 = b >> 1 == 0;
                        -- 		num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 		flag6 = num2 >> 5 == 1;
                        -- 		if (flag6) {
                        -- 			num2 = 0;
                        -- 			num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 		}
                        -- 		num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = false;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.flag2\ := False;
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.num3\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((System.Int32)(left.Size) > (System.Int32)(right.Size)) {
                        -- 	conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc = left.Size;
                        -- }
                        -- else {
                        -- 	conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc = right.Size;
                        -- }
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.3\ := signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.left\.\Size\), 32)) > signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.right\.\Size\), 32));

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_7\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_7\.
                        --     * The false branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_8\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_8\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Subtraction(BitMask,BitMask).0._State_6\.

                        if (\BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.3\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_7\;
                        else 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_6\ => 
                        -- State after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- while ((System.Int32)(num3) < (System.Int32)(conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc)) {
                        -- 	System.UInt32 remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c;
                        -- 	remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c = left.Segments [(int)num] >> (int)num2;
                        -- 	flag3 = remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c - remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c / 2u * 2u == 1u;
                        -- 	System.UInt32 remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2;
                        -- 	remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 = right.Segments [(int)num] >> (int)num2;
                        -- 	flag4 = (System.Int32)(num3) < (System.Int32)(right.Size) && remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 - remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 / 2u * 2u == 1u;
                        -- 	int conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b;
                        -- 	if (flag3) {
                        -- 		conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- 	}
                        -- 	int conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041;
                        -- 	if (flag4) {
                        -- 		conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- 	}
                        -- 	int conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026;
                        -- 	if (flag2) {
                        -- 		conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- 	}
                        -- 	b = (byte)(2 + conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b - conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 - conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026);
                        -- 	System.Int32 remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae;
                        -- 	remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae = (System.Int32)(b);
                        -- 	flag5 = (System.Int32)(remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae - remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae / 2 * 2) == 1;
                        -- 	if (flag5) {
                        -- 		array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 	}
                        -- 	flag2 = b >> 1 == 0;
                        -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 	flag6 = num2 >> 5 == 1;
                        -- 	if (flag6) {
                        -- 		num2 = 0;
                        -- 		num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 	}
                        -- 	num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_7\ => 
                        -- True branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc = left.Size;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc = left.Size;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc\ := \BitMask::op_Subtraction(BitMask,BitMask).0.left\.\Size\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_5\.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_7\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_8\ => 
                        -- False branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc = right.Size;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc = right.Size;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc\ := \BitMask::op_Subtraction(BitMask,BitMask).0.right\.\Size\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_5\.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_8\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_6\.
                        -- The while loop's condition:
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.4\ := signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.num3\), 32)) < signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.conditional5bf526fc23f8d63df2c134be9d599c01e03454112316c39104b72c7e502e8dbc\), 32));
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	System.UInt32 remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c;
                            -- 	remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c = left.Segments [(int)num] >> (int)num2;
                            -- 	flag3 = remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c - remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c / 2u * 2u == 1u;
                            -- 	System.UInt32 remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2;
                            -- 	remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 = right.Segments [(int)num] >> (int)num2;
                            -- 	flag4 = (System.Int32)(num3) < (System.Int32)(right.Size) && remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 - remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 / 2u * 2u == 1u;
                            -- 	int conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b;
                            -- 	if (flag3) {
                            -- 		conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                            -- 	}
                            -- 	int conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041;
                            -- 	if (flag4) {
                            -- 		conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                            -- 	}
                            -- 	int conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026;
                            -- 	if (flag2) {
                            -- 		conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                            -- 	}
                            -- 	b = (byte)(2 + conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b - conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 - conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026);
                            -- 	System.Int32 remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae;
                            -- 	remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae = (System.Int32)(b);
                            -- 	flag5 = (System.Int32)(remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae - remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae / 2 * 2) == 1;
                            -- 	if (flag5) {
                            -- 		array [(int)num] = array [(int)num] + 1u << (int)num2;
                            -- 	}
                            -- 	flag2 = b >> 1 == 0;
                            -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                            -- 	flag6 = num2 >> 5 == 1;
                            -- 	if (flag6) {
                            -- 		num2 = 0;
                            -- 		num = (System.UInt16)((System.Int32)(num) + 1);
                            -- 	}
                            -- 	num3 = (System.UInt16)((System.Int32)(num3) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- System.UInt32 remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c = left.Segments [(int)num] >> (int)num2;
                            -- 
                            \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.5\ := shift_right(\BitMask::op_Subtraction(BitMask,BitMask).0.left\.\Segments\(to_integer(signed(SmartResize(\BitMask::op_Subtraction(BitMask,BitMask).0.num\, 32)))), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask::op_Subtraction(BitMask,BitMask).0.num2\, 32)), 5) and "11111")));
                            \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c - remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c / 2u * 2u == 1u;
                            -- 
                            \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.6\ := \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c\ / to_unsigned(2, 32);
                            \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.7\ := SmartResize(\BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.6\ * to_unsigned(2, 32), 32);
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_11\;
                        else 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6996
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_10\ => 
                        -- State after the while loop which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::op_Subtraction(BitMask,BitMask).0.result\.\IsNull\ := false;
                        \BitMask::op_Subtraction(BitMask,BitMask).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask::op_Subtraction(BitMask,BitMask).0.result\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::op_Subtraction(BitMask,BitMask).0.array\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_29\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.8\ := \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperandb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c\ - \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.7\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.9\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.8\ = to_unsigned(1, 32);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.flag3\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- System.UInt32 remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 = right.Segments [(int)num] >> (int)num2;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.10\ := shift_right(\BitMask::op_Subtraction(BitMask,BitMask).0.right\.\Segments\(to_integer(signed(SmartResize(\BitMask::op_Subtraction(BitMask,BitMask).0.num\, 32)))), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask::op_Subtraction(BitMask,BitMask).0.num2\, 32)), 5) and "11111")));
                        \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.10\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = (System.Int32)(num3) < (System.Int32)(right.Size) && remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 - remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 / 2u * 2u == 1u;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.8293
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_12\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.11\ := signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.num3\), 32)) < signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.right\.\Size\), 32));
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.12\ := \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2\ / to_unsigned(2, 32);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.13\ := SmartResize(\BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.12\ * to_unsigned(2, 32), 32);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.14\ := \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand4138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2\ - \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.13\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0.7766
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_13\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.15\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.14\ = to_unsigned(1, 32);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.16\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.11\ and \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.15\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0.flag4\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.16\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- }
                        -- else {
                        -- 	conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_15\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_15\.
                        --     * The false branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_16\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_16\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Subtraction(BitMask,BitMask).0._State_14\.

                        if (\BitMask::op_Subtraction(BitMask,BitMask).0.flag3\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_15\;
                        else 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3751
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_14\ => 
                        -- State after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- }
                        -- else {
                        -- 	conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_18\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_18\.
                        --     * The false branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_19\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_19\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Subtraction(BitMask,BitMask).0._State_17\.

                        if (\BitMask::op_Subtraction(BitMask,BitMask).0.flag4\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_18\;
                        else 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_15\ => 
                        -- True branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_13\.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_15\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_16\ => 
                        -- False branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_13\.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_16\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_17\ => 
                        -- State after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- }
                        -- else {
                        -- 	conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_21\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_21\.
                        --     * The false branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_22\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_22\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Subtraction(BitMask,BitMask).0._State_20\.

                        if (\BitMask::op_Subtraction(BitMask,BitMask).0.flag2\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_21\;
                        else 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_18\ => 
                        -- True branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_14\.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_18\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_19\ => 
                        -- False branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_14\.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_19\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_20\ => 
                        -- State after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = (byte)(2 + conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b - conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 - conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026);
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.17\ := to_signed(2, 32) + \BitMask::op_Subtraction(BitMask,BitMask).0.conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.18\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.17\ - \BitMask::op_Subtraction(BitMask,BitMask).0.conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.19\ := SmartResize(unsigned(\BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.18\ - \BitMask::op_Subtraction(BitMask,BitMask).0.conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026\), 8);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.b\ := (\BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.19\);
                        -- The following section was transformed from the .NET statement below:
                        -- System.Int32 remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae = (System.Int32)(b);
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae\ := signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.b\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- flag5 = (System.Int32)(remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae - remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae / 2 * 2) == 1;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_23\;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_21\ => 
                        -- True branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_17\.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_21\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_22\ => 
                        -- False branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_17\.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_22\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_23\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.20\ := \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae\ / to_signed(2, 32);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.21\ := SmartResize(\BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.20\ * to_signed(2, 32), 32);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.22\ := \BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand5aef2476adabf9d8620379e89bbbe6648561161278604ffee985f2fb8e8082ae\ - \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.21\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.23\ := (\BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.22\) = to_signed(1, 32);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.flag5\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.23\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag5) {
                        -- 	array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_25\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_25\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Subtraction(BitMask,BitMask).0._State_24\.

                        if (\BitMask::op_Subtraction(BitMask,BitMask).0.flag5\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_25\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7907
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_24\ => 
                        -- State after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_23\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = b >> 1 == 0;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.26\ := signed(SmartResize(shift_right(\BitMask::op_Subtraction(BitMask,BitMask).0.b\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111"))), 32));
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.27\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.26\ = to_signed(0, 32);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.flag2\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.27\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.28\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.num2\ := (\BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.28\);
                        -- The following section was transformed from the .NET statement below:
                        -- flag6 = num2 >> 5 == 1;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0.8293
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_25\ => 
                        -- True branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_23\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.24\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask::op_Subtraction(BitMask,BitMask).0.num2\, 32)), 5))));
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.25\ := \BitMask::op_Subtraction(BitMask,BitMask).0.array\(to_integer(signed(SmartResize(\BitMask::op_Subtraction(BitMask,BitMask).0.num\, 32)))) + \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.24\;
                        \BitMask::op_Subtraction(BitMask,BitMask).0.array\(to_integer(signed(SmartResize(\BitMask::op_Subtraction(BitMask,BitMask).0.num\, 32)))) := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.25\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_23\.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_25\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_26\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.29\ := signed(SmartResize(shift_right(\BitMask::op_Subtraction(BitMask,BitMask).0.num2\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.30\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.29\ = to_signed(1, 32);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.flag6\ := \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.30\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag6) {
                        -- 	num2 = 0;
                        -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_28\ and ends in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_28\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_Subtraction(BitMask,BitMask).0._State_27\.

                        if (\BitMask::op_Subtraction(BitMask,BitMask).0.flag6\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_28\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5137
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_27\ => 
                        -- State after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.32\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.num3\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.num3\ := (\BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.32\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_6\ if the loop wasn't exited with a state change.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_27\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_28\ => 
                        -- True branch of the if-else started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = 0;
                        -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 
                        \BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.31\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_Subtraction(BitMask,BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_Subtraction(BitMask,BitMask).0.num\ := (\BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.31\);
                        -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_26\.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_28\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \BitMask::op_Subtraction(BitMask,BitMask).0._State_29\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::op_Subtraction(BitMask,BitMask).0.result\ := \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask::op_Subtraction(BitMask,BitMask).0.array\ := \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::op_Subtraction(BitMask,BitMask).0._State_2\.
                            if (\BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask::op_Subtraction(BitMask,BitMask).0._State_29\) then 
                                \BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask::op_Subtraction(BitMask,BitMask).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask::op_BitwiseAnd(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\: \BitMask::op_BitwiseAnd(BitMask,BitMask).0._States\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_0\;
        Variable \BitMask::op_BitwiseAnd(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_BitwiseAnd(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_BitwiseAnd(BitMask,BitMask).0.flag\: boolean := false;
        Variable \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\ <= false;
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= false;
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_0\;
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.flag\ := false;
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.0\ := false;
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.1\ := false;
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.3\ := to_unsigned(0, 16);
            else 
                case \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ is 
                    when \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\ <= false;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\ => 
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.left\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0.left.parameter.In\;
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.right\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (System.Int32)(left.SegmentCount) != (System.Int32)(right.SegmentCount);
                        -- 
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.0\ := signed(SmartResize((\BitMask::op_BitwiseAnd(BitMask,BitMask).0.left\.\SegmentCount\), 32)) /= signed(SmartResize((\BitMask::op_BitwiseAnd(BitMask,BitMask).0.right\.\SegmentCount\), 32));
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.flag\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = new BitMask (left.Size, false);
                        -- }
                        -- else {
                        -- 	array = new uint[1];
                        -- 	num = 0;
                        -- 	while ((int)num < 1) {
                        -- 		array [(int)num] = left.Segments [(int)num] & right.Segments [(int)num];
                        -- 		num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_4\ and ends in state \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_5\.
                        --     * The false branch starts in state \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\ and ends in state \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_9\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_3\.

                        if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0.flag\) then 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_4\;
                        else 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.return\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\;
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new BitMask (left.Size, false);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (left.Size, false);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\IsNull\ := false;
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\;
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.left\.\Size\;
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\.
                            if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ = \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_5\) then 
                                \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array = new uint[1];
                        -- 	num = 0;
                        -- 	while ((int)num < 1) {
                        -- 		array [(int)num] = left.Segments [(int)num] & right.Segments [(int)num];
                        -- 		num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)num < 1) {
                        -- 	array [(int)num] = left.Segments [(int)num] & right.Segments [(int)num];
                        -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\.
                        -- The while loop's condition:
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.1\ := signed(SmartResize(\BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\, 32)) < to_signed(1, 32);
                        if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	array [(int)num] = left.Segments [(int)num] & right.Segments [(int)num];
                            -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array [(int)num] = left.Segments [(int)num] & right.Segments [(int)num];
                            -- 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.2\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0.left\.\Segments\(to_integer(signed(SmartResize(\BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\, 32)))) and \BitMask::op_BitwiseAnd(BitMask,BitMask).0.right\.\Segments\(to_integer(signed(SmartResize(\BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\, 32))));
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\(to_integer(signed(SmartResize(\BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\, 32)))) := \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = (System.UInt16)((System.Int32)(num) + 1);
                            -- 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.3\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\ := (\BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.3\);
                        else 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7152
                    when \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_8\ => 
                        -- State after the while loop which was started in state \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\IsNull\ := false;
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\;
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\;
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\.
                            if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ = \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_9\) then 
                                \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask::op_OnesComplement(BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::op_OnesComplement(BitMask).0._State\: \BitMask::op_OnesComplement(BitMask).0._States\ := \BitMask::op_OnesComplement(BitMask).0._State_0\;
        Variable \BitMask::op_OnesComplement(BitMask).0.input\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_OnesComplement(BitMask).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::op_OnesComplement(BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.1\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::op_OnesComplement(BitMask).0._Finished\ <= false;
                \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask::op_OnesComplement(BitMask).0._State_0\;
                \BitMask::op_OnesComplement(BitMask).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::op_OnesComplement(BitMask).0.num\ := to_unsigned(0, 16);
                \BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.0\ := false;
                \BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.1\ := to_unsigned(0, 16);
            else 
                case \BitMask::op_OnesComplement(BitMask).0._State\ is 
                    when \BitMask::op_OnesComplement(BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::op_OnesComplement(BitMask).0._Started\ = true) then 
                            \BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask::op_OnesComplement(BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_OnesComplement(BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::op_OnesComplement(BitMask).0._Started\ = true) then 
                            \BitMask::op_OnesComplement(BitMask).0._Finished\ <= true;
                        else 
                            \BitMask::op_OnesComplement(BitMask).0._Finished\ <= false;
                            \BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask::op_OnesComplement(BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_OnesComplement(BitMask).0._State_2\ => 
                        \BitMask::op_OnesComplement(BitMask).0.input\ := \BitMask::op_OnesComplement(BitMask).0.input.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::op_OnesComplement(BitMask).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \BitMask::op_OnesComplement(BitMask).0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)num < 1) {
                        -- 	array [(int)num] = ~input.Segments [(int)num];
                        -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask::op_OnesComplement(BitMask).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_OnesComplement(BitMask).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::op_OnesComplement(BitMask).0._State_2\.
                        -- The while loop's condition:
                        \BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.0\ := signed(SmartResize(\BitMask::op_OnesComplement(BitMask).0.num\, 32)) < to_signed(1, 32);
                        if (\BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	array [(int)num] = ~input.Segments [(int)num];
                            -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array [(int)num] = ~input.Segments [(int)num];
                            -- 
                            \BitMask::op_OnesComplement(BitMask).0.array\(to_integer(signed(SmartResize(\BitMask::op_OnesComplement(BitMask).0.num\, 32)))) := not(\BitMask::op_OnesComplement(BitMask).0.input\.\Segments\(to_integer(signed(SmartResize(\BitMask::op_OnesComplement(BitMask).0.num\, 32)))));
                            -- The following section was transformed from the .NET statement below:
                            -- num = (System.UInt16)((System.Int32)(num) + 1);
                            -- 
                            \BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.1\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_OnesComplement(BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                            \BitMask::op_OnesComplement(BitMask).0.num\ := (\BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.1\);
                        else 
                            \BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask::op_OnesComplement(BitMask).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6766
                    when \BitMask::op_OnesComplement(BitMask).0._State_4\ => 
                        -- State after the while loop which was started in state \BitMask::op_OnesComplement(BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4 = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\.\IsNull\ := false;
                        \BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\.\Size\ := to_unsigned(0, 16);
                        \BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\;
                        \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::op_OnesComplement(BitMask).0.array\;
                        \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask::op_OnesComplement(BitMask).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_OnesComplement(BitMask).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\ := \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask::op_OnesComplement(BitMask).0.array\ := \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4;
                            -- 
                            \BitMask::op_OnesComplement(BitMask).0.return\ <= \BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\;
                            \BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask::op_OnesComplement(BitMask).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0 state machine start
    \BitMask::op_RightShift(BitMask,Int32).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::op_RightShift(BitMask,Int32).0._State\: \BitMask::op_RightShift(BitMask,Int32).0._States\ := \BitMask::op_RightShift(BitMask,Int32).0._State_0\;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.right\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.flag\: boolean := false;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::op_RightShift(BitMask,Int32).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.flag2\: boolean := false;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.num4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.flag3\: boolean := false;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.flag4\: boolean := false;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.2\: boolean := false;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.7\: boolean := false;
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.10\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.11\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::op_RightShift(BitMask,Int32).0._Finished\ <= false;
                \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_0\;
                \BitMask::op_RightShift(BitMask,Int32).0.right\ := to_signed(0, 32);
                \BitMask::op_RightShift(BitMask,Int32).0.flag\ := false;
                \BitMask::op_RightShift(BitMask,Int32).0.num\ := to_unsigned(0, 32);
                \BitMask::op_RightShift(BitMask,Int32).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::op_RightShift(BitMask,Int32).0.num2\ := to_unsigned(0, 16);
                \BitMask::op_RightShift(BitMask,Int32).0.flag2\ := false;
                \BitMask::op_RightShift(BitMask,Int32).0.num3\ := to_unsigned(0, 16);
                \BitMask::op_RightShift(BitMask,Int32).0.num4\ := to_unsigned(0, 16);
                \BitMask::op_RightShift(BitMask,Int32).0.flag3\ := false;
                \BitMask::op_RightShift(BitMask,Int32).0.flag4\ := false;
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.0\ := false;
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.1\ := false;
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.2\ := false;
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.3\ := to_unsigned(0, 16);
                \BitMask::op_RightShift(BitMask,Int32).0.remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605\ := to_unsigned(0, 32);
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.4\ := to_unsigned(0, 32);
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.7\ := false;
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.9\ := to_unsigned(0, 32);
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.10\ := to_unsigned(0, 16);
                \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.11\ := to_unsigned(0, 16);
            else 
                case \BitMask::op_RightShift(BitMask,Int32).0._State\ is 
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::op_RightShift(BitMask,Int32).0._Started\ = true) then 
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::op_RightShift(BitMask,Int32).0._Started\ = true) then 
                            \BitMask::op_RightShift(BitMask,Int32).0._Finished\ <= true;
                        else 
                            \BitMask::op_RightShift(BitMask,Int32).0._Finished\ <= false;
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_2\ => 
                        \BitMask::op_RightShift(BitMask,Int32).0.left\ := \BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\;
                        \BitMask::op_RightShift(BitMask,Int32).0.right\ := \BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = right < 0;
                        -- 
                        \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.0\ := \BitMask::op_RightShift(BitMask,Int32).0.right\ < to_signed(0, 32);
                        \BitMask::op_RightShift(BitMask,Int32).0.flag\ := \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = BitMask.op_LeftShift (left, -right);
                        -- }
                        -- else {
                        -- 	num = 2147483648u;
                        -- 	array = new uint[1];
                        -- 	System.Array.Copy (left.Segments, array, 1);
                        -- 	num2 = 0;
                        -- 	while ((int)num2 < right) {
                        -- 		flag2 = false;
                        -- 		num3 = 1;
                        -- 		while ((int)num3 <= 1) {
                        -- 			num4 = (ushort)(1 - (int)num3);
                        -- 			System.UInt32 remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                        -- 			remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                        -- 			flag3 = remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                        -- 			array [(int)num4] = array [(int)num4] >> 1;
                        -- 			flag4 = flag2;
                        -- 			if (flag4) {
                        -- 				array [(int)num4] = array [(int)num4] | num;
                        -- 			}
                        -- 			flag2 = flag3;
                        -- 			num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 		}
                        -- 		num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_RightShift(BitMask,Int32).0._State_4\ and ends in state \BitMask::op_RightShift(BitMask,Int32).0._State_5\.
                        --     * The false branch starts in state \BitMask::op_RightShift(BitMask,Int32).0._State_6\ and ends in state \BitMask::op_RightShift(BitMask,Int32).0._State_14\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_RightShift(BitMask,Int32).0._State_3\.

                        if (\BitMask::op_RightShift(BitMask,Int32).0.flag\) then 
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_4\;
                        else 
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::op_RightShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::op_RightShift(BitMask,Int32).0.return\ <= \BitMask::op_RightShift(BitMask,Int32).0.result\;
                        \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::op_RightShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = BitMask.op_LeftShift (left, -right);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = BitMask.op_LeftShift (left, -right);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::op_RightShift(BitMask,Int32).0.left\;
                        \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= -\BitMask::op_RightShift(BitMask,Int32).0.right\;
                        \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::op_RightShift(BitMask,Int32).0.return.0\ := \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \BitMask::op_RightShift(BitMask,Int32).0.result\ := \BitMask::op_RightShift(BitMask,Int32).0.return.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::op_RightShift(BitMask,Int32).0._State_2\.
                            if (\BitMask::op_RightShift(BitMask,Int32).0._State\ = \BitMask::op_RightShift(BitMask,Int32).0._State_5\) then 
                                \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask::op_RightShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 2147483648u;
                        -- 	array = new uint[1];
                        -- 	System.Array.Copy (left.Segments, array, 1);
                        -- 	num2 = 0;
                        -- 	while ((int)num2 < right) {
                        -- 		flag2 = false;
                        -- 		num3 = 1;
                        -- 		while ((int)num3 <= 1) {
                        -- 			num4 = (ushort)(1 - (int)num3);
                        -- 			System.UInt32 remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                        -- 			remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                        -- 			flag3 = remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                        -- 			array [(int)num4] = array [(int)num4] >> 1;
                        -- 			flag4 = flag2;
                        -- 			if (flag4) {
                        -- 				array [(int)num4] = array [(int)num4] | num;
                        -- 			}
                        -- 			flag2 = flag3;
                        -- 			num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 		}
                        -- 		num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \BitMask::op_RightShift(BitMask,Int32).0.num\ := "10000000000000000000000000000000";
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::op_RightShift(BitMask,Int32).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- System.Array.Copy (left.Segments, array, 1);
                        -- 
                        \BitMask::op_RightShift(BitMask,Int32).0.array\ := \BitMask::op_RightShift(BitMask,Int32).0.left\.\Segments\(0 to 0);
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask::op_RightShift(BitMask,Int32).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)num2 < right) {
                        -- 	flag2 = false;
                        -- 	num3 = 1;
                        -- 	while ((int)num3 <= 1) {
                        -- 		num4 = (ushort)(1 - (int)num3);
                        -- 		System.UInt32 remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                        -- 		remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                        -- 		flag3 = remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                        -- 		array [(int)num4] = array [(int)num4] >> 1;
                        -- 		flag4 = flag2;
                        -- 		if (flag4) {
                        -- 			array [(int)num4] = array [(int)num4] | num;
                        -- 		}
                        -- 		flag2 = flag3;
                        -- 		num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 	}
                        -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::op_RightShift(BitMask,Int32).0._State_6\.
                        -- The while loop's condition:
                        \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.1\ := signed(SmartResize(\BitMask::op_RightShift(BitMask,Int32).0.num2\, 32)) < \BitMask::op_RightShift(BitMask,Int32).0.right\;
                        if (\BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag2 = false;
                            -- 	num3 = 1;
                            -- 	while ((int)num3 <= 1) {
                            -- 		num4 = (ushort)(1 - (int)num3);
                            -- 		System.UInt32 remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                            -- 		remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                            -- 		flag3 = remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                            -- 		array [(int)num4] = array [(int)num4] >> 1;
                            -- 		flag4 = flag2;
                            -- 		if (flag4) {
                            -- 			array [(int)num4] = array [(int)num4] | num;
                            -- 		}
                            -- 		flag2 = flag3;
                            -- 		num3 = (System.UInt16)((System.Int32)(num3) + 1);
                            -- 	}
                            -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = false;
                            -- 
                            \BitMask::op_RightShift(BitMask,Int32).0.flag2\ := False;
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = 1;
                            -- 
                            \BitMask::op_RightShift(BitMask,Int32).0.num3\ := to_unsigned(1, 16);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((int)num3 <= 1) {
                            -- 	num4 = (ushort)(1 - (int)num3);
                            -- 	System.UInt32 remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                            -- 	remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                            -- 	flag3 = remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                            -- 	array [(int)num4] = array [(int)num4] >> 1;
                            -- 	flag4 = flag2;
                            -- 	if (flag4) {
                            -- 		array [(int)num4] = array [(int)num4] | num;
                            -- 	}
                            -- 	flag2 = flag3;
                            -- 	num3 = (System.UInt16)((System.Int32)(num3) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_9\;
                        else 
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_8\ => 
                        -- State after the while loop which was started in state \BitMask::op_RightShift(BitMask,Int32).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::op_RightShift(BitMask,Int32).0.result\.\IsNull\ := false;
                        \BitMask::op_RightShift(BitMask,Int32).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::op_RightShift(BitMask,Int32).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::op_RightShift(BitMask,Int32).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask::op_RightShift(BitMask,Int32).0.result\;
                        \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::op_RightShift(BitMask,Int32).0.array\;
                        \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::op_RightShift(BitMask,Int32).0._State_7\.
                        -- The while loop's condition:
                        \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.2\ := signed(SmartResize(\BitMask::op_RightShift(BitMask,Int32).0.num3\, 32)) <= to_signed(1, 32);
                        if (\BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num4 = (ushort)(1 - (int)num3);
                            -- 	System.UInt32 remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                            -- 	remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                            -- 	flag3 = remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                            -- 	array [(int)num4] = array [(int)num4] >> 1;
                            -- 	flag4 = flag2;
                            -- 	if (flag4) {
                            -- 		array [(int)num4] = array [(int)num4] | num;
                            -- 	}
                            -- 	flag2 = flag3;
                            -- 	num3 = (System.UInt16)((System.Int32)(num3) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = (ushort)(1 - (int)num3);
                            -- 
                            \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.3\ := SmartResize(unsigned(to_signed(1, 32) - signed(SmartResize(\BitMask::op_RightShift(BitMask,Int32).0.num3\, 32))), 16);
                            \BitMask::op_RightShift(BitMask,Int32).0.num4\ := (\BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.3\);
                            -- The following section was transformed from the .NET statement below:
                            -- System.UInt32 remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                            -- 
                            \BitMask::op_RightShift(BitMask,Int32).0.remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605\ := \BitMask::op_RightShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask::op_RightShift(BitMask,Int32).0.num4\, 32))));
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                            -- 
                            \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.4\ := \BitMask::op_RightShift(BitMask,Int32).0.remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605\ / to_unsigned(2, 32);
                            \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.5\ := SmartResize(\BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.4\ * to_unsigned(2, 32), 32);
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_11\;
                        else 
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7766
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_10\ => 
                        -- State after the while loop which was started in state \BitMask::op_RightShift(BitMask,Int32).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 
                        \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.11\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_RightShift(BitMask,Int32).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_RightShift(BitMask,Int32).0.num2\ := (\BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.11\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::op_RightShift(BitMask,Int32).0._State_6\ if the loop wasn't exited with a state change.
                        if (\BitMask::op_RightShift(BitMask,Int32).0._State\ = \BitMask::op_RightShift(BitMask,Int32).0._State_10\) then 
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.6\ := \BitMask::op_RightShift(BitMask,Int32).0.remainderOperand3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605\ - \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.5\;
                        \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.7\ := \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.6\ = to_unsigned(1, 32);
                        \BitMask::op_RightShift(BitMask,Int32).0.flag3\ := \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num4] = array [(int)num4] >> 1;
                        -- 
                        \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.8\ := shift_right(\BitMask::op_RightShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask::op_RightShift(BitMask,Int32).0.num4\, 32)))), to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                        \BitMask::op_RightShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask::op_RightShift(BitMask,Int32).0.num4\, 32)))) := \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.8\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = flag2;
                        -- 
                        \BitMask::op_RightShift(BitMask,Int32).0.flag4\ := \BitMask::op_RightShift(BitMask,Int32).0.flag2\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	array [(int)num4] = array [(int)num4] | num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_RightShift(BitMask,Int32).0._State_13\ and ends in state \BitMask::op_RightShift(BitMask,Int32).0._State_13\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_RightShift(BitMask,Int32).0._State_12\.

                        if (\BitMask::op_RightShift(BitMask,Int32).0.flag4\) then 
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8293
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_12\ => 
                        -- State after the if-else which was started in state \BitMask::op_RightShift(BitMask,Int32).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = flag3;
                        -- 
                        \BitMask::op_RightShift(BitMask,Int32).0.flag2\ := \BitMask::op_RightShift(BitMask,Int32).0.flag3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 
                        \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.10\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_RightShift(BitMask,Int32).0.num3\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_RightShift(BitMask,Int32).0.num3\ := (\BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.10\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::op_RightShift(BitMask,Int32).0._State_7\ if the loop wasn't exited with a state change.
                        if (\BitMask::op_RightShift(BitMask,Int32).0._State\ = \BitMask::op_RightShift(BitMask,Int32).0._State_12\) then 
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_13\ => 
                        -- True branch of the if-else started in state \BitMask::op_RightShift(BitMask,Int32).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [(int)num4] = array [(int)num4] | num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num4] = array [(int)num4] | num;
                        -- 
                        \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.9\ := \BitMask::op_RightShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask::op_RightShift(BitMask,Int32).0.num4\, 32)))) or \BitMask::op_RightShift(BitMask,Int32).0.num\;
                        \BitMask::op_RightShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask::op_RightShift(BitMask,Int32).0.num4\, 32)))) := \BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.9\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_RightShift(BitMask,Int32).0._State_11\.
                        if (\BitMask::op_RightShift(BitMask,Int32).0._State\ = \BitMask::op_RightShift(BitMask,Int32).0._State_13\) then 
                            \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1386
                    when \BitMask::op_RightShift(BitMask,Int32).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::op_RightShift(BitMask,Int32).0.result\ := \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask::op_RightShift(BitMask,Int32).0.array\ := \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::op_RightShift(BitMask,Int32).0._State_2\.
                            if (\BitMask::op_RightShift(BitMask,Int32).0._State\ = \BitMask::op_RightShift(BitMask,Int32).0._State_14\) then 
                                \BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask::op_RightShift(BitMask,Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0 state machine start
    \BitMask::op_LeftShift(BitMask,Int32).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::op_LeftShift(BitMask,Int32).0._State\: \BitMask::op_LeftShift(BitMask,Int32).0._States\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_0\;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.right\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.flag\: boolean := false;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.flag2\: boolean := false;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.num4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.flag3\: boolean := false;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.flag4\: boolean := false;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.2\: boolean := false;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.4\: boolean := false;
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::op_LeftShift(BitMask,Int32).0._Finished\ <= false;
                \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_0\;
                \BitMask::op_LeftShift(BitMask,Int32).0.right\ := to_signed(0, 32);
                \BitMask::op_LeftShift(BitMask,Int32).0.flag\ := false;
                \BitMask::op_LeftShift(BitMask,Int32).0.num\ := to_unsigned(0, 32);
                \BitMask::op_LeftShift(BitMask,Int32).0.num2\ := to_unsigned(0, 32);
                \BitMask::op_LeftShift(BitMask,Int32).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::op_LeftShift(BitMask,Int32).0.num3\ := to_unsigned(0, 16);
                \BitMask::op_LeftShift(BitMask,Int32).0.flag2\ := false;
                \BitMask::op_LeftShift(BitMask,Int32).0.num4\ := to_unsigned(0, 16);
                \BitMask::op_LeftShift(BitMask,Int32).0.flag3\ := false;
                \BitMask::op_LeftShift(BitMask,Int32).0.flag4\ := false;
                \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.0\ := false;
                \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.1\ := false;
                \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.2\ := false;
                \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.4\ := false;
                \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.7\ := to_unsigned(0, 16);
                \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.8\ := to_unsigned(0, 16);
            else 
                case \BitMask::op_LeftShift(BitMask,Int32).0._State\ is 
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::op_LeftShift(BitMask,Int32).0._Started\ = true) then 
                            \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::op_LeftShift(BitMask,Int32).0._Started\ = true) then 
                            \BitMask::op_LeftShift(BitMask,Int32).0._Finished\ <= true;
                        else 
                            \BitMask::op_LeftShift(BitMask,Int32).0._Finished\ <= false;
                            \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_2\ => 
                        \BitMask::op_LeftShift(BitMask,Int32).0.left\ := \BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\;
                        \BitMask::op_LeftShift(BitMask,Int32).0.right\ := \BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = right < 0;
                        -- 
                        \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.0\ := \BitMask::op_LeftShift(BitMask,Int32).0.right\ < to_signed(0, 32);
                        \BitMask::op_LeftShift(BitMask,Int32).0.flag\ := \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = BitMask.op_RightShift (left, -right);
                        -- }
                        -- else {
                        -- 	num = 2147483648u;
                        -- 	num2 = 1u;
                        -- 	array = new uint[1];
                        -- 	System.Array.Copy (left.Segments, array, 1);
                        -- 	num3 = 0;
                        -- 	while ((int)num3 < right) {
                        -- 		flag2 = false;
                        -- 		num4 = 0;
                        -- 		while ((int)num4 < 1) {
                        -- 			flag3 = array [(int)num4] & num == num;
                        -- 			array [(int)num4] = array [(int)num4] << 1;
                        -- 			flag4 = flag2;
                        -- 			if (flag4) {
                        -- 				array [(int)num4] = array [(int)num4] | num2;
                        -- 			}
                        -- 			flag2 = flag3;
                        -- 			num4 = (System.UInt16)((System.Int32)(num4) + 1);
                        -- 		}
                        -- 		num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::op_LeftShift(BitMask,Int32).0._State_4\ and ends in state \BitMask::op_LeftShift(BitMask,Int32).0._State_5\.
                        --     * The false branch starts in state \BitMask::op_LeftShift(BitMask,Int32).0._State_6\ and ends in state \BitMask::op_LeftShift(BitMask,Int32).0._State_13\.
                        --     * Execution after either branch will continue in the following state: \BitMask::op_LeftShift(BitMask,Int32).0._State_3\.

                        if (\BitMask::op_LeftShift(BitMask,Int32).0.flag\) then 
                            \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_4\;
                        else 
                            \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::op_LeftShift(BitMask,Int32).0.return\ <= \BitMask::op_LeftShift(BitMask,Int32).0.result\;
                        \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = BitMask.op_RightShift (left, -right);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = BitMask.op_RightShift (left, -right);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.left\;
                        \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= -\BitMask::op_LeftShift(BitMask,Int32).0.right\;
                        \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                        \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::op_LeftShift(BitMask,Int32).0.return.0\ := \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32).return.0\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.result\ := \BitMask::op_LeftShift(BitMask,Int32).0.return.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_2\.
                            if (\BitMask::op_LeftShift(BitMask,Int32).0._State\ = \BitMask::op_LeftShift(BitMask,Int32).0._State_5\) then 
                                \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 2147483648u;
                        -- 	num2 = 1u;
                        -- 	array = new uint[1];
                        -- 	System.Array.Copy (left.Segments, array, 1);
                        -- 	num3 = 0;
                        -- 	while ((int)num3 < right) {
                        -- 		flag2 = false;
                        -- 		num4 = 0;
                        -- 		while ((int)num4 < 1) {
                        -- 			flag3 = array [(int)num4] & num == num;
                        -- 			array [(int)num4] = array [(int)num4] << 1;
                        -- 			flag4 = flag2;
                        -- 			if (flag4) {
                        -- 				array [(int)num4] = array [(int)num4] | num2;
                        -- 			}
                        -- 			flag2 = flag3;
                        -- 			num4 = (System.UInt16)((System.Int32)(num4) + 1);
                        -- 		}
                        -- 		num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \BitMask::op_LeftShift(BitMask,Int32).0.num\ := "10000000000000000000000000000000";
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 1u;
                        -- 
                        \BitMask::op_LeftShift(BitMask,Int32).0.num2\ := to_unsigned(1, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::op_LeftShift(BitMask,Int32).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- System.Array.Copy (left.Segments, array, 1);
                        -- 
                        \BitMask::op_LeftShift(BitMask,Int32).0.array\ := \BitMask::op_LeftShift(BitMask,Int32).0.left\.\Segments\(0 to 0);
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \BitMask::op_LeftShift(BitMask,Int32).0.num3\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)num3 < right) {
                        -- 	flag2 = false;
                        -- 	num4 = 0;
                        -- 	while ((int)num4 < 1) {
                        -- 		flag3 = array [(int)num4] & num == num;
                        -- 		array [(int)num4] = array [(int)num4] << 1;
                        -- 		flag4 = flag2;
                        -- 		if (flag4) {
                        -- 			array [(int)num4] = array [(int)num4] | num2;
                        -- 		}
                        -- 		flag2 = flag3;
                        -- 		num4 = (System.UInt16)((System.Int32)(num4) + 1);
                        -- 	}
                        -- 	num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_6\.
                        -- The while loop's condition:
                        \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.1\ := signed(SmartResize(\BitMask::op_LeftShift(BitMask,Int32).0.num3\, 32)) < \BitMask::op_LeftShift(BitMask,Int32).0.right\;
                        if (\BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag2 = false;
                            -- 	num4 = 0;
                            -- 	while ((int)num4 < 1) {
                            -- 		flag3 = array [(int)num4] & num == num;
                            -- 		array [(int)num4] = array [(int)num4] << 1;
                            -- 		flag4 = flag2;
                            -- 		if (flag4) {
                            -- 			array [(int)num4] = array [(int)num4] | num2;
                            -- 		}
                            -- 		flag2 = flag3;
                            -- 		num4 = (System.UInt16)((System.Int32)(num4) + 1);
                            -- 	}
                            -- 	num3 = (System.UInt16)((System.Int32)(num3) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = false;
                            -- 
                            \BitMask::op_LeftShift(BitMask,Int32).0.flag2\ := False;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 0;
                            -- 
                            \BitMask::op_LeftShift(BitMask,Int32).0.num4\ := to_unsigned(0, 16);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((int)num4 < 1) {
                            -- 	flag3 = array [(int)num4] & num == num;
                            -- 	array [(int)num4] = array [(int)num4] << 1;
                            -- 	flag4 = flag2;
                            -- 	if (flag4) {
                            -- 		array [(int)num4] = array [(int)num4] | num2;
                            -- 	}
                            -- 	flag2 = flag3;
                            -- 	num4 = (System.UInt16)((System.Int32)(num4) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_9\;
                        else 
                            \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_8\ => 
                        -- State after the while loop which was started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::op_LeftShift(BitMask,Int32).0.result\.\IsNull\ := false;
                        \BitMask::op_LeftShift(BitMask,Int32).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::op_LeftShift(BitMask,Int32).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::op_LeftShift(BitMask,Int32).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.result\;
                        \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.array\;
                        \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_7\.
                        -- The while loop's condition:
                        \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.2\ := signed(SmartResize(\BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)) < to_signed(1, 32);
                        if (\BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag3 = array [(int)num4] & num == num;
                            -- 	array [(int)num4] = array [(int)num4] << 1;
                            -- 	flag4 = flag2;
                            -- 	if (flag4) {
                            -- 		array [(int)num4] = array [(int)num4] | num2;
                            -- 	}
                            -- 	flag2 = flag3;
                            -- 	num4 = (System.UInt16)((System.Int32)(num4) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = array [(int)num4] & num == num;
                            -- 
                            \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.3\ := \BitMask::op_LeftShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)))) and \BitMask::op_LeftShift(BitMask,Int32).0.num\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.4\ := \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.3\ = \BitMask::op_LeftShift(BitMask,Int32).0.num\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.flag3\ := \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- array [(int)num4] = array [(int)num4] << 1;
                            -- 
                            \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.5\ := shift_left(\BitMask::op_LeftShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)))), to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                            \BitMask::op_LeftShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)))) := \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag4 = flag2;
                            -- 
                            \BitMask::op_LeftShift(BitMask,Int32).0.flag4\ := \BitMask::op_LeftShift(BitMask,Int32).0.flag2\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag4) {
                            -- 	array [(int)num4] = array [(int)num4] | num2;
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \BitMask::op_LeftShift(BitMask,Int32).0._State_12\ and ends in state \BitMask::op_LeftShift(BitMask,Int32).0._State_12\.
                            --     * Execution after either branch will continue in the following state: \BitMask::op_LeftShift(BitMask,Int32).0._State_11\.

                            if (\BitMask::op_LeftShift(BitMask,Int32).0.flag4\) then 
                                \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_12\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_11\;
                            end if;
                        else 
                            \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7747
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_10\ => 
                        -- State after the while loop which was started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (System.UInt16)((System.Int32)(num3) + 1);
                        -- 
                        \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.8\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_LeftShift(BitMask,Int32).0.num3\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_LeftShift(BitMask,Int32).0.num3\ := (\BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.8\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_6\ if the loop wasn't exited with a state change.
                        if (\BitMask::op_LeftShift(BitMask,Int32).0._State\ = \BitMask::op_LeftShift(BitMask,Int32).0._State_10\) then 
                            \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_11\ => 
                        -- State after the if-else which was started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = flag3;
                        -- 
                        \BitMask::op_LeftShift(BitMask,Int32).0.flag2\ := \BitMask::op_LeftShift(BitMask,Int32).0.flag3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = (System.UInt16)((System.Int32)(num4) + 1);
                        -- 
                        \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.7\ := SmartResize(unsigned(signed(SmartResize((\BitMask::op_LeftShift(BitMask,Int32).0.num4\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::op_LeftShift(BitMask,Int32).0.num4\ := (\BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.7\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_7\ if the loop wasn't exited with a state change.
                        if (\BitMask::op_LeftShift(BitMask,Int32).0._State\ = \BitMask::op_LeftShift(BitMask,Int32).0._State_11\) then 
                            \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_12\ => 
                        -- True branch of the if-else started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [(int)num4] = array [(int)num4] | num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num4] = array [(int)num4] | num2;
                        -- 
                        \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.6\ := \BitMask::op_LeftShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)))) or \BitMask::op_LeftShift(BitMask,Int32).0.num2\;
                        \BitMask::op_LeftShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)))) := \BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.6\;
                        -- Going to the state after the if-else which was started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_9\.
                        if (\BitMask::op_LeftShift(BitMask,Int32).0._State\ = \BitMask::op_LeftShift(BitMask,Int32).0._State_12\) then 
                            \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1386
                    when \BitMask::op_LeftShift(BitMask,Int32).0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::op_LeftShift(BitMask,Int32).0.result\ := \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.array\ := \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::op_LeftShift(BitMask,Int32).0._State_2\.
                            if (\BitMask::op_LeftShift(BitMask,Int32).0._State\ = \BitMask::op_LeftShift(BitMask,Int32).0._State_13\) then 
                                \BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask::op_LeftShift(BitMask,Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0 state machine end


    -- System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition().0 state machine start
    \BitMask::GetMostSignificantOnePosition().0._StateMachine\: process (\Clock\) 
        Variable \BitMask::GetMostSignificantOnePosition().0._State\: \BitMask::GetMostSignificantOnePosition().0._States\ := \BitMask::GetMostSignificantOnePosition().0._State_0\;
        Variable \BitMask::GetMostSignificantOnePosition().0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetMostSignificantOnePosition().0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetMostSignificantOnePosition().0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetMostSignificantOnePosition().0.num3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::GetMostSignificantOnePosition().0.flag\: boolean := false;
        Variable \BitMask::GetMostSignificantOnePosition().0.result\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.2\: boolean := false;
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.5\: boolean := false;
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.9\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::GetMostSignificantOnePosition().0._Finished\ <= false;
                \BitMask::GetMostSignificantOnePosition().0.return\ <= to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_0\;
                \BitMask::GetMostSignificantOnePosition().0.num\ := to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0.num2\ := to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0.num3\ := to_unsigned(0, 32);
                \BitMask::GetMostSignificantOnePosition().0.flag\ := false;
                \BitMask::GetMostSignificantOnePosition().0.result\ := to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.0\ := false;
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.2\ := false;
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.4\ := to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.5\ := false;
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.6\ := to_signed(0, 32);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.7\ := to_signed(0, 32);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.8\ := to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.9\ := to_unsigned(0, 16);
            else 
                case \BitMask::GetMostSignificantOnePosition().0._State\ is 
                    when \BitMask::GetMostSignificantOnePosition().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::GetMostSignificantOnePosition().0._Started\ = true) then 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetMostSignificantOnePosition().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::GetMostSignificantOnePosition().0._Started\ = true) then 
                            \BitMask::GetMostSignificantOnePosition().0._Finished\ <= true;
                        else 
                            \BitMask::GetMostSignificantOnePosition().0._Finished\ <= false;
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetMostSignificantOnePosition().0._State_2\ => 
                        \BitMask::GetMostSignificantOnePosition().0.this\ := \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 1;
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.num2\ := to_unsigned(1, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((System.Int32)(num2) <= (System.Int32)(@this.SegmentCount)) {
                        -- 	num3 = @this.Segments [(int)((System.Int32)(@this.SegmentCount) - (System.Int32)(num2))];
                        -- 	while (num3 > 0u) {
                        -- 		num3 = num3 >> 1;
                        -- 		num = (System.UInt16)((System.Int32)(num) + 1);
                        -- 		flag = num3 == 0u;
                        -- 		if (flag) {
                        -- 			result = (System.UInt16)((System.Int32)((System.Int32)((System.Int32)(@this.SegmentCount) - (System.Int32)(num2)) * 32) + (System.Int32)(num));
                        -- 			return result;
                        -- 		}
                        -- 	}
                        -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetMostSignificantOnePosition().0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_2\.
                        -- The while loop's condition:
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.0\ := signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num2\), 32)) <= signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.this\.\SegmentCount\), 32));
                        if (\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num3 = @this.Segments [(int)((System.Int32)(@this.SegmentCount) - (System.Int32)(num2))];
                            -- 	while (num3 > 0u) {
                            -- 		num3 = num3 >> 1;
                            -- 		num = (System.UInt16)((System.Int32)(num) + 1);
                            -- 		flag = num3 == 0u;
                            -- 		if (flag) {
                            -- 			result = (System.UInt16)((System.Int32)((System.Int32)((System.Int32)(@this.SegmentCount) - (System.Int32)(num2)) * 32) + (System.Int32)(num));
                            -- 			return result;
                            -- 		}
                            -- 	}
                            -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = @this.Segments [(int)((System.Int32)(@this.SegmentCount) - (System.Int32)(num2))];
                            -- 
                            \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.1\ := signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.this\.\SegmentCount\), 32)) - signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num2\), 32));
                            \BitMask::GetMostSignificantOnePosition().0.num3\ := \BitMask::GetMostSignificantOnePosition().0.this\.\Segments\(to_integer((\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.1\)));
                            -- The following section was transformed from the .NET statement below:
                            -- while (num3 > 0u) {
                            -- 	num3 = num3 >> 1;
                            -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                            -- 	flag = num3 == 0u;
                            -- 	if (flag) {
                            -- 		result = (System.UInt16)((System.Int32)((System.Int32)((System.Int32)(@this.SegmentCount) - (System.Int32)(num2)) * 32) + (System.Int32)(num));
                            -- 		return result;
                            -- 	}
                            -- }
                            -- 
                            -- Starting a while loop.
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_5\;
                        else 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5766
                    when \BitMask::GetMostSignificantOnePosition().0._State_4\ => 
                        -- State after the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = 0;
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.result\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- return 0;
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.return\ <= to_unsigned(0, 16);
                        \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetMostSignificantOnePosition().0._State_5\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_3\.
                        -- The while loop's condition:
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.2\ := \BitMask::GetMostSignificantOnePosition().0.num3\ > to_unsigned(0, 32);
                        if (\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num3 = num3 >> 1;
                            -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                            -- 	flag = num3 == 0u;
                            -- 	if (flag) {
                            -- 		result = (System.UInt16)((System.Int32)((System.Int32)((System.Int32)(@this.SegmentCount) - (System.Int32)(num2)) * 32) + (System.Int32)(num));
                            -- 		return result;
                            -- 	}
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = num3 >> 1;
                            -- 
                            \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.3\ := shift_right(\BitMask::GetMostSignificantOnePosition().0.num3\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                            \BitMask::GetMostSignificantOnePosition().0.num3\ := \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = (System.UInt16)((System.Int32)(num) + 1);
                            -- 
                            \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.4\ := SmartResize(unsigned(signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num\), 32)) + to_signed(1, 32)), 16);
                            \BitMask::GetMostSignificantOnePosition().0.num\ := (\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.4\);
                            -- The following section was transformed from the .NET statement below:
                            -- flag = num3 == 0u;
                            -- 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_7\;
                        else 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8297
                    when \BitMask::GetMostSignificantOnePosition().0._State_6\ => 
                        -- State after the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (System.UInt16)((System.Int32)(num2) + 1);
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.9\ := SmartResize(unsigned(signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num2\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::GetMostSignificantOnePosition().0.num2\ := (\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.9\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_2\ if the loop wasn't exited with a state change.
                        if (\BitMask::GetMostSignificantOnePosition().0._State\ = \BitMask::GetMostSignificantOnePosition().0._State_6\) then 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \BitMask::GetMostSignificantOnePosition().0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.5\ := \BitMask::GetMostSignificantOnePosition().0.num3\ = to_unsigned(0, 32);
                        \BitMask::GetMostSignificantOnePosition().0.flag\ := \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = (System.UInt16)((System.Int32)((System.Int32)((System.Int32)(@this.SegmentCount) - (System.Int32)(num2)) * 32) + (System.Int32)(num));
                        -- 	return result;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::GetMostSignificantOnePosition().0._State_9\ and ends in state \BitMask::GetMostSignificantOnePosition().0._State_9\.
                        --     * Execution after either branch will continue in the following state: \BitMask::GetMostSignificantOnePosition().0._State_8\.

                        if (\BitMask::GetMostSignificantOnePosition().0.flag\) then 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_9\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \BitMask::GetMostSignificantOnePosition().0._State_8\ => 
                        -- State after the if-else which was started in state \BitMask::GetMostSignificantOnePosition().0._State_7\.
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_3\ if the loop wasn't exited with a state change.
                        if (\BitMask::GetMostSignificantOnePosition().0._State\ = \BitMask::GetMostSignificantOnePosition().0._State_8\) then 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetMostSignificantOnePosition().0._State_9\ => 
                        -- True branch of the if-else started in state \BitMask::GetMostSignificantOnePosition().0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = (System.UInt16)((System.Int32)((System.Int32)((System.Int32)(@this.SegmentCount) - (System.Int32)(num2)) * 32) + (System.Int32)(num));
                        -- 	return result;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = (System.UInt16)((System.Int32)((System.Int32)((System.Int32)(@this.SegmentCount) - (System.Int32)(num2)) * 32) + (System.Int32)(num));
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.6\ := signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.this\.\SegmentCount\), 32)) - signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num2\), 32));
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.7\ := SmartResize((\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.6\) * to_signed(32, 32), 32);
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.8\ := SmartResize(unsigned((\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.7\) + signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num\), 32))), 16);
                        \BitMask::GetMostSignificantOnePosition().0.result\ := (\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.8\);
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.return\ <= \BitMask::GetMostSignificantOnePosition().0.result\;
                        \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_1\;
                        -- Going to the state after the if-else which was started in state \BitMask::GetMostSignificantOnePosition().0._State_7\.
                        if (\BitMask::GetMostSignificantOnePosition().0._State\ = \BitMask::GetMostSignificantOnePosition().0._State_9\) then 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                end case;
            end if;
        end if;
    end process;
    -- System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0 state machine start
    \BitMask::GetTwosComplement(UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::GetTwosComplement(UInt16).0._State\: \BitMask::GetTwosComplement(UInt16).0._States\ := \BitMask::GetTwosComplement(UInt16).0._State_0\;
        Variable \BitMask::GetTwosComplement(UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetTwosComplement(UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetTwosComplement(UInt16).0.input\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetTwosComplement(UInt16).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetTwosComplement(UInt16).0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetTwosComplement(UInt16).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetTwosComplement(UInt16).0.return.3\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::GetTwosComplement(UInt16).0._Finished\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask)._Started.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_0\;
                \BitMask::GetTwosComplement(UInt16).0.size\ := to_unsigned(0, 16);
                \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.0\ := to_signed(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.3\ := to_signed(0, 32);
            else 
                case \BitMask::GetTwosComplement(UInt16).0._State\ is 
                    when \BitMask::GetTwosComplement(UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::GetTwosComplement(UInt16).0._Started\ = true) then 
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetTwosComplement(UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::GetTwosComplement(UInt16).0._Started\ = true) then 
                            \BitMask::GetTwosComplement(UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::GetTwosComplement(UInt16).0._Finished\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetTwosComplement(UInt16).0._State_2\ => 
                        \BitMask::GetTwosComplement(UInt16).0.this\ := \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\;
                        \BitMask::GetTwosComplement(UInt16).0.size\ := \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask input;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- input = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::GetTwosComplement(UInt16).0.input\.\IsNull\ := false;
                        \BitMask::GetTwosComplement(UInt16).0.input\.\Size\ := to_unsigned(0, 16);
                        \BitMask::GetTwosComplement(UInt16).0.input\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::GetTwosComplement(UInt16).0.input\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.input\;
                        \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.this\;
                        \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetTwosComplement(UInt16).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0.input\ := \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::GetTwosComplement(UInt16).0.this\ := \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return BitMask.op_RightShift (BitMask.op_LeftShift (BitMask.op_Addition (BitMask.op_OnesComplement (input), 1u), (int)((System.Int32)((System.Int32)(@this.SegmentCount) * 32) - 32)), (int)((System.Int32)((System.Int32)(@this.SegmentCount) * 32) - 32));
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask)
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask).input.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.input\;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask)._Started.0\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetTwosComplement(UInt16).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask)._Started.0\ = \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask)._Finished.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask)._Started.0\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0.return.0\ := \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.return.0\;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetTwosComplement(UInt16).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0.return.1\ := \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\BitMask::GetTwosComplement(UInt16).0.this\.\SegmentCount\), 32)) * to_signed(32, 32), 32);
                            \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.1\ := (\BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.0\) - to_signed(32, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.return.1\;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= (\BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.1\);
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \BitMask::GetTwosComplement(UInt16).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0.return.2\ := \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\BitMask::GetTwosComplement(UInt16).0.this\.\SegmentCount\), 32)) * to_signed(32, 32), 32);
                            \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.3\ := (\BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.2\) - to_signed(32, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.return.2\;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= (\BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.3\);
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \BitMask::GetTwosComplement(UInt16).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0.return.3\ := \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32).return.0\;
                            \BitMask::GetTwosComplement(UInt16).0.return\ <= \BitMask::GetTwosComplement(UInt16).0.return.3\;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0 state machine end


    -- System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0 state machine start
    \BitMask::LengthOfRunOfBits(UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::LengthOfRunOfBits(UInt16).0._State\: \BitMask::LengthOfRunOfBits(UInt16).0._States\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_0\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.flag\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.i\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.flag2\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.result\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.3\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.4\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.6\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.7\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.10\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::LengthOfRunOfBits(UInt16).0._Finished\ <= false;
                \BitMask::LengthOfRunOfBits(UInt16).0.return\ <= to_unsigned(0, 16);
                \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_0\;
                \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition\ := to_unsigned(0, 16);
                \BitMask::LengthOfRunOfBits(UInt16).0.num\ := to_unsigned(0, 16);
                \BitMask::LengthOfRunOfBits(UInt16).0.flag\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.i\ := to_signed(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.flag2\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.result\ := to_unsigned(0, 16);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.0\ := to_signed(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.3\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.4\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.6\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.7\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.8\ := to_unsigned(0, 16);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.9\ := to_signed(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.10\ := false;
            else 
                case \BitMask::LengthOfRunOfBits(UInt16).0._State\ is 
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0._Started\ = true) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0._Started\ = true) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::LengthOfRunOfBits(UInt16).0._Finished\ <= false;
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_2\ => 
                        \BitMask::LengthOfRunOfBits(UInt16).0.this\ := \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\;
                        \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition\ := \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask left;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int i;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.num\ := to_unsigned(1, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\.\IsNull\ := false;
                        \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\.\Size\ := to_unsigned(0, 16);
                        \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\;
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.this\;
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\ := \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.this\ := \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- left = BitMask.op_LeftShift (objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e, (int)((System.Int32)((System.Int32)(@this.SegmentCount) * 32) - 31));
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\BitMask::LengthOfRunOfBits(UInt16).0.this\.\SegmentCount\), 32)) * to_signed(32, 32), 32);
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.1\ := (\BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.0\) - to_signed(31, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= (\BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.1\);
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::LengthOfRunOfBits(UInt16).0.return.0\ := \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.left\ := \BitMask::LengthOfRunOfBits(UInt16).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag = left.Segments [0] >> 31 > 0u;
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.2\ := shift_right(\BitMask::LengthOfRunOfBits(UInt16).0.left\.\Segments\(to_integer(to_signed(0, 32))), to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.3\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.2\ > to_unsigned(0, 32);
                            \BitMask::LengthOfRunOfBits(UInt16).0.flag\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- left = BitMask.op_LeftShift (left, 1);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5141
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_5\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_6\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.left\;
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(1, 32);
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::LengthOfRunOfBits(UInt16).0.return.1\ := \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.left\ := \BitMask::LengthOfRunOfBits(UInt16).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- i = 0;
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.i\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (i < (int)startingPosition) {
                            -- 	flag2 = left.Segments [0] >> 31 > 0u != flag;
                            -- 	if (flag2) {
                            -- 		result = num;
                            -- 		return result;
                            -- 	}
                            -- 	left = BitMask.op_LeftShift (left, 1);
                            -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_8\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_7\.
                        -- The while loop's condition:
                        \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.4\ := \BitMask::LengthOfRunOfBits(UInt16).0.i\ < signed(SmartResize(\BitMask::LengthOfRunOfBits(UInt16).0.startingPosition\, 32));
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag2 = left.Segments [0] >> 31 > 0u != flag;
                            -- 	if (flag2) {
                            -- 		result = num;
                            -- 		return result;
                            -- 	}
                            -- 	left = BitMask.op_LeftShift (left, 1);
                            -- 	num = (System.UInt16)((System.Int32)(num) + 1);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = left.Segments [0] >> 31 > 0u != flag;
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.5\ := shift_right(\BitMask::LengthOfRunOfBits(UInt16).0.left\.\Segments\(to_integer(to_signed(0, 32))), to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.6\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.5\ > to_unsigned(0, 32);
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.7\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.6\ /= \BitMask::LengthOfRunOfBits(UInt16).0.flag\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.flag2\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.7\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag2) {
                            -- 	result = num;
                            -- 	return result;
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \BitMask::LengthOfRunOfBits(UInt16).0._State_11\ and ends in state \BitMask::LengthOfRunOfBits(UInt16).0._State_11\.
                            --     * Execution after either branch will continue in the following state: \BitMask::LengthOfRunOfBits(UInt16).0._State_10\.

                            if (\BitMask::LengthOfRunOfBits(UInt16).0.flag2\) then 
                                \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_11\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_10\;
                            end if;
                        else 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8989
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_9\ => 
                        -- State after the while loop which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- if ((System.Int32)(num) > 31) {
                        -- 	result = 31;
                        -- }
                        -- else {
                        -- 	result = num;
                        -- }
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.10\ := signed(SmartResize((\BitMask::LengthOfRunOfBits(UInt16).0.num\), 32)) > to_signed(31, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::LengthOfRunOfBits(UInt16).0._State_14\ and ends in state \BitMask::LengthOfRunOfBits(UInt16).0._State_14\.
                        --     * The false branch starts in state \BitMask::LengthOfRunOfBits(UInt16).0._State_15\ and ends in state \BitMask::LengthOfRunOfBits(UInt16).0._State_15\.
                        --     * Execution after either branch will continue in the following state: \BitMask::LengthOfRunOfBits(UInt16).0._State_13\.

                        if (\BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.10\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_14\;
                        else 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_10\ => 
                        -- State after the if-else which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- left = BitMask.op_LeftShift (left, 1);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.left\;
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(1, 32);
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_11\ => 
                        -- True branch of the if-else started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- 	return result;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.result\ := \BitMask::LengthOfRunOfBits(UInt16).0.num\;
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.return\ <= \BitMask::LengthOfRunOfBits(UInt16).0.result\;
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_1\;
                        -- Going to the state after the if-else which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_8\.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0._State\ = \BitMask::LengthOfRunOfBits(UInt16).0._State_11\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::LengthOfRunOfBits(UInt16).0.return.2\ := \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.left\ := \BitMask::LengthOfRunOfBits(UInt16).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = (System.UInt16)((System.Int32)(num) + 1);
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.8\ := SmartResize(unsigned(signed(SmartResize((\BitMask::LengthOfRunOfBits(UInt16).0.num\), 32)) + to_signed(1, 32)), 16);
                            \BitMask::LengthOfRunOfBits(UInt16).0.num\ := (\BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.8\);
                            -- The following section was transformed from the .NET statement below:
                            -- i = i + 1;
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.9\ := \BitMask::LengthOfRunOfBits(UInt16).0.i\ + to_signed(1, 32);
                            \BitMask::LengthOfRunOfBits(UInt16).0.i\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.9\;
                            -- Returning to the repeated state of the while loop which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_7\ if the loop wasn't exited with a state change.
                            if (\BitMask::LengthOfRunOfBits(UInt16).0._State\ = \BitMask::LengthOfRunOfBits(UInt16).0._State_12\) then 
                                \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_8\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_13\ => 
                        -- State after the if-else which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.return\ <= \BitMask::LengthOfRunOfBits(UInt16).0.result\;
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_14\ => 
                        -- True branch of the if-else started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = 31;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = 31;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.result\ := to_unsigned(31, 16);
                        -- Going to the state after the if-else which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_9\.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0._State\ = \BitMask::LengthOfRunOfBits(UInt16).0._State_14\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_15\ => 
                        -- False branch of the if-else started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.result\ := \BitMask::LengthOfRunOfBits(UInt16).0.num\;
                        -- Going to the state after the if-else which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_9\.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0._State\ = \BitMask::LengthOfRunOfBits(UInt16).0._State_15\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits().0 state machine start
    \BitMask::GetLowest32Bits().0._StateMachine\: process (\Clock\) 
        Variable \BitMask::GetLowest32Bits().0._State\: \BitMask::GetLowest32Bits().0._States\ := \BitMask::GetLowest32Bits().0._State_0\;
        Variable \BitMask::GetLowest32Bits().0.this\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::GetLowest32Bits().0._Finished\ <= false;
                \BitMask::GetLowest32Bits().0.return\ <= to_unsigned(0, 32);
                \BitMask::GetLowest32Bits().0._State\ := \BitMask::GetLowest32Bits().0._State_0\;
            else 
                case \BitMask::GetLowest32Bits().0._State\ is 
                    when \BitMask::GetLowest32Bits().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::GetLowest32Bits().0._Started\ = true) then 
                            \BitMask::GetLowest32Bits().0._State\ := \BitMask::GetLowest32Bits().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetLowest32Bits().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::GetLowest32Bits().0._Started\ = true) then 
                            \BitMask::GetLowest32Bits().0._Finished\ <= true;
                        else 
                            \BitMask::GetLowest32Bits().0._Finished\ <= false;
                            \BitMask::GetLowest32Bits().0._State\ := \BitMask::GetLowest32Bits().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetLowest32Bits().0._State_2\ => 
                        \BitMask::GetLowest32Bits().0.this\ := \BitMask::GetLowest32Bits().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.Segments [0];
                        -- 
                        \BitMask::GetLowest32Bits().0.return\ <= \BitMask::GetLowest32Bits().0.this\.\Segments\(to_integer(to_signed(0, 32)));
                        \BitMask::GetLowest32Bits().0._State\ := \BitMask::GetLowest32Bits().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits().0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask).0 state machine start
    \Posit::.ctor(PositEnvironment,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \Posit::.ctor(PositEnvironment,BitMask).0._State\: \Posit::.ctor(PositEnvironment,BitMask).0._States\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_0\;
        Variable \Posit::.ctor(PositEnvironment,BitMask).0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::.ctor(PositEnvironment,BitMask).0.environment\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \Posit::.ctor(PositEnvironment,BitMask).0.bits\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::.ctor(PositEnvironment,BitMask).0.return.0\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::.ctor(PositEnvironment,BitMask).0._Finished\ <= false;
                \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                \Posit::.ctor(PositEnvironment,BitMask).0._State\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_0\;
            else 
                case \Posit::.ctor(PositEnvironment,BitMask).0._State\ is 
                    when \Posit::.ctor(PositEnvironment,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::.ctor(PositEnvironment,BitMask).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,BitMask).0._State\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::.ctor(PositEnvironment,BitMask).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,BitMask).0._Finished\ <= true;
                        else 
                            \Posit::.ctor(PositEnvironment,BitMask).0._Finished\ <= false;
                            \Posit::.ctor(PositEnvironment,BitMask).0._State\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.Out\ <= \Posit::.ctor(PositEnvironment,BitMask).0.this\;
                        \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.Out\ <= \Posit::.ctor(PositEnvironment,BitMask).0.environment\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,BitMask).0._State_2\ => 
                        \Posit::.ctor(PositEnvironment,BitMask).0.this\ := \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.In\;
                        \Posit::.ctor(PositEnvironment,BitMask).0.environment\ := \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.In\;
                        \Posit::.ctor(PositEnvironment,BitMask).0.bits\ := \Posit::.ctor(PositEnvironment,BitMask).0.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this._environment = environment;
                        -- 
                        \Posit::.ctor(PositEnvironment,BitMask).0.this\.\_environment\ := \Posit::.ctor(PositEnvironment,BitMask).0.environment\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = BitMask.FromImmutableArray (bits.Segments, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,BitMask).0.bits\.\Segments\;
                        \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= true;
                        \Posit::.ctor(PositEnvironment,BitMask).0._State\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,BitMask).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        if (\Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,BitMask).0.return.0\ := \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.bits\.\Segments\ := \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.this\.\PositBits\ := \Posit::.ctor(PositEnvironment,BitMask).0.return.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0._State\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0 state machine start
    \Posit::.ctor(PositEnvironment,UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit::.ctor(PositEnvironment,UInt32).0._State\: \Posit::.ctor(PositEnvironment,UInt32).0._States\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_0\;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.environment\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.value\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.flag\: boolean := false;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.2\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.3\: boolean := false;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.5\: boolean := false;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.6\: boolean := false;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.9\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.return.1\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::.ctor(PositEnvironment,UInt32).0._Finished\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_0\;
                \Posit::.ctor(PositEnvironment,UInt32).0.value\ := to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.flag\ := false;
                \Posit::.ctor(PositEnvironment,UInt32).0.num\ := to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.num2\ := to_unsigned(0, 16);
                \Posit::.ctor(PositEnvironment,UInt32).0.return.0\ := to_unsigned(0, 16);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.2\ := to_unsigned(0, 64);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.3\ := false;
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.4\ := to_signed(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.5\ := false;
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.6\ := false;
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.9\ := to_unsigned(0, 16);
            else 
                case \Posit::.ctor(PositEnvironment,UInt32).0._State\ is 
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0._Finished\ <= true;
                        else 
                            \Posit::.ctor(PositEnvironment,UInt32).0._Finished\ <= false;
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.Out\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.Out\ <= \Posit::.ctor(PositEnvironment,UInt32).0.environment\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_2\ => 
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\ := \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.In\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.environment\ := \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.In\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.value\ := \Posit::.ctor(PositEnvironment,UInt32).0.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- @this._environment = environment;
                        -- 
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\.\_environment\ := \Posit::.ctor(PositEnvironment,UInt32).0.environment\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = new BitMask (1u, 32);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\.\IsNull\ := false;
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\.\Size\ := to_unsigned(0, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\ := \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag = false;
                            -- 
                            \Posit::.ctor(PositEnvironment,UInt32).0.flag\ := False;
                            -- The following section was transformed from the .NET statement below:
                            -- num = (uint)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (@this.PositBits)) - 1);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,UInt32).0.return.0\ := \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.0\ := unsigned(signed(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.return.0\), 32)) - to_signed(1, 32));
                            \Posit::.ctor(PositEnvironment,UInt32).0.num\ := (\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 0;
                            -- 
                            \Posit::.ctor(PositEnvironment,UInt32).0.num2\ := to_unsigned(0, 16);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((ulong)num >= (ulong)(1L << (int)((System.Int32)(environment.MaximumExponentSize) & 31)) && (System.Int32)(num2) < (System.Int32)((System.Int32)(@this._environment.Size) - 1)) {
                            -- 	num = num - 1u << (int)environment.MaximumExponentSize;
                            -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_5\ => 
                        -- Repeated state of the while loop which was started in state \Posit::.ctor(PositEnvironment,UInt32).0._State_4\.
                        -- The while loop's condition:
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.1\ := signed(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.environment\.\MaximumExponentSize\), 32)) and to_signed(31, 32);
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.2\ := SmartResize(unsigned(shift_left(to_signed(1, 64), to_integer(unsigned(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.1\), 6))))), 64);
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.3\ := SmartResize(\Posit::.ctor(PositEnvironment,UInt32).0.num\, 64) >= (\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.2\);
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.4\ := signed(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.this\.\_environment\.\Size\), 32)) - to_signed(1, 32);
                        \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.8155
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_6\ => 
                        -- State after the while loop which was started in state \Posit::.ctor(PositEnvironment,UInt32).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6 = new BitMask (num, 32);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\.\IsNull\ := false;
                        \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\.\Size\ := to_unsigned(0, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.num\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.5\ := signed(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.num2\), 32)) < (\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.4\);
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.6\ := \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.3\ and \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.5\;
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.6\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num = num - 1u << (int)environment.MaximumExponentSize;
                            -- 	num2 = (System.UInt16)((System.Int32)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num = num - 1u << (int)environment.MaximumExponentSize;
                            -- 
                            \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.7\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\Posit::.ctor(PositEnvironment,UInt32).0.environment\.\MaximumExponentSize\, 32)), 5))));
                            \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.8\ := \Posit::.ctor(PositEnvironment,UInt32).0.num\ - \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.7\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.num\ := \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (System.UInt16)((System.Int32)(num2) + 1);
                            -- 
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_8\;
                        else 
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7766
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.9\ := SmartResize(unsigned(signed(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.num2\ := (\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.9\);
                        -- Returning to the repeated state of the while loop which was started in state \Posit::.ctor(PositEnvironment,UInt32).0._State_4\ if the loop wasn't exited with a state change.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0._State\ = \Posit::.ctor(PositEnvironment,UInt32).0._State_8\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\ := \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.PositBits = Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (@this, false, (int)num2, objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6, @this.PositBits);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\ <= False;
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\ <= signed(SmartResize(\Posit::.ctor(PositEnvironment,UInt32).0.num2\, 32));
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= true;
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ = \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,UInt32).0.return.1\ := \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\ := \Posit::.ctor(PositEnvironment,UInt32).0.return.1\;
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32).0 state machine start
    \Posit::.ctor(PositEnvironment,Int32).0._StateMachine\: process (\Clock\) 
        Variable \Posit::.ctor(PositEnvironment,Int32).0._State\: \Posit::.ctor(PositEnvironment,Int32).0._States\ := \Posit::.ctor(PositEnvironment,Int32).0._State_0\;
        Variable \Posit::.ctor(PositEnvironment,Int32).0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::.ctor(PositEnvironment,Int32).0.environment\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \Posit::.ctor(PositEnvironment,Int32).0.value\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::.ctor(PositEnvironment,Int32).0.conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::.ctor(PositEnvironment,Int32).0.objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829\: \Lombiq.Arithmetics.Posit\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::.ctor(PositEnvironment,Int32).0._Finished\ <= false;
                \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).value.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\ <= false;
                \Posit::.ctor(PositEnvironment,Int32).0._State\ := \Posit::.ctor(PositEnvironment,Int32).0._State_0\;
                \Posit::.ctor(PositEnvironment,Int32).0.value\ := to_signed(0, 32);
            else 
                case \Posit::.ctor(PositEnvironment,Int32).0._State\ is 
                    when \Posit::.ctor(PositEnvironment,Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::.ctor(PositEnvironment,Int32).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,Int32).0._State\ := \Posit::.ctor(PositEnvironment,Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::.ctor(PositEnvironment,Int32).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,Int32).0._Finished\ <= true;
                        else 
                            \Posit::.ctor(PositEnvironment,Int32).0._Finished\ <= false;
                            \Posit::.ctor(PositEnvironment,Int32).0._State\ := \Posit::.ctor(PositEnvironment,Int32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.Out\ <= \Posit::.ctor(PositEnvironment,Int32).0.this\;
                        \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.Out\ <= \Posit::.ctor(PositEnvironment,Int32).0.environment\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,Int32).0._State_2\ => 
                        \Posit::.ctor(PositEnvironment,Int32).0.this\ := \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.In\;
                        \Posit::.ctor(PositEnvironment,Int32).0.environment\ := \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.In\;
                        \Posit::.ctor(PositEnvironment,Int32).0.value\ := \Posit::.ctor(PositEnvironment,Int32).0.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this._environment = environment;
                        -- 
                        \Posit::.ctor(PositEnvironment,Int32).0.this\.\_environment\ := \Posit::.ctor(PositEnvironment,Int32).0.environment\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829 = new Posit (environment, 1u);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::.ctor(PositEnvironment,Int32).0.objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829\.\IsNull\ := false;
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32)
                        \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,Int32).0.objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829\;
                        \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,Int32).0.environment\;
                        \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).value.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\ <= true;
                        \Posit::.ctor(PositEnvironment,Int32).0._State\ := \Posit::.ctor(PositEnvironment,Int32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,Int32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32)
                        if (\Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\ = \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,Int32).0.objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829\ := \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.In.0\;
                            \Posit::.ctor(PositEnvironment,Int32).0.environment\ := \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d = objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829.PositBits;
                            -- 
                            \Posit::.ctor(PositEnvironment,Int32).0.conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d\ := \Posit::.ctor(PositEnvironment,Int32).0.objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829\.\PositBits\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.PositBits = conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d;
                            -- 
                            \Posit::.ctor(PositEnvironment,Int32).0.this\.\PositBits\ := \Posit::.ctor(PositEnvironment,Int32).0.conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d\;
                            \Posit::.ctor(PositEnvironment,Int32).0._State\ := \Posit::.ctor(PositEnvironment,Int32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0 state machine start
    \Posit::IsPositive().0._StateMachine\: process (\Clock\) 
        Variable \Posit::IsPositive().0._State\: \Posit::IsPositive().0._States\ := \Posit::IsPositive().0._State_0\;
        Variable \Posit::IsPositive().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::IsPositive().0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::IsPositive().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::IsPositive().0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::IsPositive().0.return.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::IsPositive().0._Finished\ <= false;
                \Posit::IsPositive().0.return\ <= false;
                \Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\ <= false;
                \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= false;
                \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_0\;
                \Posit::IsPositive().0.return.3\ := false;
            else 
                case \Posit::IsPositive().0._State\ is 
                    when \Posit::IsPositive().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::IsPositive().0._Started\ = true) then 
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::IsPositive().0._Started\ = true) then 
                            \Posit::IsPositive().0._Finished\ <= true;
                        else 
                            \Posit::IsPositive().0._Finished\ <= false;
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_2\ => 
                        \Posit::IsPositive().0.this\ := \Posit::IsPositive().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return BitMask.op_Equality (BitMask.op_BitwiseAnd (@this.PositBits, Lombiq.Arithmetics.Posit.get_SignBitMask (@this)), Lombiq.Arithmetics.Posit.get_EmptyBitMask (@this));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask()
                        \Posit::IsPositive().0.Posit::get_SignBitMask().this.parameter.Out.0\ <= \Posit::IsPositive().0.this\;
                        \Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\ <= true;
                        \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask()
                        if (\Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\ = \Posit::IsPositive().0.Posit::get_SignBitMask()._Finished.0\) then 
                            \Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\ <= false;
                            \Posit::IsPositive().0.return.0\ := \Posit::IsPositive().0.Posit::get_SignBitMask().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::IsPositive().0.this\.\PositBits\;
                            \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::IsPositive().0.return.0\;
                            \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ = \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\) then 
                            \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::IsPositive().0.return.1\ := \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                            \Posit::IsPositive().0.Posit::get_EmptyBitMask().this.parameter.Out.0\ <= \Posit::IsPositive().0.this\;
                            \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\ <= true;
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        if (\Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\ = \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\) then 
                            \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                            \Posit::IsPositive().0.return.2\ := \Posit::IsPositive().0.Posit::get_EmptyBitMask().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::IsPositive().0.return.1\;
                            \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::IsPositive().0.return.2\;
                            \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::IsPositive().0.return.3\ := \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask).return.0\;
                            \Posit::IsPositive().0.return\ <= \Posit::IsPositive().0.return.3\;
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0 state machine start
    \Posit::IsNaN().0._StateMachine\: process (\Clock\) 
        Variable \Posit::IsNaN().0._State\: \Posit::IsNaN().0._States\ := \Posit::IsNaN().0._State_0\;
        Variable \Posit::IsNaN().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::IsNaN().0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::IsNaN().0.return.1\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::IsNaN().0._Finished\ <= false;
                \Posit::IsNaN().0.return\ <= false;
                \Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\ <= false;
                \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_0\;
                \Posit::IsNaN().0.return.1\ := false;
            else 
                case \Posit::IsNaN().0._State\ is 
                    when \Posit::IsNaN().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::IsNaN().0._Started\ = true) then 
                            \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsNaN().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::IsNaN().0._Started\ = true) then 
                            \Posit::IsNaN().0._Finished\ <= true;
                        else 
                            \Posit::IsNaN().0._Finished\ <= false;
                            \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsNaN().0._State_2\ => 
                        \Posit::IsNaN().0.this\ := \Posit::IsNaN().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return BitMask.op_Equality (@this.PositBits, Lombiq.Arithmetics.Posit.get_NaNBitMask (@this));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask()
                        \Posit::IsNaN().0.Posit::get_NaNBitMask().this.parameter.Out.0\ <= \Posit::IsNaN().0.this\;
                        \Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\ <= true;
                        \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsNaN().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask()
                        if (\Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\ = \Posit::IsNaN().0.Posit::get_NaNBitMask()._Finished.0\) then 
                            \Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\ <= false;
                            \Posit::IsNaN().0.return.0\ := \Posit::IsNaN().0.Posit::get_NaNBitMask().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::IsNaN().0.this\.\PositBits\;
                            \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::IsNaN().0.return.0\;
                            \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsNaN().0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::IsNaN().0.return.1\ := \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask).return.0\;
                            \Posit::IsNaN().0.return\ <= \Posit::IsNaN().0.return.1\;
                            \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsZero().0 state machine start
    \Posit::IsZero().0._StateMachine\: process (\Clock\) 
        Variable \Posit::IsZero().0._State\: \Posit::IsZero().0._States\ := \Posit::IsZero().0._State_0\;
        Variable \Posit::IsZero().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::IsZero().0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::IsZero().0.return.1\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::IsZero().0._Finished\ <= false;
                \Posit::IsZero().0.return\ <= false;
                \Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_0\;
                \Posit::IsZero().0.return.1\ := false;
            else 
                case \Posit::IsZero().0._State\ is 
                    when \Posit::IsZero().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::IsZero().0._Started\ = true) then 
                            \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsZero().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::IsZero().0._Started\ = true) then 
                            \Posit::IsZero().0._Finished\ <= true;
                        else 
                            \Posit::IsZero().0._Finished\ <= false;
                            \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsZero().0._State_2\ => 
                        \Posit::IsZero().0.this\ := \Posit::IsZero().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return BitMask.op_Equality (@this.PositBits, Lombiq.Arithmetics.Posit.get_EmptyBitMask (@this));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        \Posit::IsZero().0.Posit::get_EmptyBitMask().this.parameter.Out.0\ <= \Posit::IsZero().0.this\;
                        \Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\ <= true;
                        \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsZero().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        if (\Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\ = \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\) then 
                            \Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                            \Posit::IsZero().0.return.0\ := \Posit::IsZero().0.Posit::get_EmptyBitMask().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::IsZero().0.this\.\PositBits\;
                            \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::IsZero().0.return.0\;
                            \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsZero().0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::IsZero().0.return.1\ := \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask).return.0\;
                            \Posit::IsZero().0.return\ <= \Posit::IsZero().0.return.1\;
                            \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsZero().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0 state machine start
    \Posit::EncodeRegimeBits(Int32).0._StateMachine\: process (\Clock\) 
        Variable \Posit::EncodeRegimeBits(Int32).0._State\: \Posit::EncodeRegimeBits(Int32).0._States\ := \Posit::EncodeRegimeBits(Int32).0._State_0\;
        Variable \Posit::EncodeRegimeBits(Int32).0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::EncodeRegimeBits(Int32).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::EncodeRegimeBits(Int32).0.flag\: boolean := false;
        Variable \Posit::EncodeRegimeBits(Int32).0.bitMask\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::EncodeRegimeBits(Int32).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::EncodeRegimeBits(Int32).0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::EncodeRegimeBits(Int32).0.return.2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::EncodeRegimeBits(Int32).0.return.3\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::EncodeRegimeBits(Int32).0.return.4\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::EncodeRegimeBits(Int32).0._Finished\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32)._Started.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_0\;
                \Posit::EncodeRegimeBits(Int32).0.regimeKValue\ := to_signed(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.flag\ := false;
                \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.0\ := false;
                \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.return.2\ := to_unsigned(0, 16);
                \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.3\ := to_signed(0, 32);
            else 
                case \Posit::EncodeRegimeBits(Int32).0._State\ is 
                    when \Posit::EncodeRegimeBits(Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::EncodeRegimeBits(Int32).0._Started\ = true) then 
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::EncodeRegimeBits(Int32).0._Started\ = true) then 
                            \Posit::EncodeRegimeBits(Int32).0._Finished\ <= true;
                        else 
                            \Posit::EncodeRegimeBits(Int32).0._Finished\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_2\ => 
                        \Posit::EncodeRegimeBits(Int32).0.this\ := \Posit::EncodeRegimeBits(Int32).0.this.parameter.In\;
                        \Posit::EncodeRegimeBits(Int32).0.regimeKValue\ := \Posit::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask bitMask;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = regimeKValue > 0;
                        -- 
                        \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.0\ := \Posit::EncodeRegimeBits(Int32).0.regimeKValue\ > to_signed(0, 32);
                        \Posit::EncodeRegimeBits(Int32).0.flag\ := \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	BitMask object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66;
                        -- 	object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66 = new BitMask (1u, 32);
                        -- 	bitMask = BitMask.op_Subtraction (BitMask.op_LeftShift (object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66, regimeKValue + 1), 1u);
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, (int)((System.Int32)(32 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask))) - 1));
                        -- }
                        -- else {
                        -- 	bitMask = BitMask.op_LeftShift (@this._environment.FirstRegimeBitBitMask, regimeKValue);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::EncodeRegimeBits(Int32).0._State_4\ and ends in state \Posit::EncodeRegimeBits(Int32).0._State_9\.
                        --     * The false branch starts in state \Posit::EncodeRegimeBits(Int32).0._State_10\ and ends in state \Posit::EncodeRegimeBits(Int32).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit::EncodeRegimeBits(Int32).0._State_3\.

                        if (\Posit::EncodeRegimeBits(Int32).0.flag\) then 
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_4\;
                        else 
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit::EncodeRegimeBits(Int32).0._State_3\ => 
                        -- State after the if-else which was started in state \Posit::EncodeRegimeBits(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return bitMask;
                        -- 
                        \Posit::EncodeRegimeBits(Int32).0.return\ <= \Posit::EncodeRegimeBits(Int32).0.bitMask\;
                        \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_4\ => 
                        -- True branch of the if-else started in state \Posit::EncodeRegimeBits(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	BitMask object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66;
                        -- 	object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66 = new BitMask (1u, 32);
                        -- 	bitMask = BitMask.op_Subtraction (BitMask.op_LeftShift (object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66, regimeKValue + 1), 1u);
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, (int)((System.Int32)(32 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask))) - 1));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66 = new BitMask (1u, 32);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\.\IsNull\ := false;
                        \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\.\Size\ := to_unsigned(0, 16);
                        \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\;
                        \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\ := \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_Subtraction (BitMask.op_LeftShift (object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66, regimeKValue + 1), 1u);
                            -- 
                            \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.1\ := \Posit::EncodeRegimeBits(Int32).0.regimeKValue\ + to_signed(1, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.1\;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::EncodeRegimeBits(Int32).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.return.0\ := \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32)
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32).left.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.return.0\;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32)._Started.0\ <= true;
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32)._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32)._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32)._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.return.1\ := \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32).return.0\;
                            \Posit::EncodeRegimeBits(Int32).0.bitMask\ := \Posit::EncodeRegimeBits(Int32).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_LeftShift (bitMask, (int)((System.Int32)(32 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask))) - 1));
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.bitMask\;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.return.2\ := \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.2\ := to_signed(32, 32) - signed(SmartResize((\Posit::EncodeRegimeBits(Int32).0.return.2\), 32));
                            \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.3\ := (\Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.2\) - to_signed(1, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.bitMask\;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= (\Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.3\);
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit::EncodeRegimeBits(Int32).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.return.3\ := \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::EncodeRegimeBits(Int32).0.bitMask\ := \Posit::EncodeRegimeBits(Int32).0.return.3\;
                            -- Going to the state after the if-else which was started in state \Posit::EncodeRegimeBits(Int32).0._State_2\.
                            if (\Posit::EncodeRegimeBits(Int32).0._State\ = \Posit::EncodeRegimeBits(Int32).0._State_9\) then 
                                \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_10\ => 
                        -- False branch of the if-else started in state \Posit::EncodeRegimeBits(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_LeftShift (@this._environment.FirstRegimeBitBitMask, regimeKValue);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_LeftShift (@this._environment.FirstRegimeBitBitMask, regimeKValue);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_11\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.this\.\_environment\.\FirstRegimeBitBitMask\;
                        \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.regimeKValue\;
                        \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.return.4\ := \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::EncodeRegimeBits(Int32).0.bitMask\ := \Posit::EncodeRegimeBits(Int32).0.return.4\;
                            -- Going to the state after the if-else which was started in state \Posit::EncodeRegimeBits(Int32).0._State_2\.
                            if (\Posit::EncodeRegimeBits(Int32).0._State\ = \Posit::EncodeRegimeBits(Int32).0._State_12\) then 
                                \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._States\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_0\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag2\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag3\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag4\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag5\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag6\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.1\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.3\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.3\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.4\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.5\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.5\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.6\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.7\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.8\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.10\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.11\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.12\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.13\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.14\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.15\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.16\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.12\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.17\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.14\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.18\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.19\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.15\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.20\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.21\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.22\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.16\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.23\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.24\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.25\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_0\;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag2\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag3\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num3\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag4\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag5\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag6\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.1\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.3\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.4\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.5\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.6\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.6\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.8\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.9\ := to_unsigned(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.13\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.8\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.9\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.10\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.11\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.12\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.13\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.14\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.19\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.15\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.21\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.22\ := to_unsigned(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.16\ := to_unsigned(0, 32);
            else 
                case \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ is 
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ = true) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ = true) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_2\ => 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this.parameter.In\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit.parameter.In\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue.parameter.In\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits.parameter.In\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask bitMask;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = Lombiq.Arithmetics.Posit.EncodeRegimeBits (@this, regimeKValue);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.0\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.1\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (int)((System.Int32)(32 - (System.Int32)((System.Int32)(num) + 2)) - 3);
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num\), 32)) + to_signed(2, 32), 32);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.1\ := to_signed(32, 32) - (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.0\);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.2\ := (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.1\) - to_signed(3, 32);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\ := (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (exponentBits, num2));
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.2\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.2\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.3\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag = num2 < 0;
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.3\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\ < to_signed(0, 32);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	exponentBits = BitMask.op_LeftShift (exponentBits, (int)exponentBits.Size + num2);
                            -- 	BitMask objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d;
                            -- 	objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d = new BitMask (exponentBits.Size, false);
                            -- 	flag2 = BitMask.op_GreaterThanOrEqual (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d, (System.UInt16)((System.Int32)(exponentBits.Size) - 1)));
                            -- 	if (flag2) {
                            -- 		BitMask object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64;
                            -- 		object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64 = new BitMask (exponentBits.Size, false);
                            -- 		flag3 = BitMask.op_Equality (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64, (System.UInt16)((System.Int32)(exponentBits.Size) - 1)));
                            -- 		if (flag3) {
                            -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- 		}
                            -- 		else {
                            -- 			bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- 		}
                            -- 	}
                            -- 	if (!signBit) {
                            -- 		result = bitMask;
                            -- 	}
                            -- 	else {
                            -- 		result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                            -- 	}
                            -- }
                            -- else {
                            -- 	num3 = (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (fractionBits)) - 1);
                            -- 	fractionBits = Lombiq.Arithmetics.BitMask.SetZero (fractionBits, (ushort)num3);
                            -- 	num4 = 30 - num3 - (int)num - 3;
                            -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (fractionBits, num4));
                            -- 	flag4 = num4 < 0;
                            -- 	if (flag4) {
                            -- 		fractionBits = BitMask.op_LeftShift (fractionBits, (int)fractionBits.Size + num4);
                            -- 		BitMask object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0;
                            -- 		object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0 = new BitMask (fractionBits.Size, false);
                            -- 		flag5 = BitMask.op_GreaterThanOrEqual (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                            -- 		if (flag5) {
                            -- 			BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                            -- 			objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                            -- 			flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                            -- 			if (flag6) {
                            -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- 			}
                            -- 			else {
                            -- 				bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- 			}
                            -- 		}
                            -- 	}
                            -- 	if (!signBit) {
                            -- 		result = bitMask;
                            -- 	}
                            -- 	else {
                            -- 		result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_8\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\.
                            --     * The false branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_29\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_52\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_8\;
                            else 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_29\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_8\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	exponentBits = BitMask.op_LeftShift (exponentBits, (int)exponentBits.Size + num2);
                        -- 	BitMask objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d;
                        -- 	objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d = new BitMask (exponentBits.Size, false);
                        -- 	flag2 = BitMask.op_GreaterThanOrEqual (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d, (System.UInt16)((System.Int32)(exponentBits.Size) - 1)));
                        -- 	if (flag2) {
                        -- 		BitMask object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64;
                        -- 		object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64 = new BitMask (exponentBits.Size, false);
                        -- 		flag3 = BitMask.op_Equality (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64, (System.UInt16)((System.Int32)(exponentBits.Size) - 1)));
                        -- 		if (flag3) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 		}
                        -- 	}
                        -- 	if (!signBit) {
                        -- 		result = bitMask;
                        -- 	}
                        -- 	else {
                        -- 		result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = BitMask.op_LeftShift (exponentBits, (int)exponentBits.Size + num2);
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.4\ := signed(SmartResize(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\.\Size\, 32)) + \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\;
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.4\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.4\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- BitMask objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d = new BitMask (exponentBits.Size, false);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\.\IsNull\ := false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\.\Size\ := to_unsigned(0, 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\.\SegmentCount\ := to_unsigned(0, 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\.\Size\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = BitMask.op_GreaterThanOrEqual (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d, (System.UInt16)((System.Int32)(exponentBits.Size) - 1)));
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.5\ := SmartResize(unsigned(signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\.\Size\), 32)) - to_signed(1, 32)), 16);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.5\);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.5\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.5\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.6\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag2\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.6\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag2) {
                            -- 	BitMask object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64;
                            -- 	object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64 = new BitMask (exponentBits.Size, false);
                            -- 	flag3 = BitMask.op_Equality (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64, (System.UInt16)((System.Int32)(exponentBits.Size) - 1)));
                            -- 	if (flag3) {
                            -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- 	}
                            -- 	else {
                            -- 		bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag2\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (!signBit) {
                        -- 	result = bitMask;
                        -- }
                        -- else {
                        -- 	result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\.
                        --     * The false branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_27\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_28\.
                        --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\.

                        if (not(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit\)) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\;
                        else 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1002
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	BitMask object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64;
                        -- 	object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64 = new BitMask (exponentBits.Size, false);
                        -- 	flag3 = BitMask.op_Equality (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64, (System.UInt16)((System.Int32)(exponentBits.Size) - 1)));
                        -- 	if (flag3) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64 = new BitMask (exponentBits.Size, false);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\.\IsNull\ := false;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\.\Size\ := to_unsigned(0, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\.\Size\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_15\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = BitMask.op_Equality (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64, (System.UInt16)((System.Int32)(exponentBits.Size) - 1)));
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.6\ := SmartResize(unsigned(signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\.\Size\), 32)) - to_signed(1, 32)), 16);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.6\);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_16\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.7\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.7\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_17\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.8\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag3\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag3) {
                            -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- }
                            -- else {
                            -- 	bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_19\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_21\.
                            --     * The false branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_22\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_24\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag3\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_19\;
                            else 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_22\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_17\.
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_12\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_19\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_20\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.9\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.7\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.9\ and to_unsigned(1, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.7\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1386
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_21\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.10\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.10\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_17\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_21\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_22\ => 
                        -- False branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_17\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_23\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_23\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_24\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_24\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.11\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.11\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_17\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_24\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\.
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_6\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = bitMask;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = bitMask;
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_27\ => 
                        -- False branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_28\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_28\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.12\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.12\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_28\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_29\ => 
                        -- False branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num3 = (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 	fractionBits = Lombiq.Arithmetics.BitMask.SetZero (fractionBits, (ushort)num3);
                        -- 	num4 = 30 - num3 - (int)num - 3;
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (fractionBits, num4));
                        -- 	flag4 = num4 < 0;
                        -- 	if (flag4) {
                        -- 		fractionBits = BitMask.op_LeftShift (fractionBits, (int)fractionBits.Size + num4);
                        -- 		BitMask object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0;
                        -- 		object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0 = new BitMask (fractionBits.Size, false);
                        -- 		flag5 = BitMask.op_GreaterThanOrEqual (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                        -- 		if (flag5) {
                        -- 			BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                        -- 			objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                        -- 			flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                        -- 			if (flag6) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 			}
                        -- 		}
                        -- 	}
                        -- 	if (!signBit) {
                        -- 		result = bitMask;
                        -- 	}
                        -- 	else {
                        -- 		result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_30\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_30\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.13\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.8\ := signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.13\), 32)) - to_signed(1, 32);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num3\ := (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.8\);
                            -- The following section was transformed from the .NET statement below:
                            -- fractionBits = Lombiq.Arithmetics.BitMask.SetZero (fractionBits, (ushort)num3);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).index.parameter.Out.0\ <= SmartResize(unsigned(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num3\), 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_31\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_31\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.14\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.14\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 30 - num3 - (int)num - 3;
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.9\ := to_signed(30, 32) - \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num3\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.10\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.9\ - signed(SmartResize(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num\, 32));
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.11\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.10\ - to_signed(3, 32);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.11\;
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (fractionBits, num4));
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_32\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_32\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.15\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.15\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_33\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.16\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.16\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag4 = num4 < 0;
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.12\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\ < to_signed(0, 32);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag4\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.12\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag4) {
                            -- 	fractionBits = BitMask.op_LeftShift (fractionBits, (int)fractionBits.Size + num4);
                            -- 	BitMask object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0;
                            -- 	object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0 = new BitMask (fractionBits.Size, false);
                            -- 	flag5 = BitMask.op_GreaterThanOrEqual (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                            -- 	if (flag5) {
                            -- 		BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                            -- 		objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                            -- 		flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                            -- 		if (flag6) {
                            -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- 		}
                            -- 		else {
                            -- 			bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- 		}
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_35\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_40\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag4\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_35\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (!signBit) {
                        -- 	result = bitMask;
                        -- }
                        -- else {
                        -- 	result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_53\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_53\.
                        --     * The false branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_54\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_55\.
                        --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_52\.

                        if (not(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit\)) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_53\;
                        else 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_54\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1002
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_35\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	fractionBits = BitMask.op_LeftShift (fractionBits, (int)fractionBits.Size + num4);
                        -- 	BitMask object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0;
                        -- 	object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0 = new BitMask (fractionBits.Size, false);
                        -- 	flag5 = BitMask.op_GreaterThanOrEqual (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                        -- 	if (flag5) {
                        -- 		BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                        -- 		objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                        -- 		flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                        -- 		if (flag6) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- fractionBits = BitMask.op_LeftShift (fractionBits, (int)fractionBits.Size + num4);
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.13\ := signed(SmartResize(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\.\Size\, 32)) + \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\;
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.13\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.17\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.17\;
                            -- The following section was transformed from the .NET statement below:
                            -- BitMask object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0 = new BitMask (fractionBits.Size, false);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\.\IsNull\ := false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\.\Size\ := to_unsigned(0, 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\.\SegmentCount\ := to_unsigned(0, 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\.\Size\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_37\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_37\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag5 = BitMask.op_GreaterThanOrEqual (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.14\ := SmartResize(unsigned(signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\.\Size\), 32)) - to_signed(1, 32)), 16);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.14\);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_38\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.18\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.18\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_39\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_39\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.19\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag5\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.19\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag5) {
                            -- 	BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                            -- 	objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                            -- 	flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                            -- 	if (flag6) {
                            -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- 	}
                            -- 	else {
                            -- 		bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_41\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_45\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_40\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag5\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_41\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_40\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_40\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_39\.
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_33\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_40\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_41\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_39\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                        -- 	objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                        -- 	flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                        -- 	if (flag6) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\.\IsNull\ := false;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\.\Size\ := to_unsigned(0, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\.\Size\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_42\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_42\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (System.UInt16)((System.Int32)(fractionBits.Size) - 1)));
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.15\ := SmartResize(unsigned(signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\.\Size\), 32)) - to_signed(1, 32)), 16);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.15\);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_43\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_43\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.20\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.20\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_44\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_44\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.21\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag6\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.21\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag6) {
                            -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- }
                            -- else {
                            -- 	bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_48\.
                            --     * The false branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_49\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_51\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_45\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag6\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\;
                            else 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_49\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_45\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_44\.
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_39\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_45\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_40\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_47\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_47\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.22\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.16\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.22\ and to_unsigned(1, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.16\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_48\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1386
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_48\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.23\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.23\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_44\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_48\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_45\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_49\ => 
                        -- False branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_50\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_50\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_51\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_51\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.24\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.24\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_44\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_51\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_45\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_52\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\.
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_6\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_52\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_53\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = bitMask;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = bitMask;
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_53\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_52\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_54\ => 
                        -- False branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_55\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_55\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.25\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.25\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_55\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_52\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0 state machine start
    \Posit::GetRegimeKValue().0._StateMachine\: process (\Clock\) 
        Variable \Posit::GetRegimeKValue().0._State\: \Posit::GetRegimeKValue().0._States\ := \Posit::GetRegimeKValue().0._State_0\;
        Variable \Posit::GetRegimeKValue().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::GetRegimeKValue().0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetRegimeKValue().0.return.0\: boolean := false;
        Variable \Posit::GetRegimeKValue().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetRegimeKValue().0.conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::GetRegimeKValue().0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetRegimeKValue().0.return.3\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetRegimeKValue().0.return.4\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetRegimeKValue().0.return.5\: boolean := false;
        Variable \Posit::GetRegimeKValue().0.return.6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::GetRegimeKValue().0.return.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::GetRegimeKValue().0.binaryOperationResult.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::GetRegimeKValue().0._Finished\ <= false;
                \Posit::GetRegimeKValue().0.return\ <= to_signed(0, 32);
                \Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_0\;
                \Posit::GetRegimeKValue().0.return.0\ := false;
                \Posit::GetRegimeKValue().0.conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860\ := to_unsigned(0, 16);
                \Posit::GetRegimeKValue().0.return.5\ := false;
                \Posit::GetRegimeKValue().0.return.6\ := to_unsigned(0, 16);
                \Posit::GetRegimeKValue().0.return.7\ := to_unsigned(0, 16);
                \Posit::GetRegimeKValue().0.binaryOperationResult.0\ := to_unsigned(0, 16);
            else 
                case \Posit::GetRegimeKValue().0._State\ is 
                    when \Posit::GetRegimeKValue().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::GetRegimeKValue().0._Started\ = true) then 
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::GetRegimeKValue().0._Started\ = true) then 
                            \Posit::GetRegimeKValue().0._Finished\ <= true;
                        else 
                            \Posit::GetRegimeKValue().0._Finished\ <= false;
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_2\ => 
                        \Posit::GetRegimeKValue().0.this\ := \Posit::GetRegimeKValue().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask left;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (@this)) {
                        -- 	left = @this.PositBits;
                        -- }
                        -- else {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::GetRegimeKValue().0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.this\;
                        \Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\ = \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.0\ := \Posit::GetRegimeKValue().0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::GetRegimeKValue().0._State_5\ and ends in state \Posit::GetRegimeKValue().0._State_5\.
                            --     * The false branch starts in state \Posit::GetRegimeKValue().0._State_6\ and ends in state \Posit::GetRegimeKValue().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit::GetRegimeKValue().0._State_4\.

                            if (\Posit::GetRegimeKValue().0.return.0\) then 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_5\;
                            else 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit::GetRegimeKValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (BitMask.op_Equality (BitMask.op_BitwiseAnd (left, Lombiq.Arithmetics.Posit.get_FirstRegimeBitBitMask (@this)), Lombiq.Arithmetics.Posit.get_EmptyBitMask (@this))) {
                        -- 	conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860 = -(int)Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31);
                        -- }
                        -- else {
                        -- 	conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860 = (System.UInt16)((System.Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31)) - 1);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask()
                        \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.this\;
                        \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\ <= true;
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit::GetRegimeKValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = @this.PositBits;
                        -- 
                        \Posit::GetRegimeKValue().0.left\ := \Posit::GetRegimeKValue().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit::GetRegimeKValue().0._State_3\.
                        if (\Posit::GetRegimeKValue().0._State\ = \Posit::GetRegimeKValue().0._State_5\) then 
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit::GetRegimeKValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.this\.\PositBits\;
                        \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.1\ := \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::GetRegimeKValue().0.left\ := \Posit::GetRegimeKValue().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit::GetRegimeKValue().0._State_3\.
                            if (\Posit::GetRegimeKValue().0._State\ = \Posit::GetRegimeKValue().0._State_7\) then 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask()
                        if (\Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\ = \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.2\ := \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.left\;
                            \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.return.2\;
                            \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ = \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.3\ := \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                            \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.this\;
                            \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\ <= true;
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        if (\Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\ = \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.4\ := \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.return.3\;
                            \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.return.4\;
                            \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.5\ := \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask).return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::GetRegimeKValue().0._State_13\ and ends in state \Posit::GetRegimeKValue().0._State_14\.
                            --     * The false branch starts in state \Posit::GetRegimeKValue().0._State_15\ and ends in state \Posit::GetRegimeKValue().0._State_17\.
                            --     * Execution after either branch will continue in the following state: \Posit::GetRegimeKValue().0._State_12\.

                            if (\Posit::GetRegimeKValue().0.return.5\) then 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_13\;
                            else 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_15\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_12\ => 
                        -- State after the if-else which was started in state \Posit::GetRegimeKValue().0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (int)(conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860);
                        -- 
                        \Posit::GetRegimeKValue().0.return\ <= signed(SmartResize((\Posit::GetRegimeKValue().0.conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860\), 32));
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_13\ => 
                        -- True branch of the if-else started in state \Posit::GetRegimeKValue().0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860 = -(int)Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860 = -(int)Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.left\;
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit::GetRegimeKValue().0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.6\ := \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::GetRegimeKValue().0.conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860\ := SmartResize(unsigned(0 - signed(SmartResize(\Posit::GetRegimeKValue().0.return.6\, 32))), 16);
                            -- Going to the state after the if-else which was started in state \Posit::GetRegimeKValue().0._State_11\.
                            if (\Posit::GetRegimeKValue().0._State\ = \Posit::GetRegimeKValue().0._State_14\) then 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_12\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_15\ => 
                        -- False branch of the if-else started in state \Posit::GetRegimeKValue().0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860 = (System.UInt16)((System.Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31)) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860 = (System.UInt16)((System.Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31)) - 1);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_16\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_16\ => 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.left\;
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_17\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_17\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.7\ := \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::GetRegimeKValue().0.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((\Posit::GetRegimeKValue().0.return.7\), 32)) - to_signed(1, 32)), 16);
                            \Posit::GetRegimeKValue().0.conditional5bf2759b035f02935fbccb990d3e40aa232b8c67c26fcc93005e0486efa10860\ := (\Posit::GetRegimeKValue().0.binaryOperationResult.0\);
                            -- Going to the state after the if-else which was started in state \Posit::GetRegimeKValue().0._State_11\.
                            if (\Posit::GetRegimeKValue().0._State\ = \Posit::GetRegimeKValue().0._State_17\) then 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_12\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0 state machine start
    \Posit::ExponentSize().0._StateMachine\: process (\Clock\) 
        Variable \Posit::ExponentSize().0._State\: \Posit::ExponentSize().0._States\ := \Posit::ExponentSize().0._State_0\;
        Variable \Posit::ExponentSize().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::ExponentSize().0.bitMask\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::ExponentSize().0.return.0\: boolean := false;
        Variable \Posit::ExponentSize().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::ExponentSize().0.conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::ExponentSize().0.return.2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::ExponentSize().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::ExponentSize().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::ExponentSize().0.binaryOperationResult.2\: boolean := false;
        Variable \Posit::ExponentSize().0.return.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::ExponentSize().0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::ExponentSize().0.binaryOperationResult.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::ExponentSize().0._Finished\ <= false;
                \Posit::ExponentSize().0.return\ <= to_unsigned(0, 32);
                \Posit::ExponentSize().0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_0\;
                \Posit::ExponentSize().0.return.0\ := false;
                \Posit::ExponentSize().0.conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884\ := to_unsigned(0, 16);
                \Posit::ExponentSize().0.return.2\ := to_unsigned(0, 16);
                \Posit::ExponentSize().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit::ExponentSize().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::ExponentSize().0.binaryOperationResult.2\ := false;
                \Posit::ExponentSize().0.return.3\ := to_unsigned(0, 16);
                \Posit::ExponentSize().0.binaryOperationResult.3\ := to_signed(0, 32);
                \Posit::ExponentSize().0.binaryOperationResult.4\ := to_unsigned(0, 16);
            else 
                case \Posit::ExponentSize().0._State\ is 
                    when \Posit::ExponentSize().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::ExponentSize().0._Started\ = true) then 
                            \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::ExponentSize().0._Started\ = true) then 
                            \Posit::ExponentSize().0._Finished\ <= true;
                        else 
                            \Posit::ExponentSize().0._Finished\ <= false;
                            \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_2\ => 
                        \Posit::ExponentSize().0.this\ := \Posit::ExponentSize().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask bitMask;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (@this)) {
                        -- 	bitMask = @this.PositBits;
                        -- }
                        -- else {
                        -- 	bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::ExponentSize().0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::ExponentSize().0.this\;
                        \Posit::ExponentSize().0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::ExponentSize().0.Posit::IsPositive()._Started.0\ = \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::ExponentSize().0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::ExponentSize().0.return.0\ := \Posit::ExponentSize().0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::ExponentSize().0._State_5\ and ends in state \Posit::ExponentSize().0._State_5\.
                            --     * The false branch starts in state \Posit::ExponentSize().0._State_6\ and ends in state \Posit::ExponentSize().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit::ExponentSize().0._State_4\.

                            if (\Posit::ExponentSize().0.return.0\) then 
                                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_5\;
                            else 
                                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit::ExponentSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((System.Int32)(32 - (System.Int32)((System.Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31)) + 2)) > 3) {
                        -- 	conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884 = 3;
                        -- }
                        -- else {
                        -- 	conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884 = (System.UInt16)(32 - (System.Int32)((System.Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31)) + 2));
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::ExponentSize().0.bitMask\;
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                        \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit::ExponentSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = @this.PositBits;
                        -- 
                        \Posit::ExponentSize().0.bitMask\ := \Posit::ExponentSize().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit::ExponentSize().0._State_3\.
                        if (\Posit::ExponentSize().0._State\ = \Posit::ExponentSize().0._State_5\) then 
                            \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit::ExponentSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::ExponentSize().0.this\.\PositBits\;
                        \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::ExponentSize().0.return.1\ := \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::ExponentSize().0.bitMask\ := \Posit::ExponentSize().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit::ExponentSize().0._State_3\.
                            if (\Posit::ExponentSize().0._State\ = \Posit::ExponentSize().0._State_7\) then 
                                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::ExponentSize().0.return.2\ := \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::ExponentSize().0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit::ExponentSize().0.return.2\), 32)) + to_signed(2, 32), 32);
                            \Posit::ExponentSize().0.binaryOperationResult.1\ := to_signed(32, 32) - (\Posit::ExponentSize().0.binaryOperationResult.0\);
                            \Posit::ExponentSize().0.binaryOperationResult.2\ := (\Posit::ExponentSize().0.binaryOperationResult.1\) > to_signed(3, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::ExponentSize().0._State_10\ and ends in state \Posit::ExponentSize().0._State_10\.
                            --     * The false branch starts in state \Posit::ExponentSize().0._State_11\ and ends in state \Posit::ExponentSize().0._State_12\.
                            --     * Execution after either branch will continue in the following state: \Posit::ExponentSize().0._State_9\.

                            if (\Posit::ExponentSize().0.binaryOperationResult.2\) then 
                                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_10\;
                            else 
                                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_11\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9067
                    when \Posit::ExponentSize().0._State_9\ => 
                        -- State after the if-else which was started in state \Posit::ExponentSize().0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884);
                        -- 
                        \Posit::ExponentSize().0.return\ <= SmartResize((\Posit::ExponentSize().0.conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884\), 32);
                        \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_10\ => 
                        -- True branch of the if-else started in state \Posit::ExponentSize().0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884 = 3;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884 = 3;
                        -- 
                        \Posit::ExponentSize().0.conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884\ := to_unsigned(3, 16);
                        -- Going to the state after the if-else which was started in state \Posit::ExponentSize().0._State_8\.
                        if (\Posit::ExponentSize().0._State\ = \Posit::ExponentSize().0._State_10\) then 
                            \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_11\ => 
                        -- False branch of the if-else started in state \Posit::ExponentSize().0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884 = (System.UInt16)(32 - (System.Int32)((System.Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31)) + 2));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884 = (System.UInt16)(32 - (System.Int32)((System.Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31)) + 2));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::ExponentSize().0.bitMask\;
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                        \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::ExponentSize().0.return.3\ := \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::ExponentSize().0.binaryOperationResult.3\ := SmartResize(signed(SmartResize((\Posit::ExponentSize().0.return.3\), 32)) + to_signed(2, 32), 32);
                            \Posit::ExponentSize().0.binaryOperationResult.4\ := SmartResize(unsigned(to_signed(32, 32) - (\Posit::ExponentSize().0.binaryOperationResult.3\)), 16);
                            \Posit::ExponentSize().0.conditional4e9f92f1e81881e7782b69606635464a1431494ac22e15fd1d7eaf52e409a884\ := (\Posit::ExponentSize().0.binaryOperationResult.4\);
                            -- Going to the state after the if-else which was started in state \Posit::ExponentSize().0._State_8\.
                            if (\Posit::ExponentSize().0._State\ = \Posit::ExponentSize().0._State_12\) then 
                                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_9\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0 state machine start
    \Posit::GetExponentValue().0._StateMachine\: process (\Clock\) 
        Variable \Posit::GetExponentValue().0._State\: \Posit::GetExponentValue().0._States\ := \Posit::GetExponentValue().0._State_0\;
        Variable \Posit::GetExponentValue().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::GetExponentValue().0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetExponentValue().0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::GetExponentValue().0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::GetExponentValue().0.return.0\: boolean := false;
        Variable \Posit::GetExponentValue().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetExponentValue().0.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::GetExponentValue().0.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::GetExponentValue().0.return.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::GetExponentValue().0.return.5\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetExponentValue().0.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::GetExponentValue().0.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::GetExponentValue().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::GetExponentValue().0.return.7\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetExponentValue().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::GetExponentValue().0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::GetExponentValue().0.return.8\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetExponentValue().0.return.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::GetExponentValue().0._Finished\ <= false;
                \Posit::GetExponentValue().0.return\ <= to_unsigned(0, 32);
                \Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ <= false;
                \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_0\;
                \Posit::GetExponentValue().0.num\ := to_signed(0, 32);
                \Posit::GetExponentValue().0.num2\ := to_unsigned(0, 32);
                \Posit::GetExponentValue().0.return.0\ := false;
                \Posit::GetExponentValue().0.return.2\ := to_unsigned(0, 32);
                \Posit::GetExponentValue().0.return.3\ := to_unsigned(0, 32);
                \Posit::GetExponentValue().0.return.4\ := to_unsigned(0, 32);
                \Posit::GetExponentValue().0.binaryOperationResult.0\ := to_signed(0, 64);
                \Posit::GetExponentValue().0.return.6\ := to_unsigned(0, 32);
                \Posit::GetExponentValue().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::GetExponentValue().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit::GetExponentValue().0.binaryOperationResult.3\ := to_signed(0, 32);
                \Posit::GetExponentValue().0.return.9\ := to_unsigned(0, 32);
            else 
                case \Posit::GetExponentValue().0._State\ is 
                    when \Posit::GetExponentValue().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::GetExponentValue().0._Started\ = true) then 
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::GetExponentValue().0._Started\ = true) then 
                            \Posit::GetExponentValue().0._Finished\ <= true;
                        else 
                            \Posit::GetExponentValue().0._Finished\ <= false;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_2\ => 
                        \Posit::GetExponentValue().0.this\ := \Posit::GetExponentValue().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask left;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (@this)) {
                        -- 	left = @this.PositBits;
                        -- }
                        -- else {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::GetExponentValue().0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\;
                        \Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\ = \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.0\ := \Posit::GetExponentValue().0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::GetExponentValue().0._State_5\ and ends in state \Posit::GetExponentValue().0._State_5\.
                            --     * The false branch starts in state \Posit::GetExponentValue().0._State_6\ and ends in state \Posit::GetExponentValue().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit::GetExponentValue().0._State_4\.

                            if (\Posit::GetExponentValue().0.return.0\) then 
                                \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_5\;
                            else 
                                \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit::GetExponentValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)Lombiq.Arithmetics.Posit.FractionSize (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::GetExponentValue().0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\;
                        \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit::GetExponentValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = @this.PositBits;
                        -- 
                        \Posit::GetExponentValue().0.left\ := \Posit::GetExponentValue().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit::GetExponentValue().0._State_3\.
                        if (\Posit::GetExponentValue().0._State\ = \Posit::GetExponentValue().0._State_5\) then 
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit::GetExponentValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\.\PositBits\;
                        \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.1\ := \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::GetExponentValue().0.left\ := \Posit::GetExponentValue().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit::GetExponentValue().0._State_3\.
                            if (\Posit::GetExponentValue().0._State\ = \Posit::GetExponentValue().0._State_7\) then 
                                \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ = \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.2\ := \Posit::GetExponentValue().0.Posit::FractionSize().return.0\;
                            \Posit::GetExponentValue().0.num\ := signed(\Posit::GetExponentValue().0.return.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = Lombiq.Arithmetics.Posit.ExponentSize (@this);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize()
                            \Posit::GetExponentValue().0.Posit::ExponentSize().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\;
                            \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize()
                        if (\Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ = \Posit::GetExponentValue().0.Posit::ExponentSize()._Finished.0\) then 
                            \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.3\ := \Posit::GetExponentValue().0.Posit::ExponentSize().return.0\;
                            \Posit::GetExponentValue().0.num2\ := \Posit::GetExponentValue().0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- return Lombiq.Arithmetics.BitMask.GetLowest32Bits (BitMask.op_RightShift (BitMask.op_LeftShift (BitMask.op_RightShift (left, (int)Lombiq.Arithmetics.Posit.FractionSize (@this)), (int)((long)((System.Int32)(@this.PositBits.SegmentCount) * 32) - (long)((ulong)Lombiq.Arithmetics.Posit.ExponentSize (@this)))), (int)((System.Int32)((System.Int32)(@this.PositBits.SegmentCount) * 32) - 3)));
                            -- 
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_10\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::GetExponentValue().0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\;
                        \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ = \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.4\ := \Posit::GetExponentValue().0.Posit::FractionSize().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::GetExponentValue().0.left\;
                            \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= signed(\Posit::GetExponentValue().0.return.4\);
                            \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.5\ := \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).return.0\;
                            \Posit::GetExponentValue().0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit::GetExponentValue().0.this\.\PositBits\.\SegmentCount\), 32)) * to_signed(32, 32), 64);
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize()
                            \Posit::GetExponentValue().0.Posit::ExponentSize().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\;
                            \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit::GetExponentValue().0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize()
                        if (\Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ = \Posit::GetExponentValue().0.Posit::ExponentSize()._Finished.0\) then 
                            \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.6\ := \Posit::GetExponentValue().0.Posit::ExponentSize().return.0\;
                            \Posit::GetExponentValue().0.binaryOperationResult.1\ := SmartResize((\Posit::GetExponentValue().0.binaryOperationResult.0\) - signed((SmartResize(\Posit::GetExponentValue().0.return.6\, 64))), 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::GetExponentValue().0.return.5\;
                            \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= (\Posit::GetExponentValue().0.binaryOperationResult.1\);
                            \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Posit::GetExponentValue().0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.7\ := \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::GetExponentValue().0.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\Posit::GetExponentValue().0.this\.\PositBits\.\SegmentCount\), 32)) * to_signed(32, 32), 32);
                            \Posit::GetExponentValue().0.binaryOperationResult.3\ := (\Posit::GetExponentValue().0.binaryOperationResult.2\) - to_signed(3, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::GetExponentValue().0.return.7\;
                            \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= (\Posit::GetExponentValue().0.binaryOperationResult.3\);
                            \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit::GetExponentValue().0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.8\ := \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                            \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.return.8\;
                            \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_16\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        if (\Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\ = \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\) then 
                            \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.9\ := \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().return.0\;
                            \Posit::GetExponentValue().0.return\ <= \Posit::GetExponentValue().0.return.9\;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0 state machine start
    \Posit::FractionSize().0._StateMachine\: process (\Clock\) 
        Variable \Posit::FractionSize().0._State\: \Posit::FractionSize().0._States\ := \Posit::FractionSize().0._State_0\;
        Variable \Posit::FractionSize().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::FractionSize().0.bitMask\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionSize().0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionSize().0.return.0\: boolean := false;
        Variable \Posit::FractionSize().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionSize().0.return.2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::FractionSize().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionSize().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionSize().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionSize().0.conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionSize().0.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::FractionSize().0._Finished\ <= false;
                \Posit::FractionSize().0.return\ <= to_unsigned(0, 32);
                \Posit::FractionSize().0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_0\;
                \Posit::FractionSize().0.num\ := to_signed(0, 32);
                \Posit::FractionSize().0.return.0\ := false;
                \Posit::FractionSize().0.return.2\ := to_unsigned(0, 16);
                \Posit::FractionSize().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit::FractionSize().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::FractionSize().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit::FractionSize().0.conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942\ := to_signed(0, 32);
                \Posit::FractionSize().0.binaryOperationResult.3\ := false;
            else 
                case \Posit::FractionSize().0._State\ is 
                    when \Posit::FractionSize().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::FractionSize().0._Started\ = true) then 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::FractionSize().0._Started\ = true) then 
                            \Posit::FractionSize().0._Finished\ <= true;
                        else 
                            \Posit::FractionSize().0._Finished\ <= false;
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_2\ => 
                        \Posit::FractionSize().0.this\ := \Posit::FractionSize().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask bitMask;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (@this)) {
                        -- 	bitMask = @this.PositBits;
                        -- }
                        -- else {
                        -- 	bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::FractionSize().0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::FractionSize().0.this\;
                        \Posit::FractionSize().0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::FractionSize().0.Posit::IsPositive()._Started.0\ = \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::FractionSize().0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::FractionSize().0.return.0\ := \Posit::FractionSize().0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::FractionSize().0._State_5\ and ends in state \Posit::FractionSize().0._State_5\.
                            --     * The false branch starts in state \Posit::FractionSize().0._State_6\ and ends in state \Posit::FractionSize().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit::FractionSize().0._State_4\.

                            if (\Posit::FractionSize().0.return.0\) then 
                                \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_5\;
                            else 
                                \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit::FractionSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32 - (System.Int32)((System.Int32)((System.Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31)) + 2) + 3));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::FractionSize().0.bitMask\;
                        \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                        \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                        \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit::FractionSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = @this.PositBits;
                        -- 
                        \Posit::FractionSize().0.bitMask\ := \Posit::FractionSize().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit::FractionSize().0._State_3\.
                        if (\Posit::FractionSize().0._State\ = \Posit::FractionSize().0._State_5\) then 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit::FractionSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::FractionSize().0.this\.\PositBits\;
                        \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::FractionSize().0.return.1\ := \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::FractionSize().0.bitMask\ := \Posit::FractionSize().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit::FractionSize().0._State_3\.
                            if (\Posit::FractionSize().0._State\ = \Posit::FractionSize().0._State_7\) then 
                                \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::FractionSize().0.return.2\ := \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::FractionSize().0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit::FractionSize().0.return.2\), 32)) + to_signed(2, 32), 32);
                            \Posit::FractionSize().0.binaryOperationResult.1\ := SmartResize((\Posit::FractionSize().0.binaryOperationResult.0\) + to_signed(3, 32), 32);
                            \Posit::FractionSize().0.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit::FractionSize().0.binaryOperationResult.1\);
                            \Posit::FractionSize().0.num\ := (\Posit::FractionSize().0.binaryOperationResult.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- int conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num > 0) {
                            -- 	conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942 = num;
                            -- }
                            -- else {
                            -- 	conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942 = 0;
                            -- }
                            -- 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit::FractionSize().0._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::FractionSize().0.binaryOperationResult.3\ := \Posit::FractionSize().0.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::FractionSize().0._State_11\ and ends in state \Posit::FractionSize().0._State_11\.
                        --     * The false branch starts in state \Posit::FractionSize().0._State_12\ and ends in state \Posit::FractionSize().0._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit::FractionSize().0._State_10\.

                        if (\Posit::FractionSize().0.binaryOperationResult.3\) then 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_11\;
                        else 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit::FractionSize().0._State_10\ => 
                        -- State after the if-else which was started in state \Posit::FractionSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942);
                        -- 
                        \Posit::FractionSize().0.return\ <= unsigned((\Posit::FractionSize().0.conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942\));
                        \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_11\ => 
                        -- True branch of the if-else started in state \Posit::FractionSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942 = num;
                        -- 
                        \Posit::FractionSize().0.conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942\ := \Posit::FractionSize().0.num\;
                        -- Going to the state after the if-else which was started in state \Posit::FractionSize().0._State_9\.
                        if (\Posit::FractionSize().0._State\ = \Posit::FractionSize().0._State_11\) then 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_12\ => 
                        -- False branch of the if-else started in state \Posit::FractionSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942 = 0;
                        -- 
                        \Posit::FractionSize().0.conditionala165a0cf890f65fc4e299b281a11c76e934fdfe8a86fb89096497ecd6259a942\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit::FractionSize().0._State_9\.
                        if (\Posit::FractionSize().0._State\ = \Posit::FractionSize().0._State_12\) then 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0 state machine start
    \Posit::FractionWithHiddenBit().0._StateMachine\: process (\Clock\) 
        Variable \Posit::FractionWithHiddenBit().0._State\: \Posit::FractionWithHiddenBit().0._States\ := \Posit::FractionWithHiddenBit().0._State_0\;
        Variable \Posit::FractionWithHiddenBit().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::FractionWithHiddenBit().0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionWithHiddenBit().0.return.0\: boolean := false;
        Variable \Posit::FractionWithHiddenBit().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionWithHiddenBit().0.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::FractionWithHiddenBit().0.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::FractionWithHiddenBit().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionWithHiddenBit().0.return.3\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionWithHiddenBit().0.binaryOperationResult.2\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::FractionWithHiddenBit().0.return.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::FractionWithHiddenBit().0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionWithHiddenBit().0.return.5\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionWithHiddenBit().0.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::FractionWithHiddenBit().0.return.7\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::FractionWithHiddenBit().0._Finished\ <= false;
                \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_0\;
                \Posit::FractionWithHiddenBit().0.return.0\ := false;
                \Posit::FractionWithHiddenBit().0.binaryOperationResult.0\ := to_signed(0, 64);
                \Posit::FractionWithHiddenBit().0.return.2\ := to_unsigned(0, 32);
                \Posit::FractionWithHiddenBit().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::FractionWithHiddenBit().0.binaryOperationResult.2\ := to_signed(0, 64);
                \Posit::FractionWithHiddenBit().0.return.4\ := to_unsigned(0, 32);
                \Posit::FractionWithHiddenBit().0.binaryOperationResult.3\ := to_signed(0, 32);
                \Posit::FractionWithHiddenBit().0.return.6\ := to_unsigned(0, 32);
            else 
                case \Posit::FractionWithHiddenBit().0._State\ is 
                    when \Posit::FractionWithHiddenBit().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::FractionWithHiddenBit().0._Started\ = true) then 
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::FractionWithHiddenBit().0._Started\ = true) then 
                            \Posit::FractionWithHiddenBit().0._Finished\ <= true;
                        else 
                            \Posit::FractionWithHiddenBit().0._Finished\ <= false;
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_2\ => 
                        \Posit::FractionWithHiddenBit().0.this\ := \Posit::FractionWithHiddenBit().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask left;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (@this)) {
                        -- 	left = @this.PositBits;
                        -- }
                        -- else {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::FractionWithHiddenBit().0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.this\;
                        \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\ = \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.0\ := \Posit::FractionWithHiddenBit().0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::FractionWithHiddenBit().0._State_5\ and ends in state \Posit::FractionWithHiddenBit().0._State_5\.
                            --     * The false branch starts in state \Posit::FractionWithHiddenBit().0._State_6\ and ends in state \Posit::FractionWithHiddenBit().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit::FractionWithHiddenBit().0._State_4\.

                            if (\Posit::FractionWithHiddenBit().0.return.0\) then 
                                \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_5\;
                            else 
                                \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit::FractionWithHiddenBit().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return Lombiq.Arithmetics.BitMask.SetOne (BitMask.op_RightShift (BitMask.op_LeftShift (left, (int)((long)((System.Int32)(@this.PositBits.SegmentCount) * 32) - (long)((ulong)Lombiq.Arithmetics.Posit.FractionSize (@this)))), (int)((long)((System.Int32)(@this.PositBits.SegmentCount) * 32) - (long)((ulong)Lombiq.Arithmetics.Posit.FractionSize (@this)))), (ushort)Lombiq.Arithmetics.Posit.FractionSize (@this));
                        -- 
                        \Posit::FractionWithHiddenBit().0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit::FractionWithHiddenBit().0.this\.\PositBits\.\SegmentCount\), 32)) * to_signed(32, 32), 64);
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.this\;
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit::FractionWithHiddenBit().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit::FractionWithHiddenBit().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = @this.PositBits;
                        -- 
                        \Posit::FractionWithHiddenBit().0.left\ := \Posit::FractionWithHiddenBit().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit::FractionWithHiddenBit().0._State_3\.
                        if (\Posit::FractionWithHiddenBit().0._State\ = \Posit::FractionWithHiddenBit().0._State_5\) then 
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit::FractionWithHiddenBit().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.this\.\PositBits\;
                        \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.1\ := \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::FractionWithHiddenBit().0.left\ := \Posit::FractionWithHiddenBit().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit::FractionWithHiddenBit().0._State_3\.
                            if (\Posit::FractionWithHiddenBit().0._State\ = \Posit::FractionWithHiddenBit().0._State_7\) then 
                                \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ = \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.2\ := \Posit::FractionWithHiddenBit().0.Posit::FractionSize().return.0\;
                            \Posit::FractionWithHiddenBit().0.binaryOperationResult.1\ := SmartResize((\Posit::FractionWithHiddenBit().0.binaryOperationResult.0\) - signed((SmartResize(\Posit::FractionWithHiddenBit().0.return.2\, 64))), 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.left\;
                            \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= (\Posit::FractionWithHiddenBit().0.binaryOperationResult.1\);
                            \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Posit::FractionWithHiddenBit().0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.3\ := \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::FractionWithHiddenBit().0.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\Posit::FractionWithHiddenBit().0.this\.\PositBits\.\SegmentCount\), 32)) * to_signed(32, 32), 64);
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit::FractionWithHiddenBit().0._State_10\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.this\;
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ = \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.4\ := \Posit::FractionWithHiddenBit().0.Posit::FractionSize().return.0\;
                            \Posit::FractionWithHiddenBit().0.binaryOperationResult.3\ := SmartResize((\Posit::FractionWithHiddenBit().0.binaryOperationResult.2\) - signed((SmartResize(\Posit::FractionWithHiddenBit().0.return.4\, 64))), 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.return.3\;
                            \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= (\Posit::FractionWithHiddenBit().0.binaryOperationResult.3\);
                            \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Posit::FractionWithHiddenBit().0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.5\ := \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32).return.0\;
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_13\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.this\;
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ = \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.6\ := \Posit::FractionWithHiddenBit().0.Posit::FractionSize().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.return.5\;
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= SmartResize(\Posit::FractionWithHiddenBit().0.return.6\, 16);
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\ = \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.7\ := \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).return.0\;
                            \Posit::FractionWithHiddenBit().0.return\ <= \Posit::FractionWithHiddenBit().0.return.7\;
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0 state machine end


    -- System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte).0 state machine start
    \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._StateMachine\: process (\Clock\) 
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\: \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._States\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_0\;
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Finished\ <= false;
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.return\ <= to_signed(0, 32);
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_0\;
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue\ := to_signed(0, 32);
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue\ := to_unsigned(0, 32);
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize\ := to_unsigned(0, 8);
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.0\ := to_signed(0, 64);
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\ is 
                    when \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Started\ = true) then 
                            \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Started\ = true) then 
                            \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Finished\ <= true;
                        else 
                            \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Finished\ <= false;
                            \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_2\ => 
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue.parameter.In\;
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue.parameter.In\;
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return (int)((long)(regimeKValue * 8) + (long)((ulong)exponentValue));
                        -- 
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.0\ := SmartResize(\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue\ * to_signed(8, 32), 64);
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.1\ := SmartResize((\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.0\) + signed((SmartResize(\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue\, 64))), 32);
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.return\ <= (\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.1\);
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.4898
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte).0 state machine end


    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 state machine start
    \Posit::op_Addition(Posit,Posit).0._StateMachine\: process (\Clock\) 
        Variable \Posit::op_Addition(Posit,Posit).0._State\: \Posit::op_Addition(Posit,Posit).0._States\ := \Posit::op_Addition(Posit,Posit).0._State_0\;
        Variable \Posit::op_Addition(Posit,Posit).0.left\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::op_Addition(Posit,Posit).0.right\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::op_Addition(Posit,Posit).0.flag\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.flag2\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.signBit\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.flag3\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.flag4\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.posit\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::op_Addition(Posit,Posit).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.exponentValue\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.flag5\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.posit2\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::op_Addition(Posit,Posit).0.regimeKValue2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.exponentValue2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.flag6\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.result\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::op_Addition(Posit,Posit).0.flag7\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.bitMask\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.flag8\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.flag9\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.flag10\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.flag11\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.flag12\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.num5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.num6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.flag13\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.flag14\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.regimeKValue3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.exponentBits\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.0\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.return.1\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.1\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.return.4\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.9\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.2\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.3\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.return.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.5\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.return.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.6\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.return.18\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.19\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.20\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.21\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.22\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.23\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.24\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.return.25\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.26\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.27\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.28\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.29\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.30\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.31\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.32\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.33\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::op_Addition(Posit,Posit).0.return.34\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.35\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.9\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.return.36\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.37\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.38\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.39\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.40\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.41\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.42\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.43\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.44\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.45\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.46\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.47\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.48\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.49\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.50\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.51\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.52\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.53\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.54\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.55\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.19\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.56\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.57\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.20\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.21\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.58\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.59\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.60\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.22\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.23\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.61\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.62\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.return.63\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.24\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.25\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.64\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.26\: boolean := false;
        Variable \Posit::op_Addition(Posit,Posit).0.return.65\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.27\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.29\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.30\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Addition(Posit,Posit).0.return.66\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::op_Addition(Posit,Posit).0._Finished\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_0\;
                \Posit::op_Addition(Posit,Posit).0.flag\ := false;
                \Posit::op_Addition(Posit,Posit).0.flag2\ := false;
                \Posit::op_Addition(Posit,Posit).0.signBit\ := false;
                \Posit::op_Addition(Posit,Posit).0.flag3\ := false;
                \Posit::op_Addition(Posit,Posit).0.flag4\ := false;
                \Posit::op_Addition(Posit,Posit).0.regimeKValue\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.exponentValue\ := to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.flag5\ := false;
                \Posit::op_Addition(Posit,Posit).0.regimeKValue2\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.exponentValue2\ := to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.flag6\ := false;
                \Posit::op_Addition(Posit,Posit).0.flag7\ := false;
                \Posit::op_Addition(Posit,Posit).0.num\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.num2\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.flag8\ := false;
                \Posit::op_Addition(Posit,Posit).0.flag9\ := false;
                \Posit::op_Addition(Posit,Posit).0.flag10\ := false;
                \Posit::op_Addition(Posit,Posit).0.flag11\ := false;
                \Posit::op_Addition(Posit,Posit).0.num3\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.num4\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.flag12\ := false;
                \Posit::op_Addition(Posit,Posit).0.num5\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.num6\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.flag13\ := false;
                \Posit::op_Addition(Posit,Posit).0.flag14\ := false;
                \Posit::op_Addition(Posit,Posit).0.regimeKValue3\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.0\ := false;
                \Posit::op_Addition(Posit,Posit).0.return.1\ := false;
                \Posit::op_Addition(Posit,Posit).0.return.3\ := to_unsigned(0, 16);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.0\ := false;
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.1\ := false;
                \Posit::op_Addition(Posit,Posit).0.return.5\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.6\ := to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.7\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.8\ := to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.10\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.11\ := to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.12\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.13\ := to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.2\ := false;
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.3\ := false;
                \Posit::op_Addition(Posit,Posit).0.return.14\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.15\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.4\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.5\ := false;
                \Posit::op_Addition(Posit,Posit).0.return.16\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.17\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.6\ := false;
                \Posit::op_Addition(Posit,Posit).0.return.24\ := false;
                \Posit::op_Addition(Posit,Posit).0.return.33\ := to_unsigned(0, 16);
                \Posit::op_Addition(Posit,Posit).0.return.35\ := to_unsigned(0, 16);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.8\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.9\ := false;
                \Posit::op_Addition(Posit,Posit).0.return.36\ := to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.37\ := to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.10\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.41\ := to_unsigned(0, 16);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.11\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.12\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.13\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.14\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.15\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.49\ := to_unsigned(0, 16);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.16\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.17\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.50\ := to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.51\ := to_unsigned(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.18\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.55\ := to_unsigned(0, 16);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.19\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.20\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.21\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.22\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.23\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.63\ := to_unsigned(0, 16);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.24\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.25\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.return.64\ := to_unsigned(0, 16);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.26\ := false;
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.27\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.28\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.29\ := to_signed(0, 32);
                \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.30\ := to_unsigned(0, 32);
            else 
                case \Posit::op_Addition(Posit,Posit).0._State\ is 
                    when \Posit::op_Addition(Posit,Posit).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::op_Addition(Posit,Posit).0._Started\ = true) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::op_Addition(Posit,Posit).0._Started\ = true) then 
                            \Posit::op_Addition(Posit,Posit).0._Finished\ <= true;
                        else 
                            \Posit::op_Addition(Posit,Posit).0._Finished\ <= false;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_2\ => 
                        \Posit::op_Addition(Posit,Posit).0.left\ := \Posit::op_Addition(Posit,Posit).0.left.parameter.In\;
                        \Posit::op_Addition(Posit,Posit).0.right\ := \Posit::op_Addition(Posit,Posit).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool signBit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit posit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int regimeKValue;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentValue;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit posit2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int regimeKValue2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentValue2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask bitMask;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag9;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag10;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag11;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag12;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag13;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag14;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int regimeKValue3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask exponentBits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = Lombiq.Arithmetics.Posit.IsPositive (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.0\ := \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.flag\ := \Posit::op_Addition(Posit,Posit).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = Lombiq.Arithmetics.Posit.IsPositive (right);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.1\ := \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.flag2\ := \Posit::op_Addition(Posit,Posit).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- if ((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (BitMask.op_Addition (left.PositBits, right.PositBits))) < (System.Int32)(left.PositBits.Size)) {
                            -- 	signBit = !flag;
                            -- }
                            -- else {
                            -- 	signBit = !flag2;
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\.\PositBits\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\.\PositBits\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.2\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.2\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.3\ := \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.0\ := signed(SmartResize((\Posit::op_Addition(Posit,Posit).0.return.3\), 32)) < signed(SmartResize((\Posit::op_Addition(Posit,Posit).0.left\.\PositBits\.\Size\), 32));

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_10\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_10\.
                            --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_11\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_11\.
                            --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_9\.

                            if (\Posit::op_Addition(Posit,Posit).0.binaryOperationResult.0\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_10\;
                            else 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_11\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit::op_Addition(Posit,Posit).0._State_9\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = flag == flag2;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.1\ := \Posit::op_Addition(Posit,Posit).0.flag\ = \Posit::op_Addition(Posit,Posit).0.flag2\;
                        \Posit::op_Addition(Posit,Posit).0.flag3\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = !flag;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.flag4\ := not(\Posit::op_Addition(Posit,Posit).0.flag\);
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	posit = Posit.op_UnaryNegation (left);
                        -- 	regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit);
                        -- 	exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (posit);
                        -- }
                        -- else {
                        -- 	regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (left);
                        -- 	exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (left);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_13\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_16\.
                        --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_17\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_19\.
                        --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_12\.

                        if (\Posit::op_Addition(Posit,Posit).0.flag4\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_13\;
                        else 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.224
                    when \Posit::op_Addition(Posit,Posit).0._State_10\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	signBit = !flag;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = !flag;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.signBit\ := not(\Posit::op_Addition(Posit,Posit).0.flag\);
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_8\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_10\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1002
                    when \Posit::op_Addition(Posit,Posit).0._State_11\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	signBit = !flag2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = !flag2;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.signBit\ := not(\Posit::op_Addition(Posit,Posit).0.flag2\);
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_8\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_11\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1002
                    when \Posit::op_Addition(Posit,Posit).0._State_12\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag5 = !flag2;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.flag5\ := not(\Posit::op_Addition(Posit,Posit).0.flag2\);
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag5) {
                        -- 	posit2 = Posit.op_UnaryNegation (right);
                        -- 	regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit2);
                        -- 	exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (posit2);
                        -- }
                        -- else {
                        -- 	regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (right);
                        -- 	exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (right);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_21\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_24\.
                        --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_25\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_27\.
                        --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_20\.

                        if (\Posit::op_Addition(Posit,Posit).0.flag5\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_21\;
                        else 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1002
                    when \Posit::op_Addition(Posit,Posit).0._State_13\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	posit = Posit.op_UnaryNegation (left);
                        -- 	regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit);
                        -- 	exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (posit);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- posit = Posit.op_UnaryNegation (left);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit)
                        \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit).x.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit)
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.4\ := \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.posit\ := \Posit::op_Addition(Posit,Posit).0.return.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit);
                            -- 
                            -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.posit\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.5\ := \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.regimeKValue\ := \Posit::op_Addition(Posit,Posit).0.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (posit);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.posit\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_16\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.6\ := \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.exponentValue\ := \Posit::op_Addition(Posit,Posit).0.return.6\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_9\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_16\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_12\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_17\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (left);
                        -- 	exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (left);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_18\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_18\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.7\ := \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.regimeKValue\ := \Posit::op_Addition(Posit,Posit).0.return.7\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (left);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_19\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.8\ := \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.exponentValue\ := \Posit::op_Addition(Posit,Posit).0.return.8\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_9\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_19\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_12\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_20\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag6 = regimeKValue == -31;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.2\ := \Posit::op_Addition(Posit,Posit).0.regimeKValue\ = to_signed(-31, 32);
                        \Posit::op_Addition(Posit,Posit).0.flag6\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag6) {
                        -- 	if (flag) {
                        -- 		result = right;
                        -- 	}
                        -- 	else {
                        -- 		result = left;
                        -- 	}
                        -- }
                        -- else {
                        -- 	flag7 = regimeKValue2 == -31;
                        -- 	if (flag7) {
                        -- 		if (flag2) {
                        -- 			result = left;
                        -- 		}
                        -- 		else {
                        -- 			result = right;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		bitMask = new BitMask (32, false);
                        -- 		num = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3) - Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 		if (num >= 0) {
                        -- 			num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- 		}
                        -- 		else {
                        -- 			num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 		}
                        -- 		flag8 = num == 0;
                        -- 		if (flag8) {
                        -- 			flag9 = flag3;
                        -- 			if (flag9) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 			}
                        -- 			else {
                        -- 				flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 				if (flag10) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 				}
                        -- 			}
                        -- 			num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 		}
                        -- 		else {
                        -- 			flag11 = num > 0;
                        -- 			if (flag11) {
                        -- 				num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 				num4 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 				bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 				flag12 = flag3;
                        -- 				if (flag12) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 				}
                        -- 				num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 			}
                        -- 			else {
                        -- 				num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 				num6 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 				bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 				flag13 = flag3;
                        -- 				if (flag13) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 				}
                        -- 				num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 			}
                        -- 		}
                        -- 		flag14 = (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) == 0;
                        -- 		if (flag14) {
                        -- 			result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- 		}
                        -- 		else {
                        -- 			regimeKValue3 = num2 / 8;
                        -- 			exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 			result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                        -- 		}
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_29\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_30\.
                        --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_33\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_34\.
                        --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_28\.

                        if (\Posit::op_Addition(Posit,Posit).0.flag6\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_29\;
                        else 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit::op_Addition(Posit,Posit).0._State_21\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	posit2 = Posit.op_UnaryNegation (right);
                        -- 	regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit2);
                        -- 	exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (posit2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- posit2 = Posit.op_UnaryNegation (right);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit)
                        \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit).x.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_22\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_22\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit)
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.9\ := \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.posit2\ := \Posit::op_Addition(Posit,Posit).0.return.9\;
                            -- The following section was transformed from the .NET statement below:
                            -- regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit2);
                            -- 
                            -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.posit2\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_23\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.10\ := \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.regimeKValue2\ := \Posit::op_Addition(Posit,Posit).0.return.10\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (posit2);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.posit2\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_24\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.11\ := \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.exponentValue2\ := \Posit::op_Addition(Posit,Posit).0.return.11\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_12\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_24\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_20\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_25\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (right);
                        -- 	exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (right);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_26\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.12\ := \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.regimeKValue2\ := \Posit::op_Addition(Posit,Posit).0.return.12\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (right);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_27\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.13\ := \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.exponentValue2\ := \Posit::op_Addition(Posit,Posit).0.return.13\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_12\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_27\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_20\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_28\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.return\ <= \Posit::op_Addition(Posit,Posit).0.result\;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_29\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (flag) {
                        -- 		result = right;
                        -- 	}
                        -- 	else {
                        -- 		result = left;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = right;
                        -- }
                        -- else {
                        -- 	result = left;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_31\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_31\.
                        --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_32\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_32\.
                        --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_30\.

                        if (\Posit::op_Addition(Posit,Posit).0.flag\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_31\;
                        else 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_32\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_30\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_29\.
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_20\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_30\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_31\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = right;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = right;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.result\ := \Posit::op_Addition(Posit,Posit).0.right\;
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_29\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_31\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_32\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.result\ := \Posit::op_Addition(Posit,Posit).0.left\;
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_29\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_32\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_33\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag7 = regimeKValue2 == -31;
                        -- 	if (flag7) {
                        -- 		if (flag2) {
                        -- 			result = left;
                        -- 		}
                        -- 		else {
                        -- 			result = right;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		bitMask = new BitMask (32, false);
                        -- 		num = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3) - Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 		if (num >= 0) {
                        -- 			num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- 		}
                        -- 		else {
                        -- 			num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 		}
                        -- 		flag8 = num == 0;
                        -- 		if (flag8) {
                        -- 			flag9 = flag3;
                        -- 			if (flag9) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 			}
                        -- 			else {
                        -- 				flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 				if (flag10) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 				}
                        -- 			}
                        -- 			num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 		}
                        -- 		else {
                        -- 			flag11 = num > 0;
                        -- 			if (flag11) {
                        -- 				num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 				num4 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 				bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 				flag12 = flag3;
                        -- 				if (flag12) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 				}
                        -- 				num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 			}
                        -- 			else {
                        -- 				num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 				num6 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 				bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 				flag13 = flag3;
                        -- 				if (flag13) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 				}
                        -- 				num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 			}
                        -- 		}
                        -- 		flag14 = (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) == 0;
                        -- 		if (flag14) {
                        -- 			result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- 		}
                        -- 		else {
                        -- 			regimeKValue3 = num2 / 8;
                        -- 			exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 			result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag7 = regimeKValue2 == -31;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.3\ := \Posit::op_Addition(Posit,Posit).0.regimeKValue2\ = to_signed(-31, 32);
                        \Posit::op_Addition(Posit,Posit).0.flag7\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag7) {
                        -- 	if (flag2) {
                        -- 		result = left;
                        -- 	}
                        -- 	else {
                        -- 		result = right;
                        -- 	}
                        -- }
                        -- else {
                        -- 	bitMask = new BitMask (32, false);
                        -- 	num = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3) - Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 	if (num >= 0) {
                        -- 		num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- 	}
                        -- 	else {
                        -- 		num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 	}
                        -- 	flag8 = num == 0;
                        -- 	if (flag8) {
                        -- 		flag9 = flag3;
                        -- 		if (flag9) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 		}
                        -- 		else {
                        -- 			flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 			if (flag10) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 			}
                        -- 		}
                        -- 		num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 	}
                        -- 	else {
                        -- 		flag11 = num > 0;
                        -- 		if (flag11) {
                        -- 			num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 			num4 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 			bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 			flag12 = flag3;
                        -- 			if (flag12) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 			}
                        -- 			num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 		}
                        -- 		else {
                        -- 			num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 			num6 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 			bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 			flag13 = flag3;
                        -- 			if (flag13) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 			}
                        -- 			num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 		}
                        -- 	}
                        -- 	flag14 = (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) == 0;
                        -- 	if (flag14) {
                        -- 		result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- 	}
                        -- 	else {
                        -- 		regimeKValue3 = num2 / 8;
                        -- 		exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 		result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_35\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_36\.
                        --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_39\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_133\.
                        --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_34\.

                        if (\Posit::op_Addition(Posit,Posit).0.flag7\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_35\;
                        else 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_39\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit::op_Addition(Posit,Posit).0._State_34\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_33\.
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_20\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_34\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_35\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (flag2) {
                        -- 		result = left;
                        -- 	}
                        -- 	else {
                        -- 		result = right;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	result = left;
                        -- }
                        -- else {
                        -- 	result = right;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_37\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_37\.
                        --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_38\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_38\.
                        --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_36\.

                        if (\Posit::op_Addition(Posit,Posit).0.flag2\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_37\;
                        else 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_36\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_35\.
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_33\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_36\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_34\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_37\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_35\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.result\ := \Posit::op_Addition(Posit,Posit).0.left\;
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_35\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_37\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_38\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_35\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = right;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = right;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.result\ := \Posit::op_Addition(Posit,Posit).0.right\;
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_35\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_38\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_39\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = new BitMask (32, false);
                        -- 	num = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3) - Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 	if (num >= 0) {
                        -- 		num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- 	}
                        -- 	else {
                        -- 		num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 	}
                        -- 	flag8 = num == 0;
                        -- 	if (flag8) {
                        -- 		flag9 = flag3;
                        -- 		if (flag9) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 		}
                        -- 		else {
                        -- 			flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 			if (flag10) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 			}
                        -- 		}
                        -- 		num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 	}
                        -- 	else {
                        -- 		flag11 = num > 0;
                        -- 		if (flag11) {
                        -- 			num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 			num4 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 			bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 			flag12 = flag3;
                        -- 			if (flag12) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 			}
                        -- 			num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 		}
                        -- 		else {
                        -- 			num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 			num6 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 			bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 			flag13 = flag3;
                        -- 			if (flag13) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 			}
                        -- 			num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 		}
                        -- 	}
                        -- 	flag14 = (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) == 0;
                        -- 	if (flag14) {
                        -- 		result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- 	}
                        -- 	else {
                        -- 		regimeKValue3 = num2 / 8;
                        -- 		exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 		result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = new BitMask (32, false);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::op_Addition(Posit,Posit).0.bitMask\.\IsNull\ := false;
                        \Posit::op_Addition(Posit,Posit).0.bitMask\.\Size\ := to_unsigned(0, 16);
                        \Posit::op_Addition(Posit,Posit).0.bitMask\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::op_Addition(Posit,Posit).0.bitMask\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_40\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_40\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3) - Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                            -- 
                            -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                            \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.regimeKValue\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.exponentValue\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(3, 8);
                            \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_41\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_41\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.14\ := \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_42\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_43\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_43\ => 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.regimeKValue2\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.exponentValue2\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(3, 8);
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_44\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_44\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.15\ := \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.4\ := \Posit::op_Addition(Posit,Posit).0.return.14\ - \Posit::op_Addition(Posit,Posit).0.return.15\;
                            \Posit::op_Addition(Posit,Posit).0.num\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (num >= 0) {
                            -- 	num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                            -- }
                            -- else {
                            -- 	num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                            -- }
                            -- 
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.5\ := \Posit::op_Addition(Posit,Posit).0.num\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_46\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_47\.
                            --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_48\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_50\.
                            --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_45\.

                            if (\Posit::op_Addition(Posit,Posit).0.binaryOperationResult.5\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_46\;
                            else 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_48\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5911
                    when \Posit::op_Addition(Posit,Posit).0._State_45\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag8 = num == 0;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.6\ := \Posit::op_Addition(Posit,Posit).0.num\ = to_signed(0, 32);
                        \Posit::op_Addition(Posit,Posit).0.flag8\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag8) {
                        -- 	flag9 = flag3;
                        -- 	if (flag9) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 	}
                        -- 	else {
                        -- 		flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 		if (flag10) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 		}
                        -- 	}
                        -- 	num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- }
                        -- else {
                        -- 	flag11 = num > 0;
                        -- 	if (flag11) {
                        -- 		num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 		num4 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 		bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 		flag12 = flag3;
                        -- 		if (flag12) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 		}
                        -- 		num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 	}
                        -- 	else {
                        -- 		num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 		num6 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 		bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 		flag13 = flag3;
                        -- 		if (flag13) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 		}
                        -- 		num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_52\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_87\.
                        --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_88\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_89\.
                        --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_51\.

                        if (\Posit::op_Addition(Posit,Posit).0.flag8\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_52\;
                        else 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_88\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit::op_Addition(Posit,Posit).0._State_46\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.regimeKValue\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.exponentValue\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(3, 8);
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_47\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_47\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.16\ := \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.num2\ := \Posit::op_Addition(Posit,Posit).0.return.16\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_44\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_47\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_45\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_48\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_49\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_49\ => 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.regimeKValue2\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.exponentValue2\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(3, 8);
                        \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_50\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_50\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.17\ := \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.num2\ := \Posit::op_Addition(Posit,Posit).0.return.17\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_44\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_50\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_45\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_51\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_45\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag14 = (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) == 0;
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_132\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_52\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_45\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag9 = flag3;
                        -- 	if (flag9) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 	}
                        -- 	else {
                        -- 		flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 		if (flag10) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 		}
                        -- 	}
                        -- 	num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag9 = flag3;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.flag9\ := \Posit::op_Addition(Posit,Posit).0.flag3\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag9) {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- }
                        -- else {
                        -- 	flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 	if (flag10) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_54\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_62\.
                        --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_63\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_69\.
                        --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_53\.

                        if (\Posit::op_Addition(Posit,Posit).0.flag9\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_54\;
                        else 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_63\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_53\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_84\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_54\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_55\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_55\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.18\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_56\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_56\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_57\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_57\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_58\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_58\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.19\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.18\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.19\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_59\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_59\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.20\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_60\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_60\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_61\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_61\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.20\;
                        \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_62\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_62\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.21\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.return.21\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_52\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_62\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_53\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_63\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 	if (flag10) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_64\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_64\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.22\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_65\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_65\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_66\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_66\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_67\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_67\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.23\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.22\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.23\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_68\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_68\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.24\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.flag10\ := \Posit::op_Addition(Posit,Posit).0.return.24\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag10) {
                            -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                            -- }
                            -- else {
                            -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_70\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_76\.
                            --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_77\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_83\.
                            --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_69\.

                            if (\Posit::op_Addition(Posit,Posit).0.flag10\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_70\;
                            else 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_77\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_69\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_68\.
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_52\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_69\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_53\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_70\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_68\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_71\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_71\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.25\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_72\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_72\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_73\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_73\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_74\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_74\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.26\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.25\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.26\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_75\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_75\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.27\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.27\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_76\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_76\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.28\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.return.28\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_68\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_76\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_69\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_77\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_68\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_78\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_78\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.29\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_79\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_79\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_80\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_80\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_81\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_81\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.30\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.29\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.30\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_82\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_82\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.31\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.31\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_83\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_83\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.32\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.return.32\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_68\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_83\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_69\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_84\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.33\ := \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_85\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_85\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.34\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_86\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_86\ => 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.34\;
                        \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_87\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_87\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.35\ := \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.7\ := signed(SmartResize((\Posit::op_Addition(Posit,Posit).0.return.33\), 32)) - signed(SmartResize((\Posit::op_Addition(Posit,Posit).0.return.35\), 32));
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.8\ := \Posit::op_Addition(Posit,Posit).0.num2\ + (\Posit::op_Addition(Posit,Posit).0.binaryOperationResult.7\);
                            \Posit::op_Addition(Posit,Posit).0.num2\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.8\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_45\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_87\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_51\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit::op_Addition(Posit,Posit).0._State_88\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_45\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag11 = num > 0;
                        -- 	if (flag11) {
                        -- 		num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 		num4 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 		bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 		flag12 = flag3;
                        -- 		if (flag12) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 		}
                        -- 		num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 	}
                        -- 	else {
                        -- 		num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 		num6 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 		bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 		flag13 = flag3;
                        -- 		if (flag13) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 		}
                        -- 		num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag11 = num > 0;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.9\ := \Posit::op_Addition(Posit,Posit).0.num\ > to_signed(0, 32);
                        \Posit::op_Addition(Posit,Posit).0.flag11\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag11) {
                        -- 	num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 	num4 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 	flag12 = flag3;
                        -- 	if (flag12) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 	}
                        -- 	num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- }
                        -- else {
                        -- 	num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 	num6 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 	flag13 = flag3;
                        -- 	if (flag13) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 	}
                        -- 	num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_90\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_110\.
                        --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_111\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_131\.
                        --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_89\.

                        if (\Posit::op_Addition(Posit,Posit).0.flag11\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_90\;
                        else 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_111\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit::op_Addition(Posit,Posit).0._State_89\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_88\.
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_45\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_89\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_51\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_90\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_88\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 	num4 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 	flag12 = flag3;
                        -- 	if (flag12) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 	}
                        -- 	num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_91\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_91\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.36\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_92\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_92\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_93\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_93\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_94\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_94\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.37\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.10\ := signed(\Posit::op_Addition(Posit,Posit).0.return.36\ - \Posit::op_Addition(Posit,Posit).0.return.37\);
                            \Posit::op_Addition(Posit,Posit).0.num3\ := (\Posit::op_Addition(Posit,Posit).0.binaryOperationResult.10\);
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_95\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::op_Addition(Posit,Posit).0._State_95\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.38\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.38\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_96\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_96\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.39\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.return.39\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                            -- 
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_97\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_97\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_98\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_98\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.40\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.40\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_99\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_99\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.41\ := \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.11\ := to_signed(31, 32) - signed(SmartResize((\Posit::op_Addition(Posit,Posit).0.return.41\), 32));
                            \Posit::op_Addition(Posit,Posit).0.num4\ := (\Posit::op_Addition(Posit,Posit).0.binaryOperationResult.11\);
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_LeftShift (bitMask, num4);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.num4\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_100\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::op_Addition(Posit,Posit).0._State_100\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.42\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.return.42\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag12 = flag3;
                            -- 
                            \Posit::op_Addition(Posit,Posit).0.flag12\ := \Posit::op_Addition(Posit,Posit).0.flag3\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag12) {
                            -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                            -- }
                            -- else {
                            -- 	bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_102\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_105\.
                            --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_106\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_109\.
                            --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_101\.

                            if (\Posit::op_Addition(Posit,Posit).0.flag12\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_102\;
                            else 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_106\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_101\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_100\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_110\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_102\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_100\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_103\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_103\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.43\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.12\ := \Posit::op_Addition(Posit,Posit).0.num4\ - \Posit::op_Addition(Posit,Posit).0.num\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.13\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.12\ + \Posit::op_Addition(Posit,Posit).0.num3\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.43\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.13\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_104\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit::op_Addition(Posit,Posit).0._State_104\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.44\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.44\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_105\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_105\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.45\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.return.45\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_100\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_105\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_101\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_106\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_100\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_107\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_107\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.46\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.14\ := \Posit::op_Addition(Posit,Posit).0.num4\ - \Posit::op_Addition(Posit,Posit).0.num\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.15\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.14\ + \Posit::op_Addition(Posit,Posit).0.num3\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.46\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.15\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_108\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit::op_Addition(Posit,Posit).0._State_108\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.47\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.47\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_109\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_109\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.48\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.return.48\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_100\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_109\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_101\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_110\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.49\ := \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.16\ := signed(SmartResize((\Posit::op_Addition(Posit,Posit).0.return.49\), 32)) - to_signed(31, 32);
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.17\ := \Posit::op_Addition(Posit,Posit).0.num2\ + (\Posit::op_Addition(Posit,Posit).0.binaryOperationResult.16\);
                            \Posit::op_Addition(Posit,Posit).0.num2\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.17\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_88\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_110\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_89\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit::op_Addition(Posit,Posit).0._State_111\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_88\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 	num6 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 	flag13 = flag3;
                        -- 	if (flag13) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 	}
                        -- 	num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_112\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_112\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.50\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_113\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_113\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_114\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_114\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_115\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_115\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.51\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.18\ := signed(\Posit::op_Addition(Posit,Posit).0.return.50\ - \Posit::op_Addition(Posit,Posit).0.return.51\);
                            \Posit::op_Addition(Posit,Posit).0.num5\ := (\Posit::op_Addition(Posit,Posit).0.binaryOperationResult.18\);
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_116\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::op_Addition(Posit,Posit).0._State_116\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.52\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.52\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_117\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_117\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.53\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.return.53\;
                            -- The following section was transformed from the .NET statement below:
                            -- num6 = (int)(31 - (System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                            -- 
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_118\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_118\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_119\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_119\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.54\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.54\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_120\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_120\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.55\ := \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.19\ := to_signed(31, 32) - signed(SmartResize((\Posit::op_Addition(Posit,Posit).0.return.55\), 32));
                            \Posit::op_Addition(Posit,Posit).0.num6\ := (\Posit::op_Addition(Posit,Posit).0.binaryOperationResult.19\);
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_LeftShift (bitMask, num6);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.num6\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_121\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit::op_Addition(Posit,Posit).0._State_121\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.56\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.return.56\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag13 = flag3;
                            -- 
                            \Posit::op_Addition(Posit,Posit).0.flag13\ := \Posit::op_Addition(Posit,Posit).0.flag3\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag13) {
                            -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                            -- }
                            -- else {
                            -- 	bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_123\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_126\.
                            --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_127\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_130\.
                            --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_122\.

                            if (\Posit::op_Addition(Posit,Posit).0.flag13\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_123\;
                            else 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_127\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_122\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_121\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = num2 + (int)((System.Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_131\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_123\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_121\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_124\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_124\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.57\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.20\ := \Posit::op_Addition(Posit,Posit).0.num6\ + \Posit::op_Addition(Posit,Posit).0.num\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.21\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.20\ + \Posit::op_Addition(Posit,Posit).0.num5\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.57\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.21\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_125\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit::op_Addition(Posit,Posit).0._State_125\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.58\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.58\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_126\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_126\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.59\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.return.59\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_121\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_126\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_122\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_127\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_121\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_128\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_128\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.60\ := \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.22\ := \Posit::op_Addition(Posit,Posit).0.num6\ + \Posit::op_Addition(Posit,Posit).0.num\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.23\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.22\ + \Posit::op_Addition(Posit,Posit).0.num5\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.60\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.23\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_129\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit::op_Addition(Posit,Posit).0._State_129\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.61\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.61\;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_130\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_130\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.62\ := \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).return.0\;
                            \Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit::op_Addition(Posit,Posit).0.return.62\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_121\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_130\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_122\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_131\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.63\ := \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.24\ := signed(SmartResize((\Posit::op_Addition(Posit,Posit).0.return.63\), 32)) - to_signed(31, 32);
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.25\ := \Posit::op_Addition(Posit,Posit).0.num2\ + (\Posit::op_Addition(Posit,Posit).0.binaryOperationResult.24\);
                            \Posit::op_Addition(Posit,Posit).0.num2\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.25\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_88\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_131\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_89\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit::op_Addition(Posit,Posit).0._State_132\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.64\ := \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.26\ := signed(SmartResize((\Posit::op_Addition(Posit,Posit).0.return.64\), 32)) = to_signed(0, 32);
                            \Posit::op_Addition(Posit,Posit).0.flag14\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.26\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag14) {
                            -- 	result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                            -- }
                            -- else {
                            -- 	regimeKValue3 = num2 / 8;
                            -- 	exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                            -- 	result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::op_Addition(Posit,Posit).0._State_134\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_136\.
                            --     * The false branch starts in state \Posit::op_Addition(Posit,Posit).0._State_137\ and ends in state \Posit::op_Addition(Posit,Posit).0._State_140\.
                            --     * Execution after either branch will continue in the following state: \Posit::op_Addition(Posit,Posit).0._State_133\.

                            if (\Posit::op_Addition(Posit,Posit).0.flag14\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_134\;
                            else 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_137\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit::op_Addition(Posit,Posit).0._State_133\ => 
                        -- State after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_132\.
                        -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_33\.
                        if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_133\) then 
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_34\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_134\ => 
                        -- True branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_132\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::op_Addition(Posit,Posit).0.result\.\IsNull\ := false;
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_135\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_135\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.65\ := \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().return.0\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.result\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\.\_environment\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.65\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_136\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_136\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.result\ := \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\;
                            \Posit::op_Addition(Posit,Posit).0.left\.\_environment\ := \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_132\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_136\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_133\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_137\ => 
                        -- False branch of the if-else started in state \Posit::op_Addition(Posit,Posit).0._State_132\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	regimeKValue3 = num2 / 8;
                        -- 	exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 	result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue3 = num2 / 8;
                        -- 
                        \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.27\ := \Posit::op_Addition(Posit,Posit).0.num2\ / to_signed(8, 32);
                        \Posit::op_Addition(Posit,Posit).0.regimeKValue3\ := \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.27\;
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::op_Addition(Posit,Posit).0.exponentBits\.\IsNull\ := false;
                        \Posit::op_Addition(Posit,Posit).0.exponentBits\.\Size\ := to_unsigned(0, 16);
                        \Posit::op_Addition(Posit,Posit).0.exponentBits\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::op_Addition(Posit,Posit).0.exponentBits\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.28\ := \Posit::op_Addition(Posit,Posit).0.num2\ / to_signed(8, 32);
                        \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.29\ := SmartResize(\Posit::op_Addition(Posit,Posit).0.binaryOperationResult.28\ * to_signed(8, 32), 32);
                        \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.30\ := unsigned(\Posit::op_Addition(Posit,Posit).0.num2\ - \Posit::op_Addition(Posit,Posit).0.binaryOperationResult.29\);
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.exponentBits\;
                        \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= (\Posit::op_Addition(Posit,Posit).0.binaryOperationResult.30\);
                        \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_138\;
                        -- Clock cycles needed to complete this state (approximation): 0.6156
                    when \Posit::op_Addition(Posit,Posit).0._State_138\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.exponentBits\ := \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit::op_Addition(Posit,Posit).0.result\.\IsNull\ := false;
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.signBit\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.regimeKValue3\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.exponentBits\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_139\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_139\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.return.66\ := \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.result\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.left\.\_environment\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\ <= \Posit::op_Addition(Posit,Posit).0.return.66\;
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= true;
                            \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_140\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Addition(Posit,Posit).0._State_140\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                            \Posit::op_Addition(Posit,Posit).0.result\ := \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\;
                            \Posit::op_Addition(Posit,Posit).0.left\.\_environment\ := \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit::op_Addition(Posit,Posit).0._State_132\.
                            if (\Posit::op_Addition(Posit,Posit).0._State\ = \Posit::op_Addition(Posit,Posit).0._State_140\) then 
                                \Posit::op_Addition(Posit,Posit).0._State\ := \Posit::op_Addition(Posit,Posit).0._State_133\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 state machine end


    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 state machine start
    \Posit::op_UnaryNegation(Posit).0._StateMachine\: process (\Clock\) 
        Variable \Posit::op_UnaryNegation(Posit).0._State\: \Posit::op_UnaryNegation(Posit).0._States\ := \Posit::op_UnaryNegation(Posit).0._State_0\;
        Variable \Posit::op_UnaryNegation(Posit).0.x\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::op_UnaryNegation(Posit).0.flag\: boolean := false;
        Variable \Posit::op_UnaryNegation(Posit).0.result\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::op_UnaryNegation(Posit).0.return.0\: boolean := false;
        Variable \Posit::op_UnaryNegation(Posit).0.return.1\: boolean := false;
        Variable \Posit::op_UnaryNegation(Posit).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit::op_UnaryNegation(Posit).0.return.2\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::op_UnaryNegation(Posit).0._Finished\ <= false;
                \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\ <= false;
                \Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\ <= false;
                \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_0\;
                \Posit::op_UnaryNegation(Posit).0.flag\ := false;
                \Posit::op_UnaryNegation(Posit).0.return.0\ := false;
                \Posit::op_UnaryNegation(Posit).0.return.1\ := false;
                \Posit::op_UnaryNegation(Posit).0.binaryOperationResult.0\ := false;
            else 
                case \Posit::op_UnaryNegation(Posit).0._State\ is 
                    when \Posit::op_UnaryNegation(Posit).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::op_UnaryNegation(Posit).0._Started\ = true) then 
                            \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_UnaryNegation(Posit).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::op_UnaryNegation(Posit).0._Started\ = true) then 
                            \Posit::op_UnaryNegation(Posit).0._Finished\ <= true;
                        else 
                            \Posit::op_UnaryNegation(Posit).0._Finished\ <= false;
                            \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_UnaryNegation(Posit).0._State_2\ => 
                        \Posit::op_UnaryNegation(Posit).0.x\ := \Posit::op_UnaryNegation(Posit).0.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = Lombiq.Arithmetics.Posit.IsNaN (x) || Lombiq.Arithmetics.Posit.IsZero (x);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsNaN()
                        \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().this.parameter.Out.0\ <= \Posit::op_UnaryNegation(Posit).0.x\;
                        \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\ <= true;
                        \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_UnaryNegation(Posit).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsNaN()
                        if (\Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\ = \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Finished.0\) then 
                            \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\ <= false;
                            \Posit::op_UnaryNegation(Posit).0.return.0\ := \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsZero()
                            \Posit::op_UnaryNegation(Posit).0.Posit::IsZero().this.parameter.Out.0\ <= \Posit::op_UnaryNegation(Posit).0.x\;
                            \Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\ <= true;
                            \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_UnaryNegation(Posit).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsZero()
                        if (\Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\ = \Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Finished.0\) then 
                            \Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\ <= false;
                            \Posit::op_UnaryNegation(Posit).0.return.1\ := \Posit::op_UnaryNegation(Posit).0.Posit::IsZero().return.0\;
                            \Posit::op_UnaryNegation(Posit).0.binaryOperationResult.0\ := \Posit::op_UnaryNegation(Posit).0.return.0\ or \Posit::op_UnaryNegation(Posit).0.return.1\;
                            \Posit::op_UnaryNegation(Posit).0.flag\ := \Posit::op_UnaryNegation(Posit).0.binaryOperationResult.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	result = new Posit (x._environment, x.PositBits);
                            -- }
                            -- else {
                            -- 	result = new Posit (x._environment, Lombiq.Arithmetics.BitMask.GetTwosComplement (x.PositBits, 32));
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::op_UnaryNegation(Posit).0._State_6\ and ends in state \Posit::op_UnaryNegation(Posit).0._State_7\.
                            --     * The false branch starts in state \Posit::op_UnaryNegation(Posit).0._State_8\ and ends in state \Posit::op_UnaryNegation(Posit).0._State_10\.
                            --     * Execution after either branch will continue in the following state: \Posit::op_UnaryNegation(Posit).0._State_5\.

                            if (\Posit::op_UnaryNegation(Posit).0.flag\) then 
                                \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_6\;
                            else 
                                \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_8\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit::op_UnaryNegation(Posit).0._State_5\ => 
                        -- State after the if-else which was started in state \Posit::op_UnaryNegation(Posit).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit::op_UnaryNegation(Posit).0.return\ <= \Posit::op_UnaryNegation(Posit).0.result\;
                        \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_UnaryNegation(Posit).0._State_6\ => 
                        -- True branch of the if-else started in state \Posit::op_UnaryNegation(Posit).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new Posit (x._environment, x.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit (x._environment, x.PositBits);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::op_UnaryNegation(Posit).0.result\.\IsNull\ := false;
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                        \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\ <= \Posit::op_UnaryNegation(Posit).0.result\;
                        \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\ <= \Posit::op_UnaryNegation(Posit).0.x\.\_environment\;
                        \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\ <= \Posit::op_UnaryNegation(Posit).0.x\.\PositBits\;
                        \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= true;
                        \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_UnaryNegation(Posit).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\) then 
                            \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                            \Posit::op_UnaryNegation(Posit).0.result\ := \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\;
                            \Posit::op_UnaryNegation(Posit).0.x\.\_environment\ := \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit::op_UnaryNegation(Posit).0._State_4\.
                            if (\Posit::op_UnaryNegation(Posit).0._State\ = \Posit::op_UnaryNegation(Posit).0._State_7\) then 
                                \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_UnaryNegation(Posit).0._State_8\ => 
                        -- False branch of the if-else started in state \Posit::op_UnaryNegation(Posit).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new Posit (x._environment, Lombiq.Arithmetics.BitMask.GetTwosComplement (x.PositBits, 32));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit (x._environment, Lombiq.Arithmetics.BitMask.GetTwosComplement (x.PositBits, 32));
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::op_UnaryNegation(Posit).0.result\.\IsNull\ := false;
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::op_UnaryNegation(Posit).0.x\.\PositBits\;
                        \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_UnaryNegation(Posit).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::op_UnaryNegation(Posit).0.return.2\ := \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).return.0\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                            \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\ <= \Posit::op_UnaryNegation(Posit).0.result\;
                            \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\ <= \Posit::op_UnaryNegation(Posit).0.x\.\_environment\;
                            \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\ <= \Posit::op_UnaryNegation(Posit).0.return.2\;
                            \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= true;
                            \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_UnaryNegation(Posit).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                        if (\Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\) then 
                            \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                            \Posit::op_UnaryNegation(Posit).0.result\ := \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\;
                            \Posit::op_UnaryNegation(Posit).0.x\.\_environment\ := \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit::op_UnaryNegation(Posit).0._State_4\.
                            if (\Posit::op_UnaryNegation(Posit).0._State\ = \Posit::op_UnaryNegation(Posit).0._State_10\) then 
                                \Posit::op_UnaryNegation(Posit).0._State\ := \Posit::op_UnaryNegation(Posit).0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 state machine end


    -- System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0 state machine start
    \Posit::op_Explicit(Posit).0._StateMachine\: process (\Clock\) 
        Variable \Posit::op_Explicit(Posit).0._State\: \Posit::op_Explicit(Posit).0._States\ := \Posit::op_Explicit(Posit).0._State_0\;
        Variable \Posit::op_Explicit(Posit).0.x\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::op_Explicit(Posit).0.flag\: boolean := false;
        Variable \Posit::op_Explicit(Posit).0.lowest32Bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Explicit(Posit).0.result\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Explicit(Posit).0.return.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Explicit(Posit).0.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::op_Explicit(Posit).0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Explicit(Posit).0.binaryOperationResult.1\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::op_Explicit(Posit).0.binaryOperationResult.2\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::op_Explicit(Posit).0.binaryOperationResult.3\: boolean := false;
        Variable \Posit::op_Explicit(Posit).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Explicit(Posit).0.return.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Explicit(Posit).0.binaryOperationResult.4\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::op_Explicit(Posit).0.return.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Explicit(Posit).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Explicit(Posit).0.return.5\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Explicit(Posit).0.return.6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::op_Explicit(Posit).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Explicit(Posit).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::op_Explicit(Posit).0.return.7\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::op_Explicit(Posit).0.return.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Explicit(Posit).0.conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::op_Explicit(Posit).0.return.9\: boolean := false;
        Variable \Posit::op_Explicit(Posit).0.return.10\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::op_Explicit(Posit).0._Finished\ <= false;
                \Posit::op_Explicit(Posit).0.return\ <= to_signed(0, 32);
                \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_0\;
                \Posit::op_Explicit(Posit).0.flag\ := false;
                \Posit::op_Explicit(Posit).0.lowest32Bits\ := to_unsigned(0, 32);
                \Posit::op_Explicit(Posit).0.result\ := to_signed(0, 32);
                \Posit::op_Explicit(Posit).0.return.0\ := to_signed(0, 32);
                \Posit::op_Explicit(Posit).0.binaryOperationResult.0\ := to_signed(0, 64);
                \Posit::op_Explicit(Posit).0.return.1\ := to_unsigned(0, 32);
                \Posit::op_Explicit(Posit).0.binaryOperationResult.1\ := to_signed(0, 64);
                \Posit::op_Explicit(Posit).0.binaryOperationResult.2\ := to_signed(0, 64);
                \Posit::op_Explicit(Posit).0.binaryOperationResult.3\ := false;
                \Posit::op_Explicit(Posit).0.return.3\ := to_signed(0, 32);
                \Posit::op_Explicit(Posit).0.binaryOperationResult.4\ := to_signed(0, 64);
                \Posit::op_Explicit(Posit).0.return.4\ := to_unsigned(0, 32);
                \Posit::op_Explicit(Posit).0.binaryOperationResult.5\ := to_signed(0, 32);
                \Posit::op_Explicit(Posit).0.return.6\ := to_unsigned(0, 16);
                \Posit::op_Explicit(Posit).0.binaryOperationResult.6\ := to_signed(0, 32);
                \Posit::op_Explicit(Posit).0.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit::op_Explicit(Posit).0.return.8\ := to_unsigned(0, 32);
                \Posit::op_Explicit(Posit).0.conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca\ := to_unsigned(0, 32);
                \Posit::op_Explicit(Posit).0.return.9\ := false;
                \Posit::op_Explicit(Posit).0.return.10\ := false;
            else 
                case \Posit::op_Explicit(Posit).0._State\ is 
                    when \Posit::op_Explicit(Posit).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::op_Explicit(Posit).0._Started\ = true) then 
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::op_Explicit(Posit).0._Started\ = true) then 
                            \Posit::op_Explicit(Posit).0._Finished\ <= true;
                        else 
                            \Posit::op_Explicit(Posit).0._Finished\ <= false;
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_2\ => 
                        \Posit::op_Explicit(Posit).0.x\ := \Posit::op_Explicit(Posit).0.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint lowest32Bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (long)(Lombiq.Arithmetics.Posit.GetRegimeKValue (x) * 8) + (long)((ulong)Lombiq.Arithmetics.Posit.GetExponentValue (x)) + 1L < 31L;
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.x\;
                        \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                        \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Posit::op_Explicit(Posit).0.return.0\ := \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Posit::op_Explicit(Posit).0.binaryOperationResult.0\ := SmartResize(\Posit::op_Explicit(Posit).0.return.0\ * to_signed(8, 32), 64);
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Posit::op_Explicit(Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.x\;
                            \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit::op_Explicit(Posit).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ = \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Posit::op_Explicit(Posit).0.return.1\ := \Posit::op_Explicit(Posit).0.Posit::GetExponentValue().return.0\;
                            \Posit::op_Explicit(Posit).0.binaryOperationResult.1\ := (\Posit::op_Explicit(Posit).0.binaryOperationResult.0\) + signed((SmartResize(\Posit::op_Explicit(Posit).0.return.1\, 64)));
                            \Posit::op_Explicit(Posit).0.binaryOperationResult.2\ := \Posit::op_Explicit(Posit).0.binaryOperationResult.1\ + to_signed(1, 64);
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7796
                    when \Posit::op_Explicit(Posit).0._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::op_Explicit(Posit).0.binaryOperationResult.3\ := \Posit::op_Explicit(Posit).0.binaryOperationResult.2\ < to_signed(31, 64);
                        \Posit::op_Explicit(Posit).0.flag\ := \Posit::op_Explicit(Posit).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	lowest32Bits = Lombiq.Arithmetics.BitMask.GetLowest32Bits (BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x), (int)((long)(Lombiq.Arithmetics.Posit.GetRegimeKValue (x) * 8) + (long)((ulong)Lombiq.Arithmetics.Posit.GetExponentValue (x))) - (int)Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x)) + 1));
                        -- 	uint conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca;
                        -- 	if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                        -- 		conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca = lowest32Bits;
                        -- 	}
                        -- 	else {
                        -- 		conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca = (uint)((int)-(int)((ulong)lowest32Bits));
                        -- 	}
                        -- 	result = (int)(conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca);
                        -- }
                        -- else {
                        -- 	if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                        -- 		result = 2147483647;
                        -- 	}
                        -- 	else {
                        -- 		result = -2147483648;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::op_Explicit(Posit).0._State_7\ and ends in state \Posit::op_Explicit(Posit).0._State_16\.
                        --     * The false branch starts in state \Posit::op_Explicit(Posit).0._State_19\ and ends in state \Posit::op_Explicit(Posit).0._State_21\.
                        --     * Execution after either branch will continue in the following state: \Posit::op_Explicit(Posit).0._State_6\.

                        if (\Posit::op_Explicit(Posit).0.flag\) then 
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_7\;
                        else 
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2897
                    when \Posit::op_Explicit(Posit).0._State_6\ => 
                        -- State after the if-else which was started in state \Posit::op_Explicit(Posit).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit::op_Explicit(Posit).0.return\ <= \Posit::op_Explicit(Posit).0.result\;
                        \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_7\ => 
                        -- True branch of the if-else started in state \Posit::op_Explicit(Posit).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	lowest32Bits = Lombiq.Arithmetics.BitMask.GetLowest32Bits (BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x), (int)((long)(Lombiq.Arithmetics.Posit.GetRegimeKValue (x) * 8) + (long)((ulong)Lombiq.Arithmetics.Posit.GetExponentValue (x))) - (int)Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x)) + 1));
                        -- 	uint conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca;
                        -- 	if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                        -- 		conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca = lowest32Bits;
                        -- 	}
                        -- 	else {
                        -- 		conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca = (uint)((int)-(int)((ulong)lowest32Bits));
                        -- 	}
                        -- 	result = (int)(conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- lowest32Bits = Lombiq.Arithmetics.BitMask.GetLowest32Bits (BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x), (int)((long)(Lombiq.Arithmetics.Posit.GetRegimeKValue (x) * 8) + (long)((ulong)Lombiq.Arithmetics.Posit.GetExponentValue (x))) - (int)Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x)) + 1));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.x\;
                        \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Explicit(Posit).0.return.2\ := \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                            \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.x\;
                            \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Posit::op_Explicit(Posit).0.return.3\ := \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Posit::op_Explicit(Posit).0.binaryOperationResult.4\ := SmartResize(\Posit::op_Explicit(Posit).0.return.3\ * to_signed(8, 32), 64);
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Posit::op_Explicit(Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.x\;
                            \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit::op_Explicit(Posit).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ = \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Posit::op_Explicit(Posit).0.return.4\ := \Posit::op_Explicit(Posit).0.Posit::GetExponentValue().return.0\;
                            \Posit::op_Explicit(Posit).0.binaryOperationResult.5\ := SmartResize((\Posit::op_Explicit(Posit).0.binaryOperationResult.4\) + signed((SmartResize(\Posit::op_Explicit(Posit).0.return.4\, 64))), 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                            \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.x\;
                            \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3898
                    when \Posit::op_Explicit(Posit).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit::op_Explicit(Posit).0.return.5\ := \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.return.5\;
                            \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::op_Explicit(Posit).0.return.6\ := \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::op_Explicit(Posit).0.binaryOperationResult.6\ := (\Posit::op_Explicit(Posit).0.binaryOperationResult.5\) - signed(SmartResize(\Posit::op_Explicit(Posit).0.return.6\, 32));
                            \Posit::op_Explicit(Posit).0.binaryOperationResult.7\ := \Posit::op_Explicit(Posit).0.binaryOperationResult.6\ + to_signed(1, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.return.2\;
                            \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.binaryOperationResult.7\;
                            \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit::op_Explicit(Posit).0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::op_Explicit(Posit).0.return.7\ := \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                            \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().this.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.return.7\;
                            \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\ <= true;
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        if (\Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\ = \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\) then 
                            \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                            \Posit::op_Explicit(Posit).0.return.8\ := \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().return.0\;
                            \Posit::op_Explicit(Posit).0.lowest32Bits\ := \Posit::op_Explicit(Posit).0.return.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                            -- 	conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca = lowest32Bits;
                            -- }
                            -- else {
                            -- 	conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca = (uint)((int)-(int)((ulong)lowest32Bits));
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                            \Posit::op_Explicit(Posit).0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.x\;
                            \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ <= true;
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ = \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::op_Explicit(Posit).0.return.9\ := \Posit::op_Explicit(Posit).0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::op_Explicit(Posit).0._State_17\ and ends in state \Posit::op_Explicit(Posit).0._State_17\.
                            --     * The false branch starts in state \Posit::op_Explicit(Posit).0._State_18\ and ends in state \Posit::op_Explicit(Posit).0._State_18\.
                            --     * Execution after either branch will continue in the following state: \Posit::op_Explicit(Posit).0._State_16\.

                            if (\Posit::op_Explicit(Posit).0.return.9\) then 
                                \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_17\;
                            else 
                                \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_18\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_16\ => 
                        -- State after the if-else which was started in state \Posit::op_Explicit(Posit).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = (int)(conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca);
                        -- 
                        \Posit::op_Explicit(Posit).0.result\ := signed((\Posit::op_Explicit(Posit).0.conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca\));
                        -- Going to the state after the if-else which was started in state \Posit::op_Explicit(Posit).0._State_5\.
                        if (\Posit::op_Explicit(Posit).0._State\ = \Posit::op_Explicit(Posit).0._State_16\) then 
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_17\ => 
                        -- True branch of the if-else started in state \Posit::op_Explicit(Posit).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca = lowest32Bits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca = lowest32Bits;
                        -- 
                        \Posit::op_Explicit(Posit).0.conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca\ := \Posit::op_Explicit(Posit).0.lowest32Bits\;
                        -- Going to the state after the if-else which was started in state \Posit::op_Explicit(Posit).0._State_15\.
                        if (\Posit::op_Explicit(Posit).0._State\ = \Posit::op_Explicit(Posit).0._State_17\) then 
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_18\ => 
                        -- False branch of the if-else started in state \Posit::op_Explicit(Posit).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca = (uint)((int)-(int)((ulong)lowest32Bits));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca = (uint)((int)-(int)((ulong)lowest32Bits));
                        -- 
                        \Posit::op_Explicit(Posit).0.conditional842dc2f0a8da2978c5976d720ef13b48358cf52f47eb8961b0aeb448f105b9ca\ := unsigned((signed(SmartResize(-signed(SmartResize((SmartResize(\Posit::op_Explicit(Posit).0.lowest32Bits\, 64)), 32)), 32))));
                        -- Going to the state after the if-else which was started in state \Posit::op_Explicit(Posit).0._State_15\.
                        if (\Posit::op_Explicit(Posit).0._State\ = \Posit::op_Explicit(Posit).0._State_18\) then 
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit::op_Explicit(Posit).0._State_19\ => 
                        -- False branch of the if-else started in state \Posit::op_Explicit(Posit).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                        -- 		result = 2147483647;
                        -- 	}
                        -- 	else {
                        -- 		result = -2147483648;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                        -- 	result = 2147483647;
                        -- }
                        -- else {
                        -- 	result = -2147483648;
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::op_Explicit(Posit).0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::op_Explicit(Posit).0.x\;
                        \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_20\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ = \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::op_Explicit(Posit).0.return.10\ := \Posit::op_Explicit(Posit).0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::op_Explicit(Posit).0._State_22\ and ends in state \Posit::op_Explicit(Posit).0._State_22\.
                            --     * The false branch starts in state \Posit::op_Explicit(Posit).0._State_23\ and ends in state \Posit::op_Explicit(Posit).0._State_23\.
                            --     * Execution after either branch will continue in the following state: \Posit::op_Explicit(Posit).0._State_21\.

                            if (\Posit::op_Explicit(Posit).0.return.10\) then 
                                \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_22\;
                            else 
                                \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_23\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_21\ => 
                        -- State after the if-else which was started in state \Posit::op_Explicit(Posit).0._State_20\.
                        -- Going to the state after the if-else which was started in state \Posit::op_Explicit(Posit).0._State_5\.
                        if (\Posit::op_Explicit(Posit).0._State\ = \Posit::op_Explicit(Posit).0._State_21\) then 
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_22\ => 
                        -- True branch of the if-else started in state \Posit::op_Explicit(Posit).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = 2147483647;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = 2147483647;
                        -- 
                        \Posit::op_Explicit(Posit).0.result\ := to_signed(2147483647, 32);
                        -- Going to the state after the if-else which was started in state \Posit::op_Explicit(Posit).0._State_20\.
                        if (\Posit::op_Explicit(Posit).0._State\ = \Posit::op_Explicit(Posit).0._State_22\) then 
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::op_Explicit(Posit).0._State_23\ => 
                        -- False branch of the if-else started in state \Posit::op_Explicit(Posit).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = -2147483648;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = -2147483648;
                        -- 
                        \Posit::op_Explicit(Posit).0.result\ := to_signed(-2147483648, 32);
                        -- Going to the state after the if-else which was started in state \Posit::op_Explicit(Posit).0._State_20\.
                        if (\Posit::op_Explicit(Posit).0._State\ = \Posit::op_Explicit(Posit).0._State_23\) then 
                            \Posit::op_Explicit(Posit).0._State\ := \Posit::op_Explicit(Posit).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask().0 state machine start
    \Posit::get_SignBitMask().0._StateMachine\: process (\Clock\) 
        Variable \Posit::get_SignBitMask().0._State\: \Posit::get_SignBitMask().0._States\ := \Posit::get_SignBitMask().0._State_0\;
        Variable \Posit::get_SignBitMask().0.this\: \Lombiq.Arithmetics.Posit\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::get_SignBitMask().0._Finished\ <= false;
                \Posit::get_SignBitMask().0._State\ := \Posit::get_SignBitMask().0._State_0\;
            else 
                case \Posit::get_SignBitMask().0._State\ is 
                    when \Posit::get_SignBitMask().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::get_SignBitMask().0._Started\ = true) then 
                            \Posit::get_SignBitMask().0._State\ := \Posit::get_SignBitMask().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_SignBitMask().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::get_SignBitMask().0._Started\ = true) then 
                            \Posit::get_SignBitMask().0._Finished\ <= true;
                        else 
                            \Posit::get_SignBitMask().0._Finished\ <= false;
                            \Posit::get_SignBitMask().0._State\ := \Posit::get_SignBitMask().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_SignBitMask().0._State_2\ => 
                        \Posit::get_SignBitMask().0.this\ := \Posit::get_SignBitMask().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this._environment.SignBitMask;
                        -- 
                        \Posit::get_SignBitMask().0.return\ <= \Posit::get_SignBitMask().0.this\.\_environment\.\SignBitMask\;
                        \Posit::get_SignBitMask().0._State\ := \Posit::get_SignBitMask().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask().0 state machine start
    \Posit::get_FirstRegimeBitBitMask().0._StateMachine\: process (\Clock\) 
        Variable \Posit::get_FirstRegimeBitBitMask().0._State\: \Posit::get_FirstRegimeBitBitMask().0._States\ := \Posit::get_FirstRegimeBitBitMask().0._State_0\;
        Variable \Posit::get_FirstRegimeBitBitMask().0.this\: \Lombiq.Arithmetics.Posit\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::get_FirstRegimeBitBitMask().0._Finished\ <= false;
                \Posit::get_FirstRegimeBitBitMask().0._State\ := \Posit::get_FirstRegimeBitBitMask().0._State_0\;
            else 
                case \Posit::get_FirstRegimeBitBitMask().0._State\ is 
                    when \Posit::get_FirstRegimeBitBitMask().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::get_FirstRegimeBitBitMask().0._Started\ = true) then 
                            \Posit::get_FirstRegimeBitBitMask().0._State\ := \Posit::get_FirstRegimeBitBitMask().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_FirstRegimeBitBitMask().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::get_FirstRegimeBitBitMask().0._Started\ = true) then 
                            \Posit::get_FirstRegimeBitBitMask().0._Finished\ <= true;
                        else 
                            \Posit::get_FirstRegimeBitBitMask().0._Finished\ <= false;
                            \Posit::get_FirstRegimeBitBitMask().0._State\ := \Posit::get_FirstRegimeBitBitMask().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_FirstRegimeBitBitMask().0._State_2\ => 
                        \Posit::get_FirstRegimeBitBitMask().0.this\ := \Posit::get_FirstRegimeBitBitMask().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this._environment.FirstRegimeBitBitMask;
                        -- 
                        \Posit::get_FirstRegimeBitBitMask().0.return\ <= \Posit::get_FirstRegimeBitBitMask().0.this\.\_environment\.\FirstRegimeBitBitMask\;
                        \Posit::get_FirstRegimeBitBitMask().0._State\ := \Posit::get_FirstRegimeBitBitMask().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask().0 state machine start
    \Posit::get_EmptyBitMask().0._StateMachine\: process (\Clock\) 
        Variable \Posit::get_EmptyBitMask().0._State\: \Posit::get_EmptyBitMask().0._States\ := \Posit::get_EmptyBitMask().0._State_0\;
        Variable \Posit::get_EmptyBitMask().0.this\: \Lombiq.Arithmetics.Posit\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::get_EmptyBitMask().0._Finished\ <= false;
                \Posit::get_EmptyBitMask().0._State\ := \Posit::get_EmptyBitMask().0._State_0\;
            else 
                case \Posit::get_EmptyBitMask().0._State\ is 
                    when \Posit::get_EmptyBitMask().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::get_EmptyBitMask().0._Started\ = true) then 
                            \Posit::get_EmptyBitMask().0._State\ := \Posit::get_EmptyBitMask().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_EmptyBitMask().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::get_EmptyBitMask().0._Started\ = true) then 
                            \Posit::get_EmptyBitMask().0._Finished\ <= true;
                        else 
                            \Posit::get_EmptyBitMask().0._Finished\ <= false;
                            \Posit::get_EmptyBitMask().0._State\ := \Posit::get_EmptyBitMask().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_EmptyBitMask().0._State_2\ => 
                        \Posit::get_EmptyBitMask().0.this\ := \Posit::get_EmptyBitMask().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this._environment.EmptyBitMask;
                        -- 
                        \Posit::get_EmptyBitMask().0.return\ <= \Posit::get_EmptyBitMask().0.this\.\_environment\.\EmptyBitMask\;
                        \Posit::get_EmptyBitMask().0._State\ := \Posit::get_EmptyBitMask().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask().0 state machine start
    \Posit::get_NaNBitMask().0._StateMachine\: process (\Clock\) 
        Variable \Posit::get_NaNBitMask().0._State\: \Posit::get_NaNBitMask().0._States\ := \Posit::get_NaNBitMask().0._State_0\;
        Variable \Posit::get_NaNBitMask().0.this\: \Lombiq.Arithmetics.Posit\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::get_NaNBitMask().0._Finished\ <= false;
                \Posit::get_NaNBitMask().0._State\ := \Posit::get_NaNBitMask().0._State_0\;
            else 
                case \Posit::get_NaNBitMask().0._State\ is 
                    when \Posit::get_NaNBitMask().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::get_NaNBitMask().0._Started\ = true) then 
                            \Posit::get_NaNBitMask().0._State\ := \Posit::get_NaNBitMask().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_NaNBitMask().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::get_NaNBitMask().0._Started\ = true) then 
                            \Posit::get_NaNBitMask().0._Finished\ <= true;
                        else 
                            \Posit::get_NaNBitMask().0._Finished\ <= false;
                            \Posit::get_NaNBitMask().0._State\ := \Posit::get_NaNBitMask().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_NaNBitMask().0._State_2\ => 
                        \Posit::get_NaNBitMask().0.this\ := \Posit::get_NaNBitMask().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this._environment.NaNBitMask;
                        -- 
                        \Posit::get_NaNBitMask().0.return\ <= \Posit::get_NaNBitMask().0.this\.\_environment\.\NaNBitMask\;
                        \Posit::get_NaNBitMask().0._State\ := \Posit::get_NaNBitMask().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask().0 state machine end


    -- System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0 state machine start
    \PositEnvironment::.ctor(Byte,Byte).0._StateMachine\: process (\Clock\) 
        Variable \PositEnvironment::.ctor(Byte,Byte).0._State\: \PositEnvironment::.ctor(Byte,Byte).0._States\ := \PositEnvironment::.ctor(Byte,Byte).0._State_0\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.this\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.size\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.return.3\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.object9a23b576607c0ba6205e9fbf29712c9e11201f69b3cf9db5a4b21cd1cfa84bb4\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.return.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PositEnvironment::.ctor(Byte,Byte).0._Finished\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(0, 32);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_0\;
                \PositEnvironment::.ctor(Byte,Byte).0.size\ := to_unsigned(0, 8);
                \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize\ := to_unsigned(0, 8);
                \PositEnvironment::.ctor(Byte,Byte).0.return.4\ := to_unsigned(0, 16);
            else 
                case \PositEnvironment::.ctor(Byte,Byte).0._State\ is 
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PositEnvironment::.ctor(Byte,Byte).0._Started\ = true) then 
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PositEnvironment::.ctor(Byte,Byte).0._Started\ = true) then 
                            \PositEnvironment::.ctor(Byte,Byte).0._Finished\ <= true;
                        else 
                            \PositEnvironment::.ctor(Byte,Byte).0._Finished\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.Out\ <= \PositEnvironment::.ctor(Byte,Byte).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_2\ => 
                        \PositEnvironment::.ctor(Byte,Byte).0.this\ := \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.In\;
                        \PositEnvironment::.ctor(Byte,Byte).0.size\ := \PositEnvironment::.ctor(Byte,Byte).0.size.parameter.In\;
                        \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize\ := \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = 32;
                        -- 
                        \PositEnvironment::.ctor(Byte,Byte).0.this\.\Size\ := to_unsigned(32, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.MaximumExponentSize = 3;
                        -- 
                        \PositEnvironment::.ctor(Byte,Byte).0.this\.\MaximumExponentSize\ := to_unsigned(3, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Useed = 256u;
                        -- 
                        \PositEnvironment::.ctor(Byte,Byte).0.this\.\Useed\ := to_unsigned(256, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f = new BitMask (32, false);
                        -- 
                        -- Initializing record fields to their defaults.
                        \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\.\IsNull\ := false;
                        \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\.\Size\ := to_unsigned(0, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\.\SegmentCount\ := to_unsigned(0, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.SignBitMask = Lombiq.Arithmetics.BitMask.SetOne (object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f, 31);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= to_unsigned(31, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.return.0\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).return.0\;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\SignBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.FirstRegimeBitIndex = 30;
                            -- 
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\FirstRegimeBitIndex\ := to_unsigned(30, 16);
                            -- The following section was transformed from the .NET statement below:
                            -- BitMask object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed = new BitMask (32, false);
                            -- 
                            -- Initializing record fields to their defaults.
                            \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\.\IsNull\ := false;
                            \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\.\Size\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\.\SegmentCount\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.FirstRegimeBitBitMask = Lombiq.Arithmetics.BitMask.SetOne (object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed, 30);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= to_unsigned(30, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.return.1\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).return.0\;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\FirstRegimeBitBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.EmptyBitMask = new BitMask (32, false);
                            -- 
                            -- Initializing record fields to their defaults.
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\.\IsNull\ := false;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\.\Size\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\.\SegmentCount\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- BitMask objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf = new BitMask (32, true);
                            -- 
                            -- Initializing record fields to their defaults.
                            \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\.\IsNull\ := false;
                            \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\.\Size\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\.\SegmentCount\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_10\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_11\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= True;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.MaxValueBitMask = BitMask.op_RightShift (objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf, 1);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(1, 32);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.return.2\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32).return.0\;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\MaxValueBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.MinValueBitMask = BitMask.op_Addition (@this.SignBitMask, 1u);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.this\.\SignBitMask\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.return.3\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\MinValueBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.NaNBitMask = @this.SignBitMask;
                            -- 
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\NaNBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.this\.\SignBitMask\;
                            -- The following section was transformed from the .NET statement below:
                            -- BitMask object9a23b576607c0ba6205e9fbf29712c9e11201f69b3cf9db5a4b21cd1cfa84bb4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- object9a23b576607c0ba6205e9fbf29712c9e11201f69b3cf9db5a4b21cd1cfa84bb4 = new BitMask (245u, 32);
                            -- 
                            -- Initializing record fields to their defaults.
                            \PositEnvironment::.ctor(Byte,Byte).0.object9a23b576607c0ba6205e9fbf29712c9e11201f69b3cf9db5a4b21cd1cfa84bb4\.\IsNull\ := false;
                            \PositEnvironment::.ctor(Byte,Byte).0.object9a23b576607c0ba6205e9fbf29712c9e11201f69b3cf9db5a4b21cd1cfa84bb4\.\Size\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.object9a23b576607c0ba6205e9fbf29712c9e11201f69b3cf9db5a4b21cd1cfa84bb4\.\SegmentCount\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.object9a23b576607c0ba6205e9fbf29712c9e11201f69b3cf9db5a4b21cd1cfa84bb4\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object9a23b576607c0ba6205e9fbf29712c9e11201f69b3cf9db5a4b21cd1cfa84bb4\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(245, 32);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.object9a23b576607c0ba6205e9fbf29712c9e11201f69b3cf9db5a4b21cd1cfa84bb4\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.QuireSize = (uint)Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (object9a23b576607c0ba6205e9fbf29712c9e11201f69b3cf9db5a4b21cd1cfa84bb4);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object9a23b576607c0ba6205e9fbf29712c9e11201f69b3cf9db5a4b21cd1cfa84bb4\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_16\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.return.4\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\QuireSize\ := SmartResize(\PositEnvironment::.ctor(Byte,Byte).0.return.4\, 32);
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0 state machine end


    -- System.Void Hast::ExternalInvocationProxy() start
    \Finished\ <= \FinishedInternal\;
    \Hast::ExternalInvocationProxy()\: process (\Clock\) 
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \FinishedInternal\ <= false;
                \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ <= false;
            else 
                if (\Started\ = true and \FinishedInternal\ = false) then 
                    -- Starting the state machine corresponding to the given member ID.
                    case \MemberId\ is 
                        when 0 => 
                            if (\Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when others => 
                            null;
                    end case;
                else 
                    -- Waiting for Started to be pulled back to zero that signals the framework noting the finish.
                    if (\Started\ = false and \FinishedInternal\ = true) then 
                        \FinishedInternal\ <= false;
                    end if;
                end if;
            end if;
        end if;
    end process;
    -- System.Void Hast::ExternalInvocationProxy() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory() start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \PositCalculator::EnvironmentFactory().0._Started\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Finished.0\ <= \PositCalculator::EnvironmentFactory().0._Finished\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory().return.0\ <= \PositCalculator::EnvironmentFactory().0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit::.ctor(PositEnvironment,Int32).0._Started\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\;
    \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.Out.0\;
    \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.Out.0\;
    \Posit::.ctor(PositEnvironment,Int32).0.value.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).value.parameter.Out.0\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Finished.0\ <= \Posit::.ctor(PositEnvironment,Int32).0._Finished\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.Out\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit::op_Addition(Posit,Posit).0._Started\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit)._Started.0\;
    \Posit::op_Addition(Posit,Posit).0.left.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit).left.parameter.Out.0\;
    \Posit::op_Addition(Posit,Posit).0.right.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit).right.parameter.Out.0\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit)._Finished.0\ <= \Posit::op_Addition(Posit,Posit).0._Finished\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Addition(Posit,Posit).return.0\ <= \Posit::op_Addition(Posit,Posit).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit) end


    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit::op_Explicit(Posit).0._Started\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit)._Started.0\;
    \Posit::op_Explicit(Posit).0.x.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit).x.parameter.Out.0\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit)._Finished.0\ <= \Posit::op_Explicit(Posit).0._Finished\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::op_Explicit(Posit).return.0\ <= \Posit::op_Explicit(Posit).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte) start
    -- Signal connections for Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory().0 (#0):
    \PositEnvironment::.ctor(Byte,Byte).0._Started\ <= \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\;
    \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.In\ <= \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.Out.0\;
    \PositEnvironment::.ctor(Byte,Byte).0.size.parameter.In\ <= \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).size.parameter.Out.0\;
    \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize.parameter.In\ <= \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).maximumExponentSize.parameter.Out.0\;
    \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Finished.0\ <= \PositEnvironment::.ctor(Byte,Byte).0._Finished\;
    \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.In.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Addition(BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Addition(BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Subtraction(BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_OnesComplement(BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_OnesComplement(BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Addition(BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Addition(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Subtraction(BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_OnesComplement(BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_OnesComplement(BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Addition(BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Addition(BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Addition(BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Addition(BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Addition(BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Addition(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Subtraction(BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Subtraction(BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_OnesComplement(BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_OnesComplement(BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_OnesComplement(BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_OnesComplement(BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_OnesComplement(BitMask).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_OnesComplement(BitMask).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForStarted;
                \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\) then 
                            \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(BitMask).0._Started\ <= true;
                            \BitMask::.ctor(BitMask).0.this.parameter.In\ <= \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\;
                            \BitMask::.ctor(BitMask).0.source.parameter.In\ <= \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= true;
                                    \BitMask::.ctor(BitMask).0._Started\ <= false;
                                    \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.this.parameter.Out\;
                                    \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.source.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\) then 
                            \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(BitMask).0._Started\ <= true;
                            \BitMask::.ctor(BitMask).0.this.parameter.In\ <= \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\;
                            \BitMask::.ctor(BitMask).0.source.parameter.In\ <= \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= true;
                                    \BitMask::.ctor(BitMask).0._Started\ <= false;
                                    \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.this.parameter.Out\;
                                    \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.source.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(BitMask).0._Started\ <= true;
                            \BitMask::.ctor(BitMask).0.this.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\;
                            \BitMask::.ctor(BitMask).0.source.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= true;
                                    \BitMask::.ctor(BitMask).0._Started\ <= false;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.this.parameter.Out\;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.source.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(BitMask).0._Started\ <= true;
                            \BitMask::.ctor(BitMask).0.this.parameter.In\ <= \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\;
                            \BitMask::.ctor(BitMask).0.source.parameter.In\ <= \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= true;
                                    \BitMask::.ctor(BitMask).0._Started\ <= false;
                                    \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.this.parameter.Out\;
                                    \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.source.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\ := WaitingForStarted;
                \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.return\;
                                    \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.return\;
                                    \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\) then 
                            \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.In\ <= \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.size.parameter.In\ <= \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= false;
                                    \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.return\;
                                    \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    -- Signal connections for System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 (#0):
    \BitMask::op_LessThan(BitMask,BitMask).0._Started\ <= \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask)._Started.0\;
    \BitMask::op_LessThan(BitMask,BitMask).0.left.parameter.In\ <= \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask).left.parameter.Out.0\;
    \BitMask::op_LessThan(BitMask,BitMask).0.right.parameter.In\ <= \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask).right.parameter.Out.0\;
    \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask)._Finished.0\ <= \BitMask::op_LessThan(BitMask,BitMask).0._Finished\;
    \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.BitMask::op_LessThan(BitMask,BitMask).return.0\ <= \BitMask::op_LessThan(BitMask,BitMask).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\) then 
                            \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ := 0;
                            \BitMask::op_Addition(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_Addition(BitMask,BitMask).0.left.parameter.In\ <= \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_Addition(BitMask,BitMask).0.right.parameter.In\ <= \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Addition(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_Addition(BitMask,BitMask).0._Started\ <= false;
                                    \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask).return.0\ <= \BitMask::op_Addition(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_Addition(BitMask,UInt32).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::op_Addition(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_Addition(BitMask,BitMask).0.left.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_Addition(BitMask,BitMask).0.right.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Addition(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_Addition(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask).return.0\ <= \BitMask::op_Addition(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask::op_Addition(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_Addition(BitMask,BitMask).0.left.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_Addition(BitMask,BitMask).0.right.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Addition(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_Addition(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask).return.0\ <= \BitMask::op_Addition(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\) then 
                            \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ := 0;
                            \BitMask::op_Subtraction(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_Subtraction(BitMask,BitMask).0.left.parameter.In\ <= \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_Subtraction(BitMask,BitMask).0.right.parameter.In\ <= \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Subtraction(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_Subtraction(BitMask,BitMask).0._Started\ <= false;
                                    \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask).return.0\ <= \BitMask::op_Subtraction(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask::op_Subtraction(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_Subtraction(BitMask,BitMask).0.left.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_Subtraction(BitMask,BitMask).0.right.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Subtraction(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_Subtraction(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask).return.0\ <= \BitMask::op_Subtraction(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Subtraction(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean) start
    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\) then 
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt16,Boolean).0._Started\ <= true;
                            \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt16,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt16,Boolean).0._Started\ <= false;
                                    \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\ <= \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt16,Boolean).0._Started\ <= true;
                            \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt16,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt16,Boolean).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\ <= \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt16,Boolean).0._Started\ <= true;
                            \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt16,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt16,Boolean).0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\ <= \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt16,Boolean).0._Started\ <= true;
                            \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt16,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt16,Boolean).0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\ <= \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32) start
    \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ := 0;
                            \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_RightShift(BitMask,Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                            \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_LeftShift(BitMask,Int32).Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Explicit(Posit).0.BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32) start
    \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\) then 
                            \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ := 0;
                            \BitMask::op_RightShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\ <= \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\ <= \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_RightShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := AfterFinished;
                                    \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_RightShift(BitMask,Int32).0._Started\ <= false;
                                    \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32).return.0\ <= \BitMask::op_RightShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                            \BitMask::op_LeftShift(BitMask,Int32).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::op_RightShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_RightShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_RightShift(BitMask,Int32).0._Started\ <= false;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32).return.0\ <= \BitMask::op_RightShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\) then 
                            \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \BitMask::op_RightShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_RightShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_RightShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32).return.0\ <= \BitMask::op_RightShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \BitMask::op_RightShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_RightShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_RightShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32).return.0\ <= \BitMask::op_RightShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask::op_RightShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_RightShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask::op_RightShift(BitMask,Int32).0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32).return.0\ <= \BitMask::op_RightShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask) start
    -- Signal connections for Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0 (#0):
    \BitMask::op_OnesComplement(BitMask).0._Started\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask)._Started.0\;
    \BitMask::op_OnesComplement(BitMask).0.input.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask).input.parameter.Out.0\;
    \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask)._Finished.0\ <= \BitMask::op_OnesComplement(BitMask).0._Finished\;
    \BitMask::GetTwosComplement(UInt16).0.BitMask::op_OnesComplement(BitMask).return.0\ <= \BitMask::op_OnesComplement(BitMask).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32) start
    \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::op_Addition(BitMask,UInt32).0._Started\ <= true;
                            \BitMask::op_Addition(BitMask,UInt32).0.left.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\;
                            \BitMask::op_Addition(BitMask,UInt32).0.right.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Addition(BitMask,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= true;
                                    \BitMask::op_Addition(BitMask,UInt32).0._Started\ <= false;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32).return.0\ <= \BitMask::op_Addition(BitMask,UInt32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::op_Addition(BitMask,UInt32).0._Started\ <= true;
                            \BitMask::op_Addition(BitMask,UInt32).0.left.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\;
                            \BitMask::op_Addition(BitMask,UInt32).0.right.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Addition(BitMask,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= true;
                                    \BitMask::op_Addition(BitMask,UInt32).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32).return.0\ <= \BitMask::op_Addition(BitMask,UInt32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask::op_Addition(BitMask,UInt32).0._Started\ <= true;
                            \BitMask::op_Addition(BitMask,UInt32).0.left.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\;
                            \BitMask::op_Addition(BitMask,UInt32).0.right.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Addition(BitMask,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= true;
                                    \BitMask::op_Addition(BitMask,UInt32).0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32).return.0\ <= \BitMask::op_Addition(BitMask,UInt32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition() start
    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0
                case \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= true;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ <= false;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= true;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32).0 (#0):
    \Posit::.ctor(PositEnvironment,UInt32).0._Started\ <= \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\;
    \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.In\ <= \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.Out.0\;
    \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.In\ <= \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.Out.0\;
    \Posit::.ctor(PositEnvironment,UInt32).0.value.parameter.In\ <= \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).value.parameter.Out.0\;
    \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Finished.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0._Finished\;
    \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.Out\;
    \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask() start
    -- Signal connections for System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0 (#0):
    \Posit::get_SignBitMask().0._Started\ <= \Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\;
    \Posit::get_SignBitMask().0.this.parameter.In\ <= \Posit::IsPositive().0.Posit::get_SignBitMask().this.parameter.Out.0\;
    \Posit::IsPositive().0.Posit::get_SignBitMask()._Finished.0\ <= \Posit::get_SignBitMask().0._Finished\;
    \Posit::IsPositive().0.Posit::get_SignBitMask().return.0\ <= \Posit::get_SignBitMask().0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0
                case \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\) then 
                            \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ := 0;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.left.parameter.In\ <= \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.right.parameter.In\ <= \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := AfterFinished;
                                    \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsPositive().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.left.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_BitwiseAnd(BitMask,BitMask).0.right.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\ <= \BitMask::op_BitwiseAnd(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask() start
    \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0
                case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\) then 
                            \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningIndex.0\ := 0;
                            \Posit::get_EmptyBitMask().0._Started\ <= true;
                            \Posit::get_EmptyBitMask().0.this.parameter.In\ <= \Posit::IsPositive().0.Posit::get_EmptyBitMask().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::get_EmptyBitMask().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\ := AfterFinished;
                                    \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\ <= true;
                                    \Posit::get_EmptyBitMask().0._Started\ <= false;
                                    \Posit::IsPositive().0.Posit::get_EmptyBitMask().return.0\ <= \Posit::get_EmptyBitMask().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsZero().0
                case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\) then 
                            \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningIndex.0\ := 0;
                            \Posit::get_EmptyBitMask().0._Started\ <= true;
                            \Posit::get_EmptyBitMask().0.this.parameter.In\ <= \Posit::IsZero().0.Posit::get_EmptyBitMask().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::get_EmptyBitMask().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\ := AfterFinished;
                                    \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\ <= true;
                                    \Posit::get_EmptyBitMask().0._Started\ <= false;
                                    \Posit::IsZero().0.Posit::get_EmptyBitMask().return.0\ <= \Posit::get_EmptyBitMask().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\) then 
                            \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \Posit::get_EmptyBitMask().0._Started\ <= true;
                            \Posit::get_EmptyBitMask().0.this.parameter.In\ <= \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::get_EmptyBitMask().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\ <= true;
                                    \Posit::get_EmptyBitMask().0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().return.0\ <= \Posit::get_EmptyBitMask().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::get_EmptyBitMask().0._Started\ <= true;
                            \Posit::get_EmptyBitMask().0.this.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::get_EmptyBitMask().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\ <= true;
                                    \Posit::get_EmptyBitMask().0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().return.0\ <= \Posit::get_EmptyBitMask().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask() end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0
                case \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\) then 
                            \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ := 0;
                            \BitMask::op_Equality(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\ <= \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\ <= \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Equality(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := AfterFinished;
                                    \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_Equality(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask).return.0\ <= \BitMask::op_Equality(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsPositive().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0
                case \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\) then 
                            \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningIndex.0\ := 0;
                            \BitMask::op_Equality(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\ <= \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\ <= \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Equality(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\ := AfterFinished;
                                    \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_Equality(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask).return.0\ <= \BitMask::op_Equality(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsNaN().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsZero().0
                case \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\) then 
                            \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningIndex.0\ := 0;
                            \BitMask::op_Equality(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\ <= \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\ <= \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Equality(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\ := AfterFinished;
                                    \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_Equality(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask).return.0\ <= \BitMask::op_Equality(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsZero().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::op_Equality(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Equality(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_Equality(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask).return.0\ <= \BitMask::op_Equality(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \BitMask::op_Equality(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_Equality(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_Equality(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask).return.0\ <= \BitMask::op_Equality(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask() start
    -- Signal connections for System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0 (#0):
    \Posit::get_NaNBitMask().0._Started\ <= \Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\;
    \Posit::get_NaNBitMask().0.this.parameter.In\ <= \Posit::IsNaN().0.Posit::get_NaNBitMask().this.parameter.Out.0\;
    \Posit::IsNaN().0.Posit::get_NaNBitMask()._Finished.0\ <= \Posit::get_NaNBitMask().0._Finished\;
    \Posit::IsNaN().0.Posit::get_NaNBitMask().return.0\ <= \Posit::get_NaNBitMask().0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32) start
    -- Signal connections for Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0 (#0):
    \BitMask::op_Subtraction(BitMask,UInt32).0._Started\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32)._Started.0\;
    \BitMask::op_Subtraction(BitMask,UInt32).0.left.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32).left.parameter.Out.0\;
    \BitMask::op_Subtraction(BitMask,UInt32).0.right.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32).right.parameter.Out.0\;
    \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32)._Finished.0\ <= \BitMask::op_Subtraction(BitMask,UInt32).0._Finished\;
    \Posit::EncodeRegimeBits(Int32).0.BitMask::op_Subtraction(BitMask,UInt32).return.0\ <= \BitMask::op_Subtraction(BitMask,UInt32).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32) start
    -- Signal connections for Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 (#0):
    \Posit::EncodeRegimeBits(Int32).0._Started\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\;
    \Posit::EncodeRegimeBits(Int32).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).this.parameter.Out.0\;
    \Posit::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\;
    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Finished.0\ <= \Posit::EncodeRegimeBits(Int32).0._Finished\;
    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).return.0\ <= \Posit::EncodeRegimeBits(Int32).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= true;
                            \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::LengthOfRunOfBits(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= true;
                                    \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).return.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= true;
                            \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::LengthOfRunOfBits(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= true;
                                    \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).return.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0
                case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\) then 
                            \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningIndex.0\ := 0;
                            \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= true;
                            \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\ <= \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\ <= \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::LengthOfRunOfBits(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= true;
                                    \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= false;
                                    \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0
                case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\) then 
                            \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningIndex.0\ := 0;
                            \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= true;
                            \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\ <= \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\ <= \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::LengthOfRunOfBits(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= true;
                                    \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= false;
                                    \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::SetOne(UInt16).0._Started\ <= true;
                            \BitMask::SetOne(UInt16).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\;
                            \BitMask::SetOne(UInt16).0.index.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::SetOne(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\ <= true;
                                    \BitMask::SetOne(UInt16).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\ <= \BitMask::SetOne(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \BitMask::SetOne(UInt16).0._Started\ <= true;
                            \BitMask::SetOne(UInt16).0.this.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).this.parameter.Out.0\;
                            \BitMask::SetOne(UInt16).0.index.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::SetOne(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\ <= true;
                                    \BitMask::SetOne(UInt16).0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).return.0\ <= \BitMask::SetOne(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask::SetOne(UInt16).0._Started\ <= true;
                            \BitMask::SetOne(UInt16).0.this.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).this.parameter.Out.0\;
                            \BitMask::SetOne(UInt16).0.index.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::SetOne(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\ <= true;
                                    \BitMask::SetOne(UInt16).0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).return.0\ <= \BitMask::SetOne(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\ <= \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ <= true;
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\ <= \BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits() start
    \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::GetLowest32Bits().0._Started\ <= true;
                            \BitMask::GetLowest32Bits().0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetLowest32Bits().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\ <= true;
                                    \BitMask::GetLowest32Bits().0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().return.0\ <= \BitMask::GetLowest32Bits().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\) then 
                            \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \BitMask::GetLowest32Bits().0._Started\ <= true;
                            \BitMask::GetLowest32Bits().0.this.parameter.In\ <= \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetLowest32Bits().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\ <= true;
                                    \BitMask::GetLowest32Bits().0._Started\ <= false;
                                    \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().return.0\ <= \BitMask::GetLowest32Bits().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\) then 
                            \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \BitMask::GetLowest32Bits().0._Started\ <= true;
                            \BitMask::GetLowest32Bits().0.this.parameter.In\ <= \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetLowest32Bits().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\ <= true;
                                    \BitMask::GetLowest32Bits().0._Started\ <= false;
                                    \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().return.0\ <= \BitMask::GetLowest32Bits().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::op_UnaryNegation(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::op_UnaryNegation(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::op_UnaryNegation(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::op_UnaryNegation(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::op_UnaryNegation(Posit).0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::op_UnaryNegation(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::op_UnaryNegation(Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16) start
    -- Signal connections for Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 (#0):
    \BitMask::SetZero(UInt16).0._Started\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\;
    \BitMask::SetZero(UInt16).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).this.parameter.Out.0\;
    \BitMask::SetZero(UInt16).0.index.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).index.parameter.Out.0\;
    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Finished.0\ <= \BitMask::SetZero(UInt16).0._Finished\;
    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).return.0\ <= \BitMask::SetZero(UInt16).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsPositive() start
    \Hast::InternalInvocationProxy().Posit::IsPositive()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\ <= false;
                \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\ <= false;
                \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\ <= false;
                \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\ <= false;
                \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\) then 
                            \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::GetRegimeKValue().0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::ExponentSize().0.Posit::IsPositive()._Started.0\) then 
                            \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::ExponentSize().0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::ExponentSize().0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::ExponentSize().0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\) then 
                            \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::GetExponentValue().0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::GetExponentValue().0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionSize().0.Posit::IsPositive()._Started.0\) then 
                            \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::FractionSize().0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::FractionSize().0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionSize().0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::FractionWithHiddenBit().0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::op_Explicit(Posit).0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::op_Explicit(Posit).0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsPositive() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask() start
    -- Signal connections for System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0 (#0):
    \Posit::get_FirstRegimeBitBitMask().0._Started\ <= \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\;
    \Posit::get_FirstRegimeBitBitMask().0.this.parameter.In\ <= \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().this.parameter.Out.0\;
    \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Finished.0\ <= \Posit::get_FirstRegimeBitBitMask().0._Finished\;
    \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().return.0\ <= \Posit::get_FirstRegimeBitBitMask().0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::FractionSize() start
    \Hast::InternalInvocationProxy().Posit::FractionSize()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\ <= false;
                \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\) then 
                            \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \Posit::FractionSize().0._Started\ <= true;
                            \Posit::FractionSize().0.this.parameter.In\ <= \Posit::GetExponentValue().0.Posit::FractionSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\ <= true;
                                    \Posit::FractionSize().0._Started\ <= false;
                                    \Posit::GetExponentValue().0.Posit::FractionSize().return.0\ <= \Posit::FractionSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \Posit::FractionSize().0._Started\ <= true;
                            \Posit::FractionSize().0.this.parameter.In\ <= \Posit::FractionWithHiddenBit().0.Posit::FractionSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\ <= true;
                                    \Posit::FractionSize().0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.Posit::FractionSize().return.0\ <= \Posit::FractionSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::FractionSize().0._Started\ <= true;
                            \Posit::FractionSize().0.this.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\ <= true;
                                    \Posit::FractionSize().0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\ <= \Posit::FractionSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::FractionSize() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize() start
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0 (#0):
    \Posit::ExponentSize().0._Started\ <= \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\;
    \Posit::ExponentSize().0.this.parameter.In\ <= \Posit::GetExponentValue().0.Posit::ExponentSize().this.parameter.Out.0\;
    \Posit::GetExponentValue().0.Posit::ExponentSize()._Finished.0\ <= \Posit::ExponentSize().0._Finished\;
    \Posit::GetExponentValue().0.Posit::ExponentSize().return.0\ <= \Posit::ExponentSize().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit) start
    -- Signal connections for Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 (#0):
    \Posit::op_UnaryNegation(Posit).0._Started\ <= \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Started.0\;
    \Posit::op_UnaryNegation(Posit).0.x.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit).x.parameter.Out.0\;
    \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit)._Finished.0\ <= \Posit::op_UnaryNegation(Posit).0._Finished\;
    \Posit::op_Addition(Posit,Posit).0.Posit::op_UnaryNegation(Posit).return.0\ <= \Posit::op_UnaryNegation(Posit).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit) end


    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue() start
    \Hast::InternalInvocationProxy().Posit::GetRegimeKValue()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
                \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::GetRegimeKValue().0._Started\ <= true;
                            \Posit::GetRegimeKValue().0.this.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::GetRegimeKValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit::GetRegimeKValue().0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\ <= \Posit::GetRegimeKValue().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \Posit::GetRegimeKValue().0._Started\ <= true;
                            \Posit::GetRegimeKValue().0.this.parameter.In\ <= \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::GetRegimeKValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit::GetRegimeKValue().0._Started\ <= false;
                                    \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().return.0\ <= \Posit::GetRegimeKValue().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue() start
    \Hast::InternalInvocationProxy().Posit::GetExponentValue()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
                \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::GetExponentValue().0._Started\ <= true;
                            \Posit::GetExponentValue().0.this.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::GetExponentValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\ <= true;
                                    \Posit::GetExponentValue().0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\ <= \Posit::GetExponentValue().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \Posit::GetExponentValue().0._Started\ <= true;
                            \Posit::GetExponentValue().0.this.parameter.In\ <= \Posit::op_Explicit(Posit).0.Posit::GetExponentValue().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::GetExponentValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\ <= true;
                                    \Posit::GetExponentValue().0._Started\ <= false;
                                    \Posit::op_Explicit(Posit).0.Posit::GetExponentValue().return.0\ <= \Posit::GetExponentValue().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue() end


    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte) start
    -- Signal connections for Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 (#0):
    \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Started\ <= \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\;
    \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\;
    \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\;
    \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
    \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\ <= \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Finished\;
    \Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\ <= \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit() start
    \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
                \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::FractionWithHiddenBit().0._Started\ <= true;
                            \Posit::FractionWithHiddenBit().0.this.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::FractionWithHiddenBit().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= true;
                                    \Posit::FractionWithHiddenBit().0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\ <= \Posit::FractionWithHiddenBit().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\) then 
                            \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \Posit::FractionWithHiddenBit().0._Started\ <= true;
                            \Posit::FractionWithHiddenBit().0.this.parameter.In\ <= \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::FractionWithHiddenBit().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= true;
                                    \Posit::FractionWithHiddenBit().0._Started\ <= false;
                                    \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().return.0\ <= \Posit::FractionWithHiddenBit().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_UnaryNegation(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_UnaryNegation(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_UnaryNegation(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
                \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\) then 
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::.ctor(PositEnvironment,BitMask).0._Started\ <= true;
                            \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.bits.parameter.In\ <= \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::.ctor(PositEnvironment,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= true;
                                    \Posit::.ctor(PositEnvironment,BitMask).0._Started\ <= false;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.Out\;
                                    \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_UnaryNegation(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\) then 
                            \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_UnaryNegation(Posit).0.runningIndex.0\ := 0;
                            \Posit::.ctor(PositEnvironment,BitMask).0._Started\ <= true;
                            \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.In\ <= \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.In\ <= \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.bits.parameter.In\ <= \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_UnaryNegation(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::.ctor(PositEnvironment,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_UnaryNegation(Posit).0.runningState.0\ := AfterFinished;
                                    \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= true;
                                    \Posit::.ctor(PositEnvironment,BitMask).0._Started\ <= false;
                                    \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.Out\;
                                    \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsNaN() start
    -- Signal connections for Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 (#0):
    \Posit::IsNaN().0._Started\ <= \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\;
    \Posit::IsNaN().0.this.parameter.In\ <= \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().this.parameter.Out.0\;
    \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Finished.0\ <= \Posit::IsNaN().0._Finished\;
    \Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().return.0\ <= \Posit::IsNaN().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsNaN() end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsZero() start
    -- Signal connections for Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 (#0):
    \Posit::IsZero().0._Started\ <= \Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\;
    \Posit::IsZero().0.this.parameter.In\ <= \Posit::op_UnaryNegation(Posit).0.Posit::IsZero().this.parameter.Out.0\;
    \Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Finished.0\ <= \Posit::IsZero().0._Finished\;
    \Posit::op_UnaryNegation(Posit).0.Posit::IsZero().return.0\ <= \Posit::IsZero().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsZero() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Finished.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::SimpleMemoryOperationProxy() start
    \CellIndex\ <= to_integer(\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\) when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ or \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ else 0;
    \DataOut\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.DataOut\ when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ else "00000000000000000000000000000000";
    \ReadEnable\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\;
    \WriteEnable\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\;
    -- System.Void Hast::SimpleMemoryOperationProxy() end

end Imp;
