-- Generated by Hastlayer (hastlayer.com) at <date and time removed for approval testing> for the following hardware entry points: 
-- * System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculatePowerOfReal(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)
-- * System.Void Hast.Samples.SampleAssembly.Posit32Calculator::AddPositsInArray(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)

-- VHDL libraries necessary for the generated code to work. These libraries are included here instead of being managed separately in the Hardware Framework so they can be more easily updated.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package TypeConversion is
    function SmartResize(input: unsigned; size: natural) return unsigned;
    function SmartResize(input: signed; size: natural) return signed;
    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned;
end TypeConversion;
        
package body TypeConversion is

    -- The .NET behavior is different than that of resize() ("To create a larger vector, the new [leftmost] bit 
    -- positions are filled with the sign bit(ARG'LEFT). When truncating, the sign bit is retained along with the 
    -- rightmost part.") when casting to a smaller type: "If the source type is larger than the destination type, 
    -- then the source value is truncated by discarding its "extra" most significant bits. The result is then 
    -- treated as a value of the destination type." Thus we need to simply truncate when casting down. See:
    -- https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions
    function SmartResize(input: unsigned; size: natural) return unsigned is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            -- Resize() is supposed to work with little endian numbers: "When truncating, the sign bit is retained
            -- along with the rightmost part." for signed numbers and "When truncating, the leftmost bits are 
            -- dropped." for unsigned ones. See: http://www.csee.umbc.edu/portal/help/VHDL/numeric_std.vhdl
            return resize(input, size);
        end if;
    end SmartResize;

    function SmartResize(input: signed; size: natural) return signed is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            return resize(input, size);
        end if;
    end SmartResize;

    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned is
        variable result: unsigned(size - 1 downto 0);
    begin
        if (input >= 0) then
            return resize(unsigned(input), size);
        else 
            result := (others => '1');
            result(input'LENGTH - 1 downto 0) := unsigned(input);
            return result;
        end if;
    end ToUnsignedAndExpand;

end TypeConversion;


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
        
package SimpleMemory is
    -- Data conversion functions:
    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned;
        
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector;
    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean;
        
    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed;
end SimpleMemory;
        
package body SimpleMemory is

    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertUInt32ToStdLogicVector;
    
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned is
    begin
        return unsigned(input);
    end ConvertStdLogicVectorToUInt32;
    
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector is 
    begin
        case input is
            when true => return X"FFFFFFFF";
            when false => return X"00000000";
            when others => return X"00000000";
        end case;
    end ConvertBooleanToStdLogicVector;

    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean is 
    begin
        -- In .NET a false is all zeros while a true is at least one 1 bit (or more), so using the same logic here.
        return not(input = X"00000000");
    end ConvertStdLogicVectorToBoolean;

    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertInt32ToStdLogicVector;

    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed is
    begin
        return signed(input);
    end ConvertStdLogicVectorToInt32;

end SimpleMemory;

-- Hast_IP, logic generated from the input .NET assemblies starts here.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library work;
use work.TypeConversion.all;
library work;
use work.SimpleMemory.all;

entity Hast_IP is 
    port(
        \DataIn\: In std_logic_vector(31 downto 0);
        \DataOut\: Out std_logic_vector(31 downto 0);
        \CellIndex\: Out integer;
        \ReadEnable\: Out boolean;
        \WriteEnable\: Out boolean;
        \ReadsDone\: In boolean;
        \WritesDone\: In boolean;
        \MemberId\: In integer;
        \Reset\: In std_logic;
        \Started\: In boolean;
        \Finished\: Out boolean;
        \Clock\: In std_logic
    );
    -- (Hast_IP ID removed for approval testing.)
    -- (Date and time removed for approval testing.)
    -- Generated by Hastlayer - hastlayer.com

    -- Hast_IP's simple interface makes it suitable to plug it into any hardware implementation. The meaning and usage of the ports are as below:
    -- * MemberId: Each transformed .NET hardware entry point member (i.e. methods that are configured to be available to be called from the host PC) has a unique zero-based numeric ID. When selecting which one to execute this ID should be used. 
    -- * Started: Indicates whether the execution of a given hardware entry point member is started. Used in the following way:
    --     1. Started is set to TRUE by the consuming framework, after which the execution of the given member starts internally. The Finished port will be initially set to FALSE.
    --     2. Once the execution is finished, the Finished port will be set to TRUE.
    --     3. The consuming framework sets Started to FALSE, after which Finished will also be set to FALSE.
    -- * Finished: Indicates whether the execution of a given hardware entry point member is complete. See the documentation of the Started port above on how it is used.
    -- * Reset: Synchronous reset.
    -- * Clock: The main clock.
    -- * DataIn: Data read out from the memory (usually on-board DDR RAM, but depends on the framework) should be assigned to this port by the framework. The width of this port depends on the hardware platform but is at least 32b. Inputs of the algorithm implemented in Hast_IP all come through this port.
    -- * DataOut: Data to be written to the memory is assigned to this port. The width of this port depends on the hardware platform but is at least 32b. Outputs of the algorithm implemented in Hast_IP all go through this port.
    -- * CellIndex: Zero-based index of the SimpleMemory memory cell currently being read or written. Transformed code in Hastlayer can access memory in a simplified fashion by addressing 32b "cells", the accessible physical memory space being divided up in such individually addressable cells. The value of CellIndex is always aligned to the width of the DataIn and DataOut ports, so e.g. with 128b data ports CellIndex will always contain a value which is a >= 0 integer multiple of 4 (since 128 / 32 = 4).
    -- * ReadEnable: Indicates whether a memory read operation is initiated. The process of a memory read is as following:
    --     1. ReadEnable is FALSE by default. It's set to TRUE when a memory read is started. CellIndex is set to the index of the memory cell to be read out.
    --     2. Waiting for ReadsDone to be TRUE.
    --     3. Once ReadsDone is TRUE, data from DataIn will be read out and ReadEnable set to FALSE.
    -- * WriteEnable: Indicates whether a memory write operation is initiated. The process of a memory write is as following:
    --     1. WriteEnable is FALSE by default. It's set to TRUE when a memory write is started. CellIndex is set to the index of the memory cell to be written and the output data is assigned to DataOut.
    --     2. Waiting for WritesDone to be TRUE.
    --     3. Once WritesDone is TRUE, WriteEnable is set to FALSE.
    -- * ReadsDone: Indicates whether a memory read operation is completed.
    -- * WritesDone: Indicates whether a memory write operation is completed.

end Hast_IP;

architecture Imp of Hast_IP is 
    -- This IP was generated by Hastlayer from .NET code to mimic the original logic. Note the following:
    -- * For each member (methods, functions, properties) in .NET a state machine was generated. Each state machine's name corresponds to 
    --   the original member's name.
    -- * Inputs and outputs are passed between state machines as shared objects.
    -- * There are operations that take multiple clock cycles like interacting with the memory and long-running arithmetic operations 
    --   (modulo, division, multiplication). These are awaited in subsequent states but be aware that some states can take more 
    --   than one clock cycle to produce their output.
    -- * The ExternalInvocationProxy process dispatches invocations that were started from the outside to the state machines.
    -- * The InternalInvocationProxy processes dispatch invocations between state machines.

    -- Custom inter-dependent type declarations start
    type \signed32_Array\ is array (integer range <>) of signed(31 downto 0);
    type \Lombiq.Arithmetics.Posit32\ is record 
        \IsNull\: boolean;
        \PositBits\: unsigned(31 downto 0);
    end record;
    -- Custom inter-dependent type declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).0 declarations start
    -- State machine states:
    type \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._States\ is (
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_0\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_1\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_2\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_3\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_4\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_5\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_6\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_7\);
    -- Signals:
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._Finished\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).value.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Started.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Started.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._Started\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.upToNumberObject.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).return.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32).return.0\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).0 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).1 declarations start
    -- State machine states:
    type \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._States\ is (
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_0\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_1\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_2\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_3\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_4\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_5\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_6\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_7\);
    -- Signals:
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._Finished\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).value.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Started.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Started.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Started.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._Started\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.upToNumberObject.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).return.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32).return.0\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).1 declarations end


    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).2 declarations start
    -- State machine states:
    type \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._States\ is (
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_0\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_1\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_2\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_3\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_4\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_5\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_6\, 
        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_7\);
    -- Signals:
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._Finished\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).value.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Started.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Started.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Started.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._Started\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.upToNumberObject.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).return.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32).return.0\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).2 declarations end


    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._States\ is (
        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\, 
        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_1\, 
        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_2\, 
        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_3\, 
        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\, 
        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\, 
        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_6\, 
        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_7\, 
        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_8\, 
        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_9\);
    -- Signals:
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\: boolean := false;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0);
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\: boolean := false;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\: boolean := false;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Started.0\: boolean := false;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\: boolean := false;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).return.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32).return.0\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculatePowerOfReal(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._States\ is (
        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_0\, 
        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_1\, 
        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_2\, 
        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_3\, 
        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_4\, 
        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_5\, 
        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_6\, 
        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_7\, 
        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_8\, 
        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_9\, 
        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_10\);
    -- Signals:
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._Finished\: boolean := false;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0);
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\: boolean := false;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\: boolean := false;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32).left.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32).right.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32)._Started.0\: boolean := false;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._Started\: boolean := false;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\: boolean := false;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32).return.0\: \Lombiq.Arithmetics.Posit32\;
    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculatePowerOfReal(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._States\ is (
        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_0\, 
        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_1\, 
        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_2\, 
        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_3\, 
        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_4\, 
        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_5\, 
        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_6\, 
        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_7\, 
        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_8\, 
        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_9\);
    -- Signals:
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._Finished\: boolean := false;
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0);
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.0\: boolean := false;
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.1\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.1\: boolean := false;
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.2\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.2\: boolean := false;
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._Started\: boolean := false;
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Finished.1\: boolean := false;
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Finished.2\: boolean := false;
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).return.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).return.1\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).return.2\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::AddPositsInArray(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \Posit32Calculator::AddPositsInArray(SimpleMemory).0._States\ is (
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_0\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_1\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_2\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_3\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_4\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_5\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_6\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_7\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_8\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_9\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_10\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_11\, 
        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_12\);
    -- Signals:
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0._Finished\: boolean := false;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0);
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\: boolean := false;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\: boolean := false;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\: boolean := false;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0._Started\: boolean := false;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\: boolean := false;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\: boolean := false;
    Signal \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).return.0\: \Lombiq.Arithmetics.Posit32\;
    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::AddPositsInArray(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 declarations start
    -- State machine states:
    type \Posit32::.ctor(UInt32,Boolean).0._States\ is (
        \Posit32::.ctor(UInt32,Boolean).0._State_0\, 
        \Posit32::.ctor(UInt32,Boolean).0._State_1\, 
        \Posit32::.ctor(UInt32,Boolean).0._State_2\);
    -- Signals:
    Signal \Posit32::.ctor(UInt32,Boolean).0._Finished\: boolean := false;
    Signal \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32,Boolean).0._Started\: boolean := false;
    Signal \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\: boolean := false;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).1 declarations start
    -- State machine states:
    type \Posit32::.ctor(UInt32,Boolean).1._States\ is (
        \Posit32::.ctor(UInt32,Boolean).1._State_0\, 
        \Posit32::.ctor(UInt32,Boolean).1._State_1\, 
        \Posit32::.ctor(UInt32,Boolean).1._State_2\);
    -- Signals:
    Signal \Posit32::.ctor(UInt32,Boolean).1._Finished\: boolean := false;
    Signal \Posit32::.ctor(UInt32,Boolean).1.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32,Boolean).1._Started\: boolean := false;
    Signal \Posit32::.ctor(UInt32,Boolean).1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32,Boolean).1.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32,Boolean).1.fromBitMask.parameter.In\: boolean := false;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).1 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).2 declarations start
    -- State machine states:
    type \Posit32::.ctor(UInt32,Boolean).2._States\ is (
        \Posit32::.ctor(UInt32,Boolean).2._State_0\, 
        \Posit32::.ctor(UInt32,Boolean).2._State_1\, 
        \Posit32::.ctor(UInt32,Boolean).2._State_2\);
    -- Signals:
    Signal \Posit32::.ctor(UInt32,Boolean).2._Finished\: boolean := false;
    Signal \Posit32::.ctor(UInt32,Boolean).2.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32,Boolean).2._Started\: boolean := false;
    Signal \Posit32::.ctor(UInt32,Boolean).2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32,Boolean).2.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32,Boolean).2.fromBitMask.parameter.In\: boolean := false;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).2 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::.ctor(UInt32).0._States\ is (
        \Posit32::.ctor(UInt32).0._State_0\, 
        \Posit32::.ctor(UInt32).0._State_1\, 
        \Posit32::.ctor(UInt32).0._State_2\, 
        \Posit32::.ctor(UInt32).0._State_3\, 
        \Posit32::.ctor(UInt32).0._State_4\, 
        \Posit32::.ctor(UInt32).0._State_5\, 
        \Posit32::.ctor(UInt32).0._State_6\, 
        \Posit32::.ctor(UInt32).0._State_7\, 
        \Posit32::.ctor(UInt32).0._State_8\, 
        \Posit32::.ctor(UInt32).0._State_9\);
    -- Signals:
    Signal \Posit32::.ctor(UInt32).0._Finished\: boolean := false;
    Signal \Posit32::.ctor(UInt32).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).0._Started\: boolean := false;
    Signal \Posit32::.ctor(UInt32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32).0.value.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).1 declarations start
    -- State machine states:
    type \Posit32::.ctor(UInt32).1._States\ is (
        \Posit32::.ctor(UInt32).1._State_0\, 
        \Posit32::.ctor(UInt32).1._State_1\, 
        \Posit32::.ctor(UInt32).1._State_2\, 
        \Posit32::.ctor(UInt32).1._State_3\, 
        \Posit32::.ctor(UInt32).1._State_4\, 
        \Posit32::.ctor(UInt32).1._State_5\, 
        \Posit32::.ctor(UInt32).1._State_6\, 
        \Posit32::.ctor(UInt32).1._State_7\, 
        \Posit32::.ctor(UInt32).1._State_8\, 
        \Posit32::.ctor(UInt32).1._State_9\);
    -- Signals:
    Signal \Posit32::.ctor(UInt32).1._Finished\: boolean := false;
    Signal \Posit32::.ctor(UInt32).1.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).1._Started\: boolean := false;
    Signal \Posit32::.ctor(UInt32).1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32).1.value.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).1 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).2 declarations start
    -- State machine states:
    type \Posit32::.ctor(UInt32).2._States\ is (
        \Posit32::.ctor(UInt32).2._State_0\, 
        \Posit32::.ctor(UInt32).2._State_1\, 
        \Posit32::.ctor(UInt32).2._State_2\, 
        \Posit32::.ctor(UInt32).2._State_3\, 
        \Posit32::.ctor(UInt32).2._State_4\, 
        \Posit32::.ctor(UInt32).2._State_5\, 
        \Posit32::.ctor(UInt32).2._State_6\, 
        \Posit32::.ctor(UInt32).2._State_7\, 
        \Posit32::.ctor(UInt32).2._State_8\, 
        \Posit32::.ctor(UInt32).2._State_9\);
    -- Signals:
    Signal \Posit32::.ctor(UInt32).2._Finished\: boolean := false;
    Signal \Posit32::.ctor(UInt32).2.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).2._Started\: boolean := false;
    Signal \Posit32::.ctor(UInt32).2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(UInt32).2.value.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).2 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 declarations start
    -- State machine states:
    type \Posit32::.ctor(Int32).0._States\ is (
        \Posit32::.ctor(Int32).0._State_0\, 
        \Posit32::.ctor(Int32).0._State_1\, 
        \Posit32::.ctor(Int32).0._State_2\, 
        \Posit32::.ctor(Int32).0._State_3\, 
        \Posit32::.ctor(Int32).0._State_4\, 
        \Posit32::.ctor(Int32).0._State_5\, 
        \Posit32::.ctor(Int32).0._State_6\, 
        \Posit32::.ctor(Int32).0._State_7\, 
        \Posit32::.ctor(Int32).0._State_8\, 
        \Posit32::.ctor(Int32).0._State_9\);
    -- Signals:
    Signal \Posit32::.ctor(Int32).0._Finished\: boolean := false;
    Signal \Posit32::.ctor(Int32).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).0._Started\: boolean := false;
    Signal \Posit32::.ctor(Int32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.value.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).1 declarations start
    -- State machine states:
    type \Posit32::.ctor(Int32).1._States\ is (
        \Posit32::.ctor(Int32).1._State_0\, 
        \Posit32::.ctor(Int32).1._State_1\, 
        \Posit32::.ctor(Int32).1._State_2\, 
        \Posit32::.ctor(Int32).1._State_3\, 
        \Posit32::.ctor(Int32).1._State_4\, 
        \Posit32::.ctor(Int32).1._State_5\, 
        \Posit32::.ctor(Int32).1._State_6\, 
        \Posit32::.ctor(Int32).1._State_7\, 
        \Posit32::.ctor(Int32).1._State_8\, 
        \Posit32::.ctor(Int32).1._State_9\);
    -- Signals:
    Signal \Posit32::.ctor(Int32).1._Finished\: boolean := false;
    Signal \Posit32::.ctor(Int32).1.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).value.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).1._Started\: boolean := false;
    Signal \Posit32::.ctor(Int32).1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).1.value.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).1 declarations end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).2 declarations start
    -- State machine states:
    type \Posit32::.ctor(Int32).2._States\ is (
        \Posit32::.ctor(Int32).2._State_0\, 
        \Posit32::.ctor(Int32).2._State_1\, 
        \Posit32::.ctor(Int32).2._State_2\, 
        \Posit32::.ctor(Int32).2._State_3\, 
        \Posit32::.ctor(Int32).2._State_4\, 
        \Posit32::.ctor(Int32).2._State_5\, 
        \Posit32::.ctor(Int32).2._State_6\, 
        \Posit32::.ctor(Int32).2._State_7\, 
        \Posit32::.ctor(Int32).2._State_8\, 
        \Posit32::.ctor(Int32).2._State_9\);
    -- Signals:
    Signal \Posit32::.ctor(Int32).2._Finished\: boolean := false;
    Signal \Posit32::.ctor(Int32).2.this.parameter.Out\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).value.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).2._Started\: boolean := false;
    Signal \Posit32::.ctor(Int32).2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).2.value.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).2 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().0 declarations start
    -- State machine states:
    type \Posit32::IsPositive().0._States\ is (
        \Posit32::IsPositive().0._State_0\, 
        \Posit32::IsPositive().0._State_1\, 
        \Posit32::IsPositive().0._State_2\);
    -- Signals:
    Signal \Posit32::IsPositive().0._Finished\: boolean := false;
    Signal \Posit32::IsPositive().0.return\: boolean := false;
    Signal \Posit32::IsPositive().0._Started\: boolean := false;
    Signal \Posit32::IsPositive().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().1 declarations start
    -- State machine states:
    type \Posit32::IsPositive().1._States\ is (
        \Posit32::IsPositive().1._State_0\, 
        \Posit32::IsPositive().1._State_1\, 
        \Posit32::IsPositive().1._State_2\);
    -- Signals:
    Signal \Posit32::IsPositive().1._Finished\: boolean := false;
    Signal \Posit32::IsPositive().1.return\: boolean := false;
    Signal \Posit32::IsPositive().1._Started\: boolean := false;
    Signal \Posit32::IsPositive().1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().1 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().2 declarations start
    -- State machine states:
    type \Posit32::IsPositive().2._States\ is (
        \Posit32::IsPositive().2._State_0\, 
        \Posit32::IsPositive().2._State_1\, 
        \Posit32::IsPositive().2._State_2\);
    -- Signals:
    Signal \Posit32::IsPositive().2._Finished\: boolean := false;
    Signal \Posit32::IsPositive().2.return\: boolean := false;
    Signal \Posit32::IsPositive().2._Started\: boolean := false;
    Signal \Posit32::IsPositive().2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().2 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().0 declarations start
    -- State machine states:
    type \Posit32::IsNaN().0._States\ is (
        \Posit32::IsNaN().0._State_0\, 
        \Posit32::IsNaN().0._State_1\, 
        \Posit32::IsNaN().0._State_2\);
    -- Signals:
    Signal \Posit32::IsNaN().0._Finished\: boolean := false;
    Signal \Posit32::IsNaN().0.return\: boolean := false;
    Signal \Posit32::IsNaN().0._Started\: boolean := false;
    Signal \Posit32::IsNaN().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().1 declarations start
    -- State machine states:
    type \Posit32::IsNaN().1._States\ is (
        \Posit32::IsNaN().1._State_0\, 
        \Posit32::IsNaN().1._State_1\, 
        \Posit32::IsNaN().1._State_2\);
    -- Signals:
    Signal \Posit32::IsNaN().1._Finished\: boolean := false;
    Signal \Posit32::IsNaN().1.return\: boolean := false;
    Signal \Posit32::IsNaN().1._Started\: boolean := false;
    Signal \Posit32::IsNaN().1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().1 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().2 declarations start
    -- State machine states:
    type \Posit32::IsNaN().2._States\ is (
        \Posit32::IsNaN().2._State_0\, 
        \Posit32::IsNaN().2._State_1\, 
        \Posit32::IsNaN().2._State_2\);
    -- Signals:
    Signal \Posit32::IsNaN().2._Finished\: boolean := false;
    Signal \Posit32::IsNaN().2.return\: boolean := false;
    Signal \Posit32::IsNaN().2._Started\: boolean := false;
    Signal \Posit32::IsNaN().2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().2 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().0 declarations start
    -- State machine states:
    type \Posit32::IsZero().0._States\ is (
        \Posit32::IsZero().0._State_0\, 
        \Posit32::IsZero().0._State_1\, 
        \Posit32::IsZero().0._State_2\);
    -- Signals:
    Signal \Posit32::IsZero().0._Finished\: boolean := false;
    Signal \Posit32::IsZero().0.return\: boolean := false;
    Signal \Posit32::IsZero().0._Started\: boolean := false;
    Signal \Posit32::IsZero().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().1 declarations start
    -- State machine states:
    type \Posit32::IsZero().1._States\ is (
        \Posit32::IsZero().1._State_0\, 
        \Posit32::IsZero().1._State_1\, 
        \Posit32::IsZero().1._State_2\);
    -- Signals:
    Signal \Posit32::IsZero().1._Finished\: boolean := false;
    Signal \Posit32::IsZero().1.return\: boolean := false;
    Signal \Posit32::IsZero().1._Started\: boolean := false;
    Signal \Posit32::IsZero().1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().1 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().2 declarations start
    -- State machine states:
    type \Posit32::IsZero().2._States\ is (
        \Posit32::IsZero().2._State_0\, 
        \Posit32::IsZero().2._State_1\, 
        \Posit32::IsZero().2._State_2\);
    -- Signals:
    Signal \Posit32::IsZero().2._Finished\: boolean := false;
    Signal \Posit32::IsZero().2.return\: boolean := false;
    Signal \Posit32::IsZero().2._Started\: boolean := false;
    Signal \Posit32::IsZero().2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().2 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).0 declarations start
    -- State machine states:
    type \Posit32::EncodeRegimeBits(Int32).0._States\ is (
        \Posit32::EncodeRegimeBits(Int32).0._State_0\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_1\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_2\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_3\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_4\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_5\, 
        \Posit32::EncodeRegimeBits(Int32).0._State_6\);
    -- Signals:
    Signal \Posit32::EncodeRegimeBits(Int32).0._Finished\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).0._Started\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).1 declarations start
    -- State machine states:
    type \Posit32::EncodeRegimeBits(Int32).1._States\ is (
        \Posit32::EncodeRegimeBits(Int32).1._State_0\, 
        \Posit32::EncodeRegimeBits(Int32).1._State_1\, 
        \Posit32::EncodeRegimeBits(Int32).1._State_2\, 
        \Posit32::EncodeRegimeBits(Int32).1._State_3\, 
        \Posit32::EncodeRegimeBits(Int32).1._State_4\, 
        \Posit32::EncodeRegimeBits(Int32).1._State_5\, 
        \Posit32::EncodeRegimeBits(Int32).1._State_6\);
    -- Signals:
    Signal \Posit32::EncodeRegimeBits(Int32).1._Finished\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).1._Started\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).1.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).2 declarations start
    -- State machine states:
    type \Posit32::EncodeRegimeBits(Int32).2._States\ is (
        \Posit32::EncodeRegimeBits(Int32).2._State_0\, 
        \Posit32::EncodeRegimeBits(Int32).2._State_1\, 
        \Posit32::EncodeRegimeBits(Int32).2._State_2\, 
        \Posit32::EncodeRegimeBits(Int32).2._State_3\, 
        \Posit32::EncodeRegimeBits(Int32).2._State_4\, 
        \Posit32::EncodeRegimeBits(Int32).2._State_5\, 
        \Posit32::EncodeRegimeBits(Int32).2._State_6\);
    -- Signals:
    Signal \Posit32::EncodeRegimeBits(Int32).2._Finished\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).2._Started\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).2.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).2 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._States\ is (
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_3\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\);
    -- Signals:
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).1 declarations start
    -- State machine states:
    type \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._States\ is (
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_0\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_1\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_2\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_3\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_4\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_5\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_6\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_7\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_8\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_9\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_10\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_11\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_12\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_13\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_14\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_15\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_16\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_17\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_18\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_19\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_20\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_21\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_22\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_23\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_24\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_25\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_26\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_27\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_28\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_29\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_30\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_31\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_32\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_33\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_34\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_35\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_36\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_37\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_38\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_39\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_40\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_41\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_42\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_43\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_44\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_45\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_46\);
    -- Signals:
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Finished\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit.parameter.In\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).2 declarations start
    -- State machine states:
    type \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._States\ is (
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_0\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_1\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_2\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_3\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_4\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_5\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_6\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_7\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_8\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_9\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_10\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_11\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_12\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_13\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_14\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_15\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_16\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_17\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_18\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_19\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_20\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_21\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_22\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_23\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_24\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_25\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_26\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_27\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_28\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_29\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_30\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_31\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_32\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_33\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_34\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_35\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_36\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_37\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_38\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_39\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_40\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_41\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_42\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_43\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_44\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_45\, 
        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_46\);
    -- Signals:
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Finished\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit.parameter.In\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).2 declarations end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0 declarations start
    -- State machine states:
    type \Posit32::GetRegimeKValue().0._States\ is (
        \Posit32::GetRegimeKValue().0._State_0\, 
        \Posit32::GetRegimeKValue().0._State_1\, 
        \Posit32::GetRegimeKValue().0._State_2\, 
        \Posit32::GetRegimeKValue().0._State_3\, 
        \Posit32::GetRegimeKValue().0._State_4\, 
        \Posit32::GetRegimeKValue().0._State_5\, 
        \Posit32::GetRegimeKValue().0._State_6\, 
        \Posit32::GetRegimeKValue().0._State_7\, 
        \Posit32::GetRegimeKValue().0._State_8\, 
        \Posit32::GetRegimeKValue().0._State_9\, 
        \Posit32::GetRegimeKValue().0._State_10\, 
        \Posit32::GetRegimeKValue().0._State_11\);
    -- Signals:
    Signal \Posit32::GetRegimeKValue().0._Finished\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0.return\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::GetRegimeKValue().0.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0._Started\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0 declarations end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().1 declarations start
    -- State machine states:
    type \Posit32::GetRegimeKValue().1._States\ is (
        \Posit32::GetRegimeKValue().1._State_0\, 
        \Posit32::GetRegimeKValue().1._State_1\, 
        \Posit32::GetRegimeKValue().1._State_2\, 
        \Posit32::GetRegimeKValue().1._State_3\, 
        \Posit32::GetRegimeKValue().1._State_4\, 
        \Posit32::GetRegimeKValue().1._State_5\, 
        \Posit32::GetRegimeKValue().1._State_6\, 
        \Posit32::GetRegimeKValue().1._State_7\, 
        \Posit32::GetRegimeKValue().1._State_8\, 
        \Posit32::GetRegimeKValue().1._State_9\, 
        \Posit32::GetRegimeKValue().1._State_10\, 
        \Posit32::GetRegimeKValue().1._State_11\);
    -- Signals:
    Signal \Posit32::GetRegimeKValue().1._Finished\: boolean := false;
    Signal \Posit32::GetRegimeKValue().1.return\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::GetRegimeKValue().1.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().1._Started\: boolean := false;
    Signal \Posit32::GetRegimeKValue().1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().1.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().1 declarations end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().2 declarations start
    -- State machine states:
    type \Posit32::GetRegimeKValue().2._States\ is (
        \Posit32::GetRegimeKValue().2._State_0\, 
        \Posit32::GetRegimeKValue().2._State_1\, 
        \Posit32::GetRegimeKValue().2._State_2\, 
        \Posit32::GetRegimeKValue().2._State_3\, 
        \Posit32::GetRegimeKValue().2._State_4\, 
        \Posit32::GetRegimeKValue().2._State_5\, 
        \Posit32::GetRegimeKValue().2._State_6\, 
        \Posit32::GetRegimeKValue().2._State_7\, 
        \Posit32::GetRegimeKValue().2._State_8\, 
        \Posit32::GetRegimeKValue().2._State_9\, 
        \Posit32::GetRegimeKValue().2._State_10\, 
        \Posit32::GetRegimeKValue().2._State_11\);
    -- Signals:
    Signal \Posit32::GetRegimeKValue().2._Finished\: boolean := false;
    Signal \Posit32::GetRegimeKValue().2.return\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::GetRegimeKValue().2.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().2._Started\: boolean := false;
    Signal \Posit32::GetRegimeKValue().2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().2.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().2 declarations end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).0 declarations start
    -- State machine states:
    type \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._States\ is (
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_0\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_1\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_2\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_3\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_4\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_5\);
    -- Signals:
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._Finished\: boolean := false;
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.return\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._Started\: boolean := false;
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.lengthOfRunOfBits.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).0 declarations end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).1 declarations start
    -- State machine states:
    type \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._States\ is (
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_0\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_1\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_2\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_3\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_4\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_5\);
    -- Signals:
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._Finished\: boolean := false;
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.return\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._Started\: boolean := false;
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.lengthOfRunOfBits.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).1 declarations end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).2 declarations start
    -- State machine states:
    type \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._States\ is (
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_0\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_1\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_2\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_3\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_4\, 
        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_5\);
    -- Signals:
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._Finished\: boolean := false;
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.return\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._Started\: boolean := false;
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.lengthOfRunOfBits.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).2 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0 declarations start
    -- State machine states:
    type \Posit32::ExponentSize().0._States\ is (
        \Posit32::ExponentSize().0._State_0\, 
        \Posit32::ExponentSize().0._State_1\, 
        \Posit32::ExponentSize().0._State_2\, 
        \Posit32::ExponentSize().0._State_3\, 
        \Posit32::ExponentSize().0._State_4\, 
        \Posit32::ExponentSize().0._State_5\, 
        \Posit32::ExponentSize().0._State_6\, 
        \Posit32::ExponentSize().0._State_7\, 
        \Posit32::ExponentSize().0._State_8\, 
        \Posit32::ExponentSize().0._State_9\, 
        \Posit32::ExponentSize().0._State_10\, 
        \Posit32::ExponentSize().0._State_11\, 
        \Posit32::ExponentSize().0._State_12\, 
        \Posit32::ExponentSize().0._State_13\, 
        \Posit32::ExponentSize().0._State_14\);
    -- Signals:
    Signal \Posit32::ExponentSize().0._Finished\: boolean := false;
    Signal \Posit32::ExponentSize().0.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::ExponentSize().0.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::ExponentSize().0.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::ExponentSize().0._Started\: boolean := false;
    Signal \Posit32::ExponentSize().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::ExponentSize().0.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::ExponentSize().0.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0 declarations start
    -- State machine states:
    type \Posit32::GetExponentValue().0._States\ is (
        \Posit32::GetExponentValue().0._State_0\, 
        \Posit32::GetExponentValue().0._State_1\, 
        \Posit32::GetExponentValue().0._State_2\, 
        \Posit32::GetExponentValue().0._State_3\, 
        \Posit32::GetExponentValue().0._State_4\, 
        \Posit32::GetExponentValue().0._State_5\, 
        \Posit32::GetExponentValue().0._State_6\, 
        \Posit32::GetExponentValue().0._State_7\, 
        \Posit32::GetExponentValue().0._State_8\, 
        \Posit32::GetExponentValue().0._State_9\, 
        \Posit32::GetExponentValue().0._State_10\, 
        \Posit32::GetExponentValue().0._State_11\, 
        \Posit32::GetExponentValue().0._State_12\, 
        \Posit32::GetExponentValue().0._State_13\);
    -- Signals:
    Signal \Posit32::GetExponentValue().0._Finished\: boolean := false;
    Signal \Posit32::GetExponentValue().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValue().0.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().0.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0.Posit32::ExponentSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0.Posit32::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0._Started\: boolean := false;
    Signal \Posit32::GetExponentValue().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().0.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0.Posit32::ExponentSize().return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().0.Posit32::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().1 declarations start
    -- State machine states:
    type \Posit32::GetExponentValue().1._States\ is (
        \Posit32::GetExponentValue().1._State_0\, 
        \Posit32::GetExponentValue().1._State_1\, 
        \Posit32::GetExponentValue().1._State_2\, 
        \Posit32::GetExponentValue().1._State_3\, 
        \Posit32::GetExponentValue().1._State_4\, 
        \Posit32::GetExponentValue().1._State_5\, 
        \Posit32::GetExponentValue().1._State_6\, 
        \Posit32::GetExponentValue().1._State_7\, 
        \Posit32::GetExponentValue().1._State_8\, 
        \Posit32::GetExponentValue().1._State_9\, 
        \Posit32::GetExponentValue().1._State_10\, 
        \Posit32::GetExponentValue().1._State_11\, 
        \Posit32::GetExponentValue().1._State_12\, 
        \Posit32::GetExponentValue().1._State_13\);
    -- Signals:
    Signal \Posit32::GetExponentValue().1._Finished\: boolean := false;
    Signal \Posit32::GetExponentValue().1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValue().1.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().1.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().1.Posit32::ExponentSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().1.Posit32::ExponentSize()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().1.Posit32::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().1.Posit32::FractionSize()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().1._Started\: boolean := false;
    Signal \Posit32::GetExponentValue().1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().1.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().1.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValue().1.Posit32::ExponentSize()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().1.Posit32::ExponentSize().return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetExponentValue().1.Posit32::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().1.Posit32::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().2 declarations start
    -- State machine states:
    type \Posit32::GetExponentValue().2._States\ is (
        \Posit32::GetExponentValue().2._State_0\, 
        \Posit32::GetExponentValue().2._State_1\, 
        \Posit32::GetExponentValue().2._State_2\, 
        \Posit32::GetExponentValue().2._State_3\, 
        \Posit32::GetExponentValue().2._State_4\, 
        \Posit32::GetExponentValue().2._State_5\, 
        \Posit32::GetExponentValue().2._State_6\, 
        \Posit32::GetExponentValue().2._State_7\, 
        \Posit32::GetExponentValue().2._State_8\, 
        \Posit32::GetExponentValue().2._State_9\, 
        \Posit32::GetExponentValue().2._State_10\, 
        \Posit32::GetExponentValue().2._State_11\, 
        \Posit32::GetExponentValue().2._State_12\, 
        \Posit32::GetExponentValue().2._State_13\);
    -- Signals:
    Signal \Posit32::GetExponentValue().2._Finished\: boolean := false;
    Signal \Posit32::GetExponentValue().2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValue().2.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().2.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().2.Posit32::ExponentSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().2.Posit32::ExponentSize()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().2.Posit32::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().2.Posit32::FractionSize()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValue().2._Started\: boolean := false;
    Signal \Posit32::GetExponentValue().2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValue().2.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().2.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValue().2.Posit32::ExponentSize()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().2.Posit32::ExponentSize().return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetExponentValue().2.Posit32::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValue().2.Posit32::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().2 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._States\ is (
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_0\, 
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_1\, 
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_2\, 
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_3\);
    -- Signals:
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._Finished\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._Started\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.fractionSize.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize().return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).1 declarations start
    -- State machine states:
    type \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._States\ is (
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_0\, 
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_1\, 
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_2\, 
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_3\);
    -- Signals:
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._Finished\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._Started\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.fractionSize.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize().return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).2 declarations start
    -- State machine states:
    type \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._States\ is (
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_0\, 
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_1\, 
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_2\, 
        \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_3\);
    -- Signals:
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._Finished\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Started.0\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._Started\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.fractionSize.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Finished.0\: boolean := false;
    Signal \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize().return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).2 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0 declarations start
    -- State machine states:
    type \Posit32::FractionSize().0._States\ is (
        \Posit32::FractionSize().0._State_0\, 
        \Posit32::FractionSize().0._State_1\, 
        \Posit32::FractionSize().0._State_2\, 
        \Posit32::FractionSize().0._State_3\, 
        \Posit32::FractionSize().0._State_4\, 
        \Posit32::FractionSize().0._State_5\, 
        \Posit32::FractionSize().0._State_6\, 
        \Posit32::FractionSize().0._State_7\, 
        \Posit32::FractionSize().0._State_8\, 
        \Posit32::FractionSize().0._State_9\, 
        \Posit32::FractionSize().0._State_10\, 
        \Posit32::FractionSize().0._State_11\, 
        \Posit32::FractionSize().0._State_12\);
    -- Signals:
    Signal \Posit32::FractionSize().0._Finished\: boolean := false;
    Signal \Posit32::FractionSize().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().0.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSize().0.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::FractionSize().0._Started\: boolean := false;
    Signal \Posit32::FractionSize().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSize().0.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::FractionSize().0.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().1 declarations start
    -- State machine states:
    type \Posit32::FractionSize().1._States\ is (
        \Posit32::FractionSize().1._State_0\, 
        \Posit32::FractionSize().1._State_1\, 
        \Posit32::FractionSize().1._State_2\, 
        \Posit32::FractionSize().1._State_3\, 
        \Posit32::FractionSize().1._State_4\, 
        \Posit32::FractionSize().1._State_5\, 
        \Posit32::FractionSize().1._State_6\, 
        \Posit32::FractionSize().1._State_7\, 
        \Posit32::FractionSize().1._State_8\, 
        \Posit32::FractionSize().1._State_9\, 
        \Posit32::FractionSize().1._State_10\, 
        \Posit32::FractionSize().1._State_11\, 
        \Posit32::FractionSize().1._State_12\);
    -- Signals:
    Signal \Posit32::FractionSize().1._Finished\: boolean := false;
    Signal \Posit32::FractionSize().1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().1.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSize().1.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::FractionSize().1._Started\: boolean := false;
    Signal \Posit32::FractionSize().1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSize().1.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::FractionSize().1.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().2 declarations start
    -- State machine states:
    type \Posit32::FractionSize().2._States\ is (
        \Posit32::FractionSize().2._State_0\, 
        \Posit32::FractionSize().2._State_1\, 
        \Posit32::FractionSize().2._State_2\, 
        \Posit32::FractionSize().2._State_3\, 
        \Posit32::FractionSize().2._State_4\, 
        \Posit32::FractionSize().2._State_5\, 
        \Posit32::FractionSize().2._State_6\, 
        \Posit32::FractionSize().2._State_7\, 
        \Posit32::FractionSize().2._State_8\, 
        \Posit32::FractionSize().2._State_9\, 
        \Posit32::FractionSize().2._State_10\, 
        \Posit32::FractionSize().2._State_11\, 
        \Posit32::FractionSize().2._State_12\);
    -- Signals:
    Signal \Posit32::FractionSize().2._Finished\: boolean := false;
    Signal \Posit32::FractionSize().2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().2.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSize().2.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::FractionSize().2._Started\: boolean := false;
    Signal \Posit32::FractionSize().2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSize().2.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::FractionSize().2.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().2 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().0 declarations start
    -- State machine states:
    type \Posit32::FractionSizeWithoutSignCheck().0._States\ is (
        \Posit32::FractionSizeWithoutSignCheck().0._State_0\, 
        \Posit32::FractionSizeWithoutSignCheck().0._State_1\, 
        \Posit32::FractionSizeWithoutSignCheck().0._State_2\, 
        \Posit32::FractionSizeWithoutSignCheck().0._State_3\, 
        \Posit32::FractionSizeWithoutSignCheck().0._State_4\, 
        \Posit32::FractionSizeWithoutSignCheck().0._State_5\, 
        \Posit32::FractionSizeWithoutSignCheck().0._State_6\, 
        \Posit32::FractionSizeWithoutSignCheck().0._State_7\);
    -- Signals:
    Signal \Posit32::FractionSizeWithoutSignCheck().0._Finished\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().0._Started\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().1 declarations start
    -- State machine states:
    type \Posit32::FractionSizeWithoutSignCheck().1._States\ is (
        \Posit32::FractionSizeWithoutSignCheck().1._State_0\, 
        \Posit32::FractionSizeWithoutSignCheck().1._State_1\, 
        \Posit32::FractionSizeWithoutSignCheck().1._State_2\, 
        \Posit32::FractionSizeWithoutSignCheck().1._State_3\, 
        \Posit32::FractionSizeWithoutSignCheck().1._State_4\, 
        \Posit32::FractionSizeWithoutSignCheck().1._State_5\, 
        \Posit32::FractionSizeWithoutSignCheck().1._State_6\, 
        \Posit32::FractionSizeWithoutSignCheck().1._State_7\);
    -- Signals:
    Signal \Posit32::FractionSizeWithoutSignCheck().1._Finished\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().1._Started\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().2 declarations start
    -- State machine states:
    type \Posit32::FractionSizeWithoutSignCheck().2._States\ is (
        \Posit32::FractionSizeWithoutSignCheck().2._State_0\, 
        \Posit32::FractionSizeWithoutSignCheck().2._State_1\, 
        \Posit32::FractionSizeWithoutSignCheck().2._State_2\, 
        \Posit32::FractionSizeWithoutSignCheck().2._State_3\, 
        \Posit32::FractionSizeWithoutSignCheck().2._State_4\, 
        \Posit32::FractionSizeWithoutSignCheck().2._State_5\, 
        \Posit32::FractionSizeWithoutSignCheck().2._State_6\, 
        \Posit32::FractionSizeWithoutSignCheck().2._State_7\);
    -- Signals:
    Signal \Posit32::FractionSizeWithoutSignCheck().2._Finished\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().2._Started\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().2 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).0 declarations start
    -- State machine states:
    type \Posit32::FractionSizeWithoutSignCheck(Byte).0._States\ is (
        \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_0\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_1\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_2\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_3\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_4\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_5\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_6\);
    -- Signals:
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).0._Finished\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).0._Started\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).0.lengthOfRunOfBits.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).1 declarations start
    -- State machine states:
    type \Posit32::FractionSizeWithoutSignCheck(Byte).1._States\ is (
        \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_0\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_1\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_2\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_3\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_4\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_5\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_6\);
    -- Signals:
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).1._Finished\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).1._Started\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).1.lengthOfRunOfBits.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).2 declarations start
    -- State machine states:
    type \Posit32::FractionSizeWithoutSignCheck(Byte).2._States\ is (
        \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_0\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_1\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_2\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_3\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_4\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_5\, 
        \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_6\);
    -- Signals:
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).2._Finished\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).2._Started\: boolean := false;
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionSizeWithoutSignCheck(Byte).2.lengthOfRunOfBits.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).2 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0 declarations start
    -- State machine states:
    type \Posit32::FractionWithHiddenBit().0._States\ is (
        \Posit32::FractionWithHiddenBit().0._State_0\, 
        \Posit32::FractionWithHiddenBit().0._State_1\, 
        \Posit32::FractionWithHiddenBit().0._State_2\, 
        \Posit32::FractionWithHiddenBit().0._State_3\, 
        \Posit32::FractionWithHiddenBit().0._State_4\, 
        \Posit32::FractionWithHiddenBit().0._State_5\, 
        \Posit32::FractionWithHiddenBit().0._State_6\, 
        \Posit32::FractionWithHiddenBit().0._State_7\, 
        \Posit32::FractionWithHiddenBit().0._State_8\, 
        \Posit32::FractionWithHiddenBit().0._State_9\, 
        \Posit32::FractionWithHiddenBit().0._State_10\, 
        \Posit32::FractionWithHiddenBit().0._State_11\, 
        \Posit32::FractionWithHiddenBit().0._State_12\, 
        \Posit32::FractionWithHiddenBit().0._State_13\);
    -- Signals:
    Signal \Posit32::FractionWithHiddenBit().0._Finished\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0._Started\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().1 declarations start
    -- State machine states:
    type \Posit32::FractionWithHiddenBit().1._States\ is (
        \Posit32::FractionWithHiddenBit().1._State_0\, 
        \Posit32::FractionWithHiddenBit().1._State_1\, 
        \Posit32::FractionWithHiddenBit().1._State_2\, 
        \Posit32::FractionWithHiddenBit().1._State_3\, 
        \Posit32::FractionWithHiddenBit().1._State_4\, 
        \Posit32::FractionWithHiddenBit().1._State_5\, 
        \Posit32::FractionWithHiddenBit().1._State_6\, 
        \Posit32::FractionWithHiddenBit().1._State_7\, 
        \Posit32::FractionWithHiddenBit().1._State_8\, 
        \Posit32::FractionWithHiddenBit().1._State_9\, 
        \Posit32::FractionWithHiddenBit().1._State_10\, 
        \Posit32::FractionWithHiddenBit().1._State_11\, 
        \Posit32::FractionWithHiddenBit().1._State_12\, 
        \Posit32::FractionWithHiddenBit().1._State_13\);
    -- Signals:
    Signal \Posit32::FractionWithHiddenBit().1._Finished\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().1._Started\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().2 declarations start
    -- State machine states:
    type \Posit32::FractionWithHiddenBit().2._States\ is (
        \Posit32::FractionWithHiddenBit().2._State_0\, 
        \Posit32::FractionWithHiddenBit().2._State_1\, 
        \Posit32::FractionWithHiddenBit().2._State_2\, 
        \Posit32::FractionWithHiddenBit().2._State_3\, 
        \Posit32::FractionWithHiddenBit().2._State_4\, 
        \Posit32::FractionWithHiddenBit().2._State_5\, 
        \Posit32::FractionWithHiddenBit().2._State_6\, 
        \Posit32::FractionWithHiddenBit().2._State_7\, 
        \Posit32::FractionWithHiddenBit().2._State_8\, 
        \Posit32::FractionWithHiddenBit().2._State_9\, 
        \Posit32::FractionWithHiddenBit().2._State_10\, 
        \Posit32::FractionWithHiddenBit().2._State_11\, 
        \Posit32::FractionWithHiddenBit().2._State_12\, 
        \Posit32::FractionWithHiddenBit().2._State_13\);
    -- Signals:
    Signal \Posit32::FractionWithHiddenBit().2._Finished\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().2._Started\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().2 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().0 declarations start
    -- State machine states:
    type \Posit32::FractionWithHiddenBitWithoutSignCheck().0._States\ is (
        \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_0\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_1\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_2\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_3\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_4\);
    -- Signals:
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0._Finished\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0._Started\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().1 declarations start
    -- State machine states:
    type \Posit32::FractionWithHiddenBitWithoutSignCheck().1._States\ is (
        \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_0\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_1\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_2\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_3\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_4\);
    -- Signals:
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1._Finished\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1._Started\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().2 declarations start
    -- State machine states:
    type \Posit32::FractionWithHiddenBitWithoutSignCheck().2._States\ is (
        \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_0\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_1\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_2\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_3\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_4\);
    -- Signals:
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2._Finished\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2._Started\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().2 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._States\ is (
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_0\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_1\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_2\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_3\);
    -- Signals:
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._Finished\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._Started\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.fractionSize.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).1 declarations start
    -- State machine states:
    type \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._States\ is (
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_0\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_1\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_2\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_3\);
    -- Signals:
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._Finished\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._Started\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.fractionSize.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).2 declarations start
    -- State machine states:
    type \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._States\ is (
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_0\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_1\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_2\, 
        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_3\);
    -- Signals:
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._Finished\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._Started\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.fractionSize.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).2 declarations end


    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).0 declarations start
    -- State machine states:
    type \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._States\ is (
        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State_0\, 
        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State_1\, 
        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State_2\);
    -- Signals:
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Finished\: boolean := false;
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.return\: signed(15 downto 0) := to_signed(0, 16);
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\: boolean := false;
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.regimeKValue.parameter.In\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.exponentValue.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.maximumExponentSize.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).0 declarations end


    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).1 declarations start
    -- State machine states:
    type \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._States\ is (
        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State_0\, 
        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State_1\, 
        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State_2\);
    -- Signals:
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Finished\: boolean := false;
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.return\: signed(15 downto 0) := to_signed(0, 16);
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\: boolean := false;
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.regimeKValue.parameter.In\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.exponentValue.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.maximumExponentSize.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).1 declarations end


    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).2 declarations start
    -- State machine states:
    type \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._States\ is (
        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State_0\, 
        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State_1\, 
        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State_2\);
    -- Signals:
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Finished\: boolean := false;
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.return\: signed(15 downto 0) := to_signed(0, 16);
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\: boolean := false;
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.regimeKValue.parameter.In\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.exponentValue.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.maximumExponentSize.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).2 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::GetMostSignificantOnePosition(UInt32).0._States\ is (
        \Posit32::GetMostSignificantOnePosition(UInt32).0._State_0\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).0._State_1\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).0._State_2\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).0._State_3\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).0._State_4\);
    -- Signals:
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).0.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).0 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).1 declarations start
    -- State machine states:
    type \Posit32::GetMostSignificantOnePosition(UInt32).1._States\ is (
        \Posit32::GetMostSignificantOnePosition(UInt32).1._State_0\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).1._State_1\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).1._State_2\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).1._State_3\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).1._State_4\);
    -- Signals:
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).1.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).1 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).2 declarations start
    -- State machine states:
    type \Posit32::GetMostSignificantOnePosition(UInt32).2._States\ is (
        \Posit32::GetMostSignificantOnePosition(UInt32).2._State_0\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).2._State_1\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).2._State_2\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).2._State_3\, 
        \Posit32::GetMostSignificantOnePosition(UInt32).2._State_4\);
    -- Signals:
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).2.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).2 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).0 declarations start
    -- State machine states:
    type \Posit32::GetMostSignificantOnePosition(UInt64).0._States\ is (
        \Posit32::GetMostSignificantOnePosition(UInt64).0._State_0\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).0._State_1\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).0._State_2\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).0._State_3\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).0._State_4\);
    -- Signals:
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).0._Finished\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).0.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).0._Started\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).0.bits.parameter.In\: unsigned(63 downto 0) := to_unsigned(0, 64);
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).0 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).1 declarations start
    -- State machine states:
    type \Posit32::GetMostSignificantOnePosition(UInt64).1._States\ is (
        \Posit32::GetMostSignificantOnePosition(UInt64).1._State_0\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).1._State_1\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).1._State_2\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).1._State_3\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).1._State_4\);
    -- Signals:
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).1._Finished\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).1.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).1._Started\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).1.bits.parameter.In\: unsigned(63 downto 0) := to_unsigned(0, 64);
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).1 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).2 declarations start
    -- State machine states:
    type \Posit32::GetMostSignificantOnePosition(UInt64).2._States\ is (
        \Posit32::GetMostSignificantOnePosition(UInt64).2._State_0\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).2._State_1\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).2._State_2\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).2._State_3\, 
        \Posit32::GetMostSignificantOnePosition(UInt64).2._State_4\);
    -- Signals:
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).2._Finished\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).2.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).2._Started\: boolean := false;
    Signal \Posit32::GetMostSignificantOnePosition(UInt64).2.bits.parameter.In\: unsigned(63 downto 0) := to_unsigned(0, 64);
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).2 declarations end


    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::Abs(Lombiq.Arithmetics.Posit32).0 declarations start
    -- State machine states:
    type \Posit32::Abs(Posit32).0._States\ is (
        \Posit32::Abs(Posit32).0._State_0\, 
        \Posit32::Abs(Posit32).0._State_1\, 
        \Posit32::Abs(Posit32).0._State_2\, 
        \Posit32::Abs(Posit32).0._State_3\, 
        \Posit32::Abs(Posit32).0._State_4\);
    -- Signals:
    Signal \Posit32::Abs(Posit32).0._Finished\: boolean := false;
    Signal \Posit32::Abs(Posit32).0.return\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\: boolean := false;
    Signal \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\: boolean := false;
    Signal \Posit32::Abs(Posit32).0._Started\: boolean := false;
    Signal \Posit32::Abs(Posit32).0.input.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::Abs(Lombiq.Arithmetics.Posit32).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).0 declarations start
    -- State machine states:
    type \Posit32::SetOne(UInt32,UInt16).0._States\ is (
        \Posit32::SetOne(UInt32,UInt16).0._State_0\, 
        \Posit32::SetOne(UInt32,UInt16).0._State_1\, 
        \Posit32::SetOne(UInt32,UInt16).0._State_2\);
    -- Signals:
    Signal \Posit32::SetOne(UInt32,UInt16).0._Finished\: boolean := false;
    Signal \Posit32::SetOne(UInt32,UInt16).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetOne(UInt32,UInt16).0._Started\: boolean := false;
    Signal \Posit32::SetOne(UInt32,UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).0 declarations start
    -- State machine states:
    type \Posit32::SetZero(UInt32,UInt16).0._States\ is (
        \Posit32::SetZero(UInt32,UInt16).0._State_0\, 
        \Posit32::SetZero(UInt32,UInt16).0._State_1\, 
        \Posit32::SetZero(UInt32,UInt16).0._State_2\);
    -- Signals:
    Signal \Posit32::SetZero(UInt32,UInt16).0._Finished\: boolean := false;
    Signal \Posit32::SetZero(UInt32,UInt16).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetZero(UInt32,UInt16).0._Started\: boolean := false;
    Signal \Posit32::SetZero(UInt32,UInt16).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetZero(UInt32,UInt16).0.index.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).1 declarations start
    -- State machine states:
    type \Posit32::SetZero(UInt32,UInt16).1._States\ is (
        \Posit32::SetZero(UInt32,UInt16).1._State_0\, 
        \Posit32::SetZero(UInt32,UInt16).1._State_1\, 
        \Posit32::SetZero(UInt32,UInt16).1._State_2\);
    -- Signals:
    Signal \Posit32::SetZero(UInt32,UInt16).1._Finished\: boolean := false;
    Signal \Posit32::SetZero(UInt32,UInt16).1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetZero(UInt32,UInt16).1._Started\: boolean := false;
    Signal \Posit32::SetZero(UInt32,UInt16).1.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetZero(UInt32,UInt16).1.index.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).2 declarations start
    -- State machine states:
    type \Posit32::SetZero(UInt32,UInt16).2._States\ is (
        \Posit32::SetZero(UInt32,UInt16).2._State_0\, 
        \Posit32::SetZero(UInt32,UInt16).2._State_1\, 
        \Posit32::SetZero(UInt32,UInt16).2._State_2\);
    -- Signals:
    Signal \Posit32::SetZero(UInt32,UInt16).2._Finished\: boolean := false;
    Signal \Posit32::SetZero(UInt32,UInt16).2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetZero(UInt32,UInt16).2._Started\: boolean := false;
    Signal \Posit32::SetZero(UInt32,UInt16).2.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::SetZero(UInt32,UInt16).2.index.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).2 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).0 declarations start
    -- State machine states:
    type \Posit32::LengthOfRunOfBits(UInt32,Byte).0._States\ is (
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_0\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_1\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_3\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_4\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_5\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_6\);
    -- Signals:
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\: boolean := false;
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\: boolean := false;
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).0 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).1 declarations start
    -- State machine states:
    type \Posit32::LengthOfRunOfBits(UInt32,Byte).1._States\ is (
        \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_0\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_1\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_2\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_3\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_4\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_5\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_6\);
    -- Signals:
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\: boolean := false;
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\: boolean := false;
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).1 declarations end


    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).2 declarations start
    -- State machine states:
    type \Posit32::LengthOfRunOfBits(UInt32,Byte).2._States\ is (
        \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_0\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_1\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_2\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_3\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_4\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_5\, 
        \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_6\);
    -- Signals:
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\: boolean := false;
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\: boolean := false;
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).2 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).0 declarations start
    -- State machine states:
    type \Posit32::GetTwosComplement(UInt32).0._States\ is (
        \Posit32::GetTwosComplement(UInt32).0._State_0\, 
        \Posit32::GetTwosComplement(UInt32).0._State_1\, 
        \Posit32::GetTwosComplement(UInt32).0._State_2\);
    -- Signals:
    Signal \Posit32::GetTwosComplement(UInt32).0._Finished\: boolean := false;
    Signal \Posit32::GetTwosComplement(UInt32).0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetTwosComplement(UInt32).0._Started\: boolean := false;
    Signal \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).1 declarations start
    -- State machine states:
    type \Posit32::GetTwosComplement(UInt32).1._States\ is (
        \Posit32::GetTwosComplement(UInt32).1._State_0\, 
        \Posit32::GetTwosComplement(UInt32).1._State_1\, 
        \Posit32::GetTwosComplement(UInt32).1._State_2\);
    -- Signals:
    Signal \Posit32::GetTwosComplement(UInt32).1._Finished\: boolean := false;
    Signal \Posit32::GetTwosComplement(UInt32).1.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetTwosComplement(UInt32).1._Started\: boolean := false;
    Signal \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).1 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).2 declarations start
    -- State machine states:
    type \Posit32::GetTwosComplement(UInt32).2._States\ is (
        \Posit32::GetTwosComplement(UInt32).2._State_0\, 
        \Posit32::GetTwosComplement(UInt32).2._State_1\, 
        \Posit32::GetTwosComplement(UInt32).2._State_2\);
    -- Signals:
    Signal \Posit32::GetTwosComplement(UInt32).2._Finished\: boolean := false;
    Signal \Posit32::GetTwosComplement(UInt32).2.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::GetTwosComplement(UInt32).2._Started\: boolean := false;
    Signal \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).2 declarations end


    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 declarations start
    -- State machine states:
    type \Posit32::op_Addition(Posit32,Posit32).0._States\ is (
        \Posit32::op_Addition(Posit32,Posit32).0._State_0\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_1\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_2\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_3\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_4\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_5\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_6\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_7\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_8\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_9\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_10\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_11\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_12\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_13\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_14\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_15\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_16\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_17\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_18\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_19\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_20\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_21\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_22\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_23\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_24\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_25\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_26\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_27\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_28\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_29\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_30\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_31\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_32\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_33\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_34\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_35\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_36\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_37\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_38\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_39\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_40\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_41\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_42\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_43\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_44\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_45\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_46\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_47\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_48\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_49\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_50\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_51\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_52\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_53\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_54\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_55\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_56\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_57\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_58\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_59\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_60\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_61\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_62\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_63\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_64\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_65\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_66\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_67\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_68\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_69\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_70\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_71\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_72\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_73\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_74\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_75\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_76\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_77\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_78\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_79\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_80\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_81\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_82\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_83\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_84\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_85\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_86\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_87\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_88\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_89\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_90\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_91\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_92\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_93\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_94\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_95\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_96\, 
        \Posit32::op_Addition(Posit32,Posit32).0._State_97\);
    -- Signals:
    Signal \Posit32::op_Addition(Posit32,Posit32).0._Finished\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.return\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32).left.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32).right.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0._Started\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.left.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.right.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN().return.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().return.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32).return.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 declarations end


    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 declarations start
    -- State machine states:
    type \Posit32::op_Addition(Posit32,Posit32).1._States\ is (
        \Posit32::op_Addition(Posit32,Posit32).1._State_0\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_1\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_2\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_3\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_4\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_5\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_6\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_7\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_8\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_9\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_10\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_11\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_12\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_13\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_14\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_15\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_16\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_17\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_18\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_19\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_20\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_21\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_22\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_23\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_24\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_25\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_26\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_27\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_28\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_29\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_30\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_31\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_32\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_33\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_34\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_35\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_36\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_37\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_38\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_39\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_40\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_41\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_42\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_43\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_44\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_45\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_46\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_47\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_48\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_49\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_50\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_51\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_52\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_53\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_54\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_55\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_56\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_57\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_58\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_59\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_60\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_61\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_62\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_63\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_64\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_65\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_66\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_67\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_68\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_69\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_70\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_71\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_72\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_73\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_74\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_75\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_76\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_77\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_78\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_79\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_80\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_81\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_82\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_83\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_84\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_85\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_86\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_87\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_88\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_89\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_90\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_91\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_92\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_93\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_94\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_95\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_96\, 
        \Posit32::op_Addition(Posit32,Posit32).1._State_97\);
    -- Signals:
    Signal \Posit32::op_Addition(Posit32,Posit32).1._Finished\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.return\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32).left.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32).right.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1._Started\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.left.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.right.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN().return.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().return.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32).return.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 declarations end


    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 declarations start
    -- State machine states:
    type \Posit32::op_Addition(Posit32,Posit32).2._States\ is (
        \Posit32::op_Addition(Posit32,Posit32).2._State_0\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_1\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_2\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_3\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_4\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_5\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_6\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_7\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_8\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_9\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_10\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_11\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_12\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_13\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_14\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_15\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_16\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_17\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_18\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_19\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_20\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_21\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_22\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_23\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_24\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_25\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_26\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_27\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_28\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_29\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_30\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_31\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_32\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_33\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_34\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_35\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_36\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_37\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_38\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_39\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_40\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_41\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_42\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_43\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_44\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_45\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_46\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_47\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_48\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_49\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_50\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_51\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_52\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_53\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_54\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_55\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_56\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_57\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_58\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_59\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_60\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_61\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_62\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_63\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_64\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_65\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_66\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_67\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_68\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_69\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_70\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_71\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_72\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_73\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_74\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_75\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_76\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_77\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_78\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_79\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_80\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_81\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_82\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_83\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_84\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_85\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_86\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_87\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_88\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_89\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_90\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_91\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_92\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_93\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_94\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_95\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_96\, 
        \Posit32::op_Addition(Posit32,Posit32).2._State_97\);
    -- Signals:
    Signal \Posit32::op_Addition(Posit32,Posit32).2._Finished\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.return\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32).left.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32).right.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2._Started\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.left.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.right.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN().return.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().return.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32).return.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 declarations start
    -- State machine states:
    type \Posit32::op_GreaterThan(Posit32,Posit32).0._States\ is (
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_0\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_1\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_2\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_3\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_4\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_5\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_6\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_7\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_8\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_9\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_10\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_11\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_12\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_13\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_14\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).0._State_15\);
    -- Signals:
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).0._Finished\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).0.return\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).0._Started\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).0.left.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).0.right.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().return.0\: boolean := false;
    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 declarations start
    -- State machine states:
    type \Posit32::op_GreaterThan(Posit32,Posit32).1._States\ is (
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_0\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_1\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_2\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_3\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_4\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_5\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_6\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_7\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_8\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_9\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_10\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_11\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_12\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_13\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_14\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).1._State_15\);
    -- Signals:
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).1._Finished\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).1.return\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).1._Started\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).1.left.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).1.right.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().return.0\: boolean := false;
    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 declarations start
    -- State machine states:
    type \Posit32::op_GreaterThan(Posit32,Posit32).2._States\ is (
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_0\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_1\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_2\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_3\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_4\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_5\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_6\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_7\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_8\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_9\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_10\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_11\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_12\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_13\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_14\, 
        \Posit32::op_GreaterThan(Posit32,Posit32).2._State_15\);
    -- Signals:
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).2._Finished\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).2.return\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).2._Started\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).2.left.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).2.right.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().return.0\: boolean := false;
    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 declarations end


    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 declarations start
    -- State machine states:
    type \Posit32::op_Multiply(Posit32,Posit32).0._States\ is (
        \Posit32::op_Multiply(Posit32,Posit32).0._State_0\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_1\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_2\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_3\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_4\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_5\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_6\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_7\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_8\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_9\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_10\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_11\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_12\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_13\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_14\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_15\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_16\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_17\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_18\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_19\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_20\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_21\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_22\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_23\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_24\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_25\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_26\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_27\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_28\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_29\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_30\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_31\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_32\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_33\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_34\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_35\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_36\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_37\, 
        \Posit32::op_Multiply(Posit32,Posit32).0._State_38\);
    -- Signals:
    Signal \Posit32::op_Multiply(Posit32,Posit32).0._Finished\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.return\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).value.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32).input.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64).bits.parameter.Out.0\: unsigned(63 downto 0) := to_unsigned(0, 64);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64)._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0._Started\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.left.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.right.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().return.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().return.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32).return.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Finished.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64)._Finished.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Finished.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().return.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Finished.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\: signed(15 downto 0) := to_signed(0, 16);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 declarations end


    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 declarations start
    -- State machine states:
    type \Posit32::op_Explicit(Posit32).0._States\ is (
        \Posit32::op_Explicit(Posit32).0._State_0\, 
        \Posit32::op_Explicit(Posit32).0._State_1\, 
        \Posit32::op_Explicit(Posit32).0._State_2\, 
        \Posit32::op_Explicit(Posit32).0._State_3\, 
        \Posit32::op_Explicit(Posit32).0._State_4\, 
        \Posit32::op_Explicit(Posit32).0._State_5\, 
        \Posit32::op_Explicit(Posit32).0._State_6\, 
        \Posit32::op_Explicit(Posit32).0._State_7\, 
        \Posit32::op_Explicit(Posit32).0._State_8\, 
        \Posit32::op_Explicit(Posit32).0._State_9\, 
        \Posit32::op_Explicit(Posit32).0._State_10\, 
        \Posit32::op_Explicit(Posit32).0._State_11\, 
        \Posit32::op_Explicit(Posit32).0._State_12\, 
        \Posit32::op_Explicit(Posit32).0._State_13\, 
        \Posit32::op_Explicit(Posit32).0._State_14\, 
        \Posit32::op_Explicit(Posit32).0._State_15\, 
        \Posit32::op_Explicit(Posit32).0._State_16\, 
        \Posit32::op_Explicit(Posit32).0._State_17\, 
        \Posit32::op_Explicit(Posit32).0._State_18\, 
        \Posit32::op_Explicit(Posit32).0._State_19\, 
        \Posit32::op_Explicit(Posit32).0._State_20\, 
        \Posit32::op_Explicit(Posit32).0._State_21\, 
        \Posit32::op_Explicit(Posit32).0._State_22\, 
        \Posit32::op_Explicit(Posit32).0._State_23\, 
        \Posit32::op_Explicit(Posit32).0._State_24\, 
        \Posit32::op_Explicit(Posit32).0._State_25\, 
        \Posit32::op_Explicit(Posit32).0._State_26\, 
        \Posit32::op_Explicit(Posit32).0._State_27\, 
        \Posit32::op_Explicit(Posit32).0._State_28\, 
        \Posit32::op_Explicit(Posit32).0._State_29\);
    -- Signals:
    Signal \Posit32::op_Explicit(Posit32).0._Finished\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0._Started\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0.x.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue().return.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().return.0\: boolean := false;
    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 declarations end


    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).1 declarations start
    -- State machine states:
    type \Posit32::op_Explicit(Posit32).1._States\ is (
        \Posit32::op_Explicit(Posit32).1._State_0\, 
        \Posit32::op_Explicit(Posit32).1._State_1\, 
        \Posit32::op_Explicit(Posit32).1._State_2\, 
        \Posit32::op_Explicit(Posit32).1._State_3\, 
        \Posit32::op_Explicit(Posit32).1._State_4\, 
        \Posit32::op_Explicit(Posit32).1._State_5\, 
        \Posit32::op_Explicit(Posit32).1._State_6\, 
        \Posit32::op_Explicit(Posit32).1._State_7\, 
        \Posit32::op_Explicit(Posit32).1._State_8\, 
        \Posit32::op_Explicit(Posit32).1._State_9\, 
        \Posit32::op_Explicit(Posit32).1._State_10\, 
        \Posit32::op_Explicit(Posit32).1._State_11\, 
        \Posit32::op_Explicit(Posit32).1._State_12\, 
        \Posit32::op_Explicit(Posit32).1._State_13\, 
        \Posit32::op_Explicit(Posit32).1._State_14\, 
        \Posit32::op_Explicit(Posit32).1._State_15\, 
        \Posit32::op_Explicit(Posit32).1._State_16\, 
        \Posit32::op_Explicit(Posit32).1._State_17\, 
        \Posit32::op_Explicit(Posit32).1._State_18\, 
        \Posit32::op_Explicit(Posit32).1._State_19\, 
        \Posit32::op_Explicit(Posit32).1._State_20\, 
        \Posit32::op_Explicit(Posit32).1._State_21\, 
        \Posit32::op_Explicit(Posit32).1._State_22\, 
        \Posit32::op_Explicit(Posit32).1._State_23\, 
        \Posit32::op_Explicit(Posit32).1._State_24\, 
        \Posit32::op_Explicit(Posit32).1._State_25\, 
        \Posit32::op_Explicit(Posit32).1._State_26\, 
        \Posit32::op_Explicit(Posit32).1._State_27\, 
        \Posit32::op_Explicit(Posit32).1._State_28\, 
        \Posit32::op_Explicit(Posit32).1._State_29\);
    -- Signals:
    Signal \Posit32::op_Explicit(Posit32).1._Finished\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1._Started\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1.x.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue().return.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().return.0\: boolean := false;
    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).1 declarations end


    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).2 declarations start
    -- State machine states:
    type \Posit32::op_Explicit(Posit32).2._States\ is (
        \Posit32::op_Explicit(Posit32).2._State_0\, 
        \Posit32::op_Explicit(Posit32).2._State_1\, 
        \Posit32::op_Explicit(Posit32).2._State_2\, 
        \Posit32::op_Explicit(Posit32).2._State_3\, 
        \Posit32::op_Explicit(Posit32).2._State_4\, 
        \Posit32::op_Explicit(Posit32).2._State_5\, 
        \Posit32::op_Explicit(Posit32).2._State_6\, 
        \Posit32::op_Explicit(Posit32).2._State_7\, 
        \Posit32::op_Explicit(Posit32).2._State_8\, 
        \Posit32::op_Explicit(Posit32).2._State_9\, 
        \Posit32::op_Explicit(Posit32).2._State_10\, 
        \Posit32::op_Explicit(Posit32).2._State_11\, 
        \Posit32::op_Explicit(Posit32).2._State_12\, 
        \Posit32::op_Explicit(Posit32).2._State_13\, 
        \Posit32::op_Explicit(Posit32).2._State_14\, 
        \Posit32::op_Explicit(Posit32).2._State_15\, 
        \Posit32::op_Explicit(Posit32).2._State_16\, 
        \Posit32::op_Explicit(Posit32).2._State_17\, 
        \Posit32::op_Explicit(Posit32).2._State_18\, 
        \Posit32::op_Explicit(Posit32).2._State_19\, 
        \Posit32::op_Explicit(Posit32).2._State_20\, 
        \Posit32::op_Explicit(Posit32).2._State_21\, 
        \Posit32::op_Explicit(Posit32).2._State_22\, 
        \Posit32::op_Explicit(Posit32).2._State_23\, 
        \Posit32::op_Explicit(Posit32).2._State_24\, 
        \Posit32::op_Explicit(Posit32).2._State_25\, 
        \Posit32::op_Explicit(Posit32).2._State_26\, 
        \Posit32::op_Explicit(Posit32).2._State_27\, 
        \Posit32::op_Explicit(Posit32).2._State_28\, 
        \Posit32::op_Explicit(Posit32).2._State_29\);
    -- Signals:
    Signal \Posit32::op_Explicit(Posit32).2._Finished\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Started.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2._Started\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2.x.parameter.In\: \Lombiq.Arithmetics.Posit32\;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue().return.0\: signed(7 downto 0) := to_signed(0, 8);
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().return.0\: boolean := false;
    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).2 declarations end


    -- System.Void Hast::ExternalInvocationProxy() declarations start
    -- Signals:
    Signal \FinishedInternal\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32Calculator::CalculatePowerOfReal(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32Calculator::AddPositsInArray(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32Calculator::CalculatePowerOfReal(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory)._Finished.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().Posit32Calculator::AddPositsInArray(SimpleMemory)._Finished.0\: boolean := false;
    -- System.Void Hast::ExternalInvocationProxy() declarations end


    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations start
    type \InternalInvocationProxy_boolean_Array\ is array (integer range <>) of boolean;
    type \Hast::InternalInvocationProxy()._RunningStates\ is (
        WaitingForStarted, 
        WaitingForFinished, 
        AfterFinished);
    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations end

begin 

    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).0 state machine start
    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\: \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._States\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_0\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.upToNumberObject\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.posit\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.i\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.return.0\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.return.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._Finished\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.return\ <= to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_0\;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.upToNumberObject\ := to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.i\ := to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.binaryOperationResult.0\ := false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.return.1\ := to_signed(0, 32);
            else 
                case \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ is 
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._Started\ = true) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._Started\ = true) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._Finished\ <= true;
                        else 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._Finished\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_2\ => 
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.upToNumberObject\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.upToNumberObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 posit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 right;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int i;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- posit = new Posit32 (1);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.posit\.\IsNull\ := false;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.posit\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).this.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.posit\;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(1, 32);
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Started.0\ <= true;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Started.0\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Finished.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.posit\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- right = posit;
                            -- 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.right\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.posit\;
                            -- The following section was transformed from the .NET statement below:
                            -- i = 1;
                            -- 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.i\ := to_signed(1, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (i < upToNumberObject) {
                            -- 	posit = Posit32.op_Addition (posit, right);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_4\ => 
                        -- Repeated state of the while loop which was started in state \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_3\.
                        -- The while loop's condition:
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.binaryOperationResult.0\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.i\ < \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.upToNumberObject\;
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	posit = Posit32.op_Addition (posit, right);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- posit = Posit32.op_Addition (posit, right);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.posit\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.right\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= true;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_6\;
                        else 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_5\ => 
                        -- State after the while loop which was started in state \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return Posit32.op_Explicit (posit);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32).x.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.posit\;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Started.0\ <= true;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.return.0\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).return.0\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.posit\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- i = i + 1;
                            -- 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.binaryOperationResult.1\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.i\ + to_signed(1, 32);
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.i\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.binaryOperationResult.1\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_3\ if the loop wasn't exited with a state change.
                            if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_6\) then 
                                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Started.0\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Finished.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.return.1\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32).return.0\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.return\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.return.1\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).0 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).1 state machine start
    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\: \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._States\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_0\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.upToNumberObject\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.posit\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.i\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.binaryOperationResult.0\: boolean := false;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.return.0\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.return.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._Finished\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.return\ <= to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Started.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_0\;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.upToNumberObject\ := to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.i\ := to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.binaryOperationResult.0\ := false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.return.1\ := to_signed(0, 32);
            else 
                case \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ is 
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._Started\ = true) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._Started\ = true) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._Finished\ <= true;
                        else 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._Finished\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_2\ => 
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.upToNumberObject\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.upToNumberObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 posit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 right;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int i;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- posit = new Posit32 (1);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.posit\.\IsNull\ := false;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.posit\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).this.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.posit\;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(1, 32);
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Started.0\ <= true;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Started.0\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Finished.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Started.0\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.posit\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- right = posit;
                            -- 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.right\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.posit\;
                            -- The following section was transformed from the .NET statement below:
                            -- i = 1;
                            -- 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.i\ := to_signed(1, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (i < upToNumberObject) {
                            -- 	posit = Posit32.op_Addition (posit, right);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_4\ => 
                        -- Repeated state of the while loop which was started in state \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_3\.
                        -- The while loop's condition:
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.binaryOperationResult.0\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.i\ < \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.upToNumberObject\;
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	posit = Posit32.op_Addition (posit, right);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- posit = Posit32.op_Addition (posit, right);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.posit\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.right\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= true;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_6\;
                        else 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_5\ => 
                        -- State after the while loop which was started in state \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return Posit32.op_Explicit (posit);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32).x.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.posit\;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Started.0\ <= true;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Started.0\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Finished.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.return.0\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).return.0\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.posit\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- i = i + 1;
                            -- 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.binaryOperationResult.1\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.i\ + to_signed(1, 32);
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.i\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.binaryOperationResult.1\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_3\ if the loop wasn't exited with a state change.
                            if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_6\) then 
                                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Started.0\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Finished.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.return.1\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32).return.0\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.return\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.return.1\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).1 state machine end


    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).2 state machine start
    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\: \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._States\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_0\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.upToNumberObject\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.posit\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.i\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.binaryOperationResult.0\: boolean := false;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.return.0\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.return.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._Finished\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.return\ <= to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Started.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_0\;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.upToNumberObject\ := to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.i\ := to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.binaryOperationResult.0\ := false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.return.1\ := to_signed(0, 32);
            else 
                case \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ is 
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._Started\ = true) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._Started\ = true) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._Finished\ <= true;
                        else 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._Finished\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_2\ => 
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.upToNumberObject\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.upToNumberObject.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 posit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 right;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int i;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- posit = new Posit32 (1);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.posit\.\IsNull\ := false;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.posit\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).this.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.posit\;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(1, 32);
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Started.0\ <= true;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Started.0\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Finished.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Started.0\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.posit\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- right = posit;
                            -- 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.right\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.posit\;
                            -- The following section was transformed from the .NET statement below:
                            -- i = 1;
                            -- 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.i\ := to_signed(1, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (i < upToNumberObject) {
                            -- 	posit = Posit32.op_Addition (posit, right);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_4\ => 
                        -- Repeated state of the while loop which was started in state \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_3\.
                        -- The while loop's condition:
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.binaryOperationResult.0\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.i\ < \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.upToNumberObject\;
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	posit = Posit32.op_Addition (posit, right);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- posit = Posit32.op_Addition (posit, right);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.posit\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.right\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= true;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_6\;
                        else 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_5\ => 
                        -- State after the while loop which was started in state \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return Posit32.op_Explicit (posit);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32).x.parameter.Out.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.posit\;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Started.0\ <= true;
                        \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Started.0\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Finished.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.return.0\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).return.0\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.posit\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- i = i + 1;
                            -- 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.binaryOperationResult.1\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.i\ + to_signed(1, 32);
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.i\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.binaryOperationResult.1\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_3\ if the loop wasn't exited with a state change.
                            if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_6\) then 
                                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Started.0\ = \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Finished.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.return.1\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32).return.0\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.return\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.return.1\;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State\ := \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).2 state machine end


    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\: \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._States\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\;
        Variable \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0);
        Variable \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.0\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\ <= false;
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= false;
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\;
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\ := to_unsigned(0, 32);
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ := to_unsigned(0, 32);
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\ := to_signed(0, 32);
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\ := false;
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.1\ := to_signed(0, 32);
            else 
                case \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ is 
                    when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\ = true) then 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\ = true) then 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\ <= true;
                        else 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\ <= false;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 posit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 right;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int number;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(0, 32), 32);
                        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\ := ConvertStdLogicVectorToUInt32(\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- posit = new Posit32 (1);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\.\IsNull\ := false;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\.\PositBits\ := to_unsigned(0, 32);
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(1, 32);
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= true;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ = \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\) then 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- right = posit;
                            -- 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.right\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 1u;
                            -- 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ := to_unsigned(1, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (num2 < num) {
                            -- 	posit = Posit32.op_Addition (posit, right);
                            -- 	num2 = num2 + 1u;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\ => 
                        -- Repeated state of the while loop which was started in state \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\.
                        -- The while loop's condition:
                        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ < \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\;
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	posit = Posit32.op_Addition (posit, right);
                            -- 	num2 = num2 + 1u;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- posit = Posit32.op_Addition (posit, right);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.right\;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= true;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_7\;
                        else 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_6\ => 
                        -- State after the while loop which was started in state \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- number = Posit32.op_Explicit (posit);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32).x.parameter.Out.0\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Started.0\ <= true;
                        \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ = \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\) then 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= false;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.0\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).return.0\;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = num2 + 1u;
                            -- 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ + to_unsigned(1, 32);
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\ if the loop wasn't exited with a state change.
                            if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ = \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_7\) then 
                                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32)
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Started.0\ = \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Finished.0\) then 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Started.0\ <= false;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.1\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32).return.0\;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteInt32 (0, number);
                            -- 
                            -- Begin SimpleMemory write.
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(0, 32), 32);
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertInt32ToStdLogicVector(\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\);
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_9\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculatePowerOfReal(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\: \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._States\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_0\;
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.posit\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.positBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0);
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0);
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.return.0\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._Finished\ <= false;
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= false;
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32)._Started.0\ <= false;
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_0\;
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.num\ := to_signed(0, 32);
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.bits\ := to_unsigned(0, 32);
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.num2\ := to_unsigned(0, 32);
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.positBits\ := to_unsigned(0, 32);
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.binaryOperationResult.0\ := false;
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.binaryOperationResult.1\ := to_unsigned(0, 32);
            else 
                case \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ is 
                    when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._Started\ = true) then 
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._Started\ = true) then 
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._Finished\ <= true;
                        else 
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._Finished\ <= false;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 posit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 right;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint positBits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(0, 32), 32);
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.num\ := ConvertStdLogicVectorToInt32(\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- bits = memory.ReadUInt32 (1);
                            -- 
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_4\ => 
                        -- Begin SimpleMemory read.
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(1, 32), 32);
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_5\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.bits\ := ConvertStdLogicVectorToUInt32(\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.dataIn.1\);
                            -- The following section was transformed from the .NET statement below:
                            -- posit = new Posit32 (bits, true);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.posit\.\IsNull\ := false;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.posit\.\PositBits\ := to_unsigned(0, 32);
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.posit\;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.bits\;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.posit\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- right = posit;
                            -- 
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.right\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.posit\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 0u;
                            -- 
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.num2\ := to_unsigned(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((ulong)num2 < (ulong)((long)num)) {
                            -- 	posit = Posit32.op_Multiply (posit, right);
                            -- 	num2 = num2 + 1u;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_6\.
                        -- The while loop's condition:
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.binaryOperationResult.0\ := SmartResize(\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.num2\, 64) < unsigned((SmartResize(\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.num\, 64)));
                        if (\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	posit = Posit32.op_Multiply (posit, right);
                            -- 	num2 = num2 + 1u;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- posit = Posit32.op_Multiply (posit, right);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32).left.parameter.Out.0\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.posit\;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32).right.parameter.Out.0\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.right\;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32)._Started.0\ <= true;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_9\;
                        else 
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2897
                    when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_8\ => 
                        -- State after the while loop which was started in state \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- positBits = posit.PositBits;
                        -- 
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.positBits\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.posit\.\PositBits\;
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (0, positBits);
                        -- 
                        -- Begin SimpleMemory write.
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(0, 32), 32);
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.positBits\);
                        \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                        if (\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32)._Started.0\ = \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32)._Finished.0\) then 
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32)._Started.0\ <= false;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.return.0\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32).return.0\;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.posit\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = num2 + 1u;
                            -- 
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.binaryOperationResult.1\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.num2\ + to_unsigned(1, 32);
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.num2\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.binaryOperationResult.1\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_6\ if the loop wasn't exited with a state change.
                            if (\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ = \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_9\) then 
                                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_10\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State\ := \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculatePowerOfReal(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\: \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._States\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_0\;
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.array\: \signed32_Array\(0 to 4) := (others => to_signed(0, 32));
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.array2\: \signed32_Array\(0 to 4) := (others => to_signed(0, 32));
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.i\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.arg_4D_1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.j\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0);
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).invocationIndex\: integer range 0 to 2 := 0;
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.2\: boolean := false;
        Variable \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._Finished\ <= false;
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.0\ <= false;
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.1\ <= to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.1\ <= false;
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.2\ <= to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.2\ <= false;
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_0\;
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.array\ := (others => to_signed(0, 32));
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.array2\ := (others => to_signed(0, 32));
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.i\ := to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.num\ := to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.arg_4D_1\ := to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.j\ := to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.0\ := false;
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).invocationIndex\ := 0;
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.0\ := to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.1\ := to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.2\ := to_signed(0, 32);
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.2\ := false;
                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.3\ := to_signed(0, 32);
            else 
                case \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ is 
                    when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._Started\ = true) then 
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._Started\ = true) then 
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._Finished\ <= true;
                        else 
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._Finished\ <= false;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- int[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Task<int>[] array2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int i;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int arg_4D_1;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- TaskFactory arg_48_0;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Func<object, int> arg_48_1;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int j;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new int[5];
                        -- 
                        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.array\ := (others => to_signed(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- array2 = new Task<int>[5];
                        -- 
                        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.array2\ := (others => to_signed(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- i = 0;
                        -- 
                        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.i\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (i < 5) {
                        -- 	num = memory.ReadInt32 (i);
                        -- 	arg_4D_1 = i;
                        -- 	arg_48_0 = Task.Factory;
                        -- 	if (arg_48_1 = Posit32Calculator.<>c.<>9__13_0 == null) {
                        -- 		arg_48_1 = Posit32Calculator.<>c.<>9__13_0 = new Func<object, int> (Posit32Calculator.<>c.<>9.<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0);
                        -- 	}
                        -- 	array2 [arg_4D_1] = arg_48_0.StartNew<int> (arg_48_1, num);
                        -- 	i = i + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_2\.
                        -- The while loop's condition:
                        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.0\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.i\ < to_signed(5, 32);
                        if (\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num = memory.ReadInt32 (i);
                            -- 	arg_4D_1 = i;
                            -- 	arg_48_0 = Task.Factory;
                            -- 	if (arg_48_1 = Posit32Calculator.<>c.<>9__13_0 == null) {
                            -- 		arg_48_1 = Posit32Calculator.<>c.<>9__13_0 = new Func<object, int> (Posit32Calculator.<>c.<>9.<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0);
                            -- 	}
                            -- 	array2 [arg_4D_1] = arg_48_0.StartNew<int> (arg_48_1, num);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num = memory.ReadInt32 (i);
                            -- 
                            -- Begin SimpleMemory read.
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.i\, 32);
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_5\;
                        else 
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_4\ => 
                        -- State after the while loop which was started in state \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- Task.WhenAll<int> (array2).Wait ();
                        -- 
                        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_5\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.num\ := ConvertStdLogicVectorToInt32(\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- arg_4D_1 = i;
                            -- 
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.arg_4D_1\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.i\;
                            -- The following section was transformed from the .NET statement below:
                            -- arg_48_0 = Task.Factory;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (arg_48_1 = Posit32Calculator.<>c.<>9__13_0 == null) {
                            -- 	arg_48_1 = Posit32Calculator.<>c.<>9__13_0 = new Func<object, int> (Posit32Calculator.<>c.<>9.<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array2 [arg_4D_1] = arg_48_0.StartNew<int> (arg_48_1, num);
                            -- 
                            -- Starting state machine invocation for the following method: System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32)
                            case \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).invocationIndex\ is 
                                when 0 => 
                                    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.0\ <= \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.num\;
                                    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.0\ <= true;
                                when 1 => 
                                    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.1\ <= \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.num\;
                                    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.1\ <= true;
                                when 2 => 
                                    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.2\ <= \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.num\;
                                    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.2\ <= true;
                            end case;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).invocationIndex\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).invocationIndex\ + 1;
                            -- The following section was transformed from the .NET statement below:
                            -- i = i + 1;
                            -- 
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.1\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.i\ + to_signed(1, 32);
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.i\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.1\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_2\ if the loop wasn't exited with a state change.
                            if (\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ = \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_5\) then 
                                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32)
                        if (\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.1\ = \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Finished.1\ and \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.2\ = \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Finished.2\ and \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.0\ = \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Finished.0\) then 
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.0\ <= false;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.1\ <= false;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.2\ <= false;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).invocationIndex\ := 0;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.0\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).return.0\;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.1\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).return.1\;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.2\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).return.2\;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.array2\(0) := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.0\;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.array2\(1) := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.1\;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.array2\(2) := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- j = 0;
                            -- 
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.j\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (j < 5) {
                            -- 	memory.WriteInt32 (j, array2 [j].Result);
                            -- 	j = j + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_6\.
                        -- The while loop's condition:
                        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.2\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.j\ < to_signed(5, 32);
                        if (\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	memory.WriteInt32 (j, array2 [j].Result);
                            -- 	j = j + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteInt32 (j, array2 [j].Result);
                            -- 
                            -- Begin SimpleMemory write.
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.j\, 32);
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertInt32ToStdLogicVector(\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.array2\(to_integer(\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.j\)));
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_9\;
                        else 
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_8\ => 
                        -- State after the while loop which was started in state \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_6\.
                        \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_9\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            -- The following section was transformed from the .NET statement below:
                            -- j = j + 1;
                            -- 
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.3\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.j\ + to_signed(1, 32);
                            \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.j\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.binaryOperationResult.3\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_6\ if the loop wasn't exited with a state change.
                            if (\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ = \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_9\) then 
                                \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State\ := \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::AddPositsInArray(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \Posit32Calculator::AddPositsInArray(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\: \Posit32Calculator::AddPositsInArray(SimpleMemory).0._States\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_0\;
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0.left\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0);
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0.dataIn.1\: std_logic_vector(31 downto 0);
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0.object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0.dataIn.2\: std_logic_vector(31 downto 0);
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0.return.0\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0._Finished\ <= false;
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= false;
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= false;
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_0\;
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.num\ := to_unsigned(0, 32);
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.num2\ := to_signed(0, 32);
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.0\ := false;
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.2\ := to_signed(0, 32);
            else 
                case \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ is 
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32Calculator::AddPositsInArray(SimpleMemory).0._Started\ = true) then 
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32Calculator::AddPositsInArray(SimpleMemory).0._Started\ = true) then 
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._Finished\ <= true;
                        else 
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._Finished\ <= false;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 left;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(0, 32), 32);
                        \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.num\ := ConvertStdLogicVectorToUInt32(\Posit32Calculator::AddPositsInArray(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- left = new Posit32 (memory.ReadUInt32 (1), true);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.left\.\IsNull\ := false;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.left\.\PositBits\ := to_unsigned(0, 32);
                            -- Invoking the target's constructor.
                            -- The last SimpleMemory read just finished, so need to start the next one in the next state.
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_4\ => 
                        -- Begin SimpleMemory read.
                        \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(1, 32), 32);
                        \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_5\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.dataIn.1\ := \DataIn\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.left\;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= ConvertStdLogicVectorToUInt32(\Posit32Calculator::AddPositsInArray(SimpleMemory).0.dataIn.1\);
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.left\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 1;
                            -- 
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.num2\ := to_signed(1, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((long)num2 < (long)((ulong)num)) {
                            -- 	Posit32 object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27;
                            -- 	object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27 = new Posit32 (memory.ReadUInt32 (1 + num2), true);
                            -- 	left = Posit32.op_Addition (left, object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27);
                            -- 	num2 = num2 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_6\.
                        -- The while loop's condition:
                        \Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.0\ := SmartResize(\Posit32Calculator::AddPositsInArray(SimpleMemory).0.num2\, 64) < signed((SmartResize(\Posit32Calculator::AddPositsInArray(SimpleMemory).0.num\, 64)));
                        if (\Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	Posit32 object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27;
                            -- 	object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27 = new Posit32 (memory.ReadUInt32 (1 + num2), true);
                            -- 	left = Posit32.op_Addition (left, object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27);
                            -- 	num2 = num2 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- Posit32 object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27 = new Posit32 (memory.ReadUInt32 (1 + num2), true);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27\.\IsNull\ := false;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27\.\PositBits\ := to_unsigned(0, 32);
                            -- Invoking the target's constructor.
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.1\ := to_signed(1, 32) + \Posit32Calculator::AddPositsInArray(SimpleMemory).0.num2\;
                            -- Begin SimpleMemory read.
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(\Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.1\, 32);
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_9\;
                        else 
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6053
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_8\ => 
                        -- State after the while loop which was started in state \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- memory.WriteUInt32 (2, left.PositBits);
                        -- 
                        -- Begin SimpleMemory write.
                        \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(2, 32), 32);
                        \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                        \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertUInt32ToStdLogicVector(\Posit32Calculator::AddPositsInArray(SimpleMemory).0.left\.\PositBits\);
                        \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_9\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.dataIn.2\ := \DataIn\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27\;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= ConvertStdLogicVectorToUInt32(\Posit32Calculator::AddPositsInArray(SimpleMemory).0.dataIn.2\);
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- left = Posit32.op_Addition (left, object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.left\;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.object2223f118be6286062653da39806fcad31be6014b8d70a38b3ea39ed8e7f61a27\;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= true;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                        if (\Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ = \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\) then 
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ <= false;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.return.0\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).return.0\;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.left\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = num2 + 1;
                            -- 
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.2\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0.num2\ + to_signed(1, 32);
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.num2\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0.binaryOperationResult.2\;
                            -- Returning to the repeated state of the while loop which was started in state \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_6\ if the loop wasn't exited with a state change.
                            if (\Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ = \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_11\) then 
                                \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_12\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State\ := \Posit32Calculator::AddPositsInArray(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.Posit32Calculator::AddPositsInArray(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 state machine start
    \Posit32::.ctor(UInt32,Boolean).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(UInt32,Boolean).0._State\: \Posit32::.ctor(UInt32,Boolean).0._States\ := \Posit32::.ctor(UInt32,Boolean).0._State_0\;
        Variable \Posit32::.ctor(UInt32,Boolean).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(UInt32,Boolean).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(UInt32,Boolean).0.fromBitMask\: boolean := false;
        Variable \Posit32::.ctor(UInt32,Boolean).0.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(UInt32,Boolean).0._Finished\ <= false;
                \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_0\;
                \Posit32::.ctor(UInt32,Boolean).0.bits\ := to_unsigned(0, 32);
                \Posit32::.ctor(UInt32,Boolean).0.fromBitMask\ := false;
                \Posit32::.ctor(UInt32,Boolean).0.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(UInt32,Boolean).0._State\ is 
                    when \Posit32::.ctor(UInt32,Boolean).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(UInt32,Boolean).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32,Boolean).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(UInt32,Boolean).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32,Boolean).0._Finished\ <= true;
                        else 
                            \Posit32::.ctor(UInt32,Boolean).0._Finished\ <= false;
                            \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\ <= \Posit32::.ctor(UInt32,Boolean).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32,Boolean).0._State_2\ => 
                        \Posit32::.ctor(UInt32,Boolean).0.this\ := \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\;
                        \Posit32::.ctor(UInt32,Boolean).0.bits\ := \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\;
                        \Posit32::.ctor(UInt32,Boolean).0.fromBitMask\ := \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191 = bits;
                        -- 
                        \Posit32::.ctor(UInt32,Boolean).0.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\ := \Posit32::.ctor(UInt32,Boolean).0.bits\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191;
                        -- 
                        \Posit32::.ctor(UInt32,Boolean).0.this\.\PositBits\ := \Posit32::.ctor(UInt32,Boolean).0.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\;
                        \Posit32::.ctor(UInt32,Boolean).0._State\ := \Posit32::.ctor(UInt32,Boolean).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).1 state machine start
    \Posit32::.ctor(UInt32,Boolean).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(UInt32,Boolean).1._State\: \Posit32::.ctor(UInt32,Boolean).1._States\ := \Posit32::.ctor(UInt32,Boolean).1._State_0\;
        Variable \Posit32::.ctor(UInt32,Boolean).1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(UInt32,Boolean).1.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(UInt32,Boolean).1.fromBitMask\: boolean := false;
        Variable \Posit32::.ctor(UInt32,Boolean).1.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(UInt32,Boolean).1._Finished\ <= false;
                \Posit32::.ctor(UInt32,Boolean).1._State\ := \Posit32::.ctor(UInt32,Boolean).1._State_0\;
                \Posit32::.ctor(UInt32,Boolean).1.bits\ := to_unsigned(0, 32);
                \Posit32::.ctor(UInt32,Boolean).1.fromBitMask\ := false;
                \Posit32::.ctor(UInt32,Boolean).1.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(UInt32,Boolean).1._State\ is 
                    when \Posit32::.ctor(UInt32,Boolean).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(UInt32,Boolean).1._Started\ = true) then 
                            \Posit32::.ctor(UInt32,Boolean).1._State\ := \Posit32::.ctor(UInt32,Boolean).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32,Boolean).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(UInt32,Boolean).1._Started\ = true) then 
                            \Posit32::.ctor(UInt32,Boolean).1._Finished\ <= true;
                        else 
                            \Posit32::.ctor(UInt32,Boolean).1._Finished\ <= false;
                            \Posit32::.ctor(UInt32,Boolean).1._State\ := \Posit32::.ctor(UInt32,Boolean).1._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(UInt32,Boolean).1.this.parameter.Out\ <= \Posit32::.ctor(UInt32,Boolean).1.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32,Boolean).1._State_2\ => 
                        \Posit32::.ctor(UInt32,Boolean).1.this\ := \Posit32::.ctor(UInt32,Boolean).1.this.parameter.In\;
                        \Posit32::.ctor(UInt32,Boolean).1.bits\ := \Posit32::.ctor(UInt32,Boolean).1.bits.parameter.In\;
                        \Posit32::.ctor(UInt32,Boolean).1.fromBitMask\ := \Posit32::.ctor(UInt32,Boolean).1.fromBitMask.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191 = bits;
                        -- 
                        \Posit32::.ctor(UInt32,Boolean).1.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\ := \Posit32::.ctor(UInt32,Boolean).1.bits\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191;
                        -- 
                        \Posit32::.ctor(UInt32,Boolean).1.this\.\PositBits\ := \Posit32::.ctor(UInt32,Boolean).1.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\;
                        \Posit32::.ctor(UInt32,Boolean).1._State\ := \Posit32::.ctor(UInt32,Boolean).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).1 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).2 state machine start
    \Posit32::.ctor(UInt32,Boolean).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(UInt32,Boolean).2._State\: \Posit32::.ctor(UInt32,Boolean).2._States\ := \Posit32::.ctor(UInt32,Boolean).2._State_0\;
        Variable \Posit32::.ctor(UInt32,Boolean).2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(UInt32,Boolean).2.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(UInt32,Boolean).2.fromBitMask\: boolean := false;
        Variable \Posit32::.ctor(UInt32,Boolean).2.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(UInt32,Boolean).2._Finished\ <= false;
                \Posit32::.ctor(UInt32,Boolean).2._State\ := \Posit32::.ctor(UInt32,Boolean).2._State_0\;
                \Posit32::.ctor(UInt32,Boolean).2.bits\ := to_unsigned(0, 32);
                \Posit32::.ctor(UInt32,Boolean).2.fromBitMask\ := false;
                \Posit32::.ctor(UInt32,Boolean).2.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(UInt32,Boolean).2._State\ is 
                    when \Posit32::.ctor(UInt32,Boolean).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(UInt32,Boolean).2._Started\ = true) then 
                            \Posit32::.ctor(UInt32,Boolean).2._State\ := \Posit32::.ctor(UInt32,Boolean).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32,Boolean).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(UInt32,Boolean).2._Started\ = true) then 
                            \Posit32::.ctor(UInt32,Boolean).2._Finished\ <= true;
                        else 
                            \Posit32::.ctor(UInt32,Boolean).2._Finished\ <= false;
                            \Posit32::.ctor(UInt32,Boolean).2._State\ := \Posit32::.ctor(UInt32,Boolean).2._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(UInt32,Boolean).2.this.parameter.Out\ <= \Posit32::.ctor(UInt32,Boolean).2.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32,Boolean).2._State_2\ => 
                        \Posit32::.ctor(UInt32,Boolean).2.this\ := \Posit32::.ctor(UInt32,Boolean).2.this.parameter.In\;
                        \Posit32::.ctor(UInt32,Boolean).2.bits\ := \Posit32::.ctor(UInt32,Boolean).2.bits.parameter.In\;
                        \Posit32::.ctor(UInt32,Boolean).2.fromBitMask\ := \Posit32::.ctor(UInt32,Boolean).2.fromBitMask.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191 = bits;
                        -- 
                        \Posit32::.ctor(UInt32,Boolean).2.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\ := \Posit32::.ctor(UInt32,Boolean).2.bits\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191;
                        -- 
                        \Posit32::.ctor(UInt32,Boolean).2.this\.\PositBits\ := \Posit32::.ctor(UInt32,Boolean).2.conditionalee808a9bc1fddeb51cbd15cc3bc0aca4eb5f797c5a107863504df477d84ba191\;
                        \Posit32::.ctor(UInt32,Boolean).2._State\ := \Posit32::.ctor(UInt32,Boolean).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean).2 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 state machine start
    \Posit32::.ctor(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(UInt32).0._State\: \Posit32::.ctor(UInt32).0._States\ := \Posit32::.ctor(UInt32).0._State_0\;
        Variable \Posit32::.ctor(UInt32).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(UInt32).0.value\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(UInt32).0.flag\: boolean := false;
        Variable \Posit32::.ctor(UInt32).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).0.b2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::.ctor(UInt32).0.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).0.binaryOperationResult.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).0.binaryOperationResult.2\: boolean := false;
        Variable \Posit32::.ctor(UInt32).0.binaryOperationResult.3\: boolean := false;
        Variable \Posit32::.ctor(UInt32).0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::.ctor(UInt32).0.binaryOperationResult.5\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).0.binaryOperationResult.6\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(UInt32).0._Finished\ <= false;
                \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= false;
                \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_0\;
                \Posit32::.ctor(UInt32).0.value\ := to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).0.flag\ := false;
                \Posit32::.ctor(UInt32).0.b\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).0.b2\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).0.binaryOperationResult.0\ := false;
                \Posit32::.ctor(UInt32).0.return.0\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).0.binaryOperationResult.1\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).0.binaryOperationResult.2\ := false;
                \Posit32::.ctor(UInt32).0.binaryOperationResult.3\ := false;
                \Posit32::.ctor(UInt32).0.binaryOperationResult.4\ := false;
                \Posit32::.ctor(UInt32).0.binaryOperationResult.5\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).0.binaryOperationResult.6\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).0.return.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(UInt32).0._State\ is 
                    when \Posit32::.ctor(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(UInt32).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(UInt32).0._Started\ = true) then 
                            \Posit32::.ctor(UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::.ctor(UInt32).0._Finished\ <= false;
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(UInt32).0.this.parameter.Out\ <= \Posit32::.ctor(UInt32).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).0._State_2\ => 
                        \Posit32::.ctor(UInt32).0.this\ := \Posit32::.ctor(UInt32).0.this.parameter.In\;
                        \Posit32::.ctor(UInt32).0.value\ := \Posit32::.ctor(UInt32).0.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = value;
                        -- 
                        \Posit32::.ctor(UInt32).0.this\.\PositBits\ := \Posit32::.ctor(UInt32).0.value\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag = value == 0u;
                        -- 
                        \Posit32::.ctor(UInt32).0.binaryOperationResult.0\ := \Posit32::.ctor(UInt32).0.value\ = to_unsigned(0, 32);
                        \Posit32::.ctor(UInt32).0.flag\ := \Posit32::.ctor(UInt32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (!flag) {
                        -- 	b = (System.Byte)((System.Int32)(Posit32.GetMostSignificantOnePosition (@this.PositBits)) - 1);
                        -- 	b2 = 0;
                        -- 	while ((System.Int32)(b) >= 4 && (System.Int32)(b2) < 31) {
                        -- 		b = (System.Byte)((System.Int32)(b) - 4);
                        -- 		b2 = (System.Byte)((System.Int32)(b2) + 1);
                        -- 	}
                        -- 	@this.PositBits = Posit32.AssemblePositBitsWithRounding (false, (int)b2, (uint)b, @this.PositBits);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::.ctor(UInt32).0._State_4\ and ends in state \Posit32::.ctor(UInt32).0._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::.ctor(UInt32).0._State_3\.

                        if (not(\Posit32::.ctor(UInt32).0.flag\)) then 
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_4\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3753
                    when \Posit32::.ctor(UInt32).0._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(UInt32).0._State_2\.
                        \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).0._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(UInt32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	b = (System.Byte)((System.Int32)(Posit32.GetMostSignificantOnePosition (@this.PositBits)) - 1);
                        -- 	b2 = 0;
                        -- 	while ((System.Int32)(b) >= 4 && (System.Int32)(b2) < 31) {
                        -- 		b = (System.Byte)((System.Int32)(b) - 4);
                        -- 		b2 = (System.Byte)((System.Int32)(b2) + 1);
                        -- 	}
                        -- 	@this.PositBits = Posit32.AssemblePositBitsWithRounding (false, (int)b2, (uint)b, @this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = (System.Byte)((System.Int32)(Posit32.GetMostSignificantOnePosition (@this.PositBits)) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::.ctor(UInt32).0.this\.\PositBits\;
                        \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(UInt32).0.return.0\ := \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::.ctor(UInt32).0.binaryOperationResult.1\ := SmartResize(unsigned(signed(SmartResize((\Posit32::.ctor(UInt32).0.return.0\), 32)) - to_signed(1, 32)), 8);
                            \Posit32::.ctor(UInt32).0.b\ := (\Posit32::.ctor(UInt32).0.binaryOperationResult.1\);
                            -- The following section was transformed from the .NET statement below:
                            -- b2 = 0;
                            -- 
                            \Posit32::.ctor(UInt32).0.b2\ := to_unsigned(0, 8);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((System.Int32)(b) >= 4 && (System.Int32)(b2) < 31) {
                            -- 	b = (System.Byte)((System.Int32)(b) - 4);
                            -- 	b2 = (System.Byte)((System.Int32)(b2) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::.ctor(UInt32).0._State_6\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::.ctor(UInt32).0._State_5\.
                        -- The while loop's condition:
                        \Posit32::.ctor(UInt32).0.binaryOperationResult.2\ := signed(SmartResize((\Posit32::.ctor(UInt32).0.b\), 32)) >= to_signed(4, 32);
                        \Posit32::.ctor(UInt32).0.binaryOperationResult.3\ := signed(SmartResize((\Posit32::.ctor(UInt32).0.b2\), 32)) < to_signed(31, 32);
                        \Posit32::.ctor(UInt32).0.binaryOperationResult.4\ := \Posit32::.ctor(UInt32).0.binaryOperationResult.2\ and \Posit32::.ctor(UInt32).0.binaryOperationResult.3\;
                        if (\Posit32::.ctor(UInt32).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	b = (System.Byte)((System.Int32)(b) - 4);
                            -- 	b2 = (System.Byte)((System.Int32)(b2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- b = (System.Byte)((System.Int32)(b) - 4);
                            -- 
                            \Posit32::.ctor(UInt32).0.binaryOperationResult.5\ := SmartResize(unsigned(signed(SmartResize((\Posit32::.ctor(UInt32).0.b\), 32)) - to_signed(4, 32)), 8);
                            \Posit32::.ctor(UInt32).0.b\ := (\Posit32::.ctor(UInt32).0.binaryOperationResult.5\);
                            -- The following section was transformed from the .NET statement below:
                            -- b2 = (System.Byte)((System.Int32)(b2) + 1);
                            -- 
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_8\;
                        else 
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9521
                    when \Posit32::.ctor(UInt32).0._State_7\ => 
                        -- State after the while loop which was started in state \Posit32::.ctor(UInt32).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = Posit32.AssemblePositBitsWithRounding (false, (int)b2, (uint)b, @this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= False;
                        \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= signed(SmartResize(\Posit32::.ctor(UInt32).0.b2\, 32));
                        \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= SmartResize(\Posit32::.ctor(UInt32).0.b\, 32);
                        \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= \Posit32::.ctor(UInt32).0.this\.\PositBits\;
                        \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::.ctor(UInt32).0.binaryOperationResult.6\ := SmartResize(unsigned(signed(SmartResize((\Posit32::.ctor(UInt32).0.b2\), 32)) + to_signed(1, 32)), 8);
                        \Posit32::.ctor(UInt32).0.b2\ := (\Posit32::.ctor(UInt32).0.binaryOperationResult.6\);
                        -- Returning to the repeated state of the while loop which was started in state \Posit32::.ctor(UInt32).0._State_5\ if the loop wasn't exited with a state change.
                        if (\Posit32::.ctor(UInt32).0._State\ = \Posit32::.ctor(UInt32).0._State_8\) then 
                            \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::.ctor(UInt32).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        if (\Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\) then 
                            \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(UInt32).0.return.1\ := \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\;
                            \Posit32::.ctor(UInt32).0.this\.\PositBits\ := \Posit32::.ctor(UInt32).0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::.ctor(UInt32).0._State_2\.
                            if (\Posit32::.ctor(UInt32).0._State\ = \Posit32::.ctor(UInt32).0._State_9\) then 
                                \Posit32::.ctor(UInt32).0._State\ := \Posit32::.ctor(UInt32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).1 state machine start
    \Posit32::.ctor(UInt32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(UInt32).1._State\: \Posit32::.ctor(UInt32).1._States\ := \Posit32::.ctor(UInt32).1._State_0\;
        Variable \Posit32::.ctor(UInt32).1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(UInt32).1.value\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(UInt32).1.flag\: boolean := false;
        Variable \Posit32::.ctor(UInt32).1.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).1.b2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).1.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::.ctor(UInt32).1.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).1.binaryOperationResult.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).1.binaryOperationResult.2\: boolean := false;
        Variable \Posit32::.ctor(UInt32).1.binaryOperationResult.3\: boolean := false;
        Variable \Posit32::.ctor(UInt32).1.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::.ctor(UInt32).1.binaryOperationResult.5\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).1.binaryOperationResult.6\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).1.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(UInt32).1._Finished\ <= false;
                \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= false;
                \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_0\;
                \Posit32::.ctor(UInt32).1.value\ := to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).1.flag\ := false;
                \Posit32::.ctor(UInt32).1.b\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).1.b2\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).1.binaryOperationResult.0\ := false;
                \Posit32::.ctor(UInt32).1.return.0\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).1.binaryOperationResult.1\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).1.binaryOperationResult.2\ := false;
                \Posit32::.ctor(UInt32).1.binaryOperationResult.3\ := false;
                \Posit32::.ctor(UInt32).1.binaryOperationResult.4\ := false;
                \Posit32::.ctor(UInt32).1.binaryOperationResult.5\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).1.binaryOperationResult.6\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).1.return.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(UInt32).1._State\ is 
                    when \Posit32::.ctor(UInt32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(UInt32).1._Started\ = true) then 
                            \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(UInt32).1._Started\ = true) then 
                            \Posit32::.ctor(UInt32).1._Finished\ <= true;
                        else 
                            \Posit32::.ctor(UInt32).1._Finished\ <= false;
                            \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(UInt32).1.this.parameter.Out\ <= \Posit32::.ctor(UInt32).1.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).1._State_2\ => 
                        \Posit32::.ctor(UInt32).1.this\ := \Posit32::.ctor(UInt32).1.this.parameter.In\;
                        \Posit32::.ctor(UInt32).1.value\ := \Posit32::.ctor(UInt32).1.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = value;
                        -- 
                        \Posit32::.ctor(UInt32).1.this\.\PositBits\ := \Posit32::.ctor(UInt32).1.value\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag = value == 0u;
                        -- 
                        \Posit32::.ctor(UInt32).1.binaryOperationResult.0\ := \Posit32::.ctor(UInt32).1.value\ = to_unsigned(0, 32);
                        \Posit32::.ctor(UInt32).1.flag\ := \Posit32::.ctor(UInt32).1.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (!flag) {
                        -- 	b = (System.Byte)((System.Int32)(Posit32.GetMostSignificantOnePosition (@this.PositBits)) - 1);
                        -- 	b2 = 0;
                        -- 	while ((System.Int32)(b) >= 4 && (System.Int32)(b2) < 31) {
                        -- 		b = (System.Byte)((System.Int32)(b) - 4);
                        -- 		b2 = (System.Byte)((System.Int32)(b2) + 1);
                        -- 	}
                        -- 	@this.PositBits = Posit32.AssemblePositBitsWithRounding (false, (int)b2, (uint)b, @this.PositBits);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::.ctor(UInt32).1._State_4\ and ends in state \Posit32::.ctor(UInt32).1._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::.ctor(UInt32).1._State_3\.

                        if (not(\Posit32::.ctor(UInt32).1.flag\)) then 
                            \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_4\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3753
                    when \Posit32::.ctor(UInt32).1._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(UInt32).1._State_2\.
                        \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).1._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(UInt32).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	b = (System.Byte)((System.Int32)(Posit32.GetMostSignificantOnePosition (@this.PositBits)) - 1);
                        -- 	b2 = 0;
                        -- 	while ((System.Int32)(b) >= 4 && (System.Int32)(b2) < 31) {
                        -- 		b = (System.Byte)((System.Int32)(b) - 4);
                        -- 		b2 = (System.Byte)((System.Int32)(b2) + 1);
                        -- 	}
                        -- 	@this.PositBits = Posit32.AssemblePositBitsWithRounding (false, (int)b2, (uint)b, @this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = (System.Byte)((System.Int32)(Posit32.GetMostSignificantOnePosition (@this.PositBits)) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::.ctor(UInt32).1.this\.\PositBits\;
                        \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).1._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(UInt32).1.return.0\ := \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::.ctor(UInt32).1.binaryOperationResult.1\ := SmartResize(unsigned(signed(SmartResize((\Posit32::.ctor(UInt32).1.return.0\), 32)) - to_signed(1, 32)), 8);
                            \Posit32::.ctor(UInt32).1.b\ := (\Posit32::.ctor(UInt32).1.binaryOperationResult.1\);
                            -- The following section was transformed from the .NET statement below:
                            -- b2 = 0;
                            -- 
                            \Posit32::.ctor(UInt32).1.b2\ := to_unsigned(0, 8);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((System.Int32)(b) >= 4 && (System.Int32)(b2) < 31) {
                            -- 	b = (System.Byte)((System.Int32)(b) - 4);
                            -- 	b2 = (System.Byte)((System.Int32)(b2) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::.ctor(UInt32).1._State_6\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::.ctor(UInt32).1._State_5\.
                        -- The while loop's condition:
                        \Posit32::.ctor(UInt32).1.binaryOperationResult.2\ := signed(SmartResize((\Posit32::.ctor(UInt32).1.b\), 32)) >= to_signed(4, 32);
                        \Posit32::.ctor(UInt32).1.binaryOperationResult.3\ := signed(SmartResize((\Posit32::.ctor(UInt32).1.b2\), 32)) < to_signed(31, 32);
                        \Posit32::.ctor(UInt32).1.binaryOperationResult.4\ := \Posit32::.ctor(UInt32).1.binaryOperationResult.2\ and \Posit32::.ctor(UInt32).1.binaryOperationResult.3\;
                        if (\Posit32::.ctor(UInt32).1.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	b = (System.Byte)((System.Int32)(b) - 4);
                            -- 	b2 = (System.Byte)((System.Int32)(b2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- b = (System.Byte)((System.Int32)(b) - 4);
                            -- 
                            \Posit32::.ctor(UInt32).1.binaryOperationResult.5\ := SmartResize(unsigned(signed(SmartResize((\Posit32::.ctor(UInt32).1.b\), 32)) - to_signed(4, 32)), 8);
                            \Posit32::.ctor(UInt32).1.b\ := (\Posit32::.ctor(UInt32).1.binaryOperationResult.5\);
                            -- The following section was transformed from the .NET statement below:
                            -- b2 = (System.Byte)((System.Int32)(b2) + 1);
                            -- 
                            \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_8\;
                        else 
                            \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9521
                    when \Posit32::.ctor(UInt32).1._State_7\ => 
                        -- State after the while loop which was started in state \Posit32::.ctor(UInt32).1._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = Posit32.AssemblePositBitsWithRounding (false, (int)b2, (uint)b, @this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= False;
                        \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= signed(SmartResize(\Posit32::.ctor(UInt32).1.b2\, 32));
                        \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= SmartResize(\Posit32::.ctor(UInt32).1.b\, 32);
                        \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= \Posit32::.ctor(UInt32).1.this\.\PositBits\;
                        \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).1._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::.ctor(UInt32).1.binaryOperationResult.6\ := SmartResize(unsigned(signed(SmartResize((\Posit32::.ctor(UInt32).1.b2\), 32)) + to_signed(1, 32)), 8);
                        \Posit32::.ctor(UInt32).1.b2\ := (\Posit32::.ctor(UInt32).1.binaryOperationResult.6\);
                        -- Returning to the repeated state of the while loop which was started in state \Posit32::.ctor(UInt32).1._State_5\ if the loop wasn't exited with a state change.
                        if (\Posit32::.ctor(UInt32).1._State\ = \Posit32::.ctor(UInt32).1._State_8\) then 
                            \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::.ctor(UInt32).1._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        if (\Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\) then 
                            \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(UInt32).1.return.1\ := \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\;
                            \Posit32::.ctor(UInt32).1.this\.\PositBits\ := \Posit32::.ctor(UInt32).1.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::.ctor(UInt32).1._State_2\.
                            if (\Posit32::.ctor(UInt32).1._State\ = \Posit32::.ctor(UInt32).1._State_9\) then 
                                \Posit32::.ctor(UInt32).1._State\ := \Posit32::.ctor(UInt32).1._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).1 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).2 state machine start
    \Posit32::.ctor(UInt32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(UInt32).2._State\: \Posit32::.ctor(UInt32).2._States\ := \Posit32::.ctor(UInt32).2._State_0\;
        Variable \Posit32::.ctor(UInt32).2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(UInt32).2.value\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(UInt32).2.flag\: boolean := false;
        Variable \Posit32::.ctor(UInt32).2.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).2.b2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).2.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::.ctor(UInt32).2.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).2.binaryOperationResult.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).2.binaryOperationResult.2\: boolean := false;
        Variable \Posit32::.ctor(UInt32).2.binaryOperationResult.3\: boolean := false;
        Variable \Posit32::.ctor(UInt32).2.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::.ctor(UInt32).2.binaryOperationResult.5\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).2.binaryOperationResult.6\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::.ctor(UInt32).2.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(UInt32).2._Finished\ <= false;
                \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= false;
                \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_0\;
                \Posit32::.ctor(UInt32).2.value\ := to_unsigned(0, 32);
                \Posit32::.ctor(UInt32).2.flag\ := false;
                \Posit32::.ctor(UInt32).2.b\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).2.b2\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).2.binaryOperationResult.0\ := false;
                \Posit32::.ctor(UInt32).2.return.0\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).2.binaryOperationResult.1\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).2.binaryOperationResult.2\ := false;
                \Posit32::.ctor(UInt32).2.binaryOperationResult.3\ := false;
                \Posit32::.ctor(UInt32).2.binaryOperationResult.4\ := false;
                \Posit32::.ctor(UInt32).2.binaryOperationResult.5\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).2.binaryOperationResult.6\ := to_unsigned(0, 8);
                \Posit32::.ctor(UInt32).2.return.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(UInt32).2._State\ is 
                    when \Posit32::.ctor(UInt32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(UInt32).2._Started\ = true) then 
                            \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(UInt32).2._Started\ = true) then 
                            \Posit32::.ctor(UInt32).2._Finished\ <= true;
                        else 
                            \Posit32::.ctor(UInt32).2._Finished\ <= false;
                            \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(UInt32).2.this.parameter.Out\ <= \Posit32::.ctor(UInt32).2.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).2._State_2\ => 
                        \Posit32::.ctor(UInt32).2.this\ := \Posit32::.ctor(UInt32).2.this.parameter.In\;
                        \Posit32::.ctor(UInt32).2.value\ := \Posit32::.ctor(UInt32).2.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = value;
                        -- 
                        \Posit32::.ctor(UInt32).2.this\.\PositBits\ := \Posit32::.ctor(UInt32).2.value\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag = value == 0u;
                        -- 
                        \Posit32::.ctor(UInt32).2.binaryOperationResult.0\ := \Posit32::.ctor(UInt32).2.value\ = to_unsigned(0, 32);
                        \Posit32::.ctor(UInt32).2.flag\ := \Posit32::.ctor(UInt32).2.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (!flag) {
                        -- 	b = (System.Byte)((System.Int32)(Posit32.GetMostSignificantOnePosition (@this.PositBits)) - 1);
                        -- 	b2 = 0;
                        -- 	while ((System.Int32)(b) >= 4 && (System.Int32)(b2) < 31) {
                        -- 		b = (System.Byte)((System.Int32)(b) - 4);
                        -- 		b2 = (System.Byte)((System.Int32)(b2) + 1);
                        -- 	}
                        -- 	@this.PositBits = Posit32.AssemblePositBitsWithRounding (false, (int)b2, (uint)b, @this.PositBits);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::.ctor(UInt32).2._State_4\ and ends in state \Posit32::.ctor(UInt32).2._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::.ctor(UInt32).2._State_3\.

                        if (not(\Posit32::.ctor(UInt32).2.flag\)) then 
                            \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_4\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3753
                    when \Posit32::.ctor(UInt32).2._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(UInt32).2._State_2\.
                        \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).2._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(UInt32).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	b = (System.Byte)((System.Int32)(Posit32.GetMostSignificantOnePosition (@this.PositBits)) - 1);
                        -- 	b2 = 0;
                        -- 	while ((System.Int32)(b) >= 4 && (System.Int32)(b2) < 31) {
                        -- 		b = (System.Byte)((System.Int32)(b) - 4);
                        -- 		b2 = (System.Byte)((System.Int32)(b2) + 1);
                        -- 	}
                        -- 	@this.PositBits = Posit32.AssemblePositBitsWithRounding (false, (int)b2, (uint)b, @this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = (System.Byte)((System.Int32)(Posit32.GetMostSignificantOnePosition (@this.PositBits)) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::.ctor(UInt32).2.this\.\PositBits\;
                        \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).2._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(UInt32).2.return.0\ := \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::.ctor(UInt32).2.binaryOperationResult.1\ := SmartResize(unsigned(signed(SmartResize((\Posit32::.ctor(UInt32).2.return.0\), 32)) - to_signed(1, 32)), 8);
                            \Posit32::.ctor(UInt32).2.b\ := (\Posit32::.ctor(UInt32).2.binaryOperationResult.1\);
                            -- The following section was transformed from the .NET statement below:
                            -- b2 = 0;
                            -- 
                            \Posit32::.ctor(UInt32).2.b2\ := to_unsigned(0, 8);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((System.Int32)(b) >= 4 && (System.Int32)(b2) < 31) {
                            -- 	b = (System.Byte)((System.Int32)(b) - 4);
                            -- 	b2 = (System.Byte)((System.Int32)(b2) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::.ctor(UInt32).2._State_6\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::.ctor(UInt32).2._State_5\.
                        -- The while loop's condition:
                        \Posit32::.ctor(UInt32).2.binaryOperationResult.2\ := signed(SmartResize((\Posit32::.ctor(UInt32).2.b\), 32)) >= to_signed(4, 32);
                        \Posit32::.ctor(UInt32).2.binaryOperationResult.3\ := signed(SmartResize((\Posit32::.ctor(UInt32).2.b2\), 32)) < to_signed(31, 32);
                        \Posit32::.ctor(UInt32).2.binaryOperationResult.4\ := \Posit32::.ctor(UInt32).2.binaryOperationResult.2\ and \Posit32::.ctor(UInt32).2.binaryOperationResult.3\;
                        if (\Posit32::.ctor(UInt32).2.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	b = (System.Byte)((System.Int32)(b) - 4);
                            -- 	b2 = (System.Byte)((System.Int32)(b2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- b = (System.Byte)((System.Int32)(b) - 4);
                            -- 
                            \Posit32::.ctor(UInt32).2.binaryOperationResult.5\ := SmartResize(unsigned(signed(SmartResize((\Posit32::.ctor(UInt32).2.b\), 32)) - to_signed(4, 32)), 8);
                            \Posit32::.ctor(UInt32).2.b\ := (\Posit32::.ctor(UInt32).2.binaryOperationResult.5\);
                            -- The following section was transformed from the .NET statement below:
                            -- b2 = (System.Byte)((System.Int32)(b2) + 1);
                            -- 
                            \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_8\;
                        else 
                            \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9521
                    when \Posit32::.ctor(UInt32).2._State_7\ => 
                        -- State after the while loop which was started in state \Posit32::.ctor(UInt32).2._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = Posit32.AssemblePositBitsWithRounding (false, (int)b2, (uint)b, @this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= False;
                        \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= signed(SmartResize(\Posit32::.ctor(UInt32).2.b2\, 32));
                        \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= SmartResize(\Posit32::.ctor(UInt32).2.b\, 32);
                        \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= \Posit32::.ctor(UInt32).2.this\.\PositBits\;
                        \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(UInt32).2._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::.ctor(UInt32).2.binaryOperationResult.6\ := SmartResize(unsigned(signed(SmartResize((\Posit32::.ctor(UInt32).2.b2\), 32)) + to_signed(1, 32)), 8);
                        \Posit32::.ctor(UInt32).2.b2\ := (\Posit32::.ctor(UInt32).2.binaryOperationResult.6\);
                        -- Returning to the repeated state of the while loop which was started in state \Posit32::.ctor(UInt32).2._State_5\ if the loop wasn't exited with a state change.
                        if (\Posit32::.ctor(UInt32).2._State\ = \Posit32::.ctor(UInt32).2._State_8\) then 
                            \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::.ctor(UInt32).2._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        if (\Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\) then 
                            \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(UInt32).2.return.1\ := \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\;
                            \Posit32::.ctor(UInt32).2.this\.\PositBits\ := \Posit32::.ctor(UInt32).2.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::.ctor(UInt32).2._State_2\.
                            if (\Posit32::.ctor(UInt32).2._State\ = \Posit32::.ctor(UInt32).2._State_9\) then 
                                \Posit32::.ctor(UInt32).2._State\ := \Posit32::.ctor(UInt32).2._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).2 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 state machine start
    \Posit32::.ctor(Int32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(Int32).0._State\: \Posit32::.ctor(Int32).0._States\ := \Posit32::.ctor(Int32).0._State_0\;
        Variable \Posit32::.ctor(Int32).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Int32).0.value\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Int32).0.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Int32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::.ctor(Int32).0.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Int32).0.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Int32).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(Int32).0._Finished\ <= false;
                \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_0\;
                \Posit32::.ctor(Int32).0.value\ := to_signed(0, 32);
                \Posit32::.ctor(Int32).0.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\ := to_unsigned(0, 32);
                \Posit32::.ctor(Int32).0.binaryOperationResult.0\ := false;
                \Posit32::.ctor(Int32).0.return.0\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(Int32).0._State\ is 
                    when \Posit32::.ctor(Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(Int32).0._Started\ = true) then 
                            \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(Int32).0._Started\ = true) then 
                            \Posit32::.ctor(Int32).0._Finished\ <= true;
                        else 
                            \Posit32::.ctor(Int32).0._Finished\ <= false;
                            \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(Int32).0.this.parameter.Out\ <= \Posit32::.ctor(Int32).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_2\ => 
                        \Posit32::.ctor(Int32).0.this\ := \Posit32::.ctor(Int32).0.this.parameter.In\;
                        \Posit32::.ctor(Int32).0.value\ := \Posit32::.ctor(Int32).0.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (value >= 0) {
                        -- 	Posit32 objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b;
                        -- 	objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b = new Posit32 ((uint)value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b.PositBits;
                        -- }
                        -- else {
                        -- 	Posit32 object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57;
                        -- 	object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57 = new Posit32 ((uint)-value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = Posit32.GetTwosComplement (object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57.PositBits);
                        -- }
                        -- 
                        \Posit32::.ctor(Int32).0.binaryOperationResult.0\ := \Posit32::.ctor(Int32).0.value\ >= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::.ctor(Int32).0._State_4\ and ends in state \Posit32::.ctor(Int32).0._State_5\.
                        --     * The false branch starts in state \Posit32::.ctor(Int32).0._State_6\ and ends in state \Posit32::.ctor(Int32).0._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::.ctor(Int32).0._State_3\.

                        if (\Posit32::.ctor(Int32).0.binaryOperationResult.0\) then 
                            \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_4\;
                        else 
                            \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::.ctor(Int32).0._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e;
                        -- 
                        \Posit32::.ctor(Int32).0.this\.\PositBits\ := \Posit32::.ctor(Int32).0.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\;
                        \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	Posit32 objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b;
                        -- 	objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b = new Posit32 ((uint)value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b = new Posit32 ((uint)value);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::.ctor(Int32).0.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\.\IsNull\ := false;
                        \Posit32::.ctor(Int32).0.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.Out.0\ <= \Posit32::.ctor(Int32).0.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\;
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= unsigned(\Posit32::.ctor(Int32).0.value\);
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        if (\Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ = \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Int32).0.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\ := \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b.PositBits;
                            -- 
                            \Posit32::.ctor(Int32).0.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\ := \Posit32::.ctor(Int32).0.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\.\PositBits\;
                            -- Going to the state after the if-else which was started in state \Posit32::.ctor(Int32).0._State_2\.
                            if (\Posit32::.ctor(Int32).0._State\ = \Posit32::.ctor(Int32).0._State_5\) then 
                                \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::.ctor(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	Posit32 object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57;
                        -- 	object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57 = new Posit32 ((uint)-value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = Posit32.GetTwosComplement (object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57 = new Posit32 ((uint)-value);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::.ctor(Int32).0.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\.\IsNull\ := false;
                        \Posit32::.ctor(Int32).0.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::.ctor(Int32).0._State_7\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.Out.0\ <= \Posit32::.ctor(Int32).0.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\;
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= unsigned(-\Posit32::.ctor(Int32).0.value\);
                        \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        if (\Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ = \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Int32).0.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\ := \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = Posit32.GetTwosComplement (object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57.PositBits);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                            \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::.ctor(Int32).0.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\.\PositBits\;
                            \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                            \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Int32).0.return.0\ := \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::.ctor(Int32).0.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\ := \Posit32::.ctor(Int32).0.return.0\;
                            -- Going to the state after the if-else which was started in state \Posit32::.ctor(Int32).0._State_2\.
                            if (\Posit32::.ctor(Int32).0._State\ = \Posit32::.ctor(Int32).0._State_9\) then 
                                \Posit32::.ctor(Int32).0._State\ := \Posit32::.ctor(Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).1 state machine start
    \Posit32::.ctor(Int32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(Int32).1._State\: \Posit32::.ctor(Int32).1._States\ := \Posit32::.ctor(Int32).1._State_0\;
        Variable \Posit32::.ctor(Int32).1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Int32).1.value\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Int32).1.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Int32).1.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::.ctor(Int32).1.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Int32).1.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Int32).1.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(Int32).1._Finished\ <= false;
                \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_0\;
                \Posit32::.ctor(Int32).1.value\ := to_signed(0, 32);
                \Posit32::.ctor(Int32).1.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\ := to_unsigned(0, 32);
                \Posit32::.ctor(Int32).1.binaryOperationResult.0\ := false;
                \Posit32::.ctor(Int32).1.return.0\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(Int32).1._State\ is 
                    when \Posit32::.ctor(Int32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(Int32).1._Started\ = true) then 
                            \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(Int32).1._Started\ = true) then 
                            \Posit32::.ctor(Int32).1._Finished\ <= true;
                        else 
                            \Posit32::.ctor(Int32).1._Finished\ <= false;
                            \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(Int32).1.this.parameter.Out\ <= \Posit32::.ctor(Int32).1.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).1._State_2\ => 
                        \Posit32::.ctor(Int32).1.this\ := \Posit32::.ctor(Int32).1.this.parameter.In\;
                        \Posit32::.ctor(Int32).1.value\ := \Posit32::.ctor(Int32).1.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (value >= 0) {
                        -- 	Posit32 objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b;
                        -- 	objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b = new Posit32 ((uint)value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b.PositBits;
                        -- }
                        -- else {
                        -- 	Posit32 object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57;
                        -- 	object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57 = new Posit32 ((uint)-value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = Posit32.GetTwosComplement (object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57.PositBits);
                        -- }
                        -- 
                        \Posit32::.ctor(Int32).1.binaryOperationResult.0\ := \Posit32::.ctor(Int32).1.value\ >= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::.ctor(Int32).1._State_4\ and ends in state \Posit32::.ctor(Int32).1._State_5\.
                        --     * The false branch starts in state \Posit32::.ctor(Int32).1._State_6\ and ends in state \Posit32::.ctor(Int32).1._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::.ctor(Int32).1._State_3\.

                        if (\Posit32::.ctor(Int32).1.binaryOperationResult.0\) then 
                            \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_4\;
                        else 
                            \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::.ctor(Int32).1._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(Int32).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e;
                        -- 
                        \Posit32::.ctor(Int32).1.this\.\PositBits\ := \Posit32::.ctor(Int32).1.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\;
                        \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).1._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(Int32).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	Posit32 objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b;
                        -- 	objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b = new Posit32 ((uint)value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b = new Posit32 ((uint)value);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::.ctor(Int32).1.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\.\IsNull\ := false;
                        \Posit32::.ctor(Int32).1.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).this.parameter.Out.0\ <= \Posit32::.ctor(Int32).1.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\;
                        \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= unsigned(\Posit32::.ctor(Int32).1.value\);
                        \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).1._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        if (\Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Started.0\ = \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Int32).1.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\ := \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b.PositBits;
                            -- 
                            \Posit32::.ctor(Int32).1.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\ := \Posit32::.ctor(Int32).1.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\.\PositBits\;
                            -- Going to the state after the if-else which was started in state \Posit32::.ctor(Int32).1._State_2\.
                            if (\Posit32::.ctor(Int32).1._State\ = \Posit32::.ctor(Int32).1._State_5\) then 
                                \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).1._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::.ctor(Int32).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	Posit32 object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57;
                        -- 	object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57 = new Posit32 ((uint)-value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = Posit32.GetTwosComplement (object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57 = new Posit32 ((uint)-value);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::.ctor(Int32).1.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\.\IsNull\ := false;
                        \Posit32::.ctor(Int32).1.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::.ctor(Int32).1._State_7\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).this.parameter.Out.0\ <= \Posit32::.ctor(Int32).1.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\;
                        \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= unsigned(-\Posit32::.ctor(Int32).1.value\);
                        \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).1._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        if (\Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Started.0\ = \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Int32).1.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\ := \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = Posit32.GetTwosComplement (object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57.PositBits);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                            \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::.ctor(Int32).1.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\.\PositBits\;
                            \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                            \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).1._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Int32).1.return.0\ := \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::.ctor(Int32).1.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\ := \Posit32::.ctor(Int32).1.return.0\;
                            -- Going to the state after the if-else which was started in state \Posit32::.ctor(Int32).1._State_2\.
                            if (\Posit32::.ctor(Int32).1._State\ = \Posit32::.ctor(Int32).1._State_9\) then 
                                \Posit32::.ctor(Int32).1._State\ := \Posit32::.ctor(Int32).1._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).1 state machine end


    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).2 state machine start
    \Posit32::.ctor(Int32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::.ctor(Int32).2._State\: \Posit32::.ctor(Int32).2._States\ := \Posit32::.ctor(Int32).2._State_0\;
        Variable \Posit32::.ctor(Int32).2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Int32).2.value\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::.ctor(Int32).2.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::.ctor(Int32).2.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::.ctor(Int32).2.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Int32).2.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::.ctor(Int32).2.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::.ctor(Int32).2._Finished\ <= false;
                \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_0\;
                \Posit32::.ctor(Int32).2.value\ := to_signed(0, 32);
                \Posit32::.ctor(Int32).2.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\ := to_unsigned(0, 32);
                \Posit32::.ctor(Int32).2.binaryOperationResult.0\ := false;
                \Posit32::.ctor(Int32).2.return.0\ := to_unsigned(0, 32);
            else 
                case \Posit32::.ctor(Int32).2._State\ is 
                    when \Posit32::.ctor(Int32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::.ctor(Int32).2._Started\ = true) then 
                            \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::.ctor(Int32).2._Started\ = true) then 
                            \Posit32::.ctor(Int32).2._Finished\ <= true;
                        else 
                            \Posit32::.ctor(Int32).2._Finished\ <= false;
                            \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit32::.ctor(Int32).2.this.parameter.Out\ <= \Posit32::.ctor(Int32).2.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).2._State_2\ => 
                        \Posit32::.ctor(Int32).2.this\ := \Posit32::.ctor(Int32).2.this.parameter.In\;
                        \Posit32::.ctor(Int32).2.value\ := \Posit32::.ctor(Int32).2.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (value >= 0) {
                        -- 	Posit32 objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b;
                        -- 	objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b = new Posit32 ((uint)value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b.PositBits;
                        -- }
                        -- else {
                        -- 	Posit32 object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57;
                        -- 	object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57 = new Posit32 ((uint)-value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = Posit32.GetTwosComplement (object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57.PositBits);
                        -- }
                        -- 
                        \Posit32::.ctor(Int32).2.binaryOperationResult.0\ := \Posit32::.ctor(Int32).2.value\ >= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::.ctor(Int32).2._State_4\ and ends in state \Posit32::.ctor(Int32).2._State_5\.
                        --     * The false branch starts in state \Posit32::.ctor(Int32).2._State_6\ and ends in state \Posit32::.ctor(Int32).2._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::.ctor(Int32).2._State_3\.

                        if (\Posit32::.ctor(Int32).2.binaryOperationResult.0\) then 
                            \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_4\;
                        else 
                            \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::.ctor(Int32).2._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::.ctor(Int32).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e;
                        -- 
                        \Posit32::.ctor(Int32).2.this\.\PositBits\ := \Posit32::.ctor(Int32).2.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\;
                        \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).2._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::.ctor(Int32).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	Posit32 objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b;
                        -- 	objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b = new Posit32 ((uint)value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b = new Posit32 ((uint)value);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::.ctor(Int32).2.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\.\IsNull\ := false;
                        \Posit32::.ctor(Int32).2.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).this.parameter.Out.0\ <= \Posit32::.ctor(Int32).2.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\;
                        \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= unsigned(\Posit32::.ctor(Int32).2.value\);
                        \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).2._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        if (\Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Started.0\ = \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Int32).2.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\ := \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b.PositBits;
                            -- 
                            \Posit32::.ctor(Int32).2.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\ := \Posit32::.ctor(Int32).2.objecta6080a7198b481c1d6693104edda467563fe0f022258778da20725dcd3a3802b\.\PositBits\;
                            -- Going to the state after the if-else which was started in state \Posit32::.ctor(Int32).2._State_2\.
                            if (\Posit32::.ctor(Int32).2._State\ = \Posit32::.ctor(Int32).2._State_5\) then 
                                \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).2._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::.ctor(Int32).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	Posit32 object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57;
                        -- 	object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57 = new Posit32 ((uint)-value);
                        -- 	conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = Posit32.GetTwosComplement (object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57 = new Posit32 ((uint)-value);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::.ctor(Int32).2.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\.\IsNull\ := false;
                        \Posit32::.ctor(Int32).2.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::.ctor(Int32).2._State_7\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).this.parameter.Out.0\ <= \Posit32::.ctor(Int32).2.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\;
                        \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).value.parameter.Out.0\ <= unsigned(-\Posit32::.ctor(Int32).2.value\);
                        \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Started.0\ <= true;
                        \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).2._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32)
                        if (\Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Started.0\ = \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Int32).2.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\ := \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e = Posit32.GetTwosComplement (object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57.PositBits);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                            \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::.ctor(Int32).2.object4d8a67ea2db3457e33bcc1aa42ff154dd8a42d17d1f49d461569716c62987d57\.\PositBits\;
                            \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                            \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::.ctor(Int32).2._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::.ctor(Int32).2.return.0\ := \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::.ctor(Int32).2.conditionalbf40994b16b08e8bf40fff739d6e7ef277b64d0b6a7c9a9f9069815990d1f89e\ := \Posit32::.ctor(Int32).2.return.0\;
                            -- Going to the state after the if-else which was started in state \Posit32::.ctor(Int32).2._State_2\.
                            if (\Posit32::.ctor(Int32).2._State\ = \Posit32::.ctor(Int32).2._State_9\) then 
                                \Posit32::.ctor(Int32).2._State\ := \Posit32::.ctor(Int32).2._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).2 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().0 state machine start
    \Posit32::IsPositive().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::IsPositive().0._State\: \Posit32::IsPositive().0._States\ := \Posit32::IsPositive().0._State_0\;
        Variable \Posit32::IsPositive().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::IsPositive().0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::IsPositive().0.binaryOperationResult.1\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::IsPositive().0._Finished\ <= false;
                \Posit32::IsPositive().0.return\ <= false;
                \Posit32::IsPositive().0._State\ := \Posit32::IsPositive().0._State_0\;
                \Posit32::IsPositive().0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::IsPositive().0.binaryOperationResult.1\ := false;
            else 
                case \Posit32::IsPositive().0._State\ is 
                    when \Posit32::IsPositive().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::IsPositive().0._Started\ = true) then 
                            \Posit32::IsPositive().0._State\ := \Posit32::IsPositive().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsPositive().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::IsPositive().0._Started\ = true) then 
                            \Posit32::IsPositive().0._Finished\ <= true;
                        else 
                            \Posit32::IsPositive().0._Finished\ <= false;
                            \Posit32::IsPositive().0._State\ := \Posit32::IsPositive().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsPositive().0._State_2\ => 
                        \Posit32::IsPositive().0.this\ := \Posit32::IsPositive().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits & 2147483648u == 0u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::IsPositive().0.binaryOperationResult.0\ := \Posit32::IsPositive().0.this\.\PositBits\ and "10000000000000000000000000000000";
                        \Posit32::IsPositive().0.binaryOperationResult.1\ := \Posit32::IsPositive().0.binaryOperationResult.0\ = to_unsigned(0, 32);
                        \Posit32::IsPositive().0.return\ <= \Posit32::IsPositive().0.binaryOperationResult.1\;
                        \Posit32::IsPositive().0._State\ := \Posit32::IsPositive().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.4137
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().1 state machine start
    \Posit32::IsPositive().1._StateMachine\: process (\Clock\) 
        Variable \Posit32::IsPositive().1._State\: \Posit32::IsPositive().1._States\ := \Posit32::IsPositive().1._State_0\;
        Variable \Posit32::IsPositive().1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::IsPositive().1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::IsPositive().1.binaryOperationResult.1\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::IsPositive().1._Finished\ <= false;
                \Posit32::IsPositive().1.return\ <= false;
                \Posit32::IsPositive().1._State\ := \Posit32::IsPositive().1._State_0\;
                \Posit32::IsPositive().1.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::IsPositive().1.binaryOperationResult.1\ := false;
            else 
                case \Posit32::IsPositive().1._State\ is 
                    when \Posit32::IsPositive().1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::IsPositive().1._Started\ = true) then 
                            \Posit32::IsPositive().1._State\ := \Posit32::IsPositive().1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsPositive().1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::IsPositive().1._Started\ = true) then 
                            \Posit32::IsPositive().1._Finished\ <= true;
                        else 
                            \Posit32::IsPositive().1._Finished\ <= false;
                            \Posit32::IsPositive().1._State\ := \Posit32::IsPositive().1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsPositive().1._State_2\ => 
                        \Posit32::IsPositive().1.this\ := \Posit32::IsPositive().1.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits & 2147483648u == 0u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::IsPositive().1.binaryOperationResult.0\ := \Posit32::IsPositive().1.this\.\PositBits\ and "10000000000000000000000000000000";
                        \Posit32::IsPositive().1.binaryOperationResult.1\ := \Posit32::IsPositive().1.binaryOperationResult.0\ = to_unsigned(0, 32);
                        \Posit32::IsPositive().1.return\ <= \Posit32::IsPositive().1.binaryOperationResult.1\;
                        \Posit32::IsPositive().1._State\ := \Posit32::IsPositive().1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.4137
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().1 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().2 state machine start
    \Posit32::IsPositive().2._StateMachine\: process (\Clock\) 
        Variable \Posit32::IsPositive().2._State\: \Posit32::IsPositive().2._States\ := \Posit32::IsPositive().2._State_0\;
        Variable \Posit32::IsPositive().2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::IsPositive().2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::IsPositive().2.binaryOperationResult.1\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::IsPositive().2._Finished\ <= false;
                \Posit32::IsPositive().2.return\ <= false;
                \Posit32::IsPositive().2._State\ := \Posit32::IsPositive().2._State_0\;
                \Posit32::IsPositive().2.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::IsPositive().2.binaryOperationResult.1\ := false;
            else 
                case \Posit32::IsPositive().2._State\ is 
                    when \Posit32::IsPositive().2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::IsPositive().2._Started\ = true) then 
                            \Posit32::IsPositive().2._State\ := \Posit32::IsPositive().2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsPositive().2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::IsPositive().2._Started\ = true) then 
                            \Posit32::IsPositive().2._Finished\ <= true;
                        else 
                            \Posit32::IsPositive().2._Finished\ <= false;
                            \Posit32::IsPositive().2._State\ := \Posit32::IsPositive().2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsPositive().2._State_2\ => 
                        \Posit32::IsPositive().2.this\ := \Posit32::IsPositive().2.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits & 2147483648u == 0u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::IsPositive().2.binaryOperationResult.0\ := \Posit32::IsPositive().2.this\.\PositBits\ and "10000000000000000000000000000000";
                        \Posit32::IsPositive().2.binaryOperationResult.1\ := \Posit32::IsPositive().2.binaryOperationResult.0\ = to_unsigned(0, 32);
                        \Posit32::IsPositive().2.return\ <= \Posit32::IsPositive().2.binaryOperationResult.1\;
                        \Posit32::IsPositive().2._State\ := \Posit32::IsPositive().2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.4137
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsPositive().2 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().0 state machine start
    \Posit32::IsNaN().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::IsNaN().0._State\: \Posit32::IsNaN().0._States\ := \Posit32::IsNaN().0._State_0\;
        Variable \Posit32::IsNaN().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::IsNaN().0.binaryOperationResult.0\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::IsNaN().0._Finished\ <= false;
                \Posit32::IsNaN().0.return\ <= false;
                \Posit32::IsNaN().0._State\ := \Posit32::IsNaN().0._State_0\;
                \Posit32::IsNaN().0.binaryOperationResult.0\ := false;
            else 
                case \Posit32::IsNaN().0._State\ is 
                    when \Posit32::IsNaN().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::IsNaN().0._Started\ = true) then 
                            \Posit32::IsNaN().0._State\ := \Posit32::IsNaN().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsNaN().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::IsNaN().0._Started\ = true) then 
                            \Posit32::IsNaN().0._Finished\ <= true;
                        else 
                            \Posit32::IsNaN().0._Finished\ <= false;
                            \Posit32::IsNaN().0._State\ := \Posit32::IsNaN().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsNaN().0._State_2\ => 
                        \Posit32::IsNaN().0.this\ := \Posit32::IsNaN().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits == 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::IsNaN().0.binaryOperationResult.0\ := \Posit32::IsNaN().0.this\.\PositBits\ = "10000000000000000000000000000000";
                        \Posit32::IsNaN().0.return\ <= \Posit32::IsNaN().0.binaryOperationResult.0\;
                        \Posit32::IsNaN().0._State\ := \Posit32::IsNaN().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().1 state machine start
    \Posit32::IsNaN().1._StateMachine\: process (\Clock\) 
        Variable \Posit32::IsNaN().1._State\: \Posit32::IsNaN().1._States\ := \Posit32::IsNaN().1._State_0\;
        Variable \Posit32::IsNaN().1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::IsNaN().1.binaryOperationResult.0\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::IsNaN().1._Finished\ <= false;
                \Posit32::IsNaN().1.return\ <= false;
                \Posit32::IsNaN().1._State\ := \Posit32::IsNaN().1._State_0\;
                \Posit32::IsNaN().1.binaryOperationResult.0\ := false;
            else 
                case \Posit32::IsNaN().1._State\ is 
                    when \Posit32::IsNaN().1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::IsNaN().1._Started\ = true) then 
                            \Posit32::IsNaN().1._State\ := \Posit32::IsNaN().1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsNaN().1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::IsNaN().1._Started\ = true) then 
                            \Posit32::IsNaN().1._Finished\ <= true;
                        else 
                            \Posit32::IsNaN().1._Finished\ <= false;
                            \Posit32::IsNaN().1._State\ := \Posit32::IsNaN().1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsNaN().1._State_2\ => 
                        \Posit32::IsNaN().1.this\ := \Posit32::IsNaN().1.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits == 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::IsNaN().1.binaryOperationResult.0\ := \Posit32::IsNaN().1.this\.\PositBits\ = "10000000000000000000000000000000";
                        \Posit32::IsNaN().1.return\ <= \Posit32::IsNaN().1.binaryOperationResult.0\;
                        \Posit32::IsNaN().1._State\ := \Posit32::IsNaN().1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().1 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().2 state machine start
    \Posit32::IsNaN().2._StateMachine\: process (\Clock\) 
        Variable \Posit32::IsNaN().2._State\: \Posit32::IsNaN().2._States\ := \Posit32::IsNaN().2._State_0\;
        Variable \Posit32::IsNaN().2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::IsNaN().2.binaryOperationResult.0\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::IsNaN().2._Finished\ <= false;
                \Posit32::IsNaN().2.return\ <= false;
                \Posit32::IsNaN().2._State\ := \Posit32::IsNaN().2._State_0\;
                \Posit32::IsNaN().2.binaryOperationResult.0\ := false;
            else 
                case \Posit32::IsNaN().2._State\ is 
                    when \Posit32::IsNaN().2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::IsNaN().2._Started\ = true) then 
                            \Posit32::IsNaN().2._State\ := \Posit32::IsNaN().2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsNaN().2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::IsNaN().2._Started\ = true) then 
                            \Posit32::IsNaN().2._Finished\ <= true;
                        else 
                            \Posit32::IsNaN().2._Finished\ <= false;
                            \Posit32::IsNaN().2._State\ := \Posit32::IsNaN().2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsNaN().2._State_2\ => 
                        \Posit32::IsNaN().2.this\ := \Posit32::IsNaN().2.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits == 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::IsNaN().2.binaryOperationResult.0\ := \Posit32::IsNaN().2.this\.\PositBits\ = "10000000000000000000000000000000";
                        \Posit32::IsNaN().2.return\ <= \Posit32::IsNaN().2.binaryOperationResult.0\;
                        \Posit32::IsNaN().2._State\ := \Posit32::IsNaN().2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsNaN().2 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().0 state machine start
    \Posit32::IsZero().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::IsZero().0._State\: \Posit32::IsZero().0._States\ := \Posit32::IsZero().0._State_0\;
        Variable \Posit32::IsZero().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::IsZero().0.binaryOperationResult.0\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::IsZero().0._Finished\ <= false;
                \Posit32::IsZero().0.return\ <= false;
                \Posit32::IsZero().0._State\ := \Posit32::IsZero().0._State_0\;
                \Posit32::IsZero().0.binaryOperationResult.0\ := false;
            else 
                case \Posit32::IsZero().0._State\ is 
                    when \Posit32::IsZero().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::IsZero().0._Started\ = true) then 
                            \Posit32::IsZero().0._State\ := \Posit32::IsZero().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsZero().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::IsZero().0._Started\ = true) then 
                            \Posit32::IsZero().0._Finished\ <= true;
                        else 
                            \Posit32::IsZero().0._Finished\ <= false;
                            \Posit32::IsZero().0._State\ := \Posit32::IsZero().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsZero().0._State_2\ => 
                        \Posit32::IsZero().0.this\ := \Posit32::IsZero().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits == 0u;
                        -- 
                        \Posit32::IsZero().0.binaryOperationResult.0\ := \Posit32::IsZero().0.this\.\PositBits\ = to_unsigned(0, 32);
                        \Posit32::IsZero().0.return\ <= \Posit32::IsZero().0.binaryOperationResult.0\;
                        \Posit32::IsZero().0._State\ := \Posit32::IsZero().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().1 state machine start
    \Posit32::IsZero().1._StateMachine\: process (\Clock\) 
        Variable \Posit32::IsZero().1._State\: \Posit32::IsZero().1._States\ := \Posit32::IsZero().1._State_0\;
        Variable \Posit32::IsZero().1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::IsZero().1.binaryOperationResult.0\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::IsZero().1._Finished\ <= false;
                \Posit32::IsZero().1.return\ <= false;
                \Posit32::IsZero().1._State\ := \Posit32::IsZero().1._State_0\;
                \Posit32::IsZero().1.binaryOperationResult.0\ := false;
            else 
                case \Posit32::IsZero().1._State\ is 
                    when \Posit32::IsZero().1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::IsZero().1._Started\ = true) then 
                            \Posit32::IsZero().1._State\ := \Posit32::IsZero().1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsZero().1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::IsZero().1._Started\ = true) then 
                            \Posit32::IsZero().1._Finished\ <= true;
                        else 
                            \Posit32::IsZero().1._Finished\ <= false;
                            \Posit32::IsZero().1._State\ := \Posit32::IsZero().1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsZero().1._State_2\ => 
                        \Posit32::IsZero().1.this\ := \Posit32::IsZero().1.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits == 0u;
                        -- 
                        \Posit32::IsZero().1.binaryOperationResult.0\ := \Posit32::IsZero().1.this\.\PositBits\ = to_unsigned(0, 32);
                        \Posit32::IsZero().1.return\ <= \Posit32::IsZero().1.binaryOperationResult.0\;
                        \Posit32::IsZero().1._State\ := \Posit32::IsZero().1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().1 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().2 state machine start
    \Posit32::IsZero().2._StateMachine\: process (\Clock\) 
        Variable \Posit32::IsZero().2._State\: \Posit32::IsZero().2._States\ := \Posit32::IsZero().2._State_0\;
        Variable \Posit32::IsZero().2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::IsZero().2.binaryOperationResult.0\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::IsZero().2._Finished\ <= false;
                \Posit32::IsZero().2.return\ <= false;
                \Posit32::IsZero().2._State\ := \Posit32::IsZero().2._State_0\;
                \Posit32::IsZero().2.binaryOperationResult.0\ := false;
            else 
                case \Posit32::IsZero().2._State\ is 
                    when \Posit32::IsZero().2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::IsZero().2._Started\ = true) then 
                            \Posit32::IsZero().2._State\ := \Posit32::IsZero().2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsZero().2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::IsZero().2._Started\ = true) then 
                            \Posit32::IsZero().2._Finished\ <= true;
                        else 
                            \Posit32::IsZero().2._Finished\ <= false;
                            \Posit32::IsZero().2._State\ := \Posit32::IsZero().2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::IsZero().2._State_2\ => 
                        \Posit32::IsZero().2.this\ := \Posit32::IsZero().2.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits == 0u;
                        -- 
                        \Posit32::IsZero().2.binaryOperationResult.0\ := \Posit32::IsZero().2.this\.\PositBits\ = to_unsigned(0, 32);
                        \Posit32::IsZero().2.return\ <= \Posit32::IsZero().2.binaryOperationResult.0\;
                        \Posit32::IsZero().2._State\ := \Posit32::IsZero().2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::IsZero().2 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).0 state machine start
    \Posit32::EncodeRegimeBits(Int32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::EncodeRegimeBits(Int32).0._State\: \Posit32::EncodeRegimeBits(Int32).0._States\ := \Posit32::EncodeRegimeBits(Int32).0._State_0\;
        Variable \Posit32::EncodeRegimeBits(Int32).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.flag\: boolean := false;
        Variable \Posit32::EncodeRegimeBits(Int32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::EncodeRegimeBits(Int32).0._Finished\ <= false;
                \Posit32::EncodeRegimeBits(Int32).0.return\ <= to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_0\;
                \Posit32::EncodeRegimeBits(Int32).0.regimeKValue\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.flag\ := false;
                \Posit32::EncodeRegimeBits(Int32).0.num\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.0\ := false;
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.return.0\ := to_unsigned(0, 8);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.4\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.5\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.7\ := to_unsigned(0, 32);
            else 
                case \Posit32::EncodeRegimeBits(Int32).0._State\ is 
                    when \Posit32::EncodeRegimeBits(Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::EncodeRegimeBits(Int32).0._Started\ = true) then 
                            \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::EncodeRegimeBits(Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::EncodeRegimeBits(Int32).0._Started\ = true) then 
                            \Posit32::EncodeRegimeBits(Int32).0._Finished\ <= true;
                        else 
                            \Posit32::EncodeRegimeBits(Int32).0._Finished\ <= false;
                            \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::EncodeRegimeBits(Int32).0._State_2\ => 
                        \Posit32::EncodeRegimeBits(Int32).0.regimeKValue\ := \Posit32::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = regimeKValue > 0;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.0\ := \Posit32::EncodeRegimeBits(Int32).0.regimeKValue\ > to_signed(0, 32);
                        \Posit32::EncodeRegimeBits(Int32).0.flag\ := \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	num = 1u << regimeKValue + 1 - 1u;
                        -- 	num = num << (int)((System.Int32)(32 - (System.Int32)(Posit32.GetMostSignificantOnePosition (num))) - 1);
                        -- }
                        -- else {
                        -- 	num = 1073741824u >> -regimeKValue;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::EncodeRegimeBits(Int32).0._State_4\ and ends in state \Posit32::EncodeRegimeBits(Int32).0._State_5\.
                        --     * The false branch starts in state \Posit32::EncodeRegimeBits(Int32).0._State_6\ and ends in state \Posit32::EncodeRegimeBits(Int32).0._State_6\.
                        --     * Execution after either branch will continue in the following state: \Posit32::EncodeRegimeBits(Int32).0._State_3\.

                        if (\Posit32::EncodeRegimeBits(Int32).0.flag\) then 
                            \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_4\;
                        else 
                            \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::EncodeRegimeBits(Int32).0._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::EncodeRegimeBits(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return num;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).0.return\ <= \Posit32::EncodeRegimeBits(Int32).0.num\;
                        \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::EncodeRegimeBits(Int32).0._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::EncodeRegimeBits(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 1u << regimeKValue + 1 - 1u;
                        -- 	num = num << (int)((System.Int32)(32 - (System.Int32)(Posit32.GetMostSignificantOnePosition (num))) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1u << regimeKValue + 1 - 1u;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.1\ := \Posit32::EncodeRegimeBits(Int32).0.regimeKValue\ + to_signed(1, 32);
                        \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.2\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(\Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.1\, 5))));
                        \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.3\ := \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.2\ - to_unsigned(1, 32);
                        \Posit32::EncodeRegimeBits(Int32).0.num\ := \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num << (int)((System.Int32)(32 - (System.Int32)(Posit32.GetMostSignificantOnePosition (num))) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::EncodeRegimeBits(Int32).0.num\;
                        \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::EncodeRegimeBits(Int32).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::EncodeRegimeBits(Int32).0.return.0\ := \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.4\ := to_signed(32, 32) - signed(SmartResize((\Posit32::EncodeRegimeBits(Int32).0.return.0\), 32));
                            \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.5\ := (\Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.4\) - to_signed(1, 32);
                            \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.6\ := shift_left(\Posit32::EncodeRegimeBits(Int32).0.num\, to_integer(unsigned(SmartResize((\Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.5\), 5))));
                            \Posit32::EncodeRegimeBits(Int32).0.num\ := \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.6\;
                            -- Going to the state after the if-else which was started in state \Posit32::EncodeRegimeBits(Int32).0._State_2\.
                            if (\Posit32::EncodeRegimeBits(Int32).0._State\ = \Posit32::EncodeRegimeBits(Int32).0._State_5\) then 
                                \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::EncodeRegimeBits(Int32).0._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::EncodeRegimeBits(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 1073741824u >> -regimeKValue;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1073741824u >> -regimeKValue;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.7\ := shift_right(to_unsigned(1073741824, 32), to_integer(unsigned(SmartResize(-\Posit32::EncodeRegimeBits(Int32).0.regimeKValue\, 5) and "11111")));
                        \Posit32::EncodeRegimeBits(Int32).0.num\ := \Posit32::EncodeRegimeBits(Int32).0.binaryOperationResult.7\;
                        -- Going to the state after the if-else which was started in state \Posit32::EncodeRegimeBits(Int32).0._State_2\.
                        if (\Posit32::EncodeRegimeBits(Int32).0._State\ = \Posit32::EncodeRegimeBits(Int32).0._State_6\) then 
                            \Posit32::EncodeRegimeBits(Int32).0._State\ := \Posit32::EncodeRegimeBits(Int32).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).1 state machine start
    \Posit32::EncodeRegimeBits(Int32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::EncodeRegimeBits(Int32).1._State\: \Posit32::EncodeRegimeBits(Int32).1._States\ := \Posit32::EncodeRegimeBits(Int32).1._State_0\;
        Variable \Posit32::EncodeRegimeBits(Int32).1.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).1.flag\: boolean := false;
        Variable \Posit32::EncodeRegimeBits(Int32).1.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).1.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::EncodeRegimeBits(Int32).1._Finished\ <= false;
                \Posit32::EncodeRegimeBits(Int32).1.return\ <= to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::EncodeRegimeBits(Int32).1._State\ := \Posit32::EncodeRegimeBits(Int32).1._State_0\;
                \Posit32::EncodeRegimeBits(Int32).1.regimeKValue\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).1.flag\ := false;
                \Posit32::EncodeRegimeBits(Int32).1.num\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.0\ := false;
                \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).1.return.0\ := to_unsigned(0, 8);
                \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.4\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.5\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.6\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.7\ := to_unsigned(0, 32);
            else 
                case \Posit32::EncodeRegimeBits(Int32).1._State\ is 
                    when \Posit32::EncodeRegimeBits(Int32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::EncodeRegimeBits(Int32).1._Started\ = true) then 
                            \Posit32::EncodeRegimeBits(Int32).1._State\ := \Posit32::EncodeRegimeBits(Int32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::EncodeRegimeBits(Int32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::EncodeRegimeBits(Int32).1._Started\ = true) then 
                            \Posit32::EncodeRegimeBits(Int32).1._Finished\ <= true;
                        else 
                            \Posit32::EncodeRegimeBits(Int32).1._Finished\ <= false;
                            \Posit32::EncodeRegimeBits(Int32).1._State\ := \Posit32::EncodeRegimeBits(Int32).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::EncodeRegimeBits(Int32).1._State_2\ => 
                        \Posit32::EncodeRegimeBits(Int32).1.regimeKValue\ := \Posit32::EncodeRegimeBits(Int32).1.regimeKValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = regimeKValue > 0;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.0\ := \Posit32::EncodeRegimeBits(Int32).1.regimeKValue\ > to_signed(0, 32);
                        \Posit32::EncodeRegimeBits(Int32).1.flag\ := \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	num = 1u << regimeKValue + 1 - 1u;
                        -- 	num = num << (int)((System.Int32)(32 - (System.Int32)(Posit32.GetMostSignificantOnePosition (num))) - 1);
                        -- }
                        -- else {
                        -- 	num = 1073741824u >> -regimeKValue;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::EncodeRegimeBits(Int32).1._State_4\ and ends in state \Posit32::EncodeRegimeBits(Int32).1._State_5\.
                        --     * The false branch starts in state \Posit32::EncodeRegimeBits(Int32).1._State_6\ and ends in state \Posit32::EncodeRegimeBits(Int32).1._State_6\.
                        --     * Execution after either branch will continue in the following state: \Posit32::EncodeRegimeBits(Int32).1._State_3\.

                        if (\Posit32::EncodeRegimeBits(Int32).1.flag\) then 
                            \Posit32::EncodeRegimeBits(Int32).1._State\ := \Posit32::EncodeRegimeBits(Int32).1._State_4\;
                        else 
                            \Posit32::EncodeRegimeBits(Int32).1._State\ := \Posit32::EncodeRegimeBits(Int32).1._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::EncodeRegimeBits(Int32).1._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::EncodeRegimeBits(Int32).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return num;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).1.return\ <= \Posit32::EncodeRegimeBits(Int32).1.num\;
                        \Posit32::EncodeRegimeBits(Int32).1._State\ := \Posit32::EncodeRegimeBits(Int32).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::EncodeRegimeBits(Int32).1._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::EncodeRegimeBits(Int32).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 1u << regimeKValue + 1 - 1u;
                        -- 	num = num << (int)((System.Int32)(32 - (System.Int32)(Posit32.GetMostSignificantOnePosition (num))) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1u << regimeKValue + 1 - 1u;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.1\ := \Posit32::EncodeRegimeBits(Int32).1.regimeKValue\ + to_signed(1, 32);
                        \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.2\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(\Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.1\, 5))));
                        \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.3\ := \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.2\ - to_unsigned(1, 32);
                        \Posit32::EncodeRegimeBits(Int32).1.num\ := \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num << (int)((System.Int32)(32 - (System.Int32)(Posit32.GetMostSignificantOnePosition (num))) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::EncodeRegimeBits(Int32).1.num\;
                        \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::EncodeRegimeBits(Int32).1._State\ := \Posit32::EncodeRegimeBits(Int32).1._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::EncodeRegimeBits(Int32).1._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::EncodeRegimeBits(Int32).1.return.0\ := \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.4\ := to_signed(32, 32) - signed(SmartResize((\Posit32::EncodeRegimeBits(Int32).1.return.0\), 32));
                            \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.5\ := (\Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.4\) - to_signed(1, 32);
                            \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.6\ := shift_left(\Posit32::EncodeRegimeBits(Int32).1.num\, to_integer(unsigned(SmartResize((\Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.5\), 5))));
                            \Posit32::EncodeRegimeBits(Int32).1.num\ := \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.6\;
                            -- Going to the state after the if-else which was started in state \Posit32::EncodeRegimeBits(Int32).1._State_2\.
                            if (\Posit32::EncodeRegimeBits(Int32).1._State\ = \Posit32::EncodeRegimeBits(Int32).1._State_5\) then 
                                \Posit32::EncodeRegimeBits(Int32).1._State\ := \Posit32::EncodeRegimeBits(Int32).1._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::EncodeRegimeBits(Int32).1._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::EncodeRegimeBits(Int32).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 1073741824u >> -regimeKValue;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1073741824u >> -regimeKValue;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.7\ := shift_right(to_unsigned(1073741824, 32), to_integer(unsigned(SmartResize(-\Posit32::EncodeRegimeBits(Int32).1.regimeKValue\, 5) and "11111")));
                        \Posit32::EncodeRegimeBits(Int32).1.num\ := \Posit32::EncodeRegimeBits(Int32).1.binaryOperationResult.7\;
                        -- Going to the state after the if-else which was started in state \Posit32::EncodeRegimeBits(Int32).1._State_2\.
                        if (\Posit32::EncodeRegimeBits(Int32).1._State\ = \Posit32::EncodeRegimeBits(Int32).1._State_6\) then 
                            \Posit32::EncodeRegimeBits(Int32).1._State\ := \Posit32::EncodeRegimeBits(Int32).1._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).2 state machine start
    \Posit32::EncodeRegimeBits(Int32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::EncodeRegimeBits(Int32).2._State\: \Posit32::EncodeRegimeBits(Int32).2._States\ := \Posit32::EncodeRegimeBits(Int32).2._State_0\;
        Variable \Posit32::EncodeRegimeBits(Int32).2.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).2.flag\: boolean := false;
        Variable \Posit32::EncodeRegimeBits(Int32).2.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).2.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::EncodeRegimeBits(Int32).2._Finished\ <= false;
                \Posit32::EncodeRegimeBits(Int32).2.return\ <= to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::EncodeRegimeBits(Int32).2._State\ := \Posit32::EncodeRegimeBits(Int32).2._State_0\;
                \Posit32::EncodeRegimeBits(Int32).2.regimeKValue\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).2.flag\ := false;
                \Posit32::EncodeRegimeBits(Int32).2.num\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.0\ := false;
                \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).2.return.0\ := to_unsigned(0, 8);
                \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.4\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.5\ := to_signed(0, 32);
                \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.6\ := to_unsigned(0, 32);
                \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.7\ := to_unsigned(0, 32);
            else 
                case \Posit32::EncodeRegimeBits(Int32).2._State\ is 
                    when \Posit32::EncodeRegimeBits(Int32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::EncodeRegimeBits(Int32).2._Started\ = true) then 
                            \Posit32::EncodeRegimeBits(Int32).2._State\ := \Posit32::EncodeRegimeBits(Int32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::EncodeRegimeBits(Int32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::EncodeRegimeBits(Int32).2._Started\ = true) then 
                            \Posit32::EncodeRegimeBits(Int32).2._Finished\ <= true;
                        else 
                            \Posit32::EncodeRegimeBits(Int32).2._Finished\ <= false;
                            \Posit32::EncodeRegimeBits(Int32).2._State\ := \Posit32::EncodeRegimeBits(Int32).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::EncodeRegimeBits(Int32).2._State_2\ => 
                        \Posit32::EncodeRegimeBits(Int32).2.regimeKValue\ := \Posit32::EncodeRegimeBits(Int32).2.regimeKValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = regimeKValue > 0;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.0\ := \Posit32::EncodeRegimeBits(Int32).2.regimeKValue\ > to_signed(0, 32);
                        \Posit32::EncodeRegimeBits(Int32).2.flag\ := \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	num = 1u << regimeKValue + 1 - 1u;
                        -- 	num = num << (int)((System.Int32)(32 - (System.Int32)(Posit32.GetMostSignificantOnePosition (num))) - 1);
                        -- }
                        -- else {
                        -- 	num = 1073741824u >> -regimeKValue;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::EncodeRegimeBits(Int32).2._State_4\ and ends in state \Posit32::EncodeRegimeBits(Int32).2._State_5\.
                        --     * The false branch starts in state \Posit32::EncodeRegimeBits(Int32).2._State_6\ and ends in state \Posit32::EncodeRegimeBits(Int32).2._State_6\.
                        --     * Execution after either branch will continue in the following state: \Posit32::EncodeRegimeBits(Int32).2._State_3\.

                        if (\Posit32::EncodeRegimeBits(Int32).2.flag\) then 
                            \Posit32::EncodeRegimeBits(Int32).2._State\ := \Posit32::EncodeRegimeBits(Int32).2._State_4\;
                        else 
                            \Posit32::EncodeRegimeBits(Int32).2._State\ := \Posit32::EncodeRegimeBits(Int32).2._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::EncodeRegimeBits(Int32).2._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::EncodeRegimeBits(Int32).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return num;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).2.return\ <= \Posit32::EncodeRegimeBits(Int32).2.num\;
                        \Posit32::EncodeRegimeBits(Int32).2._State\ := \Posit32::EncodeRegimeBits(Int32).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::EncodeRegimeBits(Int32).2._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::EncodeRegimeBits(Int32).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 1u << regimeKValue + 1 - 1u;
                        -- 	num = num << (int)((System.Int32)(32 - (System.Int32)(Posit32.GetMostSignificantOnePosition (num))) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1u << regimeKValue + 1 - 1u;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.1\ := \Posit32::EncodeRegimeBits(Int32).2.regimeKValue\ + to_signed(1, 32);
                        \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.2\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(\Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.1\, 5))));
                        \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.3\ := \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.2\ - to_unsigned(1, 32);
                        \Posit32::EncodeRegimeBits(Int32).2.num\ := \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = num << (int)((System.Int32)(32 - (System.Int32)(Posit32.GetMostSignificantOnePosition (num))) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::EncodeRegimeBits(Int32).2.num\;
                        \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::EncodeRegimeBits(Int32).2._State\ := \Posit32::EncodeRegimeBits(Int32).2._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::EncodeRegimeBits(Int32).2._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::EncodeRegimeBits(Int32).2.return.0\ := \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.4\ := to_signed(32, 32) - signed(SmartResize((\Posit32::EncodeRegimeBits(Int32).2.return.0\), 32));
                            \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.5\ := (\Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.4\) - to_signed(1, 32);
                            \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.6\ := shift_left(\Posit32::EncodeRegimeBits(Int32).2.num\, to_integer(unsigned(SmartResize((\Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.5\), 5))));
                            \Posit32::EncodeRegimeBits(Int32).2.num\ := \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.6\;
                            -- Going to the state after the if-else which was started in state \Posit32::EncodeRegimeBits(Int32).2._State_2\.
                            if (\Posit32::EncodeRegimeBits(Int32).2._State\ = \Posit32::EncodeRegimeBits(Int32).2._State_5\) then 
                                \Posit32::EncodeRegimeBits(Int32).2._State\ := \Posit32::EncodeRegimeBits(Int32).2._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::EncodeRegimeBits(Int32).2._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::EncodeRegimeBits(Int32).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 1073741824u >> -regimeKValue;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1073741824u >> -regimeKValue;
                        -- 
                        \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.7\ := shift_right(to_unsigned(1073741824, 32), to_integer(unsigned(SmartResize(-\Posit32::EncodeRegimeBits(Int32).2.regimeKValue\, 5) and "11111")));
                        \Posit32::EncodeRegimeBits(Int32).2.num\ := \Posit32::EncodeRegimeBits(Int32).2.binaryOperationResult.7\;
                        -- Going to the state after the if-else which was started in state \Posit32::EncodeRegimeBits(Int32).2._State_2\.
                        if (\Posit32::EncodeRegimeBits(Int32).2._State\ = \Posit32::EncodeRegimeBits(Int32).2._State_6\) then 
                            \Posit32::EncodeRegimeBits(Int32).2._State\ := \Posit32::EncodeRegimeBits(Int32).2._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).2 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 state machine start
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._States\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag2\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag3\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.result\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag4\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag5\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag6\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag7\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag8\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.4\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.34\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag2\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag3\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.result\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag4\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag5\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag6\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag7\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag8\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.0\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.1\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.2\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.4\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.5\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.34\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.6\ := to_unsigned(0, 32);
            else 
                case \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ is 
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ = true) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ = true) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_2\ => 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Posit32.EncodeRegimeBits (regimeKValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.0\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- b = Posit32.LengthOfRunOfBits (num, 31);
                            -- 
                            -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.1\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (int)(28 - (System.Int32)(b));
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\ := to_signed(28, 32) - signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\), 32));
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num2 >= 0) {
                            -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits << num2;
                            -- }
                            -- else {
                            -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits >> -num2;
                            -- }
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\.
                            --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\.

                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.1\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\;
                            else 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5911
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag = num2 < 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ < to_signed(0, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	flag2 = num2 <= 28;
                        -- 	if (flag2) {
                        -- 		exponentBits = exponentBits << 32 + num2;
                        -- 	}
                        -- 	else {
                        -- 		exponentBits = exponentBits >> 32 + num2;
                        -- 	}
                        -- 	flag3 = exponentBits < 2147483648u;
                        -- 	if (flag3) {
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag4 = exponentBits == 2147483648u;
                        -- 		if (flag4) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- }
                        -- else {
                        -- 	num3 = (int)((System.Int32)(Posit32.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 	fractionBits = Posit32.SetZero (fractionBits, (ushort)num3);
                        -- 	num4 = 28 - num3 - (int)b;
                        -- 	uint conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	if (num4 >= 0) {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- 	}
                        -- 	else {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- 	}
                        -- 	num = num + conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	flag5 = num4 < 0;
                        -- 	if (flag5) {
                        -- 		flag6 = 32 + num4 >= 0;
                        -- 		if (flag6) {
                        -- 			fractionBits = fractionBits << 32 + num4;
                        -- 		}
                        -- 		else {
                        -- 			fractionBits = fractionBits >> -32 - num4;
                        -- 		}
                        -- 		flag7 = fractionBits >= 2147483648u;
                        -- 		if (flag7) {
                        -- 			flag8 = fractionBits == 2147483648u;
                        -- 			if (flag8) {
                        -- 				num = num + num & 1u;
                        -- 			}
                        -- 			else {
                        -- 				num = num + 1u;
                        -- 			}
                        -- 		}
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5766
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits << num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits << num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.2\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_6\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits >> -num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits >> -num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(-\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.3\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_4\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_7\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.result\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag2 = num2 <= 28;
                        -- 	if (flag2) {
                        -- 		exponentBits = exponentBits << 32 + num2;
                        -- 	}
                        -- 	else {
                        -- 		exponentBits = exponentBits >> 32 + num2;
                        -- 	}
                        -- 	flag3 = exponentBits < 2147483648u;
                        -- 	if (flag3) {
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag4 = exponentBits == 2147483648u;
                        -- 		if (flag4) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = num2 <= 28;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\ <= to_signed(28, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag2\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	exponentBits = exponentBits << 32 + num2;
                        -- }
                        -- else {
                        -- 	exponentBits = exponentBits >> 32 + num2;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag2\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = exponentBits < 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ < "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag3\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.11\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- else {
                        -- 	flag4 = exponentBits == 2147483648u;
                        -- 	if (flag4) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag3\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	exponentBits = exponentBits << 32 + num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = exponentBits << 32 + num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.7\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.8\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_11\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	exponentBits = exponentBits >> 32 + num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = exponentBits >> 32 + num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.9\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.10\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_9\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_12\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- else {
                        -- 	result = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_16\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.2\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.2\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_17\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_14\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_18\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag4 = exponentBits == 2147483648u;
                        -- 	if (flag4) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = exponentBits == 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits\ = "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.12\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	num = num + num & 1u;
                        -- }
                        -- else {
                        -- 	num = num + 1u;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag4\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- else {
                        -- 	result = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + num & 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + num & 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ and to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.13\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.14\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_21\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.15\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_19\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_22\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_10\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_24\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.3\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.3\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_25\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_20\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_26\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_27\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num3 = (int)((System.Int32)(Posit32.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 	fractionBits = Posit32.SetZero (fractionBits, (ushort)num3);
                        -- 	num4 = 28 - num3 - (int)b;
                        -- 	uint conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	if (num4 >= 0) {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- 	}
                        -- 	else {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- 	}
                        -- 	num = num + conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	flag5 = num4 < 0;
                        -- 	if (flag5) {
                        -- 		flag6 = 32 + num4 >= 0;
                        -- 		if (flag6) {
                        -- 			fractionBits = fractionBits << 32 + num4;
                        -- 		}
                        -- 		else {
                        -- 			fractionBits = fractionBits >> -32 - num4;
                        -- 		}
                        -- 		flag7 = fractionBits >= 2147483648u;
                        -- 		if (flag7) {
                        -- 			flag8 = fractionBits == 2147483648u;
                        -- 			if (flag8) {
                        -- 				num = num + num & 1u;
                        -- 			}
                        -- 			else {
                        -- 				num = num + 1u;
                        -- 			}
                        -- 		}
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (int)((System.Int32)(Posit32.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_28\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\ := signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.4\), 32)) - to_signed(1, 32);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.16\);
                            -- The following section was transformed from the .NET statement below:
                            -- fractionBits = Posit32.SetZero (fractionBits, (ushort)num3);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16)
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\), 16);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= true;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.5\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 28 - num3 - (int)b;
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\ := to_signed(28, 32) - \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num3\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.17\ - signed(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.b\, 32));
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.18\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num4 >= 0) {
                            -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                            -- }
                            -- else {
                            -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                            -- }
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\.
                            --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\.
                            --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\.

                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.19\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\;
                            else 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9067
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.22\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag5 = num4 < 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\ < to_signed(0, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag5\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.23\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag5) {
                        -- 	flag6 = 32 + num4 >= 0;
                        -- 	if (flag6) {
                        -- 		fractionBits = fractionBits << 32 + num4;
                        -- 	}
                        -- 	else {
                        -- 		fractionBits = fractionBits >> -32 - num4;
                        -- 	}
                        -- 	flag7 = fractionBits >= 2147483648u;
                        -- 	if (flag7) {
                        -- 		flag8 = fractionBits == 2147483648u;
                        -- 		if (flag8) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag5\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5766
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.20\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_31\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(-\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.21\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_29\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_32\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- else {
                        -- 	result = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag6 = 32 + num4 >= 0;
                        -- 	if (flag6) {
                        -- 		fractionBits = fractionBits << 32 + num4;
                        -- 	}
                        -- 	else {
                        -- 		fractionBits = fractionBits >> -32 - num4;
                        -- 	}
                        -- 	flag7 = fractionBits >= 2147483648u;
                        -- 	if (flag7) {
                        -- 		flag8 = fractionBits == 2147483648u;
                        -- 		if (flag8) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag6 = 32 + num4 >= 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.24\ >= to_signed(0, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag6\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.25\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag6) {
                        -- 	fractionBits = fractionBits << 32 + num4;
                        -- }
                        -- else {
                        -- 	fractionBits = fractionBits >> -32 - num4;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag6\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5911
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag7 = fractionBits >= 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ >= "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag7\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.30\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag7) {
                        -- 	flag8 = fractionBits == 2147483648u;
                        -- 	if (flag8) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag7\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	fractionBits = fractionBits << 32 + num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- fractionBits = fractionBits << 32 + num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.26\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.27\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_36\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	fractionBits = fractionBits >> -32 - num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- fractionBits = fractionBits >> -32 - num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\ := to_signed(32, 32) - \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\, to_integer(unsigned(SmartResize(-\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.28\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.29\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_34\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_37\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_30\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag8 = fractionBits == 2147483648u;
                        -- 	if (flag8) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag8 = fractionBits == 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits\ = "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag8\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.31\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag8) {
                        -- 	num = num + num & 1u;
                        -- }
                        -- else {
                        -- 	num = num + 1u;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.flag8\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_35\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + num & 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + num & 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ and to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.32\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.33\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_41\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.34\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ + to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.binaryOperationResult.34\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_39\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_42\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_40\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_5\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_44\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.6\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return.6\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_45\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_33\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_46\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._State_43\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).1 state machine start
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._States\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_0\;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag2\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag3\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.result\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag4\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag5\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag6\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag7\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag8\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.5\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.6\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.11\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.12\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.14\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.4\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.19\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.20\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.21\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.22\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.23\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.24\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.25\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.26\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.27\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.29\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.30\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.31\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.32\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.33\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.34\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Finished\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_0\;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.b\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num2\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag2\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag3\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.result\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag4\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num3\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num4\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag5\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag6\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag7\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag8\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.0\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.1\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.1\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.4\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.5\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.6\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.8\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.9\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.10\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.11\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.2\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.12\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.13\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.14\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.15\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.4\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.16\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.5\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.17\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.18\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.19\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.20\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.21\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.22\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.23\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.24\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.25\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.26\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.27\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.28\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.29\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.30\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.31\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.32\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.33\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.34\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.6\ := to_unsigned(0, 32);
            else 
                case \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ is 
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ = true) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ = true) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Finished\ <= true;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Finished\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_2\ => 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Posit32.EncodeRegimeBits (regimeKValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.0\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- b = Posit32.LengthOfRunOfBits (num, 31);
                            -- 
                            -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.1\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (int)(28 - (System.Int32)(b));
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.0\ := to_signed(28, 32) - signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.b\), 32));
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num2\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num2 >= 0) {
                            -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits << num2;
                            -- }
                            -- else {
                            -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits >> -num2;
                            -- }
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.1\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num2\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_6\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_6\.
                            --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_7\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_5\.

                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.1\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_6\;
                            else 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5911
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag = num2 < 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.5\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num2\ < to_signed(0, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	flag2 = num2 <= 28;
                        -- 	if (flag2) {
                        -- 		exponentBits = exponentBits << 32 + num2;
                        -- 	}
                        -- 	else {
                        -- 		exponentBits = exponentBits >> 32 + num2;
                        -- 	}
                        -- 	flag3 = exponentBits < 2147483648u;
                        -- 	if (flag3) {
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag4 = exponentBits == 2147483648u;
                        -- 		if (flag4) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- }
                        -- else {
                        -- 	num3 = (int)((System.Int32)(Posit32.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 	fractionBits = Posit32.SetZero (fractionBits, (ushort)num3);
                        -- 	num4 = 28 - num3 - (int)b;
                        -- 	uint conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	if (num4 >= 0) {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- 	}
                        -- 	else {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- 	}
                        -- 	num = num + conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	flag5 = num4 < 0;
                        -- 	if (flag5) {
                        -- 		flag6 = 32 + num4 >= 0;
                        -- 		if (flag6) {
                        -- 			fractionBits = fractionBits << 32 + num4;
                        -- 		}
                        -- 		else {
                        -- 			fractionBits = fractionBits >> -32 - num4;
                        -- 		}
                        -- 		flag7 = fractionBits >= 2147483648u;
                        -- 		if (flag7) {
                        -- 			flag8 = fractionBits == 2147483648u;
                        -- 			if (flag8) {
                        -- 				num = num + num & 1u;
                        -- 			}
                        -- 			else {
                        -- 				num = num + 1u;
                        -- 			}
                        -- 		}
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_9\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_13\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_27\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_43\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_8\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_9\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5766
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits << num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits << num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.2\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num2\), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.2\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_4\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_6\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits >> -num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits >> -num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.3\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits\, to_integer(unsigned(SmartResize(-\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num2\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.3\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_4\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_7\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_8\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.result\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_9\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag2 = num2 <= 28;
                        -- 	if (flag2) {
                        -- 		exponentBits = exponentBits << 32 + num2;
                        -- 	}
                        -- 	else {
                        -- 		exponentBits = exponentBits >> 32 + num2;
                        -- 	}
                        -- 	flag3 = exponentBits < 2147483648u;
                        -- 	if (flag3) {
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag4 = exponentBits == 2147483648u;
                        -- 		if (flag4) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = num2 <= 28;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.6\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num2\ <= to_signed(28, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag2\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	exponentBits = exponentBits << 32 + num2;
                        -- }
                        -- else {
                        -- 	exponentBits = exponentBits >> 32 + num2;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_11\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_11\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_12\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_10\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag2\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_11\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_10\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = exponentBits < 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.11\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits\ < "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag3\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.11\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- else {
                        -- 	flag4 = exponentBits == 2147483648u;
                        -- 	if (flag4) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_14\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_15\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_19\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_23\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_13\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag3\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_14\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_11\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	exponentBits = exponentBits << 32 + num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = exponentBits << 32 + num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.7\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.8\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.7\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.8\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_9\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_11\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_12\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	exponentBits = exponentBits >> 32 + num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = exponentBits >> 32 + num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.9\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.10\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.9\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.10\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_9\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_12\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_13\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_10\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_5\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_13\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_14\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- else {
                        -- 	result = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_16\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_17\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_18\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_18\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_15\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_16\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_18\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_15\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_14\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_10\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_15\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_16\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_17\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_17\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.2\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.2\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_14\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_17\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_15\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_18\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_14\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_18\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_19\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag4 = exponentBits == 2147483648u;
                        -- 	if (flag4) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = exponentBits == 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.12\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits\ = "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.12\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	num = num + num & 1u;
                        -- }
                        -- else {
                        -- 	num = num + 1u;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_21\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_21\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_22\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_22\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_20\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag4\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_21\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_20\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- else {
                        -- 	result = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_24\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_25\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_26\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_26\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_23\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_24\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_26\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_21\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + num & 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + num & 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.13\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ and to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.14\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.13\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.14\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_19\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_21\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_22\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.15\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ + to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.15\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_19\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_22\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_23\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_20\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_10\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_23\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_24\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_25\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_25\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.3\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.3\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_20\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_25\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_23\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_26\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_20\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_26\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_27\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num3 = (int)((System.Int32)(Posit32.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 	fractionBits = Posit32.SetZero (fractionBits, (ushort)num3);
                        -- 	num4 = 28 - num3 - (int)b;
                        -- 	uint conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	if (num4 >= 0) {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- 	}
                        -- 	else {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- 	}
                        -- 	num = num + conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	flag5 = num4 < 0;
                        -- 	if (flag5) {
                        -- 		flag6 = 32 + num4 >= 0;
                        -- 		if (flag6) {
                        -- 			fractionBits = fractionBits << 32 + num4;
                        -- 		}
                        -- 		else {
                        -- 			fractionBits = fractionBits >> -32 - num4;
                        -- 		}
                        -- 		flag7 = fractionBits >= 2147483648u;
                        -- 		if (flag7) {
                        -- 			flag8 = fractionBits == 2147483648u;
                        -- 			if (flag8) {
                        -- 				num = num + num & 1u;
                        -- 			}
                        -- 			else {
                        -- 				num = num + 1u;
                        -- 			}
                        -- 		}
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (int)((System.Int32)(Posit32.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_28\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_28\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.16\ := signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.4\), 32)) - to_signed(1, 32);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num3\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.16\);
                            -- The following section was transformed from the .NET statement below:
                            -- fractionBits = Posit32.SetZero (fractionBits, (ushort)num3);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16)
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num3\), 16);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= true;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_29\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_29\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.5\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 28 - num3 - (int)b;
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.17\ := to_signed(28, 32) - \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num3\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.18\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.17\ - signed(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.b\, 32));
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.18\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num4 >= 0) {
                            -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                            -- }
                            -- else {
                            -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                            -- }
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.19\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num4\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_31\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_31\.
                            --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_32\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_32\.
                            --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_30\.

                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.19\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_31\;
                            else 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_32\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9067
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_30\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.22\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.22\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag5 = num4 < 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.23\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num4\ < to_signed(0, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag5\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.23\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag5) {
                        -- 	flag6 = 32 + num4 >= 0;
                        -- 	if (flag6) {
                        -- 		fractionBits = fractionBits << 32 + num4;
                        -- 	}
                        -- 	else {
                        -- 		fractionBits = fractionBits >> -32 - num4;
                        -- 	}
                        -- 	flag7 = fractionBits >= 2147483648u;
                        -- 	if (flag7) {
                        -- 		flag8 = fractionBits == 2147483648u;
                        -- 		if (flag8) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_34\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_38\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_33\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag5\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_34\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5766
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_31\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.20\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num4\), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.20\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_29\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_31\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_32\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.21\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\, to_integer(unsigned(SmartResize(-\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num4\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.21\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_29\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_32\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_33\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_30\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- else {
                        -- 	result = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_44\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_45\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_46\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_46\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_43\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_44\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_46\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_34\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_30\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag6 = 32 + num4 >= 0;
                        -- 	if (flag6) {
                        -- 		fractionBits = fractionBits << 32 + num4;
                        -- 	}
                        -- 	else {
                        -- 		fractionBits = fractionBits >> -32 - num4;
                        -- 	}
                        -- 	flag7 = fractionBits >= 2147483648u;
                        -- 	if (flag7) {
                        -- 		flag8 = fractionBits == 2147483648u;
                        -- 		if (flag8) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag6 = 32 + num4 >= 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.24\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.25\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.24\ >= to_signed(0, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag6\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.25\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag6) {
                        -- 	fractionBits = fractionBits << 32 + num4;
                        -- }
                        -- else {
                        -- 	fractionBits = fractionBits >> -32 - num4;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_36\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_36\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_37\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_37\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_35\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag6\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_36\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_37\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5911
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_35\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag7 = fractionBits >= 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.30\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\ >= "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag7\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.30\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag7) {
                        -- 	flag8 = fractionBits == 2147483648u;
                        -- 	if (flag8) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_39\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_40\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_38\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag7\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_39\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_36\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	fractionBits = fractionBits << 32 + num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- fractionBits = fractionBits << 32 + num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.26\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.27\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.26\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.27\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_34\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_36\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_37\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	fractionBits = fractionBits >> -32 - num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- fractionBits = fractionBits >> -32 - num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.28\ := to_signed(32, 32) - \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.29\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\, to_integer(unsigned(SmartResize(-\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.28\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.29\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_34\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_37\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_38\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_35\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_30\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_38\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_39\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_35\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag8 = fractionBits == 2147483648u;
                        -- 	if (flag8) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag8 = fractionBits == 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.31\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits\ = "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag8\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.31\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag8) {
                        -- 	num = num + num & 1u;
                        -- }
                        -- else {
                        -- 	num = num + 1u;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_41\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_41\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_42\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_42\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_40\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.flag8\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_41\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_40\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_39\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_35\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_40\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_41\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_39\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + num & 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + num & 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.32\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ and to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.33\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.32\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.33\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_39\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_41\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_40\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_42\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_39\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.34\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ + to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.binaryOperationResult.34\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_39\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_42\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_40\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_43\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_33\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_5\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_43\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_44\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_45\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_45\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.6\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return.6\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_33\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_45\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_43\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_46\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_33\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_46\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._State_43\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).2 state machine start
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._States\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_0\;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag2\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag3\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.result\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag4\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag5\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag6\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag7\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag8\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.1\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.5\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.6\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.11\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.12\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.14\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.4\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.19\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.20\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.21\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.22\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.23\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.24\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.25\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.26\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.27\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.29\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.30\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.31\: boolean := false;
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.32\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.33\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.34\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Finished\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_0\;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.b\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num2\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag2\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag3\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.result\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag4\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num3\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num4\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag5\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag6\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag7\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag8\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.0\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.1\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.1\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.4\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.5\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.6\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.8\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.9\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.10\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.11\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.2\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.12\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.13\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.14\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.15\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.3\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.4\ := to_unsigned(0, 8);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.16\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.5\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.17\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.18\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.19\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.20\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.21\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.22\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.23\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.24\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.25\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.26\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.27\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.28\ := to_signed(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.29\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.30\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.31\ := false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.32\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.33\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.34\ := to_unsigned(0, 32);
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.6\ := to_unsigned(0, 32);
            else 
                case \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ is 
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ = true) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ = true) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Finished\ <= true;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Finished\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_2\ => 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits.parameter.In\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Posit32.EncodeRegimeBits (regimeKValue);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.0\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- b = Posit32.LengthOfRunOfBits (num, 31);
                            -- 
                            -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.1\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.b\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (int)(28 - (System.Int32)(b));
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.0\ := to_signed(28, 32) - signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.b\), 32));
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num2\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num2 >= 0) {
                            -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits << num2;
                            -- }
                            -- else {
                            -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits >> -num2;
                            -- }
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.1\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num2\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_6\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_6\.
                            --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_7\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_5\.

                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.1\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_6\;
                            else 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5911
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag = num2 < 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.5\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num2\ < to_signed(0, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	flag2 = num2 <= 28;
                        -- 	if (flag2) {
                        -- 		exponentBits = exponentBits << 32 + num2;
                        -- 	}
                        -- 	else {
                        -- 		exponentBits = exponentBits >> 32 + num2;
                        -- 	}
                        -- 	flag3 = exponentBits < 2147483648u;
                        -- 	if (flag3) {
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag4 = exponentBits == 2147483648u;
                        -- 		if (flag4) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- }
                        -- else {
                        -- 	num3 = (int)((System.Int32)(Posit32.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 	fractionBits = Posit32.SetZero (fractionBits, (ushort)num3);
                        -- 	num4 = 28 - num3 - (int)b;
                        -- 	uint conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	if (num4 >= 0) {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- 	}
                        -- 	else {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- 	}
                        -- 	num = num + conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	flag5 = num4 < 0;
                        -- 	if (flag5) {
                        -- 		flag6 = 32 + num4 >= 0;
                        -- 		if (flag6) {
                        -- 			fractionBits = fractionBits << 32 + num4;
                        -- 		}
                        -- 		else {
                        -- 			fractionBits = fractionBits >> -32 - num4;
                        -- 		}
                        -- 		flag7 = fractionBits >= 2147483648u;
                        -- 		if (flag7) {
                        -- 			flag8 = fractionBits == 2147483648u;
                        -- 			if (flag8) {
                        -- 				num = num + num & 1u;
                        -- 			}
                        -- 			else {
                        -- 				num = num + 1u;
                        -- 			}
                        -- 		}
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_9\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_13\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_27\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_43\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_8\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_9\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5766
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits << num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits << num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.2\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num2\), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.2\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_4\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_6\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits >> -num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328 = exponentBits >> -num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.3\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits\, to_integer(unsigned(SmartResize(-\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num2\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.conditionalab4dff45ad1531aa3ffc32fdf69ce01c7764a68f6c02e15a454679d3adb1a328\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.3\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_4\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_7\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_8\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.result\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_9\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag2 = num2 <= 28;
                        -- 	if (flag2) {
                        -- 		exponentBits = exponentBits << 32 + num2;
                        -- 	}
                        -- 	else {
                        -- 		exponentBits = exponentBits >> 32 + num2;
                        -- 	}
                        -- 	flag3 = exponentBits < 2147483648u;
                        -- 	if (flag3) {
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag4 = exponentBits == 2147483648u;
                        -- 		if (flag4) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 		if (signBit) {
                        -- 			result = Posit32.GetTwosComplement (num);
                        -- 		}
                        -- 		else {
                        -- 			result = num;
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = num2 <= 28;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.6\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num2\ <= to_signed(28, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag2\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	exponentBits = exponentBits << 32 + num2;
                        -- }
                        -- else {
                        -- 	exponentBits = exponentBits >> 32 + num2;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_11\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_11\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_12\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_10\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag2\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_11\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_10\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = exponentBits < 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.11\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits\ < "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag3\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.11\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- else {
                        -- 	flag4 = exponentBits == 2147483648u;
                        -- 	if (flag4) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_14\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_15\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_19\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_23\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_13\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag3\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_14\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_11\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	exponentBits = exponentBits << 32 + num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = exponentBits << 32 + num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.7\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.8\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.7\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.8\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_9\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_11\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_12\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	exponentBits = exponentBits >> 32 + num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = exponentBits >> 32 + num2;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.9\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num2\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.10\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.9\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.10\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_9\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_12\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_13\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_10\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_5\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_13\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_14\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- else {
                        -- 	result = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_16\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_17\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_18\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_18\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_15\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_16\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_18\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_15\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_14\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_10\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_15\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_16\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_17\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_17\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.2\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.2\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_14\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_17\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_15\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_18\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_14\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_18\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_19\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag4 = exponentBits == 2147483648u;
                        -- 	if (flag4) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = exponentBits == 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.12\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits\ = "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.12\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	num = num + num & 1u;
                        -- }
                        -- else {
                        -- 	num = num + 1u;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_21\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_21\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_22\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_22\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_20\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag4\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_21\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_20\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- else {
                        -- 	result = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_24\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_25\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_26\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_26\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_23\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_24\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_26\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_21\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + num & 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + num & 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.13\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ and to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.14\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.13\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.14\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_19\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_21\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_22\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.15\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ + to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.15\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_19\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_22\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_23\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_20\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_10\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_23\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_24\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_25\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_25\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.3\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.3\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_20\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_25\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_23\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_26\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_20\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_26\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_27\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num3 = (int)((System.Int32)(Posit32.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 	fractionBits = Posit32.SetZero (fractionBits, (ushort)num3);
                        -- 	num4 = 28 - num3 - (int)b;
                        -- 	uint conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	if (num4 >= 0) {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- 	}
                        -- 	else {
                        -- 		conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- 	}
                        -- 	num = num + conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 	flag5 = num4 < 0;
                        -- 	if (flag5) {
                        -- 		flag6 = 32 + num4 >= 0;
                        -- 		if (flag6) {
                        -- 			fractionBits = fractionBits << 32 + num4;
                        -- 		}
                        -- 		else {
                        -- 			fractionBits = fractionBits >> -32 - num4;
                        -- 		}
                        -- 		flag7 = fractionBits >= 2147483648u;
                        -- 		if (flag7) {
                        -- 			flag8 = fractionBits == 2147483648u;
                        -- 			if (flag8) {
                        -- 				num = num + num & 1u;
                        -- 			}
                        -- 			else {
                        -- 				num = num + 1u;
                        -- 			}
                        -- 		}
                        -- 	}
                        -- 	if (signBit) {
                        -- 		result = Posit32.GetTwosComplement (num);
                        -- 	}
                        -- 	else {
                        -- 		result = num;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (int)((System.Int32)(Posit32.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_28\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_28\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.16\ := signed(SmartResize((\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.4\), 32)) - to_signed(1, 32);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num3\ := (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.16\);
                            -- The following section was transformed from the .NET statement below:
                            -- fractionBits = Posit32.SetZero (fractionBits, (ushort)num3);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16)
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num3\), 16);
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= true;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_29\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_29\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.5\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 28 - num3 - (int)b;
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.17\ := to_signed(28, 32) - \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num3\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.18\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.17\ - signed(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.b\, 32));
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num4\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.18\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num4 >= 0) {
                            -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                            -- }
                            -- else {
                            -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                            -- }
                            -- 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.19\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num4\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_31\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_31\.
                            --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_32\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_32\.
                            --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_30\.

                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.19\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_31\;
                            else 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_32\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9067
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_30\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.22\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.22\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag5 = num4 < 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.23\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num4\ < to_signed(0, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag5\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.23\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag5) {
                        -- 	flag6 = 32 + num4 >= 0;
                        -- 	if (flag6) {
                        -- 		fractionBits = fractionBits << 32 + num4;
                        -- 	}
                        -- 	else {
                        -- 		fractionBits = fractionBits >> -32 - num4;
                        -- 	}
                        -- 	flag7 = fractionBits >= 2147483648u;
                        -- 	if (flag7) {
                        -- 		flag8 = fractionBits == 2147483648u;
                        -- 		if (flag8) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_34\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_38\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_33\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag5\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_34\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5766
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_31\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits << num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.20\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num4\), 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.20\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_29\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_31\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_32\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83 = fractionBits >> -num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.21\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\, to_integer(unsigned(SmartResize(-\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num4\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.conditionala397d88077016a431282a7da64c24150eade5c64d88e60f80558e29504754f83\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.21\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_29\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_32\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_33\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_30\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (signBit) {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- else {
                        -- 	result = num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_44\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_45\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_46\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_46\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_43\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_44\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_46\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_34\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_30\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag6 = 32 + num4 >= 0;
                        -- 	if (flag6) {
                        -- 		fractionBits = fractionBits << 32 + num4;
                        -- 	}
                        -- 	else {
                        -- 		fractionBits = fractionBits >> -32 - num4;
                        -- 	}
                        -- 	flag7 = fractionBits >= 2147483648u;
                        -- 	if (flag7) {
                        -- 		flag8 = fractionBits == 2147483648u;
                        -- 		if (flag8) {
                        -- 			num = num + num & 1u;
                        -- 		}
                        -- 		else {
                        -- 			num = num + 1u;
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag6 = 32 + num4 >= 0;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.24\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.25\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.24\ >= to_signed(0, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag6\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.25\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag6) {
                        -- 	fractionBits = fractionBits << 32 + num4;
                        -- }
                        -- else {
                        -- 	fractionBits = fractionBits >> -32 - num4;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_36\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_36\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_37\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_37\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_35\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag6\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_36\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_37\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5911
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_35\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag7 = fractionBits >= 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.30\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\ >= "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag7\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.30\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag7) {
                        -- 	flag8 = fractionBits == 2147483648u;
                        -- 	if (flag8) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_39\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_40\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_38\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag7\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_39\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_36\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	fractionBits = fractionBits << 32 + num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- fractionBits = fractionBits << 32 + num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.26\ := to_signed(32, 32) + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.27\ := shift_left(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\, to_integer(unsigned(SmartResize(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.26\, 5))));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.27\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_34\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_36\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_37\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_34\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	fractionBits = fractionBits >> -32 - num4;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- fractionBits = fractionBits >> -32 - num4;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.28\ := to_signed(32, 32) - \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num4\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.29\ := shift_right(\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\, to_integer(unsigned(SmartResize(-\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.28\, 5) and "11111")));
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.29\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_34\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_37\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_38\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_35\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_30\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_38\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_39\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_35\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag8 = fractionBits == 2147483648u;
                        -- 	if (flag8) {
                        -- 		num = num + num & 1u;
                        -- 	}
                        -- 	else {
                        -- 		num = num + 1u;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag8 = fractionBits == 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.31\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits\ = "10000000000000000000000000000000";
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag8\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.31\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag8) {
                        -- 	num = num + num & 1u;
                        -- }
                        -- else {
                        -- 	num = num + 1u;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_41\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_41\.
                        --     * The false branch starts in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_42\ and ends in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_42\.
                        --     * Execution after either branch will continue in the following state: \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_40\.

                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.flag8\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_41\;
                        else 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_40\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_39\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_35\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_40\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_41\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_39\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + num & 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + num & 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.32\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ and to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.33\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ + \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.32\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.33\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_39\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_41\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_40\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4542
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_42\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_39\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = num + 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = num + 1u;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.34\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ + to_unsigned(1, 32);
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.binaryOperationResult.34\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_39\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_42\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_40\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_43\ => 
                        -- State after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_33\.
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_5\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_43\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_44\ => 
                        -- True branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Posit32.GetTwosComplement (num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Posit32.GetTwosComplement (num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_45\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_45\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.6\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return.6\;
                            -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_33\.
                            if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_45\) then 
                                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_43\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_46\ => 
                        -- False branch of the if-else started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.result\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_33\.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ = \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_46\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State\ := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._State_43\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).2 state machine end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0 state machine start
    \Posit32::GetRegimeKValue().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetRegimeKValue().0._State\: \Posit32::GetRegimeKValue().0._States\ := \Posit32::GetRegimeKValue().0._State_0\;
        Variable \Posit32::GetRegimeKValue().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetRegimeKValue().0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValue().0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetRegimeKValue().0.return.0\: boolean := false;
        Variable \Posit32::GetRegimeKValue().0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValue().0.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetRegimeKValue().0.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::GetRegimeKValue().0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValue().0.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::GetRegimeKValue().0.binaryOperationResult.2\: signed(7 downto 0) := to_signed(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetRegimeKValue().0._Finished\ <= false;
                \Posit32::GetRegimeKValue().0.return\ <= to_signed(0, 8);
                \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_0\;
                \Posit32::GetRegimeKValue().0.num\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().0.b\ := to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().0.return.0\ := false;
                \Posit32::GetRegimeKValue().0.return.1\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().0.return.2\ := to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().0.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\ := to_signed(0, 8);
                \Posit32::GetRegimeKValue().0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().0.binaryOperationResult.1\ := false;
                \Posit32::GetRegimeKValue().0.binaryOperationResult.2\ := to_signed(0, 8);
            else 
                case \Posit32::GetRegimeKValue().0._State\ is 
                    when \Posit32::GetRegimeKValue().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetRegimeKValue().0._Started\ = true) then 
                            \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetRegimeKValue().0._Started\ = true) then 
                            \Posit32::GetRegimeKValue().0._Finished\ <= true;
                        else 
                            \Posit32::GetRegimeKValue().0._Finished\ <= false;
                            \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_2\ => 
                        \Posit32::GetRegimeKValue().0.this\ := \Posit32::GetRegimeKValue().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                        -- 	num = @this.PositBits;
                        -- }
                        -- else {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::GetRegimeKValue().0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::GetRegimeKValue().0.this\;
                        \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Started.0\ = \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::GetRegimeKValue().0.return.0\ := \Posit32::GetRegimeKValue().0.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::GetRegimeKValue().0._State_5\ and ends in state \Posit32::GetRegimeKValue().0._State_5\.
                            --     * The false branch starts in state \Posit32::GetRegimeKValue().0._State_6\ and ends in state \Posit32::GetRegimeKValue().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::GetRegimeKValue().0._State_4\.

                            if (\Posit32::GetRegimeKValue().0.return.0\) then 
                                \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_5\;
                            else 
                                \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::GetRegimeKValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = Posit32.LengthOfRunOfBits (num, 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::GetRegimeKValue().0.num\;
                        \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::GetRegimeKValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = @this.PositBits;
                        -- 
                        \Posit32::GetRegimeKValue().0.num\ := \Posit32::GetRegimeKValue().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().0._State_3\.
                        if (\Posit32::GetRegimeKValue().0._State\ = \Posit32::GetRegimeKValue().0._State_5\) then 
                            \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::GetRegimeKValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::GetRegimeKValue().0.this\.\PositBits\;
                        \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::GetRegimeKValue().0.return.1\ := \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::GetRegimeKValue().0.num\ := \Posit32::GetRegimeKValue().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().0._State_3\.
                            if (\Posit32::GetRegimeKValue().0._State\ = \Posit32::GetRegimeKValue().0._State_7\) then 
                                \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::GetRegimeKValue().0.return.2\ := \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::GetRegimeKValue().0.b\ := \Posit32::GetRegimeKValue().0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- sbyte conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num & 1073741824u == 0u) {
                            -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)-(System.Int32)((sbyte)b);
                            -- }
                            -- else {
                            -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)((System.Int32)(b) - 1);
                            -- }
                            -- 
                            \Posit32::GetRegimeKValue().0.binaryOperationResult.0\ := \Posit32::GetRegimeKValue().0.num\ and to_unsigned(1073741824, 32);
                            \Posit32::GetRegimeKValue().0.binaryOperationResult.1\ := \Posit32::GetRegimeKValue().0.binaryOperationResult.0\ = to_unsigned(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::GetRegimeKValue().0._State_10\ and ends in state \Posit32::GetRegimeKValue().0._State_10\.
                            --     * The false branch starts in state \Posit32::GetRegimeKValue().0._State_11\ and ends in state \Posit32::GetRegimeKValue().0._State_11\.
                            --     * Execution after either branch will continue in the following state: \Posit32::GetRegimeKValue().0._State_9\.

                            if (\Posit32::GetRegimeKValue().0.binaryOperationResult.1\) then 
                                \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_10\;
                            else 
                                \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_11\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4137
                    when \Posit32::GetRegimeKValue().0._State_9\ => 
                        -- State after the if-else which was started in state \Posit32::GetRegimeKValue().0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65;
                        -- 
                        \Posit32::GetRegimeKValue().0.return\ <= \Posit32::GetRegimeKValue().0.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\;
                        \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().0._State_10\ => 
                        -- True branch of the if-else started in state \Posit32::GetRegimeKValue().0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)-(System.Int32)((sbyte)b);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)-(System.Int32)((sbyte)b);
                        -- 
                        \Posit32::GetRegimeKValue().0.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\ := SmartResize(-signed(SmartResize((signed(\Posit32::GetRegimeKValue().0.b\)), 32)), 8);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().0._State_8\.
                        if (\Posit32::GetRegimeKValue().0._State\ = \Posit32::GetRegimeKValue().0._State_10\) then 
                            \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::GetRegimeKValue().0._State_11\ => 
                        -- False branch of the if-else started in state \Posit32::GetRegimeKValue().0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)((System.Int32)(b) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)((System.Int32)(b) - 1);
                        -- 
                        \Posit32::GetRegimeKValue().0.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\Posit32::GetRegimeKValue().0.b\), 32)) - to_signed(1, 32), 8);
                        \Posit32::GetRegimeKValue().0.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\ := (\Posit32::GetRegimeKValue().0.binaryOperationResult.2\);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().0._State_8\.
                        if (\Posit32::GetRegimeKValue().0._State\ = \Posit32::GetRegimeKValue().0._State_11\) then 
                            \Posit32::GetRegimeKValue().0._State\ := \Posit32::GetRegimeKValue().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                end case;
            end if;
        end if;
    end process;
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0 state machine end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().1 state machine start
    \Posit32::GetRegimeKValue().1._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetRegimeKValue().1._State\: \Posit32::GetRegimeKValue().1._States\ := \Posit32::GetRegimeKValue().1._State_0\;
        Variable \Posit32::GetRegimeKValue().1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetRegimeKValue().1.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValue().1.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetRegimeKValue().1.return.0\: boolean := false;
        Variable \Posit32::GetRegimeKValue().1.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValue().1.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetRegimeKValue().1.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::GetRegimeKValue().1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValue().1.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::GetRegimeKValue().1.binaryOperationResult.2\: signed(7 downto 0) := to_signed(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetRegimeKValue().1._Finished\ <= false;
                \Posit32::GetRegimeKValue().1.return\ <= to_signed(0, 8);
                \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_0\;
                \Posit32::GetRegimeKValue().1.num\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().1.b\ := to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().1.return.0\ := false;
                \Posit32::GetRegimeKValue().1.return.1\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().1.return.2\ := to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().1.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\ := to_signed(0, 8);
                \Posit32::GetRegimeKValue().1.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().1.binaryOperationResult.1\ := false;
                \Posit32::GetRegimeKValue().1.binaryOperationResult.2\ := to_signed(0, 8);
            else 
                case \Posit32::GetRegimeKValue().1._State\ is 
                    when \Posit32::GetRegimeKValue().1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetRegimeKValue().1._Started\ = true) then 
                            \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetRegimeKValue().1._Started\ = true) then 
                            \Posit32::GetRegimeKValue().1._Finished\ <= true;
                        else 
                            \Posit32::GetRegimeKValue().1._Finished\ <= false;
                            \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().1._State_2\ => 
                        \Posit32::GetRegimeKValue().1.this\ := \Posit32::GetRegimeKValue().1.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                        -- 	num = @this.PositBits;
                        -- }
                        -- else {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::GetRegimeKValue().1.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::GetRegimeKValue().1.this\;
                        \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Started.0\ = \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::GetRegimeKValue().1.return.0\ := \Posit32::GetRegimeKValue().1.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::GetRegimeKValue().1._State_5\ and ends in state \Posit32::GetRegimeKValue().1._State_5\.
                            --     * The false branch starts in state \Posit32::GetRegimeKValue().1._State_6\ and ends in state \Posit32::GetRegimeKValue().1._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::GetRegimeKValue().1._State_4\.

                            if (\Posit32::GetRegimeKValue().1.return.0\) then 
                                \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_5\;
                            else 
                                \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().1._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::GetRegimeKValue().1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = Posit32.LengthOfRunOfBits (num, 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::GetRegimeKValue().1.num\;
                        \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().1._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::GetRegimeKValue().1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = @this.PositBits;
                        -- 
                        \Posit32::GetRegimeKValue().1.num\ := \Posit32::GetRegimeKValue().1.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().1._State_3\.
                        if (\Posit32::GetRegimeKValue().1._State\ = \Posit32::GetRegimeKValue().1._State_5\) then 
                            \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().1._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::GetRegimeKValue().1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::GetRegimeKValue().1.this\.\PositBits\;
                        \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().1._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::GetRegimeKValue().1.return.1\ := \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::GetRegimeKValue().1.num\ := \Posit32::GetRegimeKValue().1.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().1._State_3\.
                            if (\Posit32::GetRegimeKValue().1._State\ = \Posit32::GetRegimeKValue().1._State_7\) then 
                                \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().1._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::GetRegimeKValue().1.return.2\ := \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::GetRegimeKValue().1.b\ := \Posit32::GetRegimeKValue().1.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- sbyte conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num & 1073741824u == 0u) {
                            -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)-(System.Int32)((sbyte)b);
                            -- }
                            -- else {
                            -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)((System.Int32)(b) - 1);
                            -- }
                            -- 
                            \Posit32::GetRegimeKValue().1.binaryOperationResult.0\ := \Posit32::GetRegimeKValue().1.num\ and to_unsigned(1073741824, 32);
                            \Posit32::GetRegimeKValue().1.binaryOperationResult.1\ := \Posit32::GetRegimeKValue().1.binaryOperationResult.0\ = to_unsigned(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::GetRegimeKValue().1._State_10\ and ends in state \Posit32::GetRegimeKValue().1._State_10\.
                            --     * The false branch starts in state \Posit32::GetRegimeKValue().1._State_11\ and ends in state \Posit32::GetRegimeKValue().1._State_11\.
                            --     * Execution after either branch will continue in the following state: \Posit32::GetRegimeKValue().1._State_9\.

                            if (\Posit32::GetRegimeKValue().1.binaryOperationResult.1\) then 
                                \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_10\;
                            else 
                                \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_11\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4137
                    when \Posit32::GetRegimeKValue().1._State_9\ => 
                        -- State after the if-else which was started in state \Posit32::GetRegimeKValue().1._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65;
                        -- 
                        \Posit32::GetRegimeKValue().1.return\ <= \Posit32::GetRegimeKValue().1.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\;
                        \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().1._State_10\ => 
                        -- True branch of the if-else started in state \Posit32::GetRegimeKValue().1._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)-(System.Int32)((sbyte)b);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)-(System.Int32)((sbyte)b);
                        -- 
                        \Posit32::GetRegimeKValue().1.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\ := SmartResize(-signed(SmartResize((signed(\Posit32::GetRegimeKValue().1.b\)), 32)), 8);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().1._State_8\.
                        if (\Posit32::GetRegimeKValue().1._State\ = \Posit32::GetRegimeKValue().1._State_10\) then 
                            \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::GetRegimeKValue().1._State_11\ => 
                        -- False branch of the if-else started in state \Posit32::GetRegimeKValue().1._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)((System.Int32)(b) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)((System.Int32)(b) - 1);
                        -- 
                        \Posit32::GetRegimeKValue().1.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\Posit32::GetRegimeKValue().1.b\), 32)) - to_signed(1, 32), 8);
                        \Posit32::GetRegimeKValue().1.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\ := (\Posit32::GetRegimeKValue().1.binaryOperationResult.2\);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().1._State_8\.
                        if (\Posit32::GetRegimeKValue().1._State\ = \Posit32::GetRegimeKValue().1._State_11\) then 
                            \Posit32::GetRegimeKValue().1._State\ := \Posit32::GetRegimeKValue().1._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                end case;
            end if;
        end if;
    end process;
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().1 state machine end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().2 state machine start
    \Posit32::GetRegimeKValue().2._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetRegimeKValue().2._State\: \Posit32::GetRegimeKValue().2._States\ := \Posit32::GetRegimeKValue().2._State_0\;
        Variable \Posit32::GetRegimeKValue().2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetRegimeKValue().2.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValue().2.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetRegimeKValue().2.return.0\: boolean := false;
        Variable \Posit32::GetRegimeKValue().2.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValue().2.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetRegimeKValue().2.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::GetRegimeKValue().2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValue().2.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::GetRegimeKValue().2.binaryOperationResult.2\: signed(7 downto 0) := to_signed(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetRegimeKValue().2._Finished\ <= false;
                \Posit32::GetRegimeKValue().2.return\ <= to_signed(0, 8);
                \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_0\;
                \Posit32::GetRegimeKValue().2.num\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().2.b\ := to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().2.return.0\ := false;
                \Posit32::GetRegimeKValue().2.return.1\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().2.return.2\ := to_unsigned(0, 8);
                \Posit32::GetRegimeKValue().2.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\ := to_signed(0, 8);
                \Posit32::GetRegimeKValue().2.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValue().2.binaryOperationResult.1\ := false;
                \Posit32::GetRegimeKValue().2.binaryOperationResult.2\ := to_signed(0, 8);
            else 
                case \Posit32::GetRegimeKValue().2._State\ is 
                    when \Posit32::GetRegimeKValue().2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetRegimeKValue().2._Started\ = true) then 
                            \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetRegimeKValue().2._Started\ = true) then 
                            \Posit32::GetRegimeKValue().2._Finished\ <= true;
                        else 
                            \Posit32::GetRegimeKValue().2._Finished\ <= false;
                            \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().2._State_2\ => 
                        \Posit32::GetRegimeKValue().2.this\ := \Posit32::GetRegimeKValue().2.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                        -- 	num = @this.PositBits;
                        -- }
                        -- else {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::GetRegimeKValue().2.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::GetRegimeKValue().2.this\;
                        \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Started.0\ = \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::GetRegimeKValue().2.return.0\ := \Posit32::GetRegimeKValue().2.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::GetRegimeKValue().2._State_5\ and ends in state \Posit32::GetRegimeKValue().2._State_5\.
                            --     * The false branch starts in state \Posit32::GetRegimeKValue().2._State_6\ and ends in state \Posit32::GetRegimeKValue().2._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::GetRegimeKValue().2._State_4\.

                            if (\Posit32::GetRegimeKValue().2.return.0\) then 
                                \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_5\;
                            else 
                                \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().2._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::GetRegimeKValue().2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = Posit32.LengthOfRunOfBits (num, 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::GetRegimeKValue().2.num\;
                        \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().2._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::GetRegimeKValue().2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = @this.PositBits;
                        -- 
                        \Posit32::GetRegimeKValue().2.num\ := \Posit32::GetRegimeKValue().2.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().2._State_3\.
                        if (\Posit32::GetRegimeKValue().2._State\ = \Posit32::GetRegimeKValue().2._State_5\) then 
                            \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().2._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::GetRegimeKValue().2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::GetRegimeKValue().2.this\.\PositBits\;
                        \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().2._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::GetRegimeKValue().2.return.1\ := \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::GetRegimeKValue().2.num\ := \Posit32::GetRegimeKValue().2.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().2._State_3\.
                            if (\Posit32::GetRegimeKValue().2._State\ = \Posit32::GetRegimeKValue().2._State_7\) then 
                                \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().2._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::GetRegimeKValue().2.return.2\ := \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::GetRegimeKValue().2.b\ := \Posit32::GetRegimeKValue().2.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- sbyte conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num & 1073741824u == 0u) {
                            -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)-(System.Int32)((sbyte)b);
                            -- }
                            -- else {
                            -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)((System.Int32)(b) - 1);
                            -- }
                            -- 
                            \Posit32::GetRegimeKValue().2.binaryOperationResult.0\ := \Posit32::GetRegimeKValue().2.num\ and to_unsigned(1073741824, 32);
                            \Posit32::GetRegimeKValue().2.binaryOperationResult.1\ := \Posit32::GetRegimeKValue().2.binaryOperationResult.0\ = to_unsigned(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::GetRegimeKValue().2._State_10\ and ends in state \Posit32::GetRegimeKValue().2._State_10\.
                            --     * The false branch starts in state \Posit32::GetRegimeKValue().2._State_11\ and ends in state \Posit32::GetRegimeKValue().2._State_11\.
                            --     * Execution after either branch will continue in the following state: \Posit32::GetRegimeKValue().2._State_9\.

                            if (\Posit32::GetRegimeKValue().2.binaryOperationResult.1\) then 
                                \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_10\;
                            else 
                                \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_11\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4137
                    when \Posit32::GetRegimeKValue().2._State_9\ => 
                        -- State after the if-else which was started in state \Posit32::GetRegimeKValue().2._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65;
                        -- 
                        \Posit32::GetRegimeKValue().2.return\ <= \Posit32::GetRegimeKValue().2.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\;
                        \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValue().2._State_10\ => 
                        -- True branch of the if-else started in state \Posit32::GetRegimeKValue().2._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)-(System.Int32)((sbyte)b);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)-(System.Int32)((sbyte)b);
                        -- 
                        \Posit32::GetRegimeKValue().2.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\ := SmartResize(-signed(SmartResize((signed(\Posit32::GetRegimeKValue().2.b\)), 32)), 8);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().2._State_8\.
                        if (\Posit32::GetRegimeKValue().2._State\ = \Posit32::GetRegimeKValue().2._State_10\) then 
                            \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::GetRegimeKValue().2._State_11\ => 
                        -- False branch of the if-else started in state \Posit32::GetRegimeKValue().2._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)((System.Int32)(b) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65 = (sbyte)((System.Int32)(b) - 1);
                        -- 
                        \Posit32::GetRegimeKValue().2.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\Posit32::GetRegimeKValue().2.b\), 32)) - to_signed(1, 32), 8);
                        \Posit32::GetRegimeKValue().2.conditional87b33f859401deb82171ed22ec6fd149518753e0ff610a76c4f9a3bc1cf3fc65\ := (\Posit32::GetRegimeKValue().2.binaryOperationResult.2\);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValue().2._State_8\.
                        if (\Posit32::GetRegimeKValue().2._State\ = \Posit32::GetRegimeKValue().2._State_11\) then 
                            \Posit32::GetRegimeKValue().2._State\ := \Posit32::GetRegimeKValue().2._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                end case;
            end if;
        end if;
    end process;
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().2 state machine end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).0 state machine start
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\: \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._States\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_0\;
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.lengthOfRunOfBits\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.2\: signed(7 downto 0) := to_signed(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._Finished\ <= false;
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.return\ <= to_signed(0, 8);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_0\;
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.lengthOfRunOfBits\ := to_unsigned(0, 8);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\ := to_signed(0, 8);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.1\ := false;
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.2\ := to_signed(0, 8);
            else 
                case \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\ is 
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._Started\ = true) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._Started\ = true) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._Finished\ <= true;
                        else 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._Finished\ <= false;
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_2\ => 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.this\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.this.parameter.In\;
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.lengthOfRunOfBits\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.lengthOfRunOfBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (@this.PositBits & 1073741824u == 0u) {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)-(System.Int32)((sbyte)lengthOfRunOfBits);
                        -- }
                        -- else {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)((System.Int32)(lengthOfRunOfBits) - 1);
                        -- }
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.0\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.this\.\PositBits\ and to_unsigned(1073741824, 32);
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.1\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.0\ = to_unsigned(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_4\ and ends in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_4\.
                        --     * The false branch starts in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_5\ and ends in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_5\.
                        --     * Execution after either branch will continue in the following state: \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_3\.

                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.1\) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_4\;
                        else 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4137
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1;
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.return\ <= \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\;
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)-(System.Int32)((sbyte)lengthOfRunOfBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)-(System.Int32)((sbyte)lengthOfRunOfBits);
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\ := SmartResize(-signed(SmartResize((signed(\Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.lengthOfRunOfBits\)), 32)), 8);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_2\.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\ = \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_4\) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_5\ => 
                        -- False branch of the if-else started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)((System.Int32)(lengthOfRunOfBits) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)((System.Int32)(lengthOfRunOfBits) - 1);
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.lengthOfRunOfBits\), 32)) - to_signed(1, 32), 8);
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\ := (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.binaryOperationResult.2\);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_2\.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\ = \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_5\) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                end case;
            end if;
        end if;
    end process;
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).0 state machine end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).1 state machine start
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\: \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._States\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_0\;
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.lengthOfRunOfBits\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.2\: signed(7 downto 0) := to_signed(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._Finished\ <= false;
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.return\ <= to_signed(0, 8);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_0\;
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.lengthOfRunOfBits\ := to_unsigned(0, 8);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\ := to_signed(0, 8);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.1\ := false;
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.2\ := to_signed(0, 8);
            else 
                case \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\ is 
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._Started\ = true) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._Started\ = true) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._Finished\ <= true;
                        else 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._Finished\ <= false;
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_2\ => 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.this\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.this.parameter.In\;
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.lengthOfRunOfBits\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.lengthOfRunOfBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (@this.PositBits & 1073741824u == 0u) {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)-(System.Int32)((sbyte)lengthOfRunOfBits);
                        -- }
                        -- else {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)((System.Int32)(lengthOfRunOfBits) - 1);
                        -- }
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.0\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.this\.\PositBits\ and to_unsigned(1073741824, 32);
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.1\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.0\ = to_unsigned(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_4\ and ends in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_4\.
                        --     * The false branch starts in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_5\ and ends in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_5\.
                        --     * Execution after either branch will continue in the following state: \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_3\.

                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.1\) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_4\;
                        else 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4137
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1;
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.return\ <= \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\;
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)-(System.Int32)((sbyte)lengthOfRunOfBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)-(System.Int32)((sbyte)lengthOfRunOfBits);
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\ := SmartResize(-signed(SmartResize((signed(\Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.lengthOfRunOfBits\)), 32)), 8);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_2\.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\ = \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_4\) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_5\ => 
                        -- False branch of the if-else started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)((System.Int32)(lengthOfRunOfBits) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)((System.Int32)(lengthOfRunOfBits) - 1);
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.lengthOfRunOfBits\), 32)) - to_signed(1, 32), 8);
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\ := (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.binaryOperationResult.2\);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_2\.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\ = \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_5\) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                end case;
            end if;
        end if;
    end process;
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).1 state machine end


    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).2 state machine start
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\: \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._States\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_0\;
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.lengthOfRunOfBits\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.2\: signed(7 downto 0) := to_signed(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._Finished\ <= false;
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.return\ <= to_signed(0, 8);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_0\;
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.lengthOfRunOfBits\ := to_unsigned(0, 8);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\ := to_signed(0, 8);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.1\ := false;
                \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.2\ := to_signed(0, 8);
            else 
                case \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\ is 
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._Started\ = true) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._Started\ = true) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._Finished\ <= true;
                        else 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._Finished\ <= false;
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_2\ => 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.this\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.this.parameter.In\;
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.lengthOfRunOfBits\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.lengthOfRunOfBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (@this.PositBits & 1073741824u == 0u) {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)-(System.Int32)((sbyte)lengthOfRunOfBits);
                        -- }
                        -- else {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)((System.Int32)(lengthOfRunOfBits) - 1);
                        -- }
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.0\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.this\.\PositBits\ and to_unsigned(1073741824, 32);
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.1\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.0\ = to_unsigned(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_4\ and ends in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_4\.
                        --     * The false branch starts in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_5\ and ends in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_5\.
                        --     * Execution after either branch will continue in the following state: \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_3\.

                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.1\) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_4\;
                        else 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4137
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1;
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.return\ <= \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\;
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)-(System.Int32)((sbyte)lengthOfRunOfBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)-(System.Int32)((sbyte)lengthOfRunOfBits);
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\ := SmartResize(-signed(SmartResize((signed(\Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.lengthOfRunOfBits\)), 32)), 8);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_2\.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\ = \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_4\) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_5\ => 
                        -- False branch of the if-else started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)((System.Int32)(lengthOfRunOfBits) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1 = (sbyte)((System.Int32)(lengthOfRunOfBits) - 1);
                        -- 
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.lengthOfRunOfBits\), 32)) - to_signed(1, 32), 8);
                        \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.conditional9b1776aafcd8c2547927d58238e920318b41cbac561cdb4ee77a41458616d3f1\ := (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.binaryOperationResult.2\);
                        -- Going to the state after the if-else which was started in state \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_2\.
                        if (\Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\ = \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_5\) then 
                            \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State\ := \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                end case;
            end if;
        end if;
    end process;
    -- System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte).2 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0 state machine start
    \Posit32::ExponentSize().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::ExponentSize().0._State\: \Posit32::ExponentSize().0._States\ := \Posit32::ExponentSize().0._State_0\;
        Variable \Posit32::ExponentSize().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::ExponentSize().0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::ExponentSize().0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::ExponentSize().0.flag\: boolean := false;
        Variable \Posit32::ExponentSize().0.result\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::ExponentSize().0.return.0\: boolean := false;
        Variable \Posit32::ExponentSize().0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::ExponentSize().0.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::ExponentSize().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::ExponentSize().0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.6\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::ExponentSize().0.binaryOperationResult.8\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::ExponentSize().0._Finished\ <= false;
                \Posit32::ExponentSize().0.return\ <= to_unsigned(0, 8);
                \Posit32::ExponentSize().0.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_0\;
                \Posit32::ExponentSize().0.bits\ := to_unsigned(0, 32);
                \Posit32::ExponentSize().0.b\ := to_unsigned(0, 8);
                \Posit32::ExponentSize().0.flag\ := false;
                \Posit32::ExponentSize().0.result\ := to_unsigned(0, 8);
                \Posit32::ExponentSize().0.return.0\ := false;
                \Posit32::ExponentSize().0.return.1\ := to_unsigned(0, 32);
                \Posit32::ExponentSize().0.return.2\ := to_unsigned(0, 8);
                \Posit32::ExponentSize().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::ExponentSize().0.binaryOperationResult.1\ := false;
                \Posit32::ExponentSize().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::ExponentSize().0.binaryOperationResult.3\ := to_signed(0, 32);
                \Posit32::ExponentSize().0.binaryOperationResult.4\ := false;
                \Posit32::ExponentSize().0.binaryOperationResult.5\ := to_signed(0, 32);
                \Posit32::ExponentSize().0.binaryOperationResult.6\ := to_unsigned(0, 8);
                \Posit32::ExponentSize().0.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit32::ExponentSize().0.binaryOperationResult.8\ := to_unsigned(0, 8);
            else 
                case \Posit32::ExponentSize().0._State\ is 
                    when \Posit32::ExponentSize().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::ExponentSize().0._Started\ = true) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::ExponentSize().0._Started\ = true) then 
                            \Posit32::ExponentSize().0._Finished\ <= true;
                        else 
                            \Posit32::ExponentSize().0._Finished\ <= false;
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_2\ => 
                        \Posit32::ExponentSize().0.this\ := \Posit32::ExponentSize().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                        -- 	bits = @this.PositBits;
                        -- }
                        -- else {
                        -- 	bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::ExponentSize().0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::ExponentSize().0.this\;
                        \Posit32::ExponentSize().0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::ExponentSize().0.Posit32::IsPositive()._Started.0\ = \Posit32::ExponentSize().0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::ExponentSize().0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::ExponentSize().0.return.0\ := \Posit32::ExponentSize().0.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::ExponentSize().0._State_5\ and ends in state \Posit32::ExponentSize().0._State_5\.
                            --     * The false branch starts in state \Posit32::ExponentSize().0._State_6\ and ends in state \Posit32::ExponentSize().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::ExponentSize().0._State_4\.

                            if (\Posit32::ExponentSize().0.return.0\) then 
                                \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_5\;
                            else 
                                \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::ExponentSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = Posit32.LengthOfRunOfBits (bits, 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::ExponentSize().0.bits\;
                        \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::ExponentSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bits = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits = @this.PositBits;
                        -- 
                        \Posit32::ExponentSize().0.bits\ := \Posit32::ExponentSize().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::ExponentSize().0._State_3\.
                        if (\Posit32::ExponentSize().0._State\ = \Posit32::ExponentSize().0._State_5\) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::ExponentSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::ExponentSize().0.this\.\PositBits\;
                        \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::ExponentSize().0.return.1\ := \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::ExponentSize().0.bits\ := \Posit32::ExponentSize().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::ExponentSize().0._State_3\.
                            if (\Posit32::ExponentSize().0._State\ = \Posit32::ExponentSize().0._State_7\) then 
                                \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::ExponentSize().0.return.2\ := \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::ExponentSize().0.b\ := \Posit32::ExponentSize().0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag = (System.Int32)((System.Int32)(b) + 2) <= 32;
                            -- 
                            \Posit32::ExponentSize().0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit32::ExponentSize().0.b\), 32)) + to_signed(2, 32), 32);
                            \Posit32::ExponentSize().0.binaryOperationResult.1\ := (\Posit32::ExponentSize().0.binaryOperationResult.0\) <= to_signed(32, 32);
                            \Posit32::ExponentSize().0.flag\ := \Posit32::ExponentSize().0.binaryOperationResult.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	if ((System.Int32)(32 - (System.Int32)((System.Int32)(b) + 2)) > 2) {
                            -- 		result = 2;
                            -- 	}
                            -- 	else {
                            -- 		result = (System.Byte)(32 - (System.Int32)((System.Int32)(b) + 2));
                            -- 	}
                            -- }
                            -- else {
                            -- 	result = (System.Byte)((System.Int32)(32 - (System.Int32)(b)) - 1);
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::ExponentSize().0._State_10\ and ends in state \Posit32::ExponentSize().0._State_11\.
                            --     * The false branch starts in state \Posit32::ExponentSize().0._State_14\ and ends in state \Posit32::ExponentSize().0._State_14\.
                            --     * Execution after either branch will continue in the following state: \Posit32::ExponentSize().0._State_9\.

                            if (\Posit32::ExponentSize().0.flag\) then 
                                \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_10\;
                            else 
                                \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_14\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5766
                    when \Posit32::ExponentSize().0._State_9\ => 
                        -- State after the if-else which was started in state \Posit32::ExponentSize().0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::ExponentSize().0.return\ <= \Posit32::ExponentSize().0.result\;
                        \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_10\ => 
                        -- True branch of the if-else started in state \Posit32::ExponentSize().0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if ((System.Int32)(32 - (System.Int32)((System.Int32)(b) + 2)) > 2) {
                        -- 		result = 2;
                        -- 	}
                        -- 	else {
                        -- 		result = (System.Byte)(32 - (System.Int32)((System.Int32)(b) + 2));
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((System.Int32)(32 - (System.Int32)((System.Int32)(b) + 2)) > 2) {
                        -- 	result = 2;
                        -- }
                        -- else {
                        -- 	result = (System.Byte)(32 - (System.Int32)((System.Int32)(b) + 2));
                        -- }
                        -- 
                        \Posit32::ExponentSize().0.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\Posit32::ExponentSize().0.b\), 32)) + to_signed(2, 32), 32);
                        \Posit32::ExponentSize().0.binaryOperationResult.3\ := to_signed(32, 32) - (\Posit32::ExponentSize().0.binaryOperationResult.2\);
                        \Posit32::ExponentSize().0.binaryOperationResult.4\ := (\Posit32::ExponentSize().0.binaryOperationResult.3\) > to_signed(2, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::ExponentSize().0._State_12\ and ends in state \Posit32::ExponentSize().0._State_12\.
                        --     * The false branch starts in state \Posit32::ExponentSize().0._State_13\ and ends in state \Posit32::ExponentSize().0._State_13\.
                        --     * Execution after either branch will continue in the following state: \Posit32::ExponentSize().0._State_11\.

                        if (\Posit32::ExponentSize().0.binaryOperationResult.4\) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_12\;
                        else 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9067
                    when \Posit32::ExponentSize().0._State_11\ => 
                        -- State after the if-else which was started in state \Posit32::ExponentSize().0._State_10\.
                        -- Going to the state after the if-else which was started in state \Posit32::ExponentSize().0._State_8\.
                        if (\Posit32::ExponentSize().0._State\ = \Posit32::ExponentSize().0._State_11\) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_12\ => 
                        -- True branch of the if-else started in state \Posit32::ExponentSize().0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = 2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = 2;
                        -- 
                        \Posit32::ExponentSize().0.result\ := to_unsigned(2, 8);
                        -- Going to the state after the if-else which was started in state \Posit32::ExponentSize().0._State_10\.
                        if (\Posit32::ExponentSize().0._State\ = \Posit32::ExponentSize().0._State_12\) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::ExponentSize().0._State_13\ => 
                        -- False branch of the if-else started in state \Posit32::ExponentSize().0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = (System.Byte)(32 - (System.Int32)((System.Int32)(b) + 2));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = (System.Byte)(32 - (System.Int32)((System.Int32)(b) + 2));
                        -- 
                        \Posit32::ExponentSize().0.binaryOperationResult.5\ := SmartResize(signed(SmartResize((\Posit32::ExponentSize().0.b\), 32)) + to_signed(2, 32), 32);
                        \Posit32::ExponentSize().0.binaryOperationResult.6\ := SmartResize(unsigned(to_signed(32, 32) - (\Posit32::ExponentSize().0.binaryOperationResult.5\)), 8);
                        \Posit32::ExponentSize().0.result\ := (\Posit32::ExponentSize().0.binaryOperationResult.6\);
                        -- Going to the state after the if-else which was started in state \Posit32::ExponentSize().0._State_10\.
                        if (\Posit32::ExponentSize().0._State\ = \Posit32::ExponentSize().0._State_13\) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::ExponentSize().0._State_14\ => 
                        -- False branch of the if-else started in state \Posit32::ExponentSize().0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = (System.Byte)((System.Int32)(32 - (System.Int32)(b)) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = (System.Byte)((System.Int32)(32 - (System.Int32)(b)) - 1);
                        -- 
                        \Posit32::ExponentSize().0.binaryOperationResult.7\ := to_signed(32, 32) - signed(SmartResize((\Posit32::ExponentSize().0.b\), 32));
                        \Posit32::ExponentSize().0.binaryOperationResult.8\ := SmartResize(unsigned((\Posit32::ExponentSize().0.binaryOperationResult.7\) - to_signed(1, 32)), 8);
                        \Posit32::ExponentSize().0.result\ := (\Posit32::ExponentSize().0.binaryOperationResult.8\);
                        -- Going to the state after the if-else which was started in state \Posit32::ExponentSize().0._State_8\.
                        if (\Posit32::ExponentSize().0._State\ = \Posit32::ExponentSize().0._State_14\) then 
                            \Posit32::ExponentSize().0._State\ := \Posit32::ExponentSize().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0 state machine start
    \Posit32::GetExponentValue().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetExponentValue().0._State\: \Posit32::GetExponentValue().0._States\ := \Posit32::GetExponentValue().0._State_0\;
        Variable \Posit32::GetExponentValue().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetExponentValue().0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetExponentValue().0.return.0\: boolean := false;
        Variable \Posit32::GetExponentValue().0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetExponentValue().0.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::GetExponentValue().0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().0.binaryOperationResult.4\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetExponentValue().0._Finished\ <= false;
                \Posit32::GetExponentValue().0.return\ <= to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\ <= false;
                \Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\ <= false;
                \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_0\;
                \Posit32::GetExponentValue().0.num\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.b\ := to_unsigned(0, 8);
                \Posit32::GetExponentValue().0.return.0\ := false;
                \Posit32::GetExponentValue().0.return.1\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.return.2\ := to_unsigned(0, 8);
                \Posit32::GetExponentValue().0.return.3\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::GetExponentValue().0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().0.binaryOperationResult.4\ := false;
            else 
                case \Posit32::GetExponentValue().0._State\ is 
                    when \Posit32::GetExponentValue().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetExponentValue().0._Started\ = true) then 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetExponentValue().0._Started\ = true) then 
                            \Posit32::GetExponentValue().0._Finished\ <= true;
                        else 
                            \Posit32::GetExponentValue().0._Finished\ <= false;
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_2\ => 
                        \Posit32::GetExponentValue().0.this\ := \Posit32::GetExponentValue().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                        -- 	num = @this.PositBits;
                        -- }
                        -- else {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::GetExponentValue().0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::GetExponentValue().0.this\;
                        \Posit32::GetExponentValue().0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::GetExponentValue().0.Posit32::IsPositive()._Started.0\ = \Posit32::GetExponentValue().0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::GetExponentValue().0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::GetExponentValue().0.return.0\ := \Posit32::GetExponentValue().0.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::GetExponentValue().0._State_5\ and ends in state \Posit32::GetExponentValue().0._State_5\.
                            --     * The false branch starts in state \Posit32::GetExponentValue().0._State_6\ and ends in state \Posit32::GetExponentValue().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::GetExponentValue().0._State_4\.

                            if (\Posit32::GetExponentValue().0.return.0\) then 
                                \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_5\;
                            else 
                                \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::GetExponentValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = Lombiq.Arithmetics.Posit32.ExponentSize (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        \Posit32::GetExponentValue().0.Posit32::ExponentSize().this.parameter.Out.0\ <= \Posit32::GetExponentValue().0.this\;
                        \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\ <= true;
                        \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::GetExponentValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = @this.PositBits;
                        -- 
                        \Posit32::GetExponentValue().0.num\ := \Posit32::GetExponentValue().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().0._State_3\.
                        if (\Posit32::GetExponentValue().0._State\ = \Posit32::GetExponentValue().0._State_5\) then 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::GetExponentValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::GetExponentValue().0.this\.\PositBits\;
                        \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::GetExponentValue().0.return.1\ := \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::GetExponentValue().0.num\ := \Posit32::GetExponentValue().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().0._State_3\.
                            if (\Posit32::GetExponentValue().0._State\ = \Posit32::GetExponentValue().0._State_7\) then 
                                \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        if (\Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\ = \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Finished.0\) then 
                            \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\ <= false;
                            \Posit32::GetExponentValue().0.return.2\ := \Posit32::GetExponentValue().0.Posit32::ExponentSize().return.0\;
                            \Posit32::GetExponentValue().0.b\ := \Posit32::GetExponentValue().0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = num >> (int)Lombiq.Arithmetics.Posit32.FractionSize (@this) << (int)(32 - (System.Int32)(b)) >> 30;
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                            \Posit32::GetExponentValue().0.Posit32::FractionSize().this.parameter.Out.0\ <= \Posit32::GetExponentValue().0.this\;
                            \Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\ <= true;
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        if (\Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\ = \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\) then 
                            \Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\ <= false;
                            \Posit32::GetExponentValue().0.return.3\ := \Posit32::GetExponentValue().0.Posit32::FractionSize().return.0\;
                            \Posit32::GetExponentValue().0.binaryOperationResult.0\ := shift_right(\Posit32::GetExponentValue().0.num\, to_integer(unsigned(SmartResize(signed(\Posit32::GetExponentValue().0.return.3\), 5) and "11111")));
                            \Posit32::GetExponentValue().0.binaryOperationResult.1\ := to_signed(32, 32) - signed(SmartResize((\Posit32::GetExponentValue().0.b\), 32));
                            \Posit32::GetExponentValue().0.binaryOperationResult.2\ := shift_left(\Posit32::GetExponentValue().0.binaryOperationResult.0\, to_integer(unsigned(SmartResize((\Posit32::GetExponentValue().0.binaryOperationResult.1\), 5))));
                            \Posit32::GetExponentValue().0.binaryOperationResult.3\ := shift_right(\Posit32::GetExponentValue().0.binaryOperationResult.2\, to_integer(unsigned(SmartResize(to_signed(30, 32), 5) and "11111")));
                            \Posit32::GetExponentValue().0.num\ := \Posit32::GetExponentValue().0.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if ((System.Int32)(b) == 0) {
                            -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = 0u;
                            -- }
                            -- else {
                            -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = num;
                            -- }
                            -- 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8928
                    when \Posit32::GetExponentValue().0._State_10\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::GetExponentValue().0.binaryOperationResult.4\ := signed(SmartResize((\Posit32::GetExponentValue().0.b\), 32)) = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::GetExponentValue().0._State_12\ and ends in state \Posit32::GetExponentValue().0._State_12\.
                        --     * The false branch starts in state \Posit32::GetExponentValue().0._State_13\ and ends in state \Posit32::GetExponentValue().0._State_13\.
                        --     * Execution after either branch will continue in the following state: \Posit32::GetExponentValue().0._State_11\.

                        if (\Posit32::GetExponentValue().0.binaryOperationResult.4\) then 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_12\;
                        else 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::GetExponentValue().0._State_11\ => 
                        -- State after the if-else which was started in state \Posit32::GetExponentValue().0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629;
                        -- 
                        \Posit32::GetExponentValue().0.return\ <= \Posit32::GetExponentValue().0.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\;
                        \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_12\ => 
                        -- True branch of the if-else started in state \Posit32::GetExponentValue().0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = 0u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = 0u;
                        -- 
                        \Posit32::GetExponentValue().0.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\ := to_unsigned(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().0._State_10\.
                        if (\Posit32::GetExponentValue().0._State\ = \Posit32::GetExponentValue().0._State_12\) then 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().0._State_13\ => 
                        -- False branch of the if-else started in state \Posit32::GetExponentValue().0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = num;
                        -- 
                        \Posit32::GetExponentValue().0.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\ := \Posit32::GetExponentValue().0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().0._State_10\.
                        if (\Posit32::GetExponentValue().0._State\ = \Posit32::GetExponentValue().0._State_13\) then 
                            \Posit32::GetExponentValue().0._State\ := \Posit32::GetExponentValue().0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().1 state machine start
    \Posit32::GetExponentValue().1._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetExponentValue().1._State\: \Posit32::GetExponentValue().1._States\ := \Posit32::GetExponentValue().1._State_0\;
        Variable \Posit32::GetExponentValue().1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetExponentValue().1.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().1.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetExponentValue().1.return.0\: boolean := false;
        Variable \Posit32::GetExponentValue().1.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().1.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetExponentValue().1.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().1.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::GetExponentValue().1.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().1.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().1.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().1.binaryOperationResult.4\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetExponentValue().1._Finished\ <= false;
                \Posit32::GetExponentValue().1.return\ <= to_unsigned(0, 32);
                \Posit32::GetExponentValue().1.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::GetExponentValue().1.Posit32::ExponentSize()._Started.0\ <= false;
                \Posit32::GetExponentValue().1.Posit32::FractionSize()._Started.0\ <= false;
                \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_0\;
                \Posit32::GetExponentValue().1.num\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().1.b\ := to_unsigned(0, 8);
                \Posit32::GetExponentValue().1.return.0\ := false;
                \Posit32::GetExponentValue().1.return.1\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().1.return.2\ := to_unsigned(0, 8);
                \Posit32::GetExponentValue().1.return.3\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().1.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().1.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::GetExponentValue().1.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().1.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().1.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().1.binaryOperationResult.4\ := false;
            else 
                case \Posit32::GetExponentValue().1._State\ is 
                    when \Posit32::GetExponentValue().1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetExponentValue().1._Started\ = true) then 
                            \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetExponentValue().1._Started\ = true) then 
                            \Posit32::GetExponentValue().1._Finished\ <= true;
                        else 
                            \Posit32::GetExponentValue().1._Finished\ <= false;
                            \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().1._State_2\ => 
                        \Posit32::GetExponentValue().1.this\ := \Posit32::GetExponentValue().1.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                        -- 	num = @this.PositBits;
                        -- }
                        -- else {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::GetExponentValue().1.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::GetExponentValue().1.this\;
                        \Posit32::GetExponentValue().1.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::GetExponentValue().1.Posit32::IsPositive()._Started.0\ = \Posit32::GetExponentValue().1.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::GetExponentValue().1.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::GetExponentValue().1.return.0\ := \Posit32::GetExponentValue().1.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::GetExponentValue().1._State_5\ and ends in state \Posit32::GetExponentValue().1._State_5\.
                            --     * The false branch starts in state \Posit32::GetExponentValue().1._State_6\ and ends in state \Posit32::GetExponentValue().1._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::GetExponentValue().1._State_4\.

                            if (\Posit32::GetExponentValue().1.return.0\) then 
                                \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_5\;
                            else 
                                \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().1._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::GetExponentValue().1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = Lombiq.Arithmetics.Posit32.ExponentSize (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        \Posit32::GetExponentValue().1.Posit32::ExponentSize().this.parameter.Out.0\ <= \Posit32::GetExponentValue().1.this\;
                        \Posit32::GetExponentValue().1.Posit32::ExponentSize()._Started.0\ <= true;
                        \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().1._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::GetExponentValue().1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = @this.PositBits;
                        -- 
                        \Posit32::GetExponentValue().1.num\ := \Posit32::GetExponentValue().1.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().1._State_3\.
                        if (\Posit32::GetExponentValue().1._State\ = \Posit32::GetExponentValue().1._State_5\) then 
                            \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().1._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::GetExponentValue().1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::GetExponentValue().1.this\.\PositBits\;
                        \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().1._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::GetExponentValue().1.return.1\ := \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::GetExponentValue().1.num\ := \Posit32::GetExponentValue().1.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().1._State_3\.
                            if (\Posit32::GetExponentValue().1._State\ = \Posit32::GetExponentValue().1._State_7\) then 
                                \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().1._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        if (\Posit32::GetExponentValue().1.Posit32::ExponentSize()._Started.0\ = \Posit32::GetExponentValue().1.Posit32::ExponentSize()._Finished.0\) then 
                            \Posit32::GetExponentValue().1.Posit32::ExponentSize()._Started.0\ <= false;
                            \Posit32::GetExponentValue().1.return.2\ := \Posit32::GetExponentValue().1.Posit32::ExponentSize().return.0\;
                            \Posit32::GetExponentValue().1.b\ := \Posit32::GetExponentValue().1.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = num >> (int)Lombiq.Arithmetics.Posit32.FractionSize (@this) << (int)(32 - (System.Int32)(b)) >> 30;
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                            \Posit32::GetExponentValue().1.Posit32::FractionSize().this.parameter.Out.0\ <= \Posit32::GetExponentValue().1.this\;
                            \Posit32::GetExponentValue().1.Posit32::FractionSize()._Started.0\ <= true;
                            \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().1._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        if (\Posit32::GetExponentValue().1.Posit32::FractionSize()._Started.0\ = \Posit32::GetExponentValue().1.Posit32::FractionSize()._Finished.0\) then 
                            \Posit32::GetExponentValue().1.Posit32::FractionSize()._Started.0\ <= false;
                            \Posit32::GetExponentValue().1.return.3\ := \Posit32::GetExponentValue().1.Posit32::FractionSize().return.0\;
                            \Posit32::GetExponentValue().1.binaryOperationResult.0\ := shift_right(\Posit32::GetExponentValue().1.num\, to_integer(unsigned(SmartResize(signed(\Posit32::GetExponentValue().1.return.3\), 5) and "11111")));
                            \Posit32::GetExponentValue().1.binaryOperationResult.1\ := to_signed(32, 32) - signed(SmartResize((\Posit32::GetExponentValue().1.b\), 32));
                            \Posit32::GetExponentValue().1.binaryOperationResult.2\ := shift_left(\Posit32::GetExponentValue().1.binaryOperationResult.0\, to_integer(unsigned(SmartResize((\Posit32::GetExponentValue().1.binaryOperationResult.1\), 5))));
                            \Posit32::GetExponentValue().1.binaryOperationResult.3\ := shift_right(\Posit32::GetExponentValue().1.binaryOperationResult.2\, to_integer(unsigned(SmartResize(to_signed(30, 32), 5) and "11111")));
                            \Posit32::GetExponentValue().1.num\ := \Posit32::GetExponentValue().1.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if ((System.Int32)(b) == 0) {
                            -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = 0u;
                            -- }
                            -- else {
                            -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = num;
                            -- }
                            -- 
                            \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8928
                    when \Posit32::GetExponentValue().1._State_10\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::GetExponentValue().1.binaryOperationResult.4\ := signed(SmartResize((\Posit32::GetExponentValue().1.b\), 32)) = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::GetExponentValue().1._State_12\ and ends in state \Posit32::GetExponentValue().1._State_12\.
                        --     * The false branch starts in state \Posit32::GetExponentValue().1._State_13\ and ends in state \Posit32::GetExponentValue().1._State_13\.
                        --     * Execution after either branch will continue in the following state: \Posit32::GetExponentValue().1._State_11\.

                        if (\Posit32::GetExponentValue().1.binaryOperationResult.4\) then 
                            \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_12\;
                        else 
                            \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::GetExponentValue().1._State_11\ => 
                        -- State after the if-else which was started in state \Posit32::GetExponentValue().1._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629;
                        -- 
                        \Posit32::GetExponentValue().1.return\ <= \Posit32::GetExponentValue().1.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\;
                        \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().1._State_12\ => 
                        -- True branch of the if-else started in state \Posit32::GetExponentValue().1._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = 0u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = 0u;
                        -- 
                        \Posit32::GetExponentValue().1.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\ := to_unsigned(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().1._State_10\.
                        if (\Posit32::GetExponentValue().1._State\ = \Posit32::GetExponentValue().1._State_12\) then 
                            \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().1._State_13\ => 
                        -- False branch of the if-else started in state \Posit32::GetExponentValue().1._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = num;
                        -- 
                        \Posit32::GetExponentValue().1.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\ := \Posit32::GetExponentValue().1.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().1._State_10\.
                        if (\Posit32::GetExponentValue().1._State\ = \Posit32::GetExponentValue().1._State_13\) then 
                            \Posit32::GetExponentValue().1._State\ := \Posit32::GetExponentValue().1._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().2 state machine start
    \Posit32::GetExponentValue().2._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetExponentValue().2._State\: \Posit32::GetExponentValue().2._States\ := \Posit32::GetExponentValue().2._State_0\;
        Variable \Posit32::GetExponentValue().2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetExponentValue().2.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().2.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetExponentValue().2.return.0\: boolean := false;
        Variable \Posit32::GetExponentValue().2.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().2.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetExponentValue().2.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().2.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::GetExponentValue().2.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().2.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().2.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValue().2.binaryOperationResult.4\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetExponentValue().2._Finished\ <= false;
                \Posit32::GetExponentValue().2.return\ <= to_unsigned(0, 32);
                \Posit32::GetExponentValue().2.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::GetExponentValue().2.Posit32::ExponentSize()._Started.0\ <= false;
                \Posit32::GetExponentValue().2.Posit32::FractionSize()._Started.0\ <= false;
                \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_0\;
                \Posit32::GetExponentValue().2.num\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().2.b\ := to_unsigned(0, 8);
                \Posit32::GetExponentValue().2.return.0\ := false;
                \Posit32::GetExponentValue().2.return.1\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().2.return.2\ := to_unsigned(0, 8);
                \Posit32::GetExponentValue().2.return.3\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().2.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().2.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::GetExponentValue().2.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().2.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().2.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\ := to_unsigned(0, 32);
                \Posit32::GetExponentValue().2.binaryOperationResult.4\ := false;
            else 
                case \Posit32::GetExponentValue().2._State\ is 
                    when \Posit32::GetExponentValue().2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetExponentValue().2._Started\ = true) then 
                            \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetExponentValue().2._Started\ = true) then 
                            \Posit32::GetExponentValue().2._Finished\ <= true;
                        else 
                            \Posit32::GetExponentValue().2._Finished\ <= false;
                            \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().2._State_2\ => 
                        \Posit32::GetExponentValue().2.this\ := \Posit32::GetExponentValue().2.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                        -- 	num = @this.PositBits;
                        -- }
                        -- else {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::GetExponentValue().2.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::GetExponentValue().2.this\;
                        \Posit32::GetExponentValue().2.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::GetExponentValue().2.Posit32::IsPositive()._Started.0\ = \Posit32::GetExponentValue().2.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::GetExponentValue().2.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::GetExponentValue().2.return.0\ := \Posit32::GetExponentValue().2.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::GetExponentValue().2._State_5\ and ends in state \Posit32::GetExponentValue().2._State_5\.
                            --     * The false branch starts in state \Posit32::GetExponentValue().2._State_6\ and ends in state \Posit32::GetExponentValue().2._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::GetExponentValue().2._State_4\.

                            if (\Posit32::GetExponentValue().2.return.0\) then 
                                \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_5\;
                            else 
                                \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().2._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::GetExponentValue().2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = Lombiq.Arithmetics.Posit32.ExponentSize (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        \Posit32::GetExponentValue().2.Posit32::ExponentSize().this.parameter.Out.0\ <= \Posit32::GetExponentValue().2.this\;
                        \Posit32::GetExponentValue().2.Posit32::ExponentSize()._Started.0\ <= true;
                        \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().2._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::GetExponentValue().2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = @this.PositBits;
                        -- 
                        \Posit32::GetExponentValue().2.num\ := \Posit32::GetExponentValue().2.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().2._State_3\.
                        if (\Posit32::GetExponentValue().2._State\ = \Posit32::GetExponentValue().2._State_5\) then 
                            \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().2._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::GetExponentValue().2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::GetExponentValue().2.this\.\PositBits\;
                        \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().2._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::GetExponentValue().2.return.1\ := \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::GetExponentValue().2.num\ := \Posit32::GetExponentValue().2.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().2._State_3\.
                            if (\Posit32::GetExponentValue().2._State\ = \Posit32::GetExponentValue().2._State_7\) then 
                                \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().2._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        if (\Posit32::GetExponentValue().2.Posit32::ExponentSize()._Started.0\ = \Posit32::GetExponentValue().2.Posit32::ExponentSize()._Finished.0\) then 
                            \Posit32::GetExponentValue().2.Posit32::ExponentSize()._Started.0\ <= false;
                            \Posit32::GetExponentValue().2.return.2\ := \Posit32::GetExponentValue().2.Posit32::ExponentSize().return.0\;
                            \Posit32::GetExponentValue().2.b\ := \Posit32::GetExponentValue().2.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = num >> (int)Lombiq.Arithmetics.Posit32.FractionSize (@this) << (int)(32 - (System.Int32)(b)) >> 30;
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                            \Posit32::GetExponentValue().2.Posit32::FractionSize().this.parameter.Out.0\ <= \Posit32::GetExponentValue().2.this\;
                            \Posit32::GetExponentValue().2.Posit32::FractionSize()._Started.0\ <= true;
                            \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().2._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        if (\Posit32::GetExponentValue().2.Posit32::FractionSize()._Started.0\ = \Posit32::GetExponentValue().2.Posit32::FractionSize()._Finished.0\) then 
                            \Posit32::GetExponentValue().2.Posit32::FractionSize()._Started.0\ <= false;
                            \Posit32::GetExponentValue().2.return.3\ := \Posit32::GetExponentValue().2.Posit32::FractionSize().return.0\;
                            \Posit32::GetExponentValue().2.binaryOperationResult.0\ := shift_right(\Posit32::GetExponentValue().2.num\, to_integer(unsigned(SmartResize(signed(\Posit32::GetExponentValue().2.return.3\), 5) and "11111")));
                            \Posit32::GetExponentValue().2.binaryOperationResult.1\ := to_signed(32, 32) - signed(SmartResize((\Posit32::GetExponentValue().2.b\), 32));
                            \Posit32::GetExponentValue().2.binaryOperationResult.2\ := shift_left(\Posit32::GetExponentValue().2.binaryOperationResult.0\, to_integer(unsigned(SmartResize((\Posit32::GetExponentValue().2.binaryOperationResult.1\), 5))));
                            \Posit32::GetExponentValue().2.binaryOperationResult.3\ := shift_right(\Posit32::GetExponentValue().2.binaryOperationResult.2\, to_integer(unsigned(SmartResize(to_signed(30, 32), 5) and "11111")));
                            \Posit32::GetExponentValue().2.num\ := \Posit32::GetExponentValue().2.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if ((System.Int32)(b) == 0) {
                            -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = 0u;
                            -- }
                            -- else {
                            -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = num;
                            -- }
                            -- 
                            \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8928
                    when \Posit32::GetExponentValue().2._State_10\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::GetExponentValue().2.binaryOperationResult.4\ := signed(SmartResize((\Posit32::GetExponentValue().2.b\), 32)) = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::GetExponentValue().2._State_12\ and ends in state \Posit32::GetExponentValue().2._State_12\.
                        --     * The false branch starts in state \Posit32::GetExponentValue().2._State_13\ and ends in state \Posit32::GetExponentValue().2._State_13\.
                        --     * Execution after either branch will continue in the following state: \Posit32::GetExponentValue().2._State_11\.

                        if (\Posit32::GetExponentValue().2.binaryOperationResult.4\) then 
                            \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_12\;
                        else 
                            \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::GetExponentValue().2._State_11\ => 
                        -- State after the if-else which was started in state \Posit32::GetExponentValue().2._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629;
                        -- 
                        \Posit32::GetExponentValue().2.return\ <= \Posit32::GetExponentValue().2.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\;
                        \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().2._State_12\ => 
                        -- True branch of the if-else started in state \Posit32::GetExponentValue().2._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = 0u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = 0u;
                        -- 
                        \Posit32::GetExponentValue().2.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\ := to_unsigned(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().2._State_10\.
                        if (\Posit32::GetExponentValue().2._State\ = \Posit32::GetExponentValue().2._State_12\) then 
                            \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValue().2._State_13\ => 
                        -- False branch of the if-else started in state \Posit32::GetExponentValue().2._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629 = num;
                        -- 
                        \Posit32::GetExponentValue().2.conditionalabf0901ee9e53320f782e035986ce2543c2518ff794faa59fcfd612c4f544629\ := \Posit32::GetExponentValue().2.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::GetExponentValue().2._State_10\.
                        if (\Posit32::GetExponentValue().2._State\ = \Posit32::GetExponentValue().2._State_13\) then 
                            \Posit32::GetExponentValue().2._State\ := \Posit32::GetExponentValue().2._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().2 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).0 state machine start
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State\: \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._States\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_0\;
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.fractionSize\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._Finished\ <= false;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.return\ <= to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Started.0\ <= false;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_0\;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.fractionSize\ := to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.return.0\ := to_unsigned(0, 8);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
            else 
                case \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State\ is 
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).0._Started\ = true) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).0._Started\ = true) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._Finished\ <= false;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_2\ => 
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.this\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.this.parameter.In\;
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.fractionSize\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.fractionSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits >> (int)fractionSize << (int)(32 - (System.Int32)(Lombiq.Arithmetics.Posit32.ExponentSize (@this))) >> 30;
                        -- 
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.0\ := shift_right(\Posit32::GetExponentValueWithoutSignCheck(UInt32).0.this\.\PositBits\, to_integer(unsigned(SmartResize(signed(\Posit32::GetExponentValueWithoutSignCheck(UInt32).0.fractionSize\), 5) and "11111")));
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize().this.parameter.Out.0\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.this\;
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Started.0\ <= true;
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.2386
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Started.0\ = \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Finished.0\) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Started.0\ <= false;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.return.0\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize().return.0\;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.1\ := to_signed(32, 32) - signed(SmartResize((\Posit32::GetExponentValueWithoutSignCheck(UInt32).0.return.0\), 32));
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.2\ := shift_left(\Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.0\, to_integer(unsigned(SmartResize((\Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.1\), 5))));
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.3\ := shift_right(\Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.2\, to_integer(unsigned(SmartResize(to_signed(30, 32), 5) and "11111")));
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.return\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.binaryOperationResult.3\;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).1 state machine start
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State\: \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._States\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_0\;
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.fractionSize\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._Finished\ <= false;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.return\ <= to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Started.0\ <= false;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_0\;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.fractionSize\ := to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.return.0\ := to_unsigned(0, 8);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.3\ := to_unsigned(0, 32);
            else 
                case \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State\ is 
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).1._Started\ = true) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).1._Started\ = true) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._Finished\ <= true;
                        else 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._Finished\ <= false;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_2\ => 
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.this\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.this.parameter.In\;
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.fractionSize\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.fractionSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits >> (int)fractionSize << (int)(32 - (System.Int32)(Lombiq.Arithmetics.Posit32.ExponentSize (@this))) >> 30;
                        -- 
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.0\ := shift_right(\Posit32::GetExponentValueWithoutSignCheck(UInt32).1.this\.\PositBits\, to_integer(unsigned(SmartResize(signed(\Posit32::GetExponentValueWithoutSignCheck(UInt32).1.fractionSize\), 5) and "11111")));
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize().this.parameter.Out.0\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.this\;
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Started.0\ <= true;
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.2386
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Started.0\ = \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Finished.0\) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Started.0\ <= false;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.return.0\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize().return.0\;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.1\ := to_signed(32, 32) - signed(SmartResize((\Posit32::GetExponentValueWithoutSignCheck(UInt32).1.return.0\), 32));
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.2\ := shift_left(\Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.0\, to_integer(unsigned(SmartResize((\Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.1\), 5))));
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.3\ := shift_right(\Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.2\, to_integer(unsigned(SmartResize(to_signed(30, 32), 5) and "11111")));
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.return\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.binaryOperationResult.3\;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).2 state machine start
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State\: \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._States\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_0\;
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.fractionSize\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._Finished\ <= false;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.return\ <= to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Started.0\ <= false;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_0\;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.fractionSize\ := to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.return.0\ := to_unsigned(0, 8);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.3\ := to_unsigned(0, 32);
            else 
                case \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State\ is 
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).2._Started\ = true) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).2._Started\ = true) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._Finished\ <= true;
                        else 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._Finished\ <= false;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_2\ => 
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.this\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.this.parameter.In\;
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.fractionSize\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.fractionSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.PositBits >> (int)fractionSize << (int)(32 - (System.Int32)(Lombiq.Arithmetics.Posit32.ExponentSize (@this))) >> 30;
                        -- 
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.0\ := shift_right(\Posit32::GetExponentValueWithoutSignCheck(UInt32).2.this\.\PositBits\, to_integer(unsigned(SmartResize(signed(\Posit32::GetExponentValueWithoutSignCheck(UInt32).2.fractionSize\), 5) and "11111")));
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize().this.parameter.Out.0\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.this\;
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Started.0\ <= true;
                        \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.2386
                    when \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::ExponentSize()
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Started.0\ = \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Finished.0\) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Started.0\ <= false;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.return.0\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize().return.0\;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.1\ := to_signed(32, 32) - signed(SmartResize((\Posit32::GetExponentValueWithoutSignCheck(UInt32).2.return.0\), 32));
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.2\ := shift_left(\Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.0\, to_integer(unsigned(SmartResize((\Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.1\), 5))));
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.3\ := shift_right(\Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.2\, to_integer(unsigned(SmartResize(to_signed(30, 32), 5) and "11111")));
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.return\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.binaryOperationResult.3\;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State\ := \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).2 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0 state machine start
    \Posit32::FractionSize().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionSize().0._State\: \Posit32::FractionSize().0._States\ := \Posit32::FractionSize().0._State_0\;
        Variable \Posit32::FractionSize().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionSize().0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionSize().0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().0.return.0\: boolean := false;
        Variable \Posit32::FractionSize().0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionSize().0.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::FractionSize().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().0.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().0.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionSize().0._Finished\ <= false;
                \Posit32::FractionSize().0.return\ <= to_unsigned(0, 32);
                \Posit32::FractionSize().0.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_0\;
                \Posit32::FractionSize().0.bits\ := to_unsigned(0, 32);
                \Posit32::FractionSize().0.num\ := to_signed(0, 32);
                \Posit32::FractionSize().0.return.0\ := false;
                \Posit32::FractionSize().0.return.1\ := to_unsigned(0, 32);
                \Posit32::FractionSize().0.return.2\ := to_unsigned(0, 8);
                \Posit32::FractionSize().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionSize().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::FractionSize().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionSize().0.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\ := to_signed(0, 32);
                \Posit32::FractionSize().0.binaryOperationResult.3\ := false;
            else 
                case \Posit32::FractionSize().0._State\ is 
                    when \Posit32::FractionSize().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionSize().0._Started\ = true) then 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionSize().0._Started\ = true) then 
                            \Posit32::FractionSize().0._Finished\ <= true;
                        else 
                            \Posit32::FractionSize().0._Finished\ <= false;
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_2\ => 
                        \Posit32::FractionSize().0.this\ := \Posit32::FractionSize().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                        -- 	bits = @this.PositBits;
                        -- }
                        -- else {
                        -- 	bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::FractionSize().0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::FractionSize().0.this\;
                        \Posit32::FractionSize().0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::FractionSize().0.Posit32::IsPositive()._Started.0\ = \Posit32::FractionSize().0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::FractionSize().0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::FractionSize().0.return.0\ := \Posit32::FractionSize().0.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::FractionSize().0._State_5\ and ends in state \Posit32::FractionSize().0._State_5\.
                            --     * The false branch starts in state \Posit32::FractionSize().0._State_6\ and ends in state \Posit32::FractionSize().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::FractionSize().0._State_4\.

                            if (\Posit32::FractionSize().0.return.0\) then 
                                \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_5\;
                            else 
                                \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32 - (System.Int32)((System.Int32)((System.Int32)(Posit32.LengthOfRunOfBits (bits, 31)) + 2) + 2));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::FractionSize().0.bits\;
                        \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bits = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits = @this.PositBits;
                        -- 
                        \Posit32::FractionSize().0.bits\ := \Posit32::FractionSize().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSize().0._State_3\.
                        if (\Posit32::FractionSize().0._State\ = \Posit32::FractionSize().0._State_5\) then 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::FractionSize().0.this\.\PositBits\;
                        \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::FractionSize().0.return.1\ := \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::FractionSize().0.bits\ := \Posit32::FractionSize().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::FractionSize().0._State_3\.
                            if (\Posit32::FractionSize().0._State\ = \Posit32::FractionSize().0._State_7\) then 
                                \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::FractionSize().0.return.2\ := \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::FractionSize().0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit32::FractionSize().0.return.2\), 32)) + to_signed(2, 32), 32);
                            \Posit32::FractionSize().0.binaryOperationResult.1\ := SmartResize((\Posit32::FractionSize().0.binaryOperationResult.0\) + to_signed(2, 32), 32);
                            \Posit32::FractionSize().0.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit32::FractionSize().0.binaryOperationResult.1\);
                            \Posit32::FractionSize().0.num\ := (\Posit32::FractionSize().0.binaryOperationResult.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- int conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num > 0) {
                            -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = num;
                            -- }
                            -- else {
                            -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = 0;
                            -- }
                            -- 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::FractionSize().0._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionSize().0.binaryOperationResult.3\ := \Posit32::FractionSize().0.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionSize().0._State_11\ and ends in state \Posit32::FractionSize().0._State_11\.
                        --     * The false branch starts in state \Posit32::FractionSize().0._State_12\ and ends in state \Posit32::FractionSize().0._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionSize().0._State_10\.

                        if (\Posit32::FractionSize().0.binaryOperationResult.3\) then 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_11\;
                        else 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::FractionSize().0._State_10\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4);
                        -- 
                        \Posit32::FractionSize().0.return\ <= unsigned((\Posit32::FractionSize().0.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\));
                        \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_11\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = num;
                        -- 
                        \Posit32::FractionSize().0.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\ := \Posit32::FractionSize().0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSize().0._State_9\.
                        if (\Posit32::FractionSize().0._State\ = \Posit32::FractionSize().0._State_11\) then 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().0._State_12\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = 0;
                        -- 
                        \Posit32::FractionSize().0.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSize().0._State_9\.
                        if (\Posit32::FractionSize().0._State\ = \Posit32::FractionSize().0._State_12\) then 
                            \Posit32::FractionSize().0._State\ := \Posit32::FractionSize().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().1 state machine start
    \Posit32::FractionSize().1._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionSize().1._State\: \Posit32::FractionSize().1._States\ := \Posit32::FractionSize().1._State_0\;
        Variable \Posit32::FractionSize().1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionSize().1.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionSize().1.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().1.return.0\: boolean := false;
        Variable \Posit32::FractionSize().1.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionSize().1.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::FractionSize().1.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().1.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().1.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().1.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().1.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionSize().1._Finished\ <= false;
                \Posit32::FractionSize().1.return\ <= to_unsigned(0, 32);
                \Posit32::FractionSize().1.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_0\;
                \Posit32::FractionSize().1.bits\ := to_unsigned(0, 32);
                \Posit32::FractionSize().1.num\ := to_signed(0, 32);
                \Posit32::FractionSize().1.return.0\ := false;
                \Posit32::FractionSize().1.return.1\ := to_unsigned(0, 32);
                \Posit32::FractionSize().1.return.2\ := to_unsigned(0, 8);
                \Posit32::FractionSize().1.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionSize().1.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::FractionSize().1.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionSize().1.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\ := to_signed(0, 32);
                \Posit32::FractionSize().1.binaryOperationResult.3\ := false;
            else 
                case \Posit32::FractionSize().1._State\ is 
                    when \Posit32::FractionSize().1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionSize().1._Started\ = true) then 
                            \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionSize().1._Started\ = true) then 
                            \Posit32::FractionSize().1._Finished\ <= true;
                        else 
                            \Posit32::FractionSize().1._Finished\ <= false;
                            \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().1._State_2\ => 
                        \Posit32::FractionSize().1.this\ := \Posit32::FractionSize().1.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                        -- 	bits = @this.PositBits;
                        -- }
                        -- else {
                        -- 	bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::FractionSize().1.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::FractionSize().1.this\;
                        \Posit32::FractionSize().1.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::FractionSize().1.Posit32::IsPositive()._Started.0\ = \Posit32::FractionSize().1.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::FractionSize().1.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::FractionSize().1.return.0\ := \Posit32::FractionSize().1.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::FractionSize().1._State_5\ and ends in state \Posit32::FractionSize().1._State_5\.
                            --     * The false branch starts in state \Posit32::FractionSize().1._State_6\ and ends in state \Posit32::FractionSize().1._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::FractionSize().1._State_4\.

                            if (\Posit32::FractionSize().1.return.0\) then 
                                \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_5\;
                            else 
                                \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().1._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSize().1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32 - (System.Int32)((System.Int32)((System.Int32)(Posit32.LengthOfRunOfBits (bits, 31)) + 2) + 2));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::FractionSize().1.bits\;
                        \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().1._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSize().1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bits = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits = @this.PositBits;
                        -- 
                        \Posit32::FractionSize().1.bits\ := \Posit32::FractionSize().1.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSize().1._State_3\.
                        if (\Posit32::FractionSize().1._State\ = \Posit32::FractionSize().1._State_5\) then 
                            \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().1._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSize().1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::FractionSize().1.this\.\PositBits\;
                        \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().1._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::FractionSize().1.return.1\ := \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::FractionSize().1.bits\ := \Posit32::FractionSize().1.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::FractionSize().1._State_3\.
                            if (\Posit32::FractionSize().1._State\ = \Posit32::FractionSize().1._State_7\) then 
                                \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().1._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::FractionSize().1.return.2\ := \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::FractionSize().1.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit32::FractionSize().1.return.2\), 32)) + to_signed(2, 32), 32);
                            \Posit32::FractionSize().1.binaryOperationResult.1\ := SmartResize((\Posit32::FractionSize().1.binaryOperationResult.0\) + to_signed(2, 32), 32);
                            \Posit32::FractionSize().1.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit32::FractionSize().1.binaryOperationResult.1\);
                            \Posit32::FractionSize().1.num\ := (\Posit32::FractionSize().1.binaryOperationResult.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- int conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num > 0) {
                            -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = num;
                            -- }
                            -- else {
                            -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = 0;
                            -- }
                            -- 
                            \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::FractionSize().1._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionSize().1.binaryOperationResult.3\ := \Posit32::FractionSize().1.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionSize().1._State_11\ and ends in state \Posit32::FractionSize().1._State_11\.
                        --     * The false branch starts in state \Posit32::FractionSize().1._State_12\ and ends in state \Posit32::FractionSize().1._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionSize().1._State_10\.

                        if (\Posit32::FractionSize().1.binaryOperationResult.3\) then 
                            \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_11\;
                        else 
                            \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::FractionSize().1._State_10\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSize().1._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4);
                        -- 
                        \Posit32::FractionSize().1.return\ <= unsigned((\Posit32::FractionSize().1.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\));
                        \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().1._State_11\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSize().1._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = num;
                        -- 
                        \Posit32::FractionSize().1.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\ := \Posit32::FractionSize().1.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSize().1._State_9\.
                        if (\Posit32::FractionSize().1._State\ = \Posit32::FractionSize().1._State_11\) then 
                            \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().1._State_12\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSize().1._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = 0;
                        -- 
                        \Posit32::FractionSize().1.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSize().1._State_9\.
                        if (\Posit32::FractionSize().1._State\ = \Posit32::FractionSize().1._State_12\) then 
                            \Posit32::FractionSize().1._State\ := \Posit32::FractionSize().1._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().2 state machine start
    \Posit32::FractionSize().2._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionSize().2._State\: \Posit32::FractionSize().2._States\ := \Posit32::FractionSize().2._State_0\;
        Variable \Posit32::FractionSize().2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionSize().2.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionSize().2.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().2.return.0\: boolean := false;
        Variable \Posit32::FractionSize().2.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionSize().2.return.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::FractionSize().2.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().2.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().2.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().2.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSize().2.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionSize().2._Finished\ <= false;
                \Posit32::FractionSize().2.return\ <= to_unsigned(0, 32);
                \Posit32::FractionSize().2.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_0\;
                \Posit32::FractionSize().2.bits\ := to_unsigned(0, 32);
                \Posit32::FractionSize().2.num\ := to_signed(0, 32);
                \Posit32::FractionSize().2.return.0\ := false;
                \Posit32::FractionSize().2.return.1\ := to_unsigned(0, 32);
                \Posit32::FractionSize().2.return.2\ := to_unsigned(0, 8);
                \Posit32::FractionSize().2.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionSize().2.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::FractionSize().2.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionSize().2.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\ := to_signed(0, 32);
                \Posit32::FractionSize().2.binaryOperationResult.3\ := false;
            else 
                case \Posit32::FractionSize().2._State\ is 
                    when \Posit32::FractionSize().2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionSize().2._Started\ = true) then 
                            \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionSize().2._Started\ = true) then 
                            \Posit32::FractionSize().2._Finished\ <= true;
                        else 
                            \Posit32::FractionSize().2._Finished\ <= false;
                            \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().2._State_2\ => 
                        \Posit32::FractionSize().2.this\ := \Posit32::FractionSize().2.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                        -- 	bits = @this.PositBits;
                        -- }
                        -- else {
                        -- 	bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::FractionSize().2.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::FractionSize().2.this\;
                        \Posit32::FractionSize().2.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::FractionSize().2.Posit32::IsPositive()._Started.0\ = \Posit32::FractionSize().2.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::FractionSize().2.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::FractionSize().2.return.0\ := \Posit32::FractionSize().2.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::FractionSize().2._State_5\ and ends in state \Posit32::FractionSize().2._State_5\.
                            --     * The false branch starts in state \Posit32::FractionSize().2._State_6\ and ends in state \Posit32::FractionSize().2._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit32::FractionSize().2._State_4\.

                            if (\Posit32::FractionSize().2.return.0\) then 
                                \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_5\;
                            else 
                                \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().2._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSize().2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32 - (System.Int32)((System.Int32)((System.Int32)(Posit32.LengthOfRunOfBits (bits, 31)) + 2) + 2));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::FractionSize().2.bits\;
                        \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().2._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSize().2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bits = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits = @this.PositBits;
                        -- 
                        \Posit32::FractionSize().2.bits\ := \Posit32::FractionSize().2.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSize().2._State_3\.
                        if (\Posit32::FractionSize().2._State\ = \Posit32::FractionSize().2._State_5\) then 
                            \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().2._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSize().2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bits = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::FractionSize().2.this\.\PositBits\;
                        \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().2._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::FractionSize().2.return.1\ := \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::FractionSize().2.bits\ := \Posit32::FractionSize().2.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit32::FractionSize().2._State_3\.
                            if (\Posit32::FractionSize().2._State\ = \Posit32::FractionSize().2._State_7\) then 
                                \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().2._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::FractionSize().2.return.2\ := \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::FractionSize().2.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit32::FractionSize().2.return.2\), 32)) + to_signed(2, 32), 32);
                            \Posit32::FractionSize().2.binaryOperationResult.1\ := SmartResize((\Posit32::FractionSize().2.binaryOperationResult.0\) + to_signed(2, 32), 32);
                            \Posit32::FractionSize().2.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit32::FractionSize().2.binaryOperationResult.1\);
                            \Posit32::FractionSize().2.num\ := (\Posit32::FractionSize().2.binaryOperationResult.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- int conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num > 0) {
                            -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = num;
                            -- }
                            -- else {
                            -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = 0;
                            -- }
                            -- 
                            \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::FractionSize().2._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionSize().2.binaryOperationResult.3\ := \Posit32::FractionSize().2.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionSize().2._State_11\ and ends in state \Posit32::FractionSize().2._State_11\.
                        --     * The false branch starts in state \Posit32::FractionSize().2._State_12\ and ends in state \Posit32::FractionSize().2._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionSize().2._State_10\.

                        if (\Posit32::FractionSize().2.binaryOperationResult.3\) then 
                            \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_11\;
                        else 
                            \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::FractionSize().2._State_10\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSize().2._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4);
                        -- 
                        \Posit32::FractionSize().2.return\ <= unsigned((\Posit32::FractionSize().2.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\));
                        \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().2._State_11\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSize().2._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = num;
                        -- 
                        \Posit32::FractionSize().2.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\ := \Posit32::FractionSize().2.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSize().2._State_9\.
                        if (\Posit32::FractionSize().2._State\ = \Posit32::FractionSize().2._State_11\) then 
                            \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSize().2._State_12\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSize().2._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4 = 0;
                        -- 
                        \Posit32::FractionSize().2.conditionalbde56351df1b2282011ba6cd070cdb77a733ba2f0a4c40b103b7647c834f06a4\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSize().2._State_9\.
                        if (\Posit32::FractionSize().2._State\ = \Posit32::FractionSize().2._State_12\) then 
                            \Posit32::FractionSize().2._State\ := \Posit32::FractionSize().2._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().2 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().0 state machine start
    \Posit32::FractionSizeWithoutSignCheck().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionSizeWithoutSignCheck().0._State\: \Posit32::FractionSizeWithoutSignCheck().0._States\ := \Posit32::FractionSizeWithoutSignCheck().0._State_0\;
        Variable \Posit32::FractionSizeWithoutSignCheck().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionSizeWithoutSignCheck().0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().0.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().0.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionSizeWithoutSignCheck().0._Finished\ <= false;
                \Posit32::FractionSizeWithoutSignCheck().0.return\ <= to_unsigned(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::FractionSizeWithoutSignCheck().0._State\ := \Posit32::FractionSizeWithoutSignCheck().0._State_0\;
                \Posit32::FractionSizeWithoutSignCheck().0.num\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().0.return.0\ := to_unsigned(0, 8);
                \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().0.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.3\ := false;
            else 
                case \Posit32::FractionSizeWithoutSignCheck().0._State\ is 
                    when \Posit32::FractionSizeWithoutSignCheck().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionSizeWithoutSignCheck().0._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck().0._State\ := \Posit32::FractionSizeWithoutSignCheck().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionSizeWithoutSignCheck().0._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck().0._Finished\ <= true;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck().0._Finished\ <= false;
                            \Posit32::FractionSizeWithoutSignCheck().0._State\ := \Posit32::FractionSizeWithoutSignCheck().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().0._State_2\ => 
                        \Posit32::FractionSizeWithoutSignCheck().0.this\ := \Posit32::FractionSizeWithoutSignCheck().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32 - (System.Int32)((System.Int32)((System.Int32)(Posit32.LengthOfRunOfBits (@this.PositBits, 31)) + 2) + 2));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::FractionSizeWithoutSignCheck().0.this\.\PositBits\;
                        \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::FractionSizeWithoutSignCheck().0._State\ := \Posit32::FractionSizeWithoutSignCheck().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::FractionSizeWithoutSignCheck().0.return.0\ := \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit32::FractionSizeWithoutSignCheck().0.return.0\), 32)) + to_signed(2, 32), 32);
                            \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.1\ := SmartResize((\Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.0\) + to_signed(2, 32), 32);
                            \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.1\);
                            \Posit32::FractionSizeWithoutSignCheck().0.num\ := (\Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- int conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num > 0) {
                            -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = num;
                            -- }
                            -- else {
                            -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = 0;
                            -- }
                            -- 
                            \Posit32::FractionSizeWithoutSignCheck().0._State\ := \Posit32::FractionSizeWithoutSignCheck().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::FractionSizeWithoutSignCheck().0._State_4\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.3\ := \Posit32::FractionSizeWithoutSignCheck().0.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionSizeWithoutSignCheck().0._State_6\ and ends in state \Posit32::FractionSizeWithoutSignCheck().0._State_6\.
                        --     * The false branch starts in state \Posit32::FractionSizeWithoutSignCheck().0._State_7\ and ends in state \Posit32::FractionSizeWithoutSignCheck().0._State_7\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionSizeWithoutSignCheck().0._State_5\.

                        if (\Posit32::FractionSizeWithoutSignCheck().0.binaryOperationResult.3\) then 
                            \Posit32::FractionSizeWithoutSignCheck().0._State\ := \Posit32::FractionSizeWithoutSignCheck().0._State_6\;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck().0._State\ := \Posit32::FractionSizeWithoutSignCheck().0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::FractionSizeWithoutSignCheck().0._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck().0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671);
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck().0.return\ <= unsigned((\Posit32::FractionSizeWithoutSignCheck().0.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\));
                        \Posit32::FractionSizeWithoutSignCheck().0._State\ := \Posit32::FractionSizeWithoutSignCheck().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().0._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck().0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = num;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck().0.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\ := \Posit32::FractionSizeWithoutSignCheck().0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck().0._State_4\.
                        if (\Posit32::FractionSizeWithoutSignCheck().0._State\ = \Posit32::FractionSizeWithoutSignCheck().0._State_6\) then 
                            \Posit32::FractionSizeWithoutSignCheck().0._State\ := \Posit32::FractionSizeWithoutSignCheck().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().0._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck().0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = 0;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck().0.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck().0._State_4\.
                        if (\Posit32::FractionSizeWithoutSignCheck().0._State\ = \Posit32::FractionSizeWithoutSignCheck().0._State_7\) then 
                            \Posit32::FractionSizeWithoutSignCheck().0._State\ := \Posit32::FractionSizeWithoutSignCheck().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().1 state machine start
    \Posit32::FractionSizeWithoutSignCheck().1._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionSizeWithoutSignCheck().1._State\: \Posit32::FractionSizeWithoutSignCheck().1._States\ := \Posit32::FractionSizeWithoutSignCheck().1._State_0\;
        Variable \Posit32::FractionSizeWithoutSignCheck().1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionSizeWithoutSignCheck().1.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().1.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().1.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionSizeWithoutSignCheck().1._Finished\ <= false;
                \Posit32::FractionSizeWithoutSignCheck().1.return\ <= to_unsigned(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::FractionSizeWithoutSignCheck().1._State\ := \Posit32::FractionSizeWithoutSignCheck().1._State_0\;
                \Posit32::FractionSizeWithoutSignCheck().1.num\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().1.return.0\ := to_unsigned(0, 8);
                \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().1.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.3\ := false;
            else 
                case \Posit32::FractionSizeWithoutSignCheck().1._State\ is 
                    when \Posit32::FractionSizeWithoutSignCheck().1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionSizeWithoutSignCheck().1._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck().1._State\ := \Posit32::FractionSizeWithoutSignCheck().1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionSizeWithoutSignCheck().1._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck().1._Finished\ <= true;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck().1._Finished\ <= false;
                            \Posit32::FractionSizeWithoutSignCheck().1._State\ := \Posit32::FractionSizeWithoutSignCheck().1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().1._State_2\ => 
                        \Posit32::FractionSizeWithoutSignCheck().1.this\ := \Posit32::FractionSizeWithoutSignCheck().1.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32 - (System.Int32)((System.Int32)((System.Int32)(Posit32.LengthOfRunOfBits (@this.PositBits, 31)) + 2) + 2));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::FractionSizeWithoutSignCheck().1.this\.\PositBits\;
                        \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::FractionSizeWithoutSignCheck().1._State\ := \Posit32::FractionSizeWithoutSignCheck().1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::FractionSizeWithoutSignCheck().1.return.0\ := \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit32::FractionSizeWithoutSignCheck().1.return.0\), 32)) + to_signed(2, 32), 32);
                            \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.1\ := SmartResize((\Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.0\) + to_signed(2, 32), 32);
                            \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.1\);
                            \Posit32::FractionSizeWithoutSignCheck().1.num\ := (\Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- int conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num > 0) {
                            -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = num;
                            -- }
                            -- else {
                            -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = 0;
                            -- }
                            -- 
                            \Posit32::FractionSizeWithoutSignCheck().1._State\ := \Posit32::FractionSizeWithoutSignCheck().1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::FractionSizeWithoutSignCheck().1._State_4\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.3\ := \Posit32::FractionSizeWithoutSignCheck().1.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionSizeWithoutSignCheck().1._State_6\ and ends in state \Posit32::FractionSizeWithoutSignCheck().1._State_6\.
                        --     * The false branch starts in state \Posit32::FractionSizeWithoutSignCheck().1._State_7\ and ends in state \Posit32::FractionSizeWithoutSignCheck().1._State_7\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionSizeWithoutSignCheck().1._State_5\.

                        if (\Posit32::FractionSizeWithoutSignCheck().1.binaryOperationResult.3\) then 
                            \Posit32::FractionSizeWithoutSignCheck().1._State\ := \Posit32::FractionSizeWithoutSignCheck().1._State_6\;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck().1._State\ := \Posit32::FractionSizeWithoutSignCheck().1._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::FractionSizeWithoutSignCheck().1._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck().1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671);
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck().1.return\ <= unsigned((\Posit32::FractionSizeWithoutSignCheck().1.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\));
                        \Posit32::FractionSizeWithoutSignCheck().1._State\ := \Posit32::FractionSizeWithoutSignCheck().1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().1._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck().1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = num;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck().1.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\ := \Posit32::FractionSizeWithoutSignCheck().1.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck().1._State_4\.
                        if (\Posit32::FractionSizeWithoutSignCheck().1._State\ = \Posit32::FractionSizeWithoutSignCheck().1._State_6\) then 
                            \Posit32::FractionSizeWithoutSignCheck().1._State\ := \Posit32::FractionSizeWithoutSignCheck().1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().1._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck().1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = 0;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck().1.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck().1._State_4\.
                        if (\Posit32::FractionSizeWithoutSignCheck().1._State\ = \Posit32::FractionSizeWithoutSignCheck().1._State_7\) then 
                            \Posit32::FractionSizeWithoutSignCheck().1._State\ := \Posit32::FractionSizeWithoutSignCheck().1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().2 state machine start
    \Posit32::FractionSizeWithoutSignCheck().2._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionSizeWithoutSignCheck().2._State\: \Posit32::FractionSizeWithoutSignCheck().2._States\ := \Posit32::FractionSizeWithoutSignCheck().2._State_0\;
        Variable \Posit32::FractionSizeWithoutSignCheck().2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionSizeWithoutSignCheck().2.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().2.return.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().2.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionSizeWithoutSignCheck().2._Finished\ <= false;
                \Posit32::FractionSizeWithoutSignCheck().2.return\ <= to_unsigned(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::FractionSizeWithoutSignCheck().2._State\ := \Posit32::FractionSizeWithoutSignCheck().2._State_0\;
                \Posit32::FractionSizeWithoutSignCheck().2.num\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().2.return.0\ := to_unsigned(0, 8);
                \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().2.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.3\ := false;
            else 
                case \Posit32::FractionSizeWithoutSignCheck().2._State\ is 
                    when \Posit32::FractionSizeWithoutSignCheck().2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionSizeWithoutSignCheck().2._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck().2._State\ := \Posit32::FractionSizeWithoutSignCheck().2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionSizeWithoutSignCheck().2._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck().2._Finished\ <= true;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck().2._Finished\ <= false;
                            \Posit32::FractionSizeWithoutSignCheck().2._State\ := \Posit32::FractionSizeWithoutSignCheck().2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().2._State_2\ => 
                        \Posit32::FractionSizeWithoutSignCheck().2.this\ := \Posit32::FractionSizeWithoutSignCheck().2.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32 - (System.Int32)((System.Int32)((System.Int32)(Posit32.LengthOfRunOfBits (@this.PositBits, 31)) + 2) + 2));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::FractionSizeWithoutSignCheck().2.this\.\PositBits\;
                        \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::FractionSizeWithoutSignCheck().2._State\ := \Posit32::FractionSizeWithoutSignCheck().2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::FractionSizeWithoutSignCheck().2.return.0\ := \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit32::FractionSizeWithoutSignCheck().2.return.0\), 32)) + to_signed(2, 32), 32);
                            \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.1\ := SmartResize((\Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.0\) + to_signed(2, 32), 32);
                            \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.1\);
                            \Posit32::FractionSizeWithoutSignCheck().2.num\ := (\Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- int conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (num > 0) {
                            -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = num;
                            -- }
                            -- else {
                            -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = 0;
                            -- }
                            -- 
                            \Posit32::FractionSizeWithoutSignCheck().2._State\ := \Posit32::FractionSizeWithoutSignCheck().2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::FractionSizeWithoutSignCheck().2._State_4\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.3\ := \Posit32::FractionSizeWithoutSignCheck().2.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionSizeWithoutSignCheck().2._State_6\ and ends in state \Posit32::FractionSizeWithoutSignCheck().2._State_6\.
                        --     * The false branch starts in state \Posit32::FractionSizeWithoutSignCheck().2._State_7\ and ends in state \Posit32::FractionSizeWithoutSignCheck().2._State_7\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionSizeWithoutSignCheck().2._State_5\.

                        if (\Posit32::FractionSizeWithoutSignCheck().2.binaryOperationResult.3\) then 
                            \Posit32::FractionSizeWithoutSignCheck().2._State\ := \Posit32::FractionSizeWithoutSignCheck().2._State_6\;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck().2._State\ := \Posit32::FractionSizeWithoutSignCheck().2._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::FractionSizeWithoutSignCheck().2._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck().2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671);
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck().2.return\ <= unsigned((\Posit32::FractionSizeWithoutSignCheck().2.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\));
                        \Posit32::FractionSizeWithoutSignCheck().2._State\ := \Posit32::FractionSizeWithoutSignCheck().2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().2._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck().2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = num;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck().2.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\ := \Posit32::FractionSizeWithoutSignCheck().2.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck().2._State_4\.
                        if (\Posit32::FractionSizeWithoutSignCheck().2._State\ = \Posit32::FractionSizeWithoutSignCheck().2._State_6\) then 
                            \Posit32::FractionSizeWithoutSignCheck().2._State\ := \Posit32::FractionSizeWithoutSignCheck().2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck().2._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck().2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671 = 0;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck().2.conditionald7ac243f635bdf2cbd7df4de28525d3129c10fd3c3126ba54534613dcb7b9671\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck().2._State_4\.
                        if (\Posit32::FractionSizeWithoutSignCheck().2._State\ = \Posit32::FractionSizeWithoutSignCheck().2._State_7\) then 
                            \Posit32::FractionSizeWithoutSignCheck().2._State\ := \Posit32::FractionSizeWithoutSignCheck().2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().2 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).0 state machine start
    \Posit32::FractionSizeWithoutSignCheck(Byte).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).0._State\: \Posit32::FractionSizeWithoutSignCheck(Byte).0._States\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_0\;
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).0.lengthOfRunOfBits\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).0.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionSizeWithoutSignCheck(Byte).0._Finished\ <= false;
                \Posit32::FractionSizeWithoutSignCheck(Byte).0.return\ <= to_unsigned(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_0\;
                \Posit32::FractionSizeWithoutSignCheck(Byte).0.lengthOfRunOfBits\ := to_unsigned(0, 8);
                \Posit32::FractionSizeWithoutSignCheck(Byte).0.num\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).0.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.3\ := false;
            else 
                case \Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ is 
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).0._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).0._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).0._Finished\ <= true;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).0._Finished\ <= false;
                            \Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_2\ => 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0.this\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0.this.parameter.In\;
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0.lengthOfRunOfBits\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0.lengthOfRunOfBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32 - (System.Int32)((System.Int32)((System.Int32)(lengthOfRunOfBits) + 2) + 2));
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit32::FractionSizeWithoutSignCheck(Byte).0.lengthOfRunOfBits\), 32)) + to_signed(2, 32), 32);
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.1\ := SmartResize((\Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.0\) + to_signed(2, 32), 32);
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.1\);
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0.num\ := (\Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.2\);
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 0) {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = num;
                        -- }
                        -- else {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = 0;
                        -- }
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_3\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.3\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_5\ and ends in state \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_5\.
                        --     * The false branch starts in state \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_6\ and ends in state \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_6\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_4\.

                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).0.binaryOperationResult.3\) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_5\;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125);
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0.return\ <= unsigned((\Posit32::FractionSizeWithoutSignCheck(Byte).0.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\));
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = num;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_3\.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ = \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_5\) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = 0;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).0.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_3\.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ = \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_6\) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).0._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).1 state machine start
    \Posit32::FractionSizeWithoutSignCheck(Byte).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).1._State\: \Posit32::FractionSizeWithoutSignCheck(Byte).1._States\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_0\;
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).1.lengthOfRunOfBits\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).1.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).1.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionSizeWithoutSignCheck(Byte).1._Finished\ <= false;
                \Posit32::FractionSizeWithoutSignCheck(Byte).1.return\ <= to_unsigned(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_0\;
                \Posit32::FractionSizeWithoutSignCheck(Byte).1.lengthOfRunOfBits\ := to_unsigned(0, 8);
                \Posit32::FractionSizeWithoutSignCheck(Byte).1.num\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).1.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.3\ := false;
            else 
                case \Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ is 
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).1._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).1._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).1._Finished\ <= true;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).1._Finished\ <= false;
                            \Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_2\ => 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1.this\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1.this.parameter.In\;
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1.lengthOfRunOfBits\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1.lengthOfRunOfBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32 - (System.Int32)((System.Int32)((System.Int32)(lengthOfRunOfBits) + 2) + 2));
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit32::FractionSizeWithoutSignCheck(Byte).1.lengthOfRunOfBits\), 32)) + to_signed(2, 32), 32);
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.1\ := SmartResize((\Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.0\) + to_signed(2, 32), 32);
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.1\);
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1.num\ := (\Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.2\);
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 0) {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = num;
                        -- }
                        -- else {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = 0;
                        -- }
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_3\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.3\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_5\ and ends in state \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_5\.
                        --     * The false branch starts in state \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_6\ and ends in state \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_6\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_4\.

                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).1.binaryOperationResult.3\) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_5\;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125);
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1.return\ <= unsigned((\Posit32::FractionSizeWithoutSignCheck(Byte).1.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\));
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = num;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_3\.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ = \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_5\) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = 0;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).1.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_3\.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ = \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_6\) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).1._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).2 state machine start
    \Posit32::FractionSizeWithoutSignCheck(Byte).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).2._State\: \Posit32::FractionSizeWithoutSignCheck(Byte).2._States\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_0\;
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).2.lengthOfRunOfBits\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).2.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).2.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionSizeWithoutSignCheck(Byte).2._Finished\ <= false;
                \Posit32::FractionSizeWithoutSignCheck(Byte).2.return\ <= to_unsigned(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_0\;
                \Posit32::FractionSizeWithoutSignCheck(Byte).2.lengthOfRunOfBits\ := to_unsigned(0, 8);
                \Posit32::FractionSizeWithoutSignCheck(Byte).2.num\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).2.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\ := to_signed(0, 32);
                \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.3\ := false;
            else 
                case \Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ is 
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).2._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).2._Started\ = true) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).2._Finished\ <= true;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).2._Finished\ <= false;
                            \Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_2\ => 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2.this\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2.this.parameter.In\;
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2.lengthOfRunOfBits\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2.lengthOfRunOfBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32 - (System.Int32)((System.Int32)((System.Int32)(lengthOfRunOfBits) + 2) + 2));
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit32::FractionSizeWithoutSignCheck(Byte).2.lengthOfRunOfBits\), 32)) + to_signed(2, 32), 32);
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.1\ := SmartResize((\Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.0\) + to_signed(2, 32), 32);
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.1\);
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2.num\ := (\Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.2\);
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 0) {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = num;
                        -- }
                        -- else {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = 0;
                        -- }
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_3\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.3\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_5\ and ends in state \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_5\.
                        --     * The false branch starts in state \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_6\ and ends in state \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_6\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_4\.

                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).2.binaryOperationResult.3\) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_5\;
                        else 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125);
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2.return\ <= unsigned((\Posit32::FractionSizeWithoutSignCheck(Byte).2.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\));
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = num;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2.num\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_3\.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ = \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_5\) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125 = 0;
                        -- 
                        \Posit32::FractionSizeWithoutSignCheck(Byte).2.conditional2a50c664506816d40adfd538d04cc8496886175a43fc7cdb1dc5c5f3cedbe125\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_3\.
                        if (\Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ = \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_6\) then 
                            \Posit32::FractionSizeWithoutSignCheck(Byte).2._State\ := \Posit32::FractionSizeWithoutSignCheck(Byte).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte).2 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0 state machine start
    \Posit32::FractionWithHiddenBit().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionWithHiddenBit().0._State\: \Posit32::FractionWithHiddenBit().0._States\ := \Posit32::FractionWithHiddenBit().0._State_0\;
        Variable \Posit32::FractionWithHiddenBit().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionWithHiddenBit().0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.return.1\: boolean := false;
        Variable \Posit32::FractionWithHiddenBit().0.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::FractionWithHiddenBit().0.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionWithHiddenBit().0._Finished\ <= false;
                \Posit32::FractionWithHiddenBit().0.return\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_0\;
                \Posit32::FractionWithHiddenBit().0.num\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.num2\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.bits\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.return.0\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.return.1\ := false;
                \Posit32::FractionWithHiddenBit().0.return.2\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBit().0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBit().0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().0.binaryOperationResult.4\ := false;
                \Posit32::FractionWithHiddenBit().0.return.3\ := to_unsigned(0, 32);
            else 
                case \Posit32::FractionWithHiddenBit().0._State\ is 
                    when \Posit32::FractionWithHiddenBit().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionWithHiddenBit().0._Started\ = true) then 
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionWithHiddenBit().0._Started\ = true) then 
                            \Posit32::FractionWithHiddenBit().0._Finished\ <= true;
                        else 
                            \Posit32::FractionWithHiddenBit().0._Finished\ <= false;
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_2\ => 
                        \Posit32::FractionWithHiddenBit().0.this\ := \Posit32::FractionWithHiddenBit().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Lombiq.Arithmetics.Posit32.FractionSize (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().0.this\;
                        \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\ = \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().0.return.0\ := \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().return.0\;
                            \Posit32::FractionWithHiddenBit().0.num\ := \Posit32::FractionWithHiddenBit().0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                            -- 	num2 = @this.PositBits;
                            -- }
                            -- else {
                            -- 	num2 = Posit32.GetTwosComplement (@this.PositBits);
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                            \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().0.this\;
                            \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Started.0\ <= true;
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Started.0\ = \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().0.return.1\ := \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::FractionWithHiddenBit().0._State_6\ and ends in state \Posit32::FractionWithHiddenBit().0._State_6\.
                            --     * The false branch starts in state \Posit32::FractionWithHiddenBit().0._State_7\ and ends in state \Posit32::FractionWithHiddenBit().0._State_8\.
                            --     * Execution after either branch will continue in the following state: \Posit32::FractionWithHiddenBit().0._State_5\.

                            if (\Posit32::FractionWithHiddenBit().0.return.1\) then 
                                \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_6\;
                            else 
                                \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::FractionWithHiddenBit().0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- bits = num2 << (int)(32u - num) >> (int)(32u - num);
                        -- 
                        \Posit32::FractionWithHiddenBit().0.binaryOperationResult.0\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBit().0.num\);
                        \Posit32::FractionWithHiddenBit().0.binaryOperationResult.1\ := shift_left(\Posit32::FractionWithHiddenBit().0.num2\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBit().0.binaryOperationResult.0\), 5))));
                        \Posit32::FractionWithHiddenBit().0.binaryOperationResult.2\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBit().0.num\);
                        \Posit32::FractionWithHiddenBit().0.binaryOperationResult.3\ := shift_right(\Posit32::FractionWithHiddenBit().0.binaryOperationResult.1\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBit().0.binaryOperationResult.2\), 5) and "11111")));
                        \Posit32::FractionWithHiddenBit().0.bits\ := \Posit32::FractionWithHiddenBit().0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num == 0u) {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = 1u;
                        -- }
                        -- else {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                        -- }
                        -- 
                        \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::FractionWithHiddenBit().0._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::FractionWithHiddenBit().0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = @this.PositBits;
                        -- 
                        \Posit32::FractionWithHiddenBit().0.num2\ := \Posit32::FractionWithHiddenBit().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().0._State_4\.
                        if (\Posit32::FractionWithHiddenBit().0._State\ = \Posit32::FractionWithHiddenBit().0._State_6\) then 
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::FractionWithHiddenBit().0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().0.this\.\PositBits\;
                        \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().0.return.2\ := \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::FractionWithHiddenBit().0.num2\ := \Posit32::FractionWithHiddenBit().0.return.2\;
                            -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().0._State_4\.
                            if (\Posit32::FractionWithHiddenBit().0._State\ = \Posit32::FractionWithHiddenBit().0._State_8\) then 
                                \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionWithHiddenBit().0.binaryOperationResult.4\ := \Posit32::FractionWithHiddenBit().0.num\ = to_unsigned(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionWithHiddenBit().0._State_11\ and ends in state \Posit32::FractionWithHiddenBit().0._State_11\.
                        --     * The false branch starts in state \Posit32::FractionWithHiddenBit().0._State_12\ and ends in state \Posit32::FractionWithHiddenBit().0._State_13\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionWithHiddenBit().0._State_10\.

                        if (\Posit32::FractionWithHiddenBit().0.binaryOperationResult.4\) then 
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_11\;
                        else 
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::FractionWithHiddenBit().0._State_10\ => 
                        -- State after the if-else which was started in state \Posit32::FractionWithHiddenBit().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3;
                        -- 
                        \Posit32::FractionWithHiddenBit().0.return\ <= \Posit32::FractionWithHiddenBit().0.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\;
                        \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_11\ => 
                        -- True branch of the if-else started in state \Posit32::FractionWithHiddenBit().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = 1u;
                        -- 
                        \Posit32::FractionWithHiddenBit().0.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\ := to_unsigned(1, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().0._State_9\.
                        if (\Posit32::FractionWithHiddenBit().0._State\ = \Posit32::FractionWithHiddenBit().0._State_11\) then 
                            \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_12\ => 
                        -- False branch of the if-else started in state \Posit32::FractionWithHiddenBit().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().0.this\;
                        \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().0.bits\;
                        \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(\Posit32::FractionWithHiddenBit().0.num\, 16);
                        \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ = \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().0.return.3\ := \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).return.0\;
                            \Posit32::FractionWithHiddenBit().0.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\ := \Posit32::FractionWithHiddenBit().0.return.3\;
                            -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().0._State_9\.
                            if (\Posit32::FractionWithHiddenBit().0._State\ = \Posit32::FractionWithHiddenBit().0._State_13\) then 
                                \Posit32::FractionWithHiddenBit().0._State\ := \Posit32::FractionWithHiddenBit().0._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().1 state machine start
    \Posit32::FractionWithHiddenBit().1._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionWithHiddenBit().1._State\: \Posit32::FractionWithHiddenBit().1._States\ := \Posit32::FractionWithHiddenBit().1._State_0\;
        Variable \Posit32::FractionWithHiddenBit().1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionWithHiddenBit().1.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().1.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().1.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().1.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().1.return.1\: boolean := false;
        Variable \Posit32::FractionWithHiddenBit().1.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().1.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBit().1.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().1.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBit().1.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().1.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().1.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::FractionWithHiddenBit().1.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionWithHiddenBit().1._Finished\ <= false;
                \Posit32::FractionWithHiddenBit().1.return\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_0\;
                \Posit32::FractionWithHiddenBit().1.num\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().1.num2\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().1.bits\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().1.return.0\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().1.return.1\ := false;
                \Posit32::FractionWithHiddenBit().1.return.2\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().1.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBit().1.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().1.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBit().1.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().1.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().1.binaryOperationResult.4\ := false;
                \Posit32::FractionWithHiddenBit().1.return.3\ := to_unsigned(0, 32);
            else 
                case \Posit32::FractionWithHiddenBit().1._State\ is 
                    when \Posit32::FractionWithHiddenBit().1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionWithHiddenBit().1._Started\ = true) then 
                            \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionWithHiddenBit().1._Started\ = true) then 
                            \Posit32::FractionWithHiddenBit().1._Finished\ <= true;
                        else 
                            \Posit32::FractionWithHiddenBit().1._Finished\ <= false;
                            \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().1._State_2\ => 
                        \Posit32::FractionWithHiddenBit().1.this\ := \Posit32::FractionWithHiddenBit().1.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Lombiq.Arithmetics.Posit32.FractionSize (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize().this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().1.this\;
                        \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Started.0\ = \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().1.return.0\ := \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize().return.0\;
                            \Posit32::FractionWithHiddenBit().1.num\ := \Posit32::FractionWithHiddenBit().1.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                            -- 	num2 = @this.PositBits;
                            -- }
                            -- else {
                            -- 	num2 = Posit32.GetTwosComplement (@this.PositBits);
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                            \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().1.this\;
                            \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Started.0\ <= true;
                            \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().1._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Started.0\ = \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().1.return.1\ := \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::FractionWithHiddenBit().1._State_6\ and ends in state \Posit32::FractionWithHiddenBit().1._State_6\.
                            --     * The false branch starts in state \Posit32::FractionWithHiddenBit().1._State_7\ and ends in state \Posit32::FractionWithHiddenBit().1._State_8\.
                            --     * Execution after either branch will continue in the following state: \Posit32::FractionWithHiddenBit().1._State_5\.

                            if (\Posit32::FractionWithHiddenBit().1.return.1\) then 
                                \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_6\;
                            else 
                                \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().1._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::FractionWithHiddenBit().1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- bits = num2 << (int)(32u - num) >> (int)(32u - num);
                        -- 
                        \Posit32::FractionWithHiddenBit().1.binaryOperationResult.0\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBit().1.num\);
                        \Posit32::FractionWithHiddenBit().1.binaryOperationResult.1\ := shift_left(\Posit32::FractionWithHiddenBit().1.num2\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBit().1.binaryOperationResult.0\), 5))));
                        \Posit32::FractionWithHiddenBit().1.binaryOperationResult.2\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBit().1.num\);
                        \Posit32::FractionWithHiddenBit().1.binaryOperationResult.3\ := shift_right(\Posit32::FractionWithHiddenBit().1.binaryOperationResult.1\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBit().1.binaryOperationResult.2\), 5) and "11111")));
                        \Posit32::FractionWithHiddenBit().1.bits\ := \Posit32::FractionWithHiddenBit().1.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num == 0u) {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = 1u;
                        -- }
                        -- else {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                        -- }
                        -- 
                        \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::FractionWithHiddenBit().1._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::FractionWithHiddenBit().1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = @this.PositBits;
                        -- 
                        \Posit32::FractionWithHiddenBit().1.num2\ := \Posit32::FractionWithHiddenBit().1.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().1._State_4\.
                        if (\Posit32::FractionWithHiddenBit().1._State\ = \Posit32::FractionWithHiddenBit().1._State_6\) then 
                            \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().1._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::FractionWithHiddenBit().1._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().1.this\.\PositBits\;
                        \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().1._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().1.return.2\ := \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::FractionWithHiddenBit().1.num2\ := \Posit32::FractionWithHiddenBit().1.return.2\;
                            -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().1._State_4\.
                            if (\Posit32::FractionWithHiddenBit().1._State\ = \Posit32::FractionWithHiddenBit().1._State_8\) then 
                                \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().1._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionWithHiddenBit().1.binaryOperationResult.4\ := \Posit32::FractionWithHiddenBit().1.num\ = to_unsigned(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionWithHiddenBit().1._State_11\ and ends in state \Posit32::FractionWithHiddenBit().1._State_11\.
                        --     * The false branch starts in state \Posit32::FractionWithHiddenBit().1._State_12\ and ends in state \Posit32::FractionWithHiddenBit().1._State_13\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionWithHiddenBit().1._State_10\.

                        if (\Posit32::FractionWithHiddenBit().1.binaryOperationResult.4\) then 
                            \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_11\;
                        else 
                            \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::FractionWithHiddenBit().1._State_10\ => 
                        -- State after the if-else which was started in state \Posit32::FractionWithHiddenBit().1._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3;
                        -- 
                        \Posit32::FractionWithHiddenBit().1.return\ <= \Posit32::FractionWithHiddenBit().1.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\;
                        \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().1._State_11\ => 
                        -- True branch of the if-else started in state \Posit32::FractionWithHiddenBit().1._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = 1u;
                        -- 
                        \Posit32::FractionWithHiddenBit().1.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\ := to_unsigned(1, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().1._State_9\.
                        if (\Posit32::FractionWithHiddenBit().1._State\ = \Posit32::FractionWithHiddenBit().1._State_11\) then 
                            \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().1._State_12\ => 
                        -- False branch of the if-else started in state \Posit32::FractionWithHiddenBit().1._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().1.this\;
                        \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().1.bits\;
                        \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(\Posit32::FractionWithHiddenBit().1.num\, 16);
                        \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().1._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Started.0\ = \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().1.return.3\ := \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).return.0\;
                            \Posit32::FractionWithHiddenBit().1.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\ := \Posit32::FractionWithHiddenBit().1.return.3\;
                            -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().1._State_9\.
                            if (\Posit32::FractionWithHiddenBit().1._State\ = \Posit32::FractionWithHiddenBit().1._State_13\) then 
                                \Posit32::FractionWithHiddenBit().1._State\ := \Posit32::FractionWithHiddenBit().1._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().2 state machine start
    \Posit32::FractionWithHiddenBit().2._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionWithHiddenBit().2._State\: \Posit32::FractionWithHiddenBit().2._States\ := \Posit32::FractionWithHiddenBit().2._State_0\;
        Variable \Posit32::FractionWithHiddenBit().2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionWithHiddenBit().2.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().2.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().2.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().2.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().2.return.1\: boolean := false;
        Variable \Posit32::FractionWithHiddenBit().2.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().2.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBit().2.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().2.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBit().2.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().2.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBit().2.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::FractionWithHiddenBit().2.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionWithHiddenBit().2._Finished\ <= false;
                \Posit32::FractionWithHiddenBit().2.return\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_0\;
                \Posit32::FractionWithHiddenBit().2.num\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().2.num2\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().2.bits\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().2.return.0\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().2.return.1\ := false;
                \Posit32::FractionWithHiddenBit().2.return.2\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().2.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBit().2.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().2.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBit().2.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().2.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBit().2.binaryOperationResult.4\ := false;
                \Posit32::FractionWithHiddenBit().2.return.3\ := to_unsigned(0, 32);
            else 
                case \Posit32::FractionWithHiddenBit().2._State\ is 
                    when \Posit32::FractionWithHiddenBit().2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionWithHiddenBit().2._Started\ = true) then 
                            \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionWithHiddenBit().2._Started\ = true) then 
                            \Posit32::FractionWithHiddenBit().2._Finished\ <= true;
                        else 
                            \Posit32::FractionWithHiddenBit().2._Finished\ <= false;
                            \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().2._State_2\ => 
                        \Posit32::FractionWithHiddenBit().2.this\ := \Posit32::FractionWithHiddenBit().2.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Lombiq.Arithmetics.Posit32.FractionSize (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize().this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().2.this\;
                        \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize()
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Started.0\ = \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().2.return.0\ := \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize().return.0\;
                            \Posit32::FractionWithHiddenBit().2.num\ := \Posit32::FractionWithHiddenBit().2.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (Lombiq.Arithmetics.Posit32.IsPositive (@this)) {
                            -- 	num2 = @this.PositBits;
                            -- }
                            -- else {
                            -- 	num2 = Posit32.GetTwosComplement (@this.PositBits);
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                            \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().2.this\;
                            \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Started.0\ <= true;
                            \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().2._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Started.0\ = \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().2.return.1\ := \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::FractionWithHiddenBit().2._State_6\ and ends in state \Posit32::FractionWithHiddenBit().2._State_6\.
                            --     * The false branch starts in state \Posit32::FractionWithHiddenBit().2._State_7\ and ends in state \Posit32::FractionWithHiddenBit().2._State_8\.
                            --     * Execution after either branch will continue in the following state: \Posit32::FractionWithHiddenBit().2._State_5\.

                            if (\Posit32::FractionWithHiddenBit().2.return.1\) then 
                                \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_6\;
                            else 
                                \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().2._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::FractionWithHiddenBit().2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- bits = num2 << (int)(32u - num) >> (int)(32u - num);
                        -- 
                        \Posit32::FractionWithHiddenBit().2.binaryOperationResult.0\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBit().2.num\);
                        \Posit32::FractionWithHiddenBit().2.binaryOperationResult.1\ := shift_left(\Posit32::FractionWithHiddenBit().2.num2\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBit().2.binaryOperationResult.0\), 5))));
                        \Posit32::FractionWithHiddenBit().2.binaryOperationResult.2\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBit().2.num\);
                        \Posit32::FractionWithHiddenBit().2.binaryOperationResult.3\ := shift_right(\Posit32::FractionWithHiddenBit().2.binaryOperationResult.1\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBit().2.binaryOperationResult.2\), 5) and "11111")));
                        \Posit32::FractionWithHiddenBit().2.bits\ := \Posit32::FractionWithHiddenBit().2.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num == 0u) {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = 1u;
                        -- }
                        -- else {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                        -- }
                        -- 
                        \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::FractionWithHiddenBit().2._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::FractionWithHiddenBit().2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = @this.PositBits;
                        -- 
                        \Posit32::FractionWithHiddenBit().2.num2\ := \Posit32::FractionWithHiddenBit().2.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().2._State_4\.
                        if (\Posit32::FractionWithHiddenBit().2._State\ = \Posit32::FractionWithHiddenBit().2._State_6\) then 
                            \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().2._State_7\ => 
                        -- False branch of the if-else started in state \Posit32::FractionWithHiddenBit().2._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Posit32.GetTwosComplement (@this.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Posit32.GetTwosComplement (@this.PositBits);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().2.this\.\PositBits\;
                        \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().2._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32)
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Started.0\ = \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().2.return.2\ := \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32).return.0\;
                            \Posit32::FractionWithHiddenBit().2.num2\ := \Posit32::FractionWithHiddenBit().2.return.2\;
                            -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().2._State_4\.
                            if (\Posit32::FractionWithHiddenBit().2._State\ = \Posit32::FractionWithHiddenBit().2._State_8\) then 
                                \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().2._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::FractionWithHiddenBit().2.binaryOperationResult.4\ := \Posit32::FractionWithHiddenBit().2.num\ = to_unsigned(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::FractionWithHiddenBit().2._State_11\ and ends in state \Posit32::FractionWithHiddenBit().2._State_11\.
                        --     * The false branch starts in state \Posit32::FractionWithHiddenBit().2._State_12\ and ends in state \Posit32::FractionWithHiddenBit().2._State_13\.
                        --     * Execution after either branch will continue in the following state: \Posit32::FractionWithHiddenBit().2._State_10\.

                        if (\Posit32::FractionWithHiddenBit().2.binaryOperationResult.4\) then 
                            \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_11\;
                        else 
                            \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::FractionWithHiddenBit().2._State_10\ => 
                        -- State after the if-else which was started in state \Posit32::FractionWithHiddenBit().2._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- return conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3;
                        -- 
                        \Posit32::FractionWithHiddenBit().2.return\ <= \Posit32::FractionWithHiddenBit().2.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\;
                        \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().2._State_11\ => 
                        -- True branch of the if-else started in state \Posit32::FractionWithHiddenBit().2._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = 1u;
                        -- 
                        \Posit32::FractionWithHiddenBit().2.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\ := to_unsigned(1, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().2._State_9\.
                        if (\Posit32::FractionWithHiddenBit().2._State\ = \Posit32::FractionWithHiddenBit().2._State_11\) then 
                            \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().2._State_12\ => 
                        -- False branch of the if-else started in state \Posit32::FractionWithHiddenBit().2._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3 = Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().2.this\;
                        \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBit().2.bits\;
                        \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(\Posit32::FractionWithHiddenBit().2.num\, 16);
                        \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBit().2._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Started.0\ = \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBit().2.return.3\ := \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).return.0\;
                            \Posit32::FractionWithHiddenBit().2.conditional0994fe80d759efc0d8545994917aa8060a36714eeda7a8e74d997628ff998ab3\ := \Posit32::FractionWithHiddenBit().2.return.3\;
                            -- Going to the state after the if-else which was started in state \Posit32::FractionWithHiddenBit().2._State_9\.
                            if (\Posit32::FractionWithHiddenBit().2._State\ = \Posit32::FractionWithHiddenBit().2._State_13\) then 
                                \Posit32::FractionWithHiddenBit().2._State\ := \Posit32::FractionWithHiddenBit().2._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().2 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().0 state machine start
    \Posit32::FractionWithHiddenBitWithoutSignCheck().0._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State\: \Posit32::FractionWithHiddenBitWithoutSignCheck().0._States\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_0\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0._Finished\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_0\;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.num\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.bits\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return.0\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State\ is 
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().0._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().0._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0._Finished\ <= true;
                        else 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0._Finished\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_2\ => 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().0.this\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck()
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0.this\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck()
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ = \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return.0\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck().return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.num\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- bits = @this.PositBits << (int)(32u - num) >> (int)(32u - num);
                            -- 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.0\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBitWithoutSignCheck().0.num\);
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.1\ := shift_left(\Posit32::FractionWithHiddenBitWithoutSignCheck().0.this\.\PositBits\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.0\), 5))));
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.2\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBitWithoutSignCheck().0.num\);
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.3\ := shift_right(\Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.1\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.2\), 5) and "11111")));
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.bits\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- return Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0.this\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0.bits\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(\Posit32::FractionWithHiddenBitWithoutSignCheck().0.num\, 16);
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= true;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ = \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return.1\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return.1\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().1 state machine start
    \Posit32::FractionWithHiddenBitWithoutSignCheck().1._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State\: \Posit32::FractionWithHiddenBitWithoutSignCheck().1._States\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_0\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().1.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().1.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().1.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().1.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1._Finished\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.return\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_0\;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.num\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.bits\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.return.0\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.return.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State\ is 
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().1._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().1._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1._Finished\ <= true;
                        else 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1._Finished\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_2\ => 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().1.this\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck()
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().1.this\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck()
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Started.0\ = \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Finished.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.return.0\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck().return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.num\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- bits = @this.PositBits << (int)(32u - num) >> (int)(32u - num);
                            -- 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.0\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBitWithoutSignCheck().1.num\);
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.1\ := shift_left(\Posit32::FractionWithHiddenBitWithoutSignCheck().1.this\.\PositBits\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.0\), 5))));
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.2\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBitWithoutSignCheck().1.num\);
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.3\ := shift_right(\Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.1\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.2\), 5) and "11111")));
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.bits\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- return Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().1.this\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().1.bits\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(\Posit32::FractionWithHiddenBitWithoutSignCheck().1.num\, 16);
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= true;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Started.0\ = \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.return.1\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.return\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().1.return.1\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().1._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().2 state machine start
    \Posit32::FractionWithHiddenBitWithoutSignCheck().2._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State\: \Posit32::FractionWithHiddenBitWithoutSignCheck().2._States\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_0\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().2.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().2.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().2.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck().2.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2._Finished\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.return\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_0\;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.num\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.bits\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.return.0\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.return.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State\ is 
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().2._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().2._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2._Finished\ <= true;
                        else 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2._Finished\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_2\ => 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().2.this\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck()
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().2.this\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck()
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Started.0\ = \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Finished.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.return.0\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck().return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.num\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- bits = @this.PositBits << (int)(32u - num) >> (int)(32u - num);
                            -- 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.0\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBitWithoutSignCheck().2.num\);
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.1\ := shift_left(\Posit32::FractionWithHiddenBitWithoutSignCheck().2.this\.\PositBits\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.0\), 5))));
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.2\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBitWithoutSignCheck().2.num\);
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.3\ := shift_right(\Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.1\, to_integer(unsigned(SmartResize((\Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.2\), 5) and "11111")));
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.bits\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- return Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)num);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().2.this\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().2.bits\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(\Posit32::FractionWithHiddenBitWithoutSignCheck().2.num\, 16);
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= true;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Started.0\ = \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.return.1\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.return\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().2.return.1\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck().2._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().2 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).0 state machine start
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State\: \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._States\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_0\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.fractionSize\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._Finished\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.return\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_0\;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.fractionSize\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.num\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.bits\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.return.0\ := to_unsigned(0, 32);
            else 
                case \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State\ is 
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._Finished\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_2\ => 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.this\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.this.parameter.In\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.fractionSize\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.fractionSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32u - fractionSize);
                        -- 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.0\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.fractionSize\);
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.num\ := (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.0\);
                        -- The following section was transformed from the .NET statement below:
                        -- bits = @this.PositBits << num >> num;
                        -- 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.1\ := shift_left(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.this\.\PositBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.num\), 5))));
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.2\ := shift_right(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.1\, to_integer(unsigned(SmartResize(unsigned(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.num\), 5) and "11111")));
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.bits\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- return Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)fractionSize);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.this\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.bits\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.fractionSize\, 16);
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Started.0\ = \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.return.0\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.return\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).1 state machine start
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State\: \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._States\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_0\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.fractionSize\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._Finished\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.return\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_0\;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.fractionSize\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.num\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.bits\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.return.0\ := to_unsigned(0, 32);
            else 
                case \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State\ is 
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._Finished\ <= true;
                        else 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._Finished\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_2\ => 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.this\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.this.parameter.In\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.fractionSize\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.fractionSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32u - fractionSize);
                        -- 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.0\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.fractionSize\);
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.num\ := (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.0\);
                        -- The following section was transformed from the .NET statement below:
                        -- bits = @this.PositBits << num >> num;
                        -- 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.1\ := shift_left(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.this\.\PositBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.num\), 5))));
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.2\ := shift_right(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.1\, to_integer(unsigned(SmartResize(unsigned(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.num\), 5) and "11111")));
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.bits\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- return Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)fractionSize);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.this\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.bits\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.fractionSize\, 16);
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Started.0\ = \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.return.0\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.return\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).2 state machine start
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State\: \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._States\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_0\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.fractionSize\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._Finished\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.return\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_0\;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.fractionSize\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.num\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.bits\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.return.0\ := to_unsigned(0, 32);
            else 
                case \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State\ is 
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._Started\ = true) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._Finished\ <= true;
                        else 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._Finished\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_2\ => 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.this\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.this.parameter.In\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.fractionSize\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.fractionSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32u - fractionSize);
                        -- 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.0\ := signed(to_unsigned(32, 32) - \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.fractionSize\);
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.num\ := (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.0\);
                        -- The following section was transformed from the .NET statement below:
                        -- bits = @this.PositBits << num >> num;
                        -- 
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.1\ := shift_left(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.this\.\PositBits\, to_integer(unsigned(SmartResize(unsigned(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.num\), 5))));
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.2\ := shift_right(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.1\, to_integer(unsigned(SmartResize(unsigned(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.num\), 5) and "11111")));
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.bits\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- return Lombiq.Arithmetics.Posit32.SetOne (@this, bits, (ushort)fractionSize);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.this\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.bits\;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\ <= SmartResize(\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.fractionSize\, 16);
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= true;
                        \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                    when \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16)
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Started.0\ = \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Finished.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Started.0\ <= false;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.return.0\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.return\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.return.0\;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State\ := \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).2 state machine end


    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).0 state machine start
    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State\: \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._States\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State_0\;
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.regimeKValue\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.exponentValue\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.maximumExponentSize\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.binaryOperationResult.1\: signed(15 downto 0) := to_signed(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Finished\ <= false;
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.return\ <= to_signed(0, 16);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State_0\;
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.regimeKValue\ := to_signed(0, 8);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.exponentValue\ := to_unsigned(0, 32);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.maximumExponentSize\ := to_unsigned(0, 8);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.binaryOperationResult.0\ := to_signed(0, 64);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.binaryOperationResult.1\ := to_signed(0, 16);
            else 
                case \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State\ is 
                    when \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\ = true) then 
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\ = true) then 
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Finished\ <= true;
                        else 
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Finished\ <= false;
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State_2\ => 
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.regimeKValue\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.regimeKValue.parameter.In\;
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.exponentValue\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.exponentValue.parameter.In\;
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.maximumExponentSize\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.maximumExponentSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return (short)((long)((int)regimeKValue * 4) + (long)((ulong)exponentValue));
                        -- 
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.binaryOperationResult.0\ := SmartResize(SmartResize(\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.regimeKValue\, 32) * to_signed(4, 32), 64);
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.binaryOperationResult.1\ := SmartResize((\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.binaryOperationResult.0\) + signed((SmartResize(\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.exponentValue\, 64))), 16);
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.return\ <= (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.binaryOperationResult.1\);
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.4898
                end case;
            end if;
        end if;
    end process;
    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).0 state machine end


    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).1 state machine start
    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State\: \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._States\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State_0\;
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.regimeKValue\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.exponentValue\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.maximumExponentSize\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.binaryOperationResult.1\: signed(15 downto 0) := to_signed(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Finished\ <= false;
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.return\ <= to_signed(0, 16);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State_0\;
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.regimeKValue\ := to_signed(0, 8);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.exponentValue\ := to_unsigned(0, 32);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.maximumExponentSize\ := to_unsigned(0, 8);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.binaryOperationResult.0\ := to_signed(0, 64);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.binaryOperationResult.1\ := to_signed(0, 16);
            else 
                case \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State\ is 
                    when \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ = true) then 
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ = true) then 
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Finished\ <= true;
                        else 
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Finished\ <= false;
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State_2\ => 
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.regimeKValue\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.regimeKValue.parameter.In\;
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.exponentValue\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.exponentValue.parameter.In\;
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.maximumExponentSize\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.maximumExponentSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return (short)((long)((int)regimeKValue * 4) + (long)((ulong)exponentValue));
                        -- 
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.binaryOperationResult.0\ := SmartResize(SmartResize(\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.regimeKValue\, 32) * to_signed(4, 32), 64);
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.binaryOperationResult.1\ := SmartResize((\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.binaryOperationResult.0\) + signed((SmartResize(\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.exponentValue\, 64))), 16);
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.return\ <= (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.binaryOperationResult.1\);
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.4898
                end case;
            end if;
        end if;
    end process;
    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).1 state machine end


    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).2 state machine start
    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State\: \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._States\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State_0\;
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.regimeKValue\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.exponentValue\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.maximumExponentSize\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.binaryOperationResult.1\: signed(15 downto 0) := to_signed(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Finished\ <= false;
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.return\ <= to_signed(0, 16);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State_0\;
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.regimeKValue\ := to_signed(0, 8);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.exponentValue\ := to_unsigned(0, 32);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.maximumExponentSize\ := to_unsigned(0, 8);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.binaryOperationResult.0\ := to_signed(0, 64);
                \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.binaryOperationResult.1\ := to_signed(0, 16);
            else 
                case \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State\ is 
                    when \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ = true) then 
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ = true) then 
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Finished\ <= true;
                        else 
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Finished\ <= false;
                            \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State_2\ => 
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.regimeKValue\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.regimeKValue.parameter.In\;
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.exponentValue\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.exponentValue.parameter.In\;
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.maximumExponentSize\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.maximumExponentSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return (short)((long)((int)regimeKValue * 4) + (long)((ulong)exponentValue));
                        -- 
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.binaryOperationResult.0\ := SmartResize(SmartResize(\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.regimeKValue\, 32) * to_signed(4, 32), 64);
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.binaryOperationResult.1\ := SmartResize((\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.binaryOperationResult.0\) + signed((SmartResize(\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.exponentValue\, 64))), 16);
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.return\ <= (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.binaryOperationResult.1\);
                        \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State\ := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.4898
                end case;
            end if;
        end if;
    end process;
    -- System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte).2 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).0 state machine start
    \Posit32::GetMostSignificantOnePosition(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0._State\: \Posit32::GetMostSignificantOnePosition(UInt32).0._States\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_0\;
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\ <= false;
                \Posit32::GetMostSignificantOnePosition(UInt32).0.return\ <= to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_0\;
                \Posit32::GetMostSignificantOnePosition(UInt32).0.bits\ := to_unsigned(0, 32);
                \Posit32::GetMostSignificantOnePosition(UInt32).0.b\ := to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.0\ := false;
                \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.2\ := to_unsigned(0, 8);
            else 
                case \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ is 
                    when \Posit32::GetMostSignificantOnePosition(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\ <= false;
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).0._State_2\ => 
                        \Posit32::GetMostSignificantOnePosition(UInt32).0.bits\ := \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = 0;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt32).0.b\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- while (bits > 0u) {
                        -- 	bits = bits >> 1;
                        -- 	b = (System.Byte)((System.Int32)(b) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt32).0._State_2\.
                        -- The while loop's condition:
                        \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.0\ := \Posit32::GetMostSignificantOnePosition(UInt32).0.bits\ > to_unsigned(0, 32);
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits = bits >> 1;
                            -- 	b = (System.Byte)((System.Int32)(b) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits = bits >> 1;
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.1\ := shift_right(\Posit32::GetMostSignificantOnePosition(UInt32).0.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                            \Posit32::GetMostSignificantOnePosition(UInt32).0.bits\ := \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- b = (System.Byte)((System.Int32)(b) + 1);
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.2\ := SmartResize(unsigned(signed(SmartResize((\Posit32::GetMostSignificantOnePosition(UInt32).0.b\), 32)) + to_signed(1, 32)), 8);
                            \Posit32::GetMostSignificantOnePosition(UInt32).0.b\ := (\Posit32::GetMostSignificantOnePosition(UInt32).0.binaryOperationResult.2\);
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8297
                    when \Posit32::GetMostSignificantOnePosition(UInt32).0._State_4\ => 
                        -- State after the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return b;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt32).0.return\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.b\;
                        \Posit32::GetMostSignificantOnePosition(UInt32).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).0 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).1 state machine start
    \Posit32::GetMostSignificantOnePosition(UInt32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).1._State\: \Posit32::GetMostSignificantOnePosition(UInt32).1._States\ := \Posit32::GetMostSignificantOnePosition(UInt32).1._State_0\;
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).1.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).1.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\ <= false;
                \Posit32::GetMostSignificantOnePosition(UInt32).1.return\ <= to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt32).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).1._State_0\;
                \Posit32::GetMostSignificantOnePosition(UInt32).1.bits\ := to_unsigned(0, 32);
                \Posit32::GetMostSignificantOnePosition(UInt32).1.b\ := to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.0\ := false;
                \Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.2\ := to_unsigned(0, 8);
            else 
                case \Posit32::GetMostSignificantOnePosition(UInt32).1._State\ is 
                    when \Posit32::GetMostSignificantOnePosition(UInt32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt32).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\ <= true;
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\ <= false;
                            \Posit32::GetMostSignificantOnePosition(UInt32).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).1._State_2\ => 
                        \Posit32::GetMostSignificantOnePosition(UInt32).1.bits\ := \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = 0;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt32).1.b\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- while (bits > 0u) {
                        -- 	bits = bits >> 1;
                        -- 	b = (System.Byte)((System.Int32)(b) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::GetMostSignificantOnePosition(UInt32).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).1._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt32).1._State_2\.
                        -- The while loop's condition:
                        \Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.0\ := \Posit32::GetMostSignificantOnePosition(UInt32).1.bits\ > to_unsigned(0, 32);
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits = bits >> 1;
                            -- 	b = (System.Byte)((System.Int32)(b) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits = bits >> 1;
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.1\ := shift_right(\Posit32::GetMostSignificantOnePosition(UInt32).1.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                            \Posit32::GetMostSignificantOnePosition(UInt32).1.bits\ := \Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- b = (System.Byte)((System.Int32)(b) + 1);
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.2\ := SmartResize(unsigned(signed(SmartResize((\Posit32::GetMostSignificantOnePosition(UInt32).1.b\), 32)) + to_signed(1, 32)), 8);
                            \Posit32::GetMostSignificantOnePosition(UInt32).1.b\ := (\Posit32::GetMostSignificantOnePosition(UInt32).1.binaryOperationResult.2\);
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt32).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8297
                    when \Posit32::GetMostSignificantOnePosition(UInt32).1._State_4\ => 
                        -- State after the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt32).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return b;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt32).1.return\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.b\;
                        \Posit32::GetMostSignificantOnePosition(UInt32).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).1 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).2 state machine start
    \Posit32::GetMostSignificantOnePosition(UInt32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).2._State\: \Posit32::GetMostSignificantOnePosition(UInt32).2._States\ := \Posit32::GetMostSignificantOnePosition(UInt32).2._State_0\;
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).2.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).2.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\ <= false;
                \Posit32::GetMostSignificantOnePosition(UInt32).2.return\ <= to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt32).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).2._State_0\;
                \Posit32::GetMostSignificantOnePosition(UInt32).2.bits\ := to_unsigned(0, 32);
                \Posit32::GetMostSignificantOnePosition(UInt32).2.b\ := to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.0\ := false;
                \Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.2\ := to_unsigned(0, 8);
            else 
                case \Posit32::GetMostSignificantOnePosition(UInt32).2._State\ is 
                    when \Posit32::GetMostSignificantOnePosition(UInt32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt32).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\ <= true;
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\ <= false;
                            \Posit32::GetMostSignificantOnePosition(UInt32).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).2._State_2\ => 
                        \Posit32::GetMostSignificantOnePosition(UInt32).2.bits\ := \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = 0;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt32).2.b\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- while (bits > 0u) {
                        -- 	bits = bits >> 1;
                        -- 	b = (System.Byte)((System.Int32)(b) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::GetMostSignificantOnePosition(UInt32).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt32).2._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt32).2._State_2\.
                        -- The while loop's condition:
                        \Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.0\ := \Posit32::GetMostSignificantOnePosition(UInt32).2.bits\ > to_unsigned(0, 32);
                        if (\Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits = bits >> 1;
                            -- 	b = (System.Byte)((System.Int32)(b) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits = bits >> 1;
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.1\ := shift_right(\Posit32::GetMostSignificantOnePosition(UInt32).2.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                            \Posit32::GetMostSignificantOnePosition(UInt32).2.bits\ := \Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- b = (System.Byte)((System.Int32)(b) + 1);
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.2\ := SmartResize(unsigned(signed(SmartResize((\Posit32::GetMostSignificantOnePosition(UInt32).2.b\), 32)) + to_signed(1, 32)), 8);
                            \Posit32::GetMostSignificantOnePosition(UInt32).2.b\ := (\Posit32::GetMostSignificantOnePosition(UInt32).2.binaryOperationResult.2\);
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt32).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8297
                    when \Posit32::GetMostSignificantOnePosition(UInt32).2._State_4\ => 
                        -- State after the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt32).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return b;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt32).2.return\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.b\;
                        \Posit32::GetMostSignificantOnePosition(UInt32).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt32).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32).2 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).0 state machine start
    \Posit32::GetMostSignificantOnePosition(UInt64).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).0._State\: \Posit32::GetMostSignificantOnePosition(UInt64).0._States\ := \Posit32::GetMostSignificantOnePosition(UInt64).0._State_0\;
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).0.bits\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.1\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetMostSignificantOnePosition(UInt64).0._Finished\ <= false;
                \Posit32::GetMostSignificantOnePosition(UInt64).0.return\ <= to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt64).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).0._State_0\;
                \Posit32::GetMostSignificantOnePosition(UInt64).0.bits\ := to_unsigned(0, 64);
                \Posit32::GetMostSignificantOnePosition(UInt64).0.b\ := to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.0\ := false;
                \Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.1\ := to_unsigned(0, 64);
                \Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.2\ := to_unsigned(0, 8);
            else 
                case \Posit32::GetMostSignificantOnePosition(UInt64).0._State\ is 
                    when \Posit32::GetMostSignificantOnePosition(UInt64).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetMostSignificantOnePosition(UInt64).0._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt64).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt64).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetMostSignificantOnePosition(UInt64).0._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt64).0._Finished\ <= true;
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt64).0._Finished\ <= false;
                            \Posit32::GetMostSignificantOnePosition(UInt64).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt64).0._State_2\ => 
                        \Posit32::GetMostSignificantOnePosition(UInt64).0.bits\ := \Posit32::GetMostSignificantOnePosition(UInt64).0.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = 0;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt64).0.b\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- while (bits > 0uL) {
                        -- 	bits = bits >> 1;
                        -- 	b = (System.Byte)((System.Int32)(b) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::GetMostSignificantOnePosition(UInt64).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt64).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt64).0._State_2\.
                        -- The while loop's condition:
                        \Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.0\ := \Posit32::GetMostSignificantOnePosition(UInt64).0.bits\ > to_unsigned(0, 64);
                        if (\Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits = bits >> 1;
                            -- 	b = (System.Byte)((System.Int32)(b) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits = bits >> 1;
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.1\ := SmartResize(shift_right(\Posit32::GetMostSignificantOnePosition(UInt64).0.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 6) and "111111"))), 64);
                            \Posit32::GetMostSignificantOnePosition(UInt64).0.bits\ := \Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- b = (System.Byte)((System.Int32)(b) + 1);
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.2\ := SmartResize(unsigned(signed(SmartResize((\Posit32::GetMostSignificantOnePosition(UInt64).0.b\), 32)) + to_signed(1, 32)), 8);
                            \Posit32::GetMostSignificantOnePosition(UInt64).0.b\ := (\Posit32::GetMostSignificantOnePosition(UInt64).0.binaryOperationResult.2\);
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt64).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8889
                    when \Posit32::GetMostSignificantOnePosition(UInt64).0._State_4\ => 
                        -- State after the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt64).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return b;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt64).0.return\ <= \Posit32::GetMostSignificantOnePosition(UInt64).0.b\;
                        \Posit32::GetMostSignificantOnePosition(UInt64).0._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).0 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).1 state machine start
    \Posit32::GetMostSignificantOnePosition(UInt64).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).1._State\: \Posit32::GetMostSignificantOnePosition(UInt64).1._States\ := \Posit32::GetMostSignificantOnePosition(UInt64).1._State_0\;
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).1.bits\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).1.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.1\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetMostSignificantOnePosition(UInt64).1._Finished\ <= false;
                \Posit32::GetMostSignificantOnePosition(UInt64).1.return\ <= to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt64).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).1._State_0\;
                \Posit32::GetMostSignificantOnePosition(UInt64).1.bits\ := to_unsigned(0, 64);
                \Posit32::GetMostSignificantOnePosition(UInt64).1.b\ := to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.0\ := false;
                \Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.1\ := to_unsigned(0, 64);
                \Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.2\ := to_unsigned(0, 8);
            else 
                case \Posit32::GetMostSignificantOnePosition(UInt64).1._State\ is 
                    when \Posit32::GetMostSignificantOnePosition(UInt64).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetMostSignificantOnePosition(UInt64).1._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt64).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt64).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetMostSignificantOnePosition(UInt64).1._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt64).1._Finished\ <= true;
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt64).1._Finished\ <= false;
                            \Posit32::GetMostSignificantOnePosition(UInt64).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt64).1._State_2\ => 
                        \Posit32::GetMostSignificantOnePosition(UInt64).1.bits\ := \Posit32::GetMostSignificantOnePosition(UInt64).1.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = 0;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt64).1.b\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- while (bits > 0uL) {
                        -- 	bits = bits >> 1;
                        -- 	b = (System.Byte)((System.Int32)(b) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::GetMostSignificantOnePosition(UInt64).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt64).1._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt64).1._State_2\.
                        -- The while loop's condition:
                        \Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.0\ := \Posit32::GetMostSignificantOnePosition(UInt64).1.bits\ > to_unsigned(0, 64);
                        if (\Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits = bits >> 1;
                            -- 	b = (System.Byte)((System.Int32)(b) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits = bits >> 1;
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.1\ := SmartResize(shift_right(\Posit32::GetMostSignificantOnePosition(UInt64).1.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 6) and "111111"))), 64);
                            \Posit32::GetMostSignificantOnePosition(UInt64).1.bits\ := \Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- b = (System.Byte)((System.Int32)(b) + 1);
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.2\ := SmartResize(unsigned(signed(SmartResize((\Posit32::GetMostSignificantOnePosition(UInt64).1.b\), 32)) + to_signed(1, 32)), 8);
                            \Posit32::GetMostSignificantOnePosition(UInt64).1.b\ := (\Posit32::GetMostSignificantOnePosition(UInt64).1.binaryOperationResult.2\);
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt64).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8889
                    when \Posit32::GetMostSignificantOnePosition(UInt64).1._State_4\ => 
                        -- State after the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt64).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return b;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt64).1.return\ <= \Posit32::GetMostSignificantOnePosition(UInt64).1.b\;
                        \Posit32::GetMostSignificantOnePosition(UInt64).1._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).1 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).2 state machine start
    \Posit32::GetMostSignificantOnePosition(UInt64).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).2._State\: \Posit32::GetMostSignificantOnePosition(UInt64).2._States\ := \Posit32::GetMostSignificantOnePosition(UInt64).2._State_0\;
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).2.bits\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).2.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.1\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.2\: unsigned(7 downto 0) := to_unsigned(0, 8);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetMostSignificantOnePosition(UInt64).2._Finished\ <= false;
                \Posit32::GetMostSignificantOnePosition(UInt64).2.return\ <= to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt64).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).2._State_0\;
                \Posit32::GetMostSignificantOnePosition(UInt64).2.bits\ := to_unsigned(0, 64);
                \Posit32::GetMostSignificantOnePosition(UInt64).2.b\ := to_unsigned(0, 8);
                \Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.0\ := false;
                \Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.1\ := to_unsigned(0, 64);
                \Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.2\ := to_unsigned(0, 8);
            else 
                case \Posit32::GetMostSignificantOnePosition(UInt64).2._State\ is 
                    when \Posit32::GetMostSignificantOnePosition(UInt64).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetMostSignificantOnePosition(UInt64).2._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt64).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt64).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetMostSignificantOnePosition(UInt64).2._Started\ = true) then 
                            \Posit32::GetMostSignificantOnePosition(UInt64).2._Finished\ <= true;
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt64).2._Finished\ <= false;
                            \Posit32::GetMostSignificantOnePosition(UInt64).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt64).2._State_2\ => 
                        \Posit32::GetMostSignificantOnePosition(UInt64).2.bits\ := \Posit32::GetMostSignificantOnePosition(UInt64).2.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = 0;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt64).2.b\ := to_unsigned(0, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- while (bits > 0uL) {
                        -- 	bits = bits >> 1;
                        -- 	b = (System.Byte)((System.Int32)(b) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::GetMostSignificantOnePosition(UInt64).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetMostSignificantOnePosition(UInt64).2._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt64).2._State_2\.
                        -- The while loop's condition:
                        \Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.0\ := \Posit32::GetMostSignificantOnePosition(UInt64).2.bits\ > to_unsigned(0, 64);
                        if (\Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	bits = bits >> 1;
                            -- 	b = (System.Byte)((System.Int32)(b) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- bits = bits >> 1;
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.1\ := SmartResize(shift_right(\Posit32::GetMostSignificantOnePosition(UInt64).2.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 6) and "111111"))), 64);
                            \Posit32::GetMostSignificantOnePosition(UInt64).2.bits\ := \Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- b = (System.Byte)((System.Int32)(b) + 1);
                            -- 
                            \Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.2\ := SmartResize(unsigned(signed(SmartResize((\Posit32::GetMostSignificantOnePosition(UInt64).2.b\), 32)) + to_signed(1, 32)), 8);
                            \Posit32::GetMostSignificantOnePosition(UInt64).2.b\ := (\Posit32::GetMostSignificantOnePosition(UInt64).2.binaryOperationResult.2\);
                        else 
                            \Posit32::GetMostSignificantOnePosition(UInt64).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8889
                    when \Posit32::GetMostSignificantOnePosition(UInt64).2._State_4\ => 
                        -- State after the while loop which was started in state \Posit32::GetMostSignificantOnePosition(UInt64).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return b;
                        -- 
                        \Posit32::GetMostSignificantOnePosition(UInt64).2.return\ <= \Posit32::GetMostSignificantOnePosition(UInt64).2.b\;
                        \Posit32::GetMostSignificantOnePosition(UInt64).2._State\ := \Posit32::GetMostSignificantOnePosition(UInt64).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64).2 state machine end


    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::Abs(Lombiq.Arithmetics.Posit32).0 state machine start
    \Posit32::Abs(Posit32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::Abs(Posit32).0._State\: \Posit32::Abs(Posit32).0._States\ := \Posit32::Abs(Posit32).0._State_0\;
        Variable \Posit32::Abs(Posit32).0.input\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::Abs(Posit32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::Abs(Posit32).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::Abs(Posit32).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::Abs(Posit32).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::Abs(Posit32).0.object1cc97102e4f7da13ed25dd34fdba4382d50d51e75fcb997eb90ee645b6ace470\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::Abs(Posit32).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::Abs(Posit32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::Abs(Posit32).0._Finished\ <= false;
                \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= false;
                \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                \Posit32::Abs(Posit32).0._State\ := \Posit32::Abs(Posit32).0._State_0\;
                \Posit32::Abs(Posit32).0.num\ := to_unsigned(0, 32);
                \Posit32::Abs(Posit32).0.num2\ := to_unsigned(0, 32);
                \Posit32::Abs(Posit32).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::Abs(Posit32).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::Abs(Posit32).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::Abs(Posit32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
            else 
                case \Posit32::Abs(Posit32).0._State\ is 
                    when \Posit32::Abs(Posit32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::Abs(Posit32).0._Started\ = true) then 
                            \Posit32::Abs(Posit32).0._State\ := \Posit32::Abs(Posit32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::Abs(Posit32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::Abs(Posit32).0._Started\ = true) then 
                            \Posit32::Abs(Posit32).0._Finished\ <= true;
                        else 
                            \Posit32::Abs(Posit32).0._Finished\ <= false;
                            \Posit32::Abs(Posit32).0._State\ := \Posit32::Abs(Posit32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::Abs(Posit32).0._State_2\ => 
                        \Posit32::Abs(Posit32).0.input\ := \Posit32::Abs(Posit32).0.input.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = input.PositBits >> 31;
                        -- 
                        \Posit32::Abs(Posit32).0.binaryOperationResult.0\ := shift_right(\Posit32::Abs(Posit32).0.input\.\PositBits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Posit32::Abs(Posit32).0.num\ := \Posit32::Abs(Posit32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0u - num;
                        -- 
                        \Posit32::Abs(Posit32).0.binaryOperationResult.1\ := to_unsigned(0, 32) - \Posit32::Abs(Posit32).0.num\;
                        \Posit32::Abs(Posit32).0.num2\ := \Posit32::Abs(Posit32).0.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 object1cc97102e4f7da13ed25dd34fdba4382d50d51e75fcb997eb90ee645b6ace470;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object1cc97102e4f7da13ed25dd34fdba4382d50d51e75fcb997eb90ee645b6ace470 = new Posit32 (input.PositBits ^ num2 + num, true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::Abs(Posit32).0.object1cc97102e4f7da13ed25dd34fdba4382d50d51e75fcb997eb90ee645b6ace470\.\IsNull\ := false;
                        \Posit32::Abs(Posit32).0.object1cc97102e4f7da13ed25dd34fdba4382d50d51e75fcb997eb90ee645b6ace470\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        \Posit32::Abs(Posit32).0.binaryOperationResult.2\ := \Posit32::Abs(Posit32).0.input\.\PositBits\ xor \Posit32::Abs(Posit32).0.num2\;
                        \Posit32::Abs(Posit32).0._State\ := \Posit32::Abs(Posit32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.6928
                    when \Posit32::Abs(Posit32).0._State_3\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::Abs(Posit32).0.binaryOperationResult.3\ := \Posit32::Abs(Posit32).0.binaryOperationResult.2\ + \Posit32::Abs(Posit32).0.num\;
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::Abs(Posit32).0.object1cc97102e4f7da13ed25dd34fdba4382d50d51e75fcb997eb90ee645b6ace470\;
                        \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32::Abs(Posit32).0.binaryOperationResult.3\;
                        \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                        \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                        \Posit32::Abs(Posit32).0._State\ := \Posit32::Abs(Posit32).0._State_4\;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::Abs(Posit32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::Abs(Posit32).0.object1cc97102e4f7da13ed25dd34fdba4382d50d51e75fcb997eb90ee645b6ace470\ := \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return object1cc97102e4f7da13ed25dd34fdba4382d50d51e75fcb997eb90ee645b6ace470;
                            -- 
                            \Posit32::Abs(Posit32).0.return\ <= \Posit32::Abs(Posit32).0.object1cc97102e4f7da13ed25dd34fdba4382d50d51e75fcb997eb90ee645b6ace470\;
                            \Posit32::Abs(Posit32).0._State\ := \Posit32::Abs(Posit32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::Abs(Lombiq.Arithmetics.Posit32).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).0 state machine start
    \Posit32::SetOne(UInt32,UInt16).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::SetOne(UInt32,UInt16).0._State\: \Posit32::SetOne(UInt32,UInt16).0._States\ := \Posit32::SetOne(UInt32,UInt16).0._State_0\;
        Variable \Posit32::SetOne(UInt32,UInt16).0.this\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::SetOne(UInt32,UInt16).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::SetOne(UInt32,UInt16).0.index\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::SetOne(UInt32,UInt16).0._Finished\ <= false;
                \Posit32::SetOne(UInt32,UInt16).0.return\ <= to_unsigned(0, 32);
                \Posit32::SetOne(UInt32,UInt16).0._State\ := \Posit32::SetOne(UInt32,UInt16).0._State_0\;
                \Posit32::SetOne(UInt32,UInt16).0.bits\ := to_unsigned(0, 32);
                \Posit32::SetOne(UInt32,UInt16).0.index\ := to_unsigned(0, 16);
                \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::SetOne(UInt32,UInt16).0._State\ is 
                    when \Posit32::SetOne(UInt32,UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::SetOne(UInt32,UInt16).0._Started\ = true) then 
                            \Posit32::SetOne(UInt32,UInt16).0._State\ := \Posit32::SetOne(UInt32,UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetOne(UInt32,UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::SetOne(UInt32,UInt16).0._Started\ = true) then 
                            \Posit32::SetOne(UInt32,UInt16).0._Finished\ <= true;
                        else 
                            \Posit32::SetOne(UInt32,UInt16).0._Finished\ <= false;
                            \Posit32::SetOne(UInt32,UInt16).0._State\ := \Posit32::SetOne(UInt32,UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetOne(UInt32,UInt16).0._State_2\ => 
                        \Posit32::SetOne(UInt32,UInt16).0.this\ := \Posit32::SetOne(UInt32,UInt16).0.this.parameter.In\;
                        \Posit32::SetOne(UInt32,UInt16).0.bits\ := \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\;
                        \Posit32::SetOne(UInt32,UInt16).0.index\ := \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return bits | 1u << (int)index;
                        -- 
                        \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.0\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\Posit32::SetOne(UInt32,UInt16).0.index\, 32)), 5))));
                        \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.1\ := \Posit32::SetOne(UInt32,UInt16).0.bits\ or \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.0\;
                        \Posit32::SetOne(UInt32,UInt16).0.return\ <= \Posit32::SetOne(UInt32,UInt16).0.binaryOperationResult.1\;
                        \Posit32::SetOne(UInt32,UInt16).0._State\ := \Posit32::SetOne(UInt32,UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.2386
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).0 state machine start
    \Posit32::SetZero(UInt32,UInt16).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::SetZero(UInt32,UInt16).0._State\: \Posit32::SetZero(UInt32,UInt16).0._States\ := \Posit32::SetZero(UInt32,UInt16).0._State_0\;
        Variable \Posit32::SetZero(UInt32,UInt16).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::SetZero(UInt32,UInt16).0.index\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::SetZero(UInt32,UInt16).0._Finished\ <= false;
                \Posit32::SetZero(UInt32,UInt16).0.return\ <= to_unsigned(0, 32);
                \Posit32::SetZero(UInt32,UInt16).0._State\ := \Posit32::SetZero(UInt32,UInt16).0._State_0\;
                \Posit32::SetZero(UInt32,UInt16).0.bits\ := to_unsigned(0, 32);
                \Posit32::SetZero(UInt32,UInt16).0.index\ := to_unsigned(0, 16);
                \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::SetZero(UInt32,UInt16).0._State\ is 
                    when \Posit32::SetZero(UInt32,UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::SetZero(UInt32,UInt16).0._Started\ = true) then 
                            \Posit32::SetZero(UInt32,UInt16).0._State\ := \Posit32::SetZero(UInt32,UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetZero(UInt32,UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::SetZero(UInt32,UInt16).0._Started\ = true) then 
                            \Posit32::SetZero(UInt32,UInt16).0._Finished\ <= true;
                        else 
                            \Posit32::SetZero(UInt32,UInt16).0._Finished\ <= false;
                            \Posit32::SetZero(UInt32,UInt16).0._State\ := \Posit32::SetZero(UInt32,UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetZero(UInt32,UInt16).0._State_2\ => 
                        \Posit32::SetZero(UInt32,UInt16).0.bits\ := \Posit32::SetZero(UInt32,UInt16).0.bits.parameter.In\;
                        \Posit32::SetZero(UInt32,UInt16).0.index\ := \Posit32::SetZero(UInt32,UInt16).0.index.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return bits & ~1u << (int)index;
                        -- 
                        \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.0\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\Posit32::SetZero(UInt32,UInt16).0.index\, 32)), 5))));
                        \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.1\ := \Posit32::SetZero(UInt32,UInt16).0.bits\ and not(\Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.0\);
                        \Posit32::SetZero(UInt32,UInt16).0.return\ <= \Posit32::SetZero(UInt32,UInt16).0.binaryOperationResult.1\;
                        \Posit32::SetZero(UInt32,UInt16).0._State\ := \Posit32::SetZero(UInt32,UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).1 state machine start
    \Posit32::SetZero(UInt32,UInt16).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::SetZero(UInt32,UInt16).1._State\: \Posit32::SetZero(UInt32,UInt16).1._States\ := \Posit32::SetZero(UInt32,UInt16).1._State_0\;
        Variable \Posit32::SetZero(UInt32,UInt16).1.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::SetZero(UInt32,UInt16).1.index\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit32::SetZero(UInt32,UInt16).1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::SetZero(UInt32,UInt16).1.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::SetZero(UInt32,UInt16).1._Finished\ <= false;
                \Posit32::SetZero(UInt32,UInt16).1.return\ <= to_unsigned(0, 32);
                \Posit32::SetZero(UInt32,UInt16).1._State\ := \Posit32::SetZero(UInt32,UInt16).1._State_0\;
                \Posit32::SetZero(UInt32,UInt16).1.bits\ := to_unsigned(0, 32);
                \Posit32::SetZero(UInt32,UInt16).1.index\ := to_unsigned(0, 16);
                \Posit32::SetZero(UInt32,UInt16).1.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::SetZero(UInt32,UInt16).1.binaryOperationResult.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::SetZero(UInt32,UInt16).1._State\ is 
                    when \Posit32::SetZero(UInt32,UInt16).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::SetZero(UInt32,UInt16).1._Started\ = true) then 
                            \Posit32::SetZero(UInt32,UInt16).1._State\ := \Posit32::SetZero(UInt32,UInt16).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetZero(UInt32,UInt16).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::SetZero(UInt32,UInt16).1._Started\ = true) then 
                            \Posit32::SetZero(UInt32,UInt16).1._Finished\ <= true;
                        else 
                            \Posit32::SetZero(UInt32,UInt16).1._Finished\ <= false;
                            \Posit32::SetZero(UInt32,UInt16).1._State\ := \Posit32::SetZero(UInt32,UInt16).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetZero(UInt32,UInt16).1._State_2\ => 
                        \Posit32::SetZero(UInt32,UInt16).1.bits\ := \Posit32::SetZero(UInt32,UInt16).1.bits.parameter.In\;
                        \Posit32::SetZero(UInt32,UInt16).1.index\ := \Posit32::SetZero(UInt32,UInt16).1.index.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return bits & ~1u << (int)index;
                        -- 
                        \Posit32::SetZero(UInt32,UInt16).1.binaryOperationResult.0\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\Posit32::SetZero(UInt32,UInt16).1.index\, 32)), 5))));
                        \Posit32::SetZero(UInt32,UInt16).1.binaryOperationResult.1\ := \Posit32::SetZero(UInt32,UInt16).1.bits\ and not(\Posit32::SetZero(UInt32,UInt16).1.binaryOperationResult.0\);
                        \Posit32::SetZero(UInt32,UInt16).1.return\ <= \Posit32::SetZero(UInt32,UInt16).1.binaryOperationResult.1\;
                        \Posit32::SetZero(UInt32,UInt16).1._State\ := \Posit32::SetZero(UInt32,UInt16).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).2 state machine start
    \Posit32::SetZero(UInt32,UInt16).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::SetZero(UInt32,UInt16).2._State\: \Posit32::SetZero(UInt32,UInt16).2._States\ := \Posit32::SetZero(UInt32,UInt16).2._State_0\;
        Variable \Posit32::SetZero(UInt32,UInt16).2.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::SetZero(UInt32,UInt16).2.index\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit32::SetZero(UInt32,UInt16).2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::SetZero(UInt32,UInt16).2.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::SetZero(UInt32,UInt16).2._Finished\ <= false;
                \Posit32::SetZero(UInt32,UInt16).2.return\ <= to_unsigned(0, 32);
                \Posit32::SetZero(UInt32,UInt16).2._State\ := \Posit32::SetZero(UInt32,UInt16).2._State_0\;
                \Posit32::SetZero(UInt32,UInt16).2.bits\ := to_unsigned(0, 32);
                \Posit32::SetZero(UInt32,UInt16).2.index\ := to_unsigned(0, 16);
                \Posit32::SetZero(UInt32,UInt16).2.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::SetZero(UInt32,UInt16).2.binaryOperationResult.1\ := to_unsigned(0, 32);
            else 
                case \Posit32::SetZero(UInt32,UInt16).2._State\ is 
                    when \Posit32::SetZero(UInt32,UInt16).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::SetZero(UInt32,UInt16).2._Started\ = true) then 
                            \Posit32::SetZero(UInt32,UInt16).2._State\ := \Posit32::SetZero(UInt32,UInt16).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetZero(UInt32,UInt16).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::SetZero(UInt32,UInt16).2._Started\ = true) then 
                            \Posit32::SetZero(UInt32,UInt16).2._Finished\ <= true;
                        else 
                            \Posit32::SetZero(UInt32,UInt16).2._Finished\ <= false;
                            \Posit32::SetZero(UInt32,UInt16).2._State\ := \Posit32::SetZero(UInt32,UInt16).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::SetZero(UInt32,UInt16).2._State_2\ => 
                        \Posit32::SetZero(UInt32,UInt16).2.bits\ := \Posit32::SetZero(UInt32,UInt16).2.bits.parameter.In\;
                        \Posit32::SetZero(UInt32,UInt16).2.index\ := \Posit32::SetZero(UInt32,UInt16).2.index.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return bits & ~1u << (int)index;
                        -- 
                        \Posit32::SetZero(UInt32,UInt16).2.binaryOperationResult.0\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\Posit32::SetZero(UInt32,UInt16).2.index\, 32)), 5))));
                        \Posit32::SetZero(UInt32,UInt16).2.binaryOperationResult.1\ := \Posit32::SetZero(UInt32,UInt16).2.bits\ and not(\Posit32::SetZero(UInt32,UInt16).2.binaryOperationResult.0\);
                        \Posit32::SetZero(UInt32,UInt16).2.return\ <= \Posit32::SetZero(UInt32,UInt16).2.binaryOperationResult.1\;
                        \Posit32::SetZero(UInt32,UInt16).2._State\ := \Posit32::SetZero(UInt32,UInt16).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16).2 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).0 state machine start
    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\: \Posit32::LengthOfRunOfBits(UInt32,Byte).0._States\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_0\;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.i\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.flag\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.6\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.8\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\ <= false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\ <= to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_0\;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.i\ := to_signed(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.flag\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.4\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.6\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.8\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.9\ := to_signed(0, 32);
            else 
                case \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ is 
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ = true) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ = true) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\ <= true;
                        else 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\ <= false;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\ => 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\;
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int i;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\ := to_unsigned(1, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- bits = bits << 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.0\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = bits >> 31 & 1u;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.1\ := shift_right(\Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.2\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.1\ and to_unsigned(1, 32);
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- bits = bits << 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.3\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- i = 0;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.i\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (i < (int)startingPosition) {
                        -- 	flag = bits >> 31 != num;
                        -- 	if (flag) {
                        -- 		break;
                        -- 	}
                        -- 	bits = bits << 1;
                        -- 	b = (System.Byte)((System.Int32)(b) + 1);
                        -- 	i = i + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.5772
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\.
                        -- The while loop's condition:
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.4\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.i\ < signed(SmartResize(\Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition\, 32));
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag = bits >> 31 != num;
                            -- 	if (flag) {
                            -- 		break;
                            -- 	}
                            -- 	bits = bits << 1;
                            -- 	b = (System.Byte)((System.Int32)(b) + 1);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag = bits >> 31 != num;
                            -- 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.5\ := shift_right(\Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.6\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.5\ /= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.num\;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0.flag\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.6\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	break;
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_6\ and ends in state \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_6\.
                            --     * Execution after either branch will continue in the following state: \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_5\.

                            if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0.flag\) then 
                                \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_5\;
                            end if;
                        else 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7747
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_4\ => 
                        -- State after the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return b;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\;
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- bits = bits << 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.7\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- b = (System.Byte)((System.Int32)(b) + 1);
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.8\ := SmartResize(unsigned(signed(SmartResize((\Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\), 32)) + to_signed(1, 32)), 8);
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.b\ := (\Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.8\);
                        -- The following section was transformed from the .NET statement below:
                        -- i = i + 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.9\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.i\ + to_signed(1, 32);
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0.i\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0.binaryOperationResult.9\;
                        -- Returning to the repeated state of the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_2\ if the loop wasn't exited with a state change.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ = \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_5\) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	break;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- break;
                        -- 
                        -- Exiting the while loop with a break statement.
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_4\;
                        -- Going to the state after the if-else which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_3\.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ = \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_6\) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).0 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).1 state machine start
    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\: \Posit32::LengthOfRunOfBits(UInt32,Byte).1._States\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_0\;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.i\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.flag\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.6\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.8\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\ <= false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\ <= to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_0\;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.b\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.num\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.i\ := to_signed(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.flag\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.4\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.6\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.8\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.9\ := to_signed(0, 32);
            else 
                case \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ is 
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ = true) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ = true) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\ <= true;
                        else 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\ <= false;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_2\ => 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\;
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int i;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.b\ := to_unsigned(1, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- bits = bits << 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.0\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = bits >> 31 & 1u;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.1\ := shift_right(\Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.2\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.1\ and to_unsigned(1, 32);
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.num\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- bits = bits << 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.3\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- i = 0;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.i\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (i < (int)startingPosition) {
                        -- 	flag = bits >> 31 != num;
                        -- 	if (flag) {
                        -- 		break;
                        -- 	}
                        -- 	bits = bits << 1;
                        -- 	b = (System.Byte)((System.Int32)(b) + 1);
                        -- 	i = i + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.5772
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_2\.
                        -- The while loop's condition:
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.4\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.i\ < signed(SmartResize(\Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition\, 32));
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag = bits >> 31 != num;
                            -- 	if (flag) {
                            -- 		break;
                            -- 	}
                            -- 	bits = bits << 1;
                            -- 	b = (System.Byte)((System.Int32)(b) + 1);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag = bits >> 31 != num;
                            -- 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.5\ := shift_right(\Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.6\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.5\ /= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.num\;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).1.flag\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.6\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	break;
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_6\ and ends in state \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_6\.
                            --     * Execution after either branch will continue in the following state: \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_5\.

                            if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1.flag\) then 
                                \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_5\;
                            end if;
                        else 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7747
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_4\ => 
                        -- State after the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return b;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.b\;
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- bits = bits << 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.7\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- b = (System.Byte)((System.Int32)(b) + 1);
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.8\ := SmartResize(unsigned(signed(SmartResize((\Posit32::LengthOfRunOfBits(UInt32,Byte).1.b\), 32)) + to_signed(1, 32)), 8);
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.b\ := (\Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.8\);
                        -- The following section was transformed from the .NET statement below:
                        -- i = i + 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.9\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.i\ + to_signed(1, 32);
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1.i\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1.binaryOperationResult.9\;
                        -- Returning to the repeated state of the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_2\ if the loop wasn't exited with a state change.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ = \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_5\) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	break;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- break;
                        -- 
                        -- Exiting the while loop with a break statement.
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_4\;
                        -- Going to the state after the if-else which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_3\.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ = \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_6\) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).1 state machine end


    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).2 state machine start
    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\: \Posit32::LengthOfRunOfBits(UInt32,Byte).2._States\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_0\;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.i\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.flag\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.6\: boolean := false;
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.8\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\ <= false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\ <= to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_0\;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.b\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.num\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.i\ := to_signed(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.flag\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.4\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.6\ := false;
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.8\ := to_unsigned(0, 8);
                \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.9\ := to_signed(0, 32);
            else 
                case \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ is 
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ = true) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ = true) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\ <= true;
                        else 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\ <= false;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_2\ => 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\;
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int i;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- b = 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.b\ := to_unsigned(1, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- bits = bits << 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.0\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- num = bits >> 31 & 1u;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.1\ := shift_right(\Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.2\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.1\ and to_unsigned(1, 32);
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.num\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- bits = bits << 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.3\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- i = 0;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.i\ := to_signed(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- while (i < (int)startingPosition) {
                        -- 	flag = bits >> 31 != num;
                        -- 	if (flag) {
                        -- 		break;
                        -- 	}
                        -- 	bits = bits << 1;
                        -- 	b = (System.Byte)((System.Int32)(b) + 1);
                        -- 	i = i + 1;
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.5772
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_2\.
                        -- The while loop's condition:
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.4\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.i\ < signed(SmartResize(\Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition\, 32));
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag = bits >> 31 != num;
                            -- 	if (flag) {
                            -- 		break;
                            -- 	}
                            -- 	bits = bits << 1;
                            -- 	b = (System.Byte)((System.Int32)(b) + 1);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag = bits >> 31 != num;
                            -- 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.5\ := shift_right(\Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.6\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.5\ /= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.num\;
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).2.flag\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.6\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	break;
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_6\ and ends in state \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_6\.
                            --     * Execution after either branch will continue in the following state: \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_5\.

                            if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2.flag\) then 
                                \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_6\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_5\;
                            end if;
                        else 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7747
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_4\ => 
                        -- State after the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return b;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.b\;
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_5\ => 
                        -- State after the if-else which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- bits = bits << 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.7\ := shift_left(\Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- b = (System.Byte)((System.Int32)(b) + 1);
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.8\ := SmartResize(unsigned(signed(SmartResize((\Posit32::LengthOfRunOfBits(UInt32,Byte).2.b\), 32)) + to_signed(1, 32)), 8);
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.b\ := (\Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.8\);
                        -- The following section was transformed from the .NET statement below:
                        -- i = i + 1;
                        -- 
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.9\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.i\ + to_signed(1, 32);
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2.i\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2.binaryOperationResult.9\;
                        -- Returning to the repeated state of the while loop which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_2\ if the loop wasn't exited with a state change.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ = \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_5\) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_6\ => 
                        -- True branch of the if-else started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	break;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- break;
                        -- 
                        -- Exiting the while loop with a break statement.
                        \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_4\;
                        -- Going to the state after the if-else which was started in state \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_3\.
                        if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ = \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_6\) then 
                            \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State\ := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte).2 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).0 state machine start
    \Posit32::GetTwosComplement(UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetTwosComplement(UInt32).0._State\: \Posit32::GetTwosComplement(UInt32).0._States\ := \Posit32::GetTwosComplement(UInt32).0._State_0\;
        Variable \Posit32::GetTwosComplement(UInt32).0.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetTwosComplement(UInt32).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetTwosComplement(UInt32).0._Finished\ <= false;
                \Posit32::GetTwosComplement(UInt32).0.return\ <= to_unsigned(0, 32);
                \Posit32::GetTwosComplement(UInt32).0._State\ := \Posit32::GetTwosComplement(UInt32).0._State_0\;
                \Posit32::GetTwosComplement(UInt32).0.bits\ := to_unsigned(0, 32);
                \Posit32::GetTwosComplement(UInt32).0.binaryOperationResult.0\ := to_unsigned(0, 32);
            else 
                case \Posit32::GetTwosComplement(UInt32).0._State\ is 
                    when \Posit32::GetTwosComplement(UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetTwosComplement(UInt32).0._Started\ = true) then 
                            \Posit32::GetTwosComplement(UInt32).0._State\ := \Posit32::GetTwosComplement(UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetTwosComplement(UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetTwosComplement(UInt32).0._Started\ = true) then 
                            \Posit32::GetTwosComplement(UInt32).0._Finished\ <= true;
                        else 
                            \Posit32::GetTwosComplement(UInt32).0._Finished\ <= false;
                            \Posit32::GetTwosComplement(UInt32).0._State\ := \Posit32::GetTwosComplement(UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetTwosComplement(UInt32).0._State_2\ => 
                        \Posit32::GetTwosComplement(UInt32).0.bits\ := \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return ~bits + 1u;
                        -- 
                        \Posit32::GetTwosComplement(UInt32).0.binaryOperationResult.0\ := not(\Posit32::GetTwosComplement(UInt32).0.bits\) + to_unsigned(1, 32);
                        \Posit32::GetTwosComplement(UInt32).0.return\ <= \Posit32::GetTwosComplement(UInt32).0.binaryOperationResult.0\;
                        \Posit32::GetTwosComplement(UInt32).0._State\ := \Posit32::GetTwosComplement(UInt32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).1 state machine start
    \Posit32::GetTwosComplement(UInt32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetTwosComplement(UInt32).1._State\: \Posit32::GetTwosComplement(UInt32).1._States\ := \Posit32::GetTwosComplement(UInt32).1._State_0\;
        Variable \Posit32::GetTwosComplement(UInt32).1.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetTwosComplement(UInt32).1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetTwosComplement(UInt32).1._Finished\ <= false;
                \Posit32::GetTwosComplement(UInt32).1.return\ <= to_unsigned(0, 32);
                \Posit32::GetTwosComplement(UInt32).1._State\ := \Posit32::GetTwosComplement(UInt32).1._State_0\;
                \Posit32::GetTwosComplement(UInt32).1.bits\ := to_unsigned(0, 32);
                \Posit32::GetTwosComplement(UInt32).1.binaryOperationResult.0\ := to_unsigned(0, 32);
            else 
                case \Posit32::GetTwosComplement(UInt32).1._State\ is 
                    when \Posit32::GetTwosComplement(UInt32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetTwosComplement(UInt32).1._Started\ = true) then 
                            \Posit32::GetTwosComplement(UInt32).1._State\ := \Posit32::GetTwosComplement(UInt32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetTwosComplement(UInt32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetTwosComplement(UInt32).1._Started\ = true) then 
                            \Posit32::GetTwosComplement(UInt32).1._Finished\ <= true;
                        else 
                            \Posit32::GetTwosComplement(UInt32).1._Finished\ <= false;
                            \Posit32::GetTwosComplement(UInt32).1._State\ := \Posit32::GetTwosComplement(UInt32).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetTwosComplement(UInt32).1._State_2\ => 
                        \Posit32::GetTwosComplement(UInt32).1.bits\ := \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return ~bits + 1u;
                        -- 
                        \Posit32::GetTwosComplement(UInt32).1.binaryOperationResult.0\ := not(\Posit32::GetTwosComplement(UInt32).1.bits\) + to_unsigned(1, 32);
                        \Posit32::GetTwosComplement(UInt32).1.return\ <= \Posit32::GetTwosComplement(UInt32).1.binaryOperationResult.0\;
                        \Posit32::GetTwosComplement(UInt32).1._State\ := \Posit32::GetTwosComplement(UInt32).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).1 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).2 state machine start
    \Posit32::GetTwosComplement(UInt32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::GetTwosComplement(UInt32).2._State\: \Posit32::GetTwosComplement(UInt32).2._States\ := \Posit32::GetTwosComplement(UInt32).2._State_0\;
        Variable \Posit32::GetTwosComplement(UInt32).2.bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::GetTwosComplement(UInt32).2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::GetTwosComplement(UInt32).2._Finished\ <= false;
                \Posit32::GetTwosComplement(UInt32).2.return\ <= to_unsigned(0, 32);
                \Posit32::GetTwosComplement(UInt32).2._State\ := \Posit32::GetTwosComplement(UInt32).2._State_0\;
                \Posit32::GetTwosComplement(UInt32).2.bits\ := to_unsigned(0, 32);
                \Posit32::GetTwosComplement(UInt32).2.binaryOperationResult.0\ := to_unsigned(0, 32);
            else 
                case \Posit32::GetTwosComplement(UInt32).2._State\ is 
                    when \Posit32::GetTwosComplement(UInt32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::GetTwosComplement(UInt32).2._Started\ = true) then 
                            \Posit32::GetTwosComplement(UInt32).2._State\ := \Posit32::GetTwosComplement(UInt32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetTwosComplement(UInt32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::GetTwosComplement(UInt32).2._Started\ = true) then 
                            \Posit32::GetTwosComplement(UInt32).2._Finished\ <= true;
                        else 
                            \Posit32::GetTwosComplement(UInt32).2._Finished\ <= false;
                            \Posit32::GetTwosComplement(UInt32).2._State\ := \Posit32::GetTwosComplement(UInt32).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::GetTwosComplement(UInt32).2._State_2\ => 
                        \Posit32::GetTwosComplement(UInt32).2.bits\ := \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return ~bits + 1u;
                        -- 
                        \Posit32::GetTwosComplement(UInt32).2.binaryOperationResult.0\ := not(\Posit32::GetTwosComplement(UInt32).2.bits\) + to_unsigned(1, 32);
                        \Posit32::GetTwosComplement(UInt32).2.return\ <= \Posit32::GetTwosComplement(UInt32).2.binaryOperationResult.0\;
                        \Posit32::GetTwosComplement(UInt32).2._State\ := \Posit32::GetTwosComplement(UInt32).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32).2 state machine end


    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 state machine start
    \Posit32::op_Addition(Posit32,Posit32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::op_Addition(Posit32,Posit32).0._State\: \Posit32::op_Addition(Posit32,Posit32).0._States\ := \Posit32::op_Addition(Posit32,Posit32).0._State_0\;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.left\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.result\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag2\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag3\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag4\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.left2\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.right2\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.lengthOfRunOfBits\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.lengthOfRunOfBits2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag5\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.regimeKValueWithoutSignCheck\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.exponentValueWithoutSignCheck\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.regimeKValueWithoutSignCheck2\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.exponentValueWithoutSignCheck2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.signBit\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num8\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num9\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num11\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag6\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag7\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag8\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag9\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag10\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag11\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.num18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag12\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag13\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag14\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.flag15\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.exponentBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.0\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.1\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.2\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.3\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.4\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.5\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.8\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.8\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.10\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.12\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.9\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.10\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.13\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.14\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.12\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.16\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.13\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.14\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.16\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.17\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.18\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.19\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.20\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.17\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.21\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.22\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.23\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.24\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.25\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.26\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.27\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.29\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.30\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.31\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.32\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.33\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.34\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.35\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.36\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.37\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.38\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.39\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.40\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.18\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.41\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.42\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.43\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.44\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.45\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.46\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.47\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.48\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.49\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.50\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.51\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.52\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.53\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.54\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.55\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.56\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.57\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.58\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.59\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.60\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.61\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.62\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.63\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.64\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.65\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.66\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.67\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.68\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.69\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.19\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.70\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.71\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.72\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.73\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.74\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.75\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.76\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).0.return.20\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::op_Addition(Posit32,Posit32).0._Finished\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_0\;
                \Posit32::op_Addition(Posit32,Posit32).0.flag\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.flag2\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.flag3\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.flag4\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.num\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.num2\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.num3\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.num4\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.lengthOfRunOfBits\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.lengthOfRunOfBits2\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.num5\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.num6\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.flag5\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.regimeKValueWithoutSignCheck\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.exponentValueWithoutSignCheck\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.regimeKValueWithoutSignCheck2\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.exponentValueWithoutSignCheck2\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.signBit\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.num7\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.num8\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).0.num9\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).0.num10\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.num11\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).0.num12\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.num13\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.flag6\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.flag7\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.flag8\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.flag9\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.num14\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.num15\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.num16\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.flag10\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.flag11\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.num17\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.num18\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.flag12\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.flag13\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.flag14\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.flag15\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.regimeKValue\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.exponentBits\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.return.0\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.return.1\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.return.2\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.return.3\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.4\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.return.4\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.return.5\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.return.6\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.return.7\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.8\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.return.8\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.return.9\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.return.10\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.return.11\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.return.12\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.9\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.10\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.return.13\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).0.return.14\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.11\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.12\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.return.15\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.return.16\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.13\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.14\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.15\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.16\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.17\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.18\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.19\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.20\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.return.17\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.21\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.22\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.23\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.24\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.25\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.26\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.27\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.28\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.29\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.30\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.31\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.32\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.33\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.34\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.35\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.36\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.37\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.38\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.39\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.40\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.return.18\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.41\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.42\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.43\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.44\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.45\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.46\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.47\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.48\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.49\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.50\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.51\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.52\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.53\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.54\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.55\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.56\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.57\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.58\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.59\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.60\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.61\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.62\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.63\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.64\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.65\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.66\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.67\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.68\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.69\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.return.19\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.70\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.71\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.72\ := false;
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.73\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.74\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.75\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.76\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).0.return.20\ := to_unsigned(0, 32);
            else 
                case \Posit32::op_Addition(Posit32,Posit32).0._State\ is 
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._Started\ = true) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._Started\ = true) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._Finished\ <= true;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).0._Finished\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_2\ => 
                        \Posit32::op_Addition(Posit32,Posit32).0.left\ := \Posit32::op_Addition(Posit32,Posit32).0.left.parameter.In\;
                        \Posit32::op_Addition(Posit32,Posit32).0.right\ := \Posit32::op_Addition(Posit32,Posit32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 left2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 right2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte lengthOfRunOfBits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte lengthOfRunOfBits2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte regimeKValueWithoutSignCheck;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentValueWithoutSignCheck;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte regimeKValueWithoutSignCheck2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentValueWithoutSignCheck2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool signBit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- short num8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- short num9;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num10;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- short num11;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num12;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num13;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag9;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num14;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num15;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num16;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag10;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag11;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num17;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num18;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag12;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag13;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag14;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag15;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int regimeKValue;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentBits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = Lombiq.Arithmetics.Posit32.IsNaN (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.left\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.0\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.flag\ := \Posit32::op_Addition(Posit32,Posit32).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	result = left;
                            -- }
                            -- else {
                            -- 	flag2 = Lombiq.Arithmetics.Posit32.IsNaN (right);
                            -- 	if (flag2) {
                            -- 		result = right;
                            -- 	}
                            -- 	else {
                            -- 		flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                            -- 		if (flag3) {
                            -- 			result = right;
                            -- 		}
                            -- 		else {
                            -- 			flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                            -- 			if (flag4) {
                            -- 				result = left;
                            -- 			}
                            -- 			else {
                            -- 				num = left.PositBits >> 31;
                            -- 				num2 = 0u - num;
                            -- 				left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 				num3 = right.PositBits >> 31;
                            -- 				num4 = 0u - num3;
                            -- 				right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 				lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 				lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 				num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 				num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 				flag5 = num == num3;
                            -- 				regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 				exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 				regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 				exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 				if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 					signBit = num == 1u;
                            -- 				}
                            -- 				else {
                            -- 					signBit = num3 == 1u;
                            -- 				}
                            -- 				num7 = 0u;
                            -- 				num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 				num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 				num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 				if (num10 >= 0) {
                            -- 					num11 = num8;
                            -- 				}
                            -- 				else {
                            -- 					num11 = num9;
                            -- 				}
                            -- 				num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 				num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 				flag6 = num10 == 0;
                            -- 				if (flag6) {
                            -- 					flag7 = flag5;
                            -- 					if (flag7) {
                            -- 						num7 = 0u + num12 + num13;
                            -- 					}
                            -- 					else {
                            -- 						flag8 = num12 >= num13;
                            -- 						if (flag8) {
                            -- 							num7 = num7 + num12 - num13;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 + num13 - num12;
                            -- 						}
                            -- 					}
                            -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 				}
                            -- 				else {
                            -- 					flag9 = num10 > 0;
                            -- 					if (flag9) {
                            -- 						num14 = (int)(num5 - num6);
                            -- 						num7 = num7 + num12;
                            -- 						num15 = (int)(31u - num5 - 1u);
                            -- 						num7 = num7 << num15;
                            -- 						num16 = num15 - num10 + num14;
                            -- 						flag10 = flag5;
                            -- 						if (flag10) {
                            -- 							flag11 = num16 >= 0;
                            -- 							if (flag11) {
                            -- 								num7 = num7 + num13 << num16;
                            -- 							}
                            -- 							else {
                            -- 								num7 = num7 + num13 >> -num16;
                            -- 							}
                            -- 						}
                            -- 						else {
                            -- 							uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 							if (num16 >= 0) {
                            -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 							}
                            -- 							else {
                            -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 							}
                            -- 							num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 						}
                            -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 					}
                            -- 					else {
                            -- 						num17 = (int)(num6 - num5);
                            -- 						num7 = num7 + num13;
                            -- 						num18 = (int)(31u - num6 - 1u);
                            -- 						num7 = num7 << num18;
                            -- 						flag12 = flag5;
                            -- 						if (flag12) {
                            -- 							flag13 = num18 + num10 + num17 >= 0;
                            -- 							if (flag13) {
                            -- 								num7 = num7 + num12 << num18 + num10 + num17;
                            -- 							}
                            -- 							else {
                            -- 								num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 							}
                            -- 						}
                            -- 						else {
                            -- 							flag14 = num18 + num10 + num17 >= 0;
                            -- 							if (flag14) {
                            -- 								num7 = num7 - num12 << num18 + num10 + num17;
                            -- 							}
                            -- 							else {
                            -- 								num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 							}
                            -- 						}
                            -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 					}
                            -- 				}
                            -- 				flag15 = num7 == 0u;
                            -- 				if (flag15) {
                            -- 					result = new Posit32 (0u, true);
                            -- 				}
                            -- 				else {
                            -- 					regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 					System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 					remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 					exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 					result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 				}
                            -- 			}
                            -- 		}
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_5\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_5\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_6\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_8\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_4\.

                            if (\Posit32::op_Addition(Posit32,Posit32).0.flag\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_5\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.return\ <= \Posit32::op_Addition(Posit32,Posit32).0.result\;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.result\ := \Posit32::op_Addition(Posit32,Posit32).0.left\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_3\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_5\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag2 = Lombiq.Arithmetics.Posit32.IsNaN (right);
                        -- 	if (flag2) {
                        -- 		result = right;
                        -- 	}
                        -- 	else {
                        -- 		flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                        -- 		if (flag3) {
                        -- 			result = right;
                        -- 		}
                        -- 		else {
                        -- 			flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 			if (flag4) {
                        -- 				result = left;
                        -- 			}
                        -- 			else {
                        -- 				num = left.PositBits >> 31;
                        -- 				num2 = 0u - num;
                        -- 				left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 				num3 = right.PositBits >> 31;
                        -- 				num4 = 0u - num3;
                        -- 				right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 				lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 				lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 				num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 				num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 				flag5 = num == num3;
                        -- 				regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 				exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 				regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 				exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 				if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 					signBit = num == 1u;
                        -- 				}
                        -- 				else {
                        -- 					signBit = num3 == 1u;
                        -- 				}
                        -- 				num7 = 0u;
                        -- 				num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 				num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 				num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 				if (num10 >= 0) {
                        -- 					num11 = num8;
                        -- 				}
                        -- 				else {
                        -- 					num11 = num9;
                        -- 				}
                        -- 				num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 				num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 				flag6 = num10 == 0;
                        -- 				if (flag6) {
                        -- 					flag7 = flag5;
                        -- 					if (flag7) {
                        -- 						num7 = 0u + num12 + num13;
                        -- 					}
                        -- 					else {
                        -- 						flag8 = num12 >= num13;
                        -- 						if (flag8) {
                        -- 							num7 = num7 + num12 - num13;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 + num13 - num12;
                        -- 						}
                        -- 					}
                        -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 				}
                        -- 				else {
                        -- 					flag9 = num10 > 0;
                        -- 					if (flag9) {
                        -- 						num14 = (int)(num5 - num6);
                        -- 						num7 = num7 + num12;
                        -- 						num15 = (int)(31u - num5 - 1u);
                        -- 						num7 = num7 << num15;
                        -- 						num16 = num15 - num10 + num14;
                        -- 						flag10 = flag5;
                        -- 						if (flag10) {
                        -- 							flag11 = num16 >= 0;
                        -- 							if (flag11) {
                        -- 								num7 = num7 + num13 << num16;
                        -- 							}
                        -- 							else {
                        -- 								num7 = num7 + num13 >> -num16;
                        -- 							}
                        -- 						}
                        -- 						else {
                        -- 							uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 							if (num16 >= 0) {
                        -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 							}
                        -- 							else {
                        -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 							}
                        -- 							num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 						}
                        -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 					}
                        -- 					else {
                        -- 						num17 = (int)(num6 - num5);
                        -- 						num7 = num7 + num13;
                        -- 						num18 = (int)(31u - num6 - 1u);
                        -- 						num7 = num7 << num18;
                        -- 						flag12 = flag5;
                        -- 						if (flag12) {
                        -- 							flag13 = num18 + num10 + num17 >= 0;
                        -- 							if (flag13) {
                        -- 								num7 = num7 + num12 << num18 + num10 + num17;
                        -- 							}
                        -- 							else {
                        -- 								num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 							}
                        -- 						}
                        -- 						else {
                        -- 							flag14 = num18 + num10 + num17 >= 0;
                        -- 							if (flag14) {
                        -- 								num7 = num7 - num12 << num18 + num10 + num17;
                        -- 							}
                        -- 							else {
                        -- 								num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 							}
                        -- 						}
                        -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 					}
                        -- 				}
                        -- 				flag15 = num7 == 0u;
                        -- 				if (flag15) {
                        -- 					result = new Posit32 (0u, true);
                        -- 				}
                        -- 				else {
                        -- 					regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 					System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 					remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 					exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 					result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 				}
                        -- 			}
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = Lombiq.Arithmetics.Posit32.IsNaN (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.right\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.1\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.flag2\ := \Posit32::op_Addition(Posit32,Posit32).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag2) {
                            -- 	result = right;
                            -- }
                            -- else {
                            -- 	flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                            -- 	if (flag3) {
                            -- 		result = right;
                            -- 	}
                            -- 	else {
                            -- 		flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                            -- 		if (flag4) {
                            -- 			result = left;
                            -- 		}
                            -- 		else {
                            -- 			num = left.PositBits >> 31;
                            -- 			num2 = 0u - num;
                            -- 			left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 			num3 = right.PositBits >> 31;
                            -- 			num4 = 0u - num3;
                            -- 			right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 			lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 			lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 			num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 			num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 			flag5 = num == num3;
                            -- 			regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 			exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 			regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 			exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 			if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 				signBit = num == 1u;
                            -- 			}
                            -- 			else {
                            -- 				signBit = num3 == 1u;
                            -- 			}
                            -- 			num7 = 0u;
                            -- 			num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 			num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 			num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 			if (num10 >= 0) {
                            -- 				num11 = num8;
                            -- 			}
                            -- 			else {
                            -- 				num11 = num9;
                            -- 			}
                            -- 			num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 			num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 			flag6 = num10 == 0;
                            -- 			if (flag6) {
                            -- 				flag7 = flag5;
                            -- 				if (flag7) {
                            -- 					num7 = 0u + num12 + num13;
                            -- 				}
                            -- 				else {
                            -- 					flag8 = num12 >= num13;
                            -- 					if (flag8) {
                            -- 						num7 = num7 + num12 - num13;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 + num13 - num12;
                            -- 					}
                            -- 				}
                            -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 			}
                            -- 			else {
                            -- 				flag9 = num10 > 0;
                            -- 				if (flag9) {
                            -- 					num14 = (int)(num5 - num6);
                            -- 					num7 = num7 + num12;
                            -- 					num15 = (int)(31u - num5 - 1u);
                            -- 					num7 = num7 << num15;
                            -- 					num16 = num15 - num10 + num14;
                            -- 					flag10 = flag5;
                            -- 					if (flag10) {
                            -- 						flag11 = num16 >= 0;
                            -- 						if (flag11) {
                            -- 							num7 = num7 + num13 << num16;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 + num13 >> -num16;
                            -- 						}
                            -- 					}
                            -- 					else {
                            -- 						uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 						if (num16 >= 0) {
                            -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 						}
                            -- 						else {
                            -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 						}
                            -- 						num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 					}
                            -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 				}
                            -- 				else {
                            -- 					num17 = (int)(num6 - num5);
                            -- 					num7 = num7 + num13;
                            -- 					num18 = (int)(31u - num6 - 1u);
                            -- 					num7 = num7 << num18;
                            -- 					flag12 = flag5;
                            -- 					if (flag12) {
                            -- 						flag13 = num18 + num10 + num17 >= 0;
                            -- 						if (flag13) {
                            -- 							num7 = num7 + num12 << num18 + num10 + num17;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 						}
                            -- 					}
                            -- 					else {
                            -- 						flag14 = num18 + num10 + num17 >= 0;
                            -- 						if (flag14) {
                            -- 							num7 = num7 - num12 << num18 + num10 + num17;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 						}
                            -- 					}
                            -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 				}
                            -- 			}
                            -- 			flag15 = num7 == 0u;
                            -- 			if (flag15) {
                            -- 				result = new Posit32 (0u, true);
                            -- 			}
                            -- 			else {
                            -- 				regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 				System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 				remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 				exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 				result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 			}
                            -- 		}
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_9\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_9\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_10\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_12\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_8\.

                            if (\Posit32::op_Addition(Posit32,Posit32).0.flag2\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_9\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_8\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_7\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_3\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_8\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_9\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = right;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = right;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.result\ := \Posit32::op_Addition(Posit32,Posit32).0.right\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_7\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_9\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_10\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                        -- 	if (flag3) {
                        -- 		result = right;
                        -- 	}
                        -- 	else {
                        -- 		flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 		if (flag4) {
                        -- 			result = left;
                        -- 		}
                        -- 		else {
                        -- 			num = left.PositBits >> 31;
                        -- 			num2 = 0u - num;
                        -- 			left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 			num3 = right.PositBits >> 31;
                        -- 			num4 = 0u - num3;
                        -- 			right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 			lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 			lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 			num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 			num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 			flag5 = num == num3;
                        -- 			regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 			exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 			regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 			exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 			if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 				signBit = num == 1u;
                        -- 			}
                        -- 			else {
                        -- 				signBit = num3 == 1u;
                        -- 			}
                        -- 			num7 = 0u;
                        -- 			num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 			num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 			num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 			if (num10 >= 0) {
                        -- 				num11 = num8;
                        -- 			}
                        -- 			else {
                        -- 				num11 = num9;
                        -- 			}
                        -- 			num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 			num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 			flag6 = num10 == 0;
                        -- 			if (flag6) {
                        -- 				flag7 = flag5;
                        -- 				if (flag7) {
                        -- 					num7 = 0u + num12 + num13;
                        -- 				}
                        -- 				else {
                        -- 					flag8 = num12 >= num13;
                        -- 					if (flag8) {
                        -- 						num7 = num7 + num12 - num13;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 + num13 - num12;
                        -- 					}
                        -- 				}
                        -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 			}
                        -- 			else {
                        -- 				flag9 = num10 > 0;
                        -- 				if (flag9) {
                        -- 					num14 = (int)(num5 - num6);
                        -- 					num7 = num7 + num12;
                        -- 					num15 = (int)(31u - num5 - 1u);
                        -- 					num7 = num7 << num15;
                        -- 					num16 = num15 - num10 + num14;
                        -- 					flag10 = flag5;
                        -- 					if (flag10) {
                        -- 						flag11 = num16 >= 0;
                        -- 						if (flag11) {
                        -- 							num7 = num7 + num13 << num16;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 + num13 >> -num16;
                        -- 						}
                        -- 					}
                        -- 					else {
                        -- 						uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 						if (num16 >= 0) {
                        -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 						}
                        -- 						else {
                        -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 						}
                        -- 						num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 					}
                        -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 				}
                        -- 				else {
                        -- 					num17 = (int)(num6 - num5);
                        -- 					num7 = num7 + num13;
                        -- 					num18 = (int)(31u - num6 - 1u);
                        -- 					num7 = num7 << num18;
                        -- 					flag12 = flag5;
                        -- 					if (flag12) {
                        -- 						flag13 = num18 + num10 + num17 >= 0;
                        -- 						if (flag13) {
                        -- 							num7 = num7 + num12 << num18 + num10 + num17;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 						}
                        -- 					}
                        -- 					else {
                        -- 						flag14 = num18 + num10 + num17 >= 0;
                        -- 						if (flag14) {
                        -- 							num7 = num7 - num12 << num18 + num10 + num17;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 						}
                        -- 					}
                        -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 				}
                        -- 			}
                        -- 			flag15 = num7 == 0u;
                        -- 			if (flag15) {
                        -- 				result = new Posit32 (0u, true);
                        -- 			}
                        -- 			else {
                        -- 				regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 				System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 				remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 				exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 				result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 			}
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.left\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.2\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.flag3\ := \Posit32::op_Addition(Posit32,Posit32).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag3) {
                            -- 	result = right;
                            -- }
                            -- else {
                            -- 	flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                            -- 	if (flag4) {
                            -- 		result = left;
                            -- 	}
                            -- 	else {
                            -- 		num = left.PositBits >> 31;
                            -- 		num2 = 0u - num;
                            -- 		left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 		num3 = right.PositBits >> 31;
                            -- 		num4 = 0u - num3;
                            -- 		right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 		lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 		lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 		num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 		num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 		flag5 = num == num3;
                            -- 		regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 		exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 		regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 		exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 		if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 			signBit = num == 1u;
                            -- 		}
                            -- 		else {
                            -- 			signBit = num3 == 1u;
                            -- 		}
                            -- 		num7 = 0u;
                            -- 		num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 		num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 		num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 		if (num10 >= 0) {
                            -- 			num11 = num8;
                            -- 		}
                            -- 		else {
                            -- 			num11 = num9;
                            -- 		}
                            -- 		num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 		num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 		flag6 = num10 == 0;
                            -- 		if (flag6) {
                            -- 			flag7 = flag5;
                            -- 			if (flag7) {
                            -- 				num7 = 0u + num12 + num13;
                            -- 			}
                            -- 			else {
                            -- 				flag8 = num12 >= num13;
                            -- 				if (flag8) {
                            -- 					num7 = num7 + num12 - num13;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 + num13 - num12;
                            -- 				}
                            -- 			}
                            -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 		}
                            -- 		else {
                            -- 			flag9 = num10 > 0;
                            -- 			if (flag9) {
                            -- 				num14 = (int)(num5 - num6);
                            -- 				num7 = num7 + num12;
                            -- 				num15 = (int)(31u - num5 - 1u);
                            -- 				num7 = num7 << num15;
                            -- 				num16 = num15 - num10 + num14;
                            -- 				flag10 = flag5;
                            -- 				if (flag10) {
                            -- 					flag11 = num16 >= 0;
                            -- 					if (flag11) {
                            -- 						num7 = num7 + num13 << num16;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 + num13 >> -num16;
                            -- 					}
                            -- 				}
                            -- 				else {
                            -- 					uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 					if (num16 >= 0) {
                            -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 					}
                            -- 					else {
                            -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 					}
                            -- 					num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 				}
                            -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 			}
                            -- 			else {
                            -- 				num17 = (int)(num6 - num5);
                            -- 				num7 = num7 + num13;
                            -- 				num18 = (int)(31u - num6 - 1u);
                            -- 				num7 = num7 << num18;
                            -- 				flag12 = flag5;
                            -- 				if (flag12) {
                            -- 					flag13 = num18 + num10 + num17 >= 0;
                            -- 					if (flag13) {
                            -- 						num7 = num7 + num12 << num18 + num10 + num17;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 					}
                            -- 				}
                            -- 				else {
                            -- 					flag14 = num18 + num10 + num17 >= 0;
                            -- 					if (flag14) {
                            -- 						num7 = num7 - num12 << num18 + num10 + num17;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 					}
                            -- 				}
                            -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 			}
                            -- 		}
                            -- 		flag15 = num7 == 0u;
                            -- 		if (flag15) {
                            -- 			result = new Posit32 (0u, true);
                            -- 		}
                            -- 		else {
                            -- 			regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 			System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 			remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 			exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 			result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 		}
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_13\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_13\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_14\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_16\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_12\.

                            if (\Posit32::op_Addition(Posit32,Posit32).0.flag3\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_13\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_14\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_12\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_11\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_7\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_12\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_13\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = right;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = right;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.result\ := \Posit32::op_Addition(Posit32,Posit32).0.right\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_11\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_13\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_14\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 	if (flag4) {
                        -- 		result = left;
                        -- 	}
                        -- 	else {
                        -- 		num = left.PositBits >> 31;
                        -- 		num2 = 0u - num;
                        -- 		left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 		num3 = right.PositBits >> 31;
                        -- 		num4 = 0u - num3;
                        -- 		right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 		lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 		lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 		num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 		num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 		flag5 = num == num3;
                        -- 		regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 		exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 		regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 		exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 		if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 			signBit = num == 1u;
                        -- 		}
                        -- 		else {
                        -- 			signBit = num3 == 1u;
                        -- 		}
                        -- 		num7 = 0u;
                        -- 		num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 		num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 		num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 		if (num10 >= 0) {
                        -- 			num11 = num8;
                        -- 		}
                        -- 		else {
                        -- 			num11 = num9;
                        -- 		}
                        -- 		num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 		num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 		flag6 = num10 == 0;
                        -- 		if (flag6) {
                        -- 			flag7 = flag5;
                        -- 			if (flag7) {
                        -- 				num7 = 0u + num12 + num13;
                        -- 			}
                        -- 			else {
                        -- 				flag8 = num12 >= num13;
                        -- 				if (flag8) {
                        -- 					num7 = num7 + num12 - num13;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 + num13 - num12;
                        -- 				}
                        -- 			}
                        -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 		}
                        -- 		else {
                        -- 			flag9 = num10 > 0;
                        -- 			if (flag9) {
                        -- 				num14 = (int)(num5 - num6);
                        -- 				num7 = num7 + num12;
                        -- 				num15 = (int)(31u - num5 - 1u);
                        -- 				num7 = num7 << num15;
                        -- 				num16 = num15 - num10 + num14;
                        -- 				flag10 = flag5;
                        -- 				if (flag10) {
                        -- 					flag11 = num16 >= 0;
                        -- 					if (flag11) {
                        -- 						num7 = num7 + num13 << num16;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 + num13 >> -num16;
                        -- 					}
                        -- 				}
                        -- 				else {
                        -- 					uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 					if (num16 >= 0) {
                        -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 					}
                        -- 					else {
                        -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 					}
                        -- 					num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 				}
                        -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 			}
                        -- 			else {
                        -- 				num17 = (int)(num6 - num5);
                        -- 				num7 = num7 + num13;
                        -- 				num18 = (int)(31u - num6 - 1u);
                        -- 				num7 = num7 << num18;
                        -- 				flag12 = flag5;
                        -- 				if (flag12) {
                        -- 					flag13 = num18 + num10 + num17 >= 0;
                        -- 					if (flag13) {
                        -- 						num7 = num7 + num12 << num18 + num10 + num17;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 					}
                        -- 				}
                        -- 				else {
                        -- 					flag14 = num18 + num10 + num17 >= 0;
                        -- 					if (flag14) {
                        -- 						num7 = num7 - num12 << num18 + num10 + num17;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 					}
                        -- 				}
                        -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 			}
                        -- 		}
                        -- 		flag15 = num7 == 0u;
                        -- 		if (flag15) {
                        -- 			result = new Posit32 (0u, true);
                        -- 		}
                        -- 		else {
                        -- 			regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 			System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 			remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 			exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 			result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.right\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_15\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.3\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.flag4\ := \Posit32::op_Addition(Posit32,Posit32).0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag4) {
                            -- 	result = left;
                            -- }
                            -- else {
                            -- 	num = left.PositBits >> 31;
                            -- 	num2 = 0u - num;
                            -- 	left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 	num3 = right.PositBits >> 31;
                            -- 	num4 = 0u - num3;
                            -- 	right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 	lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 	lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 	num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 	num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 	flag5 = num == num3;
                            -- 	regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 	exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 	regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 	exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 	if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 		signBit = num == 1u;
                            -- 	}
                            -- 	else {
                            -- 		signBit = num3 == 1u;
                            -- 	}
                            -- 	num7 = 0u;
                            -- 	num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 	num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 	num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 	if (num10 >= 0) {
                            -- 		num11 = num8;
                            -- 	}
                            -- 	else {
                            -- 		num11 = num9;
                            -- 	}
                            -- 	num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 	num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 	flag6 = num10 == 0;
                            -- 	if (flag6) {
                            -- 		flag7 = flag5;
                            -- 		if (flag7) {
                            -- 			num7 = 0u + num12 + num13;
                            -- 		}
                            -- 		else {
                            -- 			flag8 = num12 >= num13;
                            -- 			if (flag8) {
                            -- 				num7 = num7 + num12 - num13;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 + num13 - num12;
                            -- 			}
                            -- 		}
                            -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 	}
                            -- 	else {
                            -- 		flag9 = num10 > 0;
                            -- 		if (flag9) {
                            -- 			num14 = (int)(num5 - num6);
                            -- 			num7 = num7 + num12;
                            -- 			num15 = (int)(31u - num5 - 1u);
                            -- 			num7 = num7 << num15;
                            -- 			num16 = num15 - num10 + num14;
                            -- 			flag10 = flag5;
                            -- 			if (flag10) {
                            -- 				flag11 = num16 >= 0;
                            -- 				if (flag11) {
                            -- 					num7 = num7 + num13 << num16;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 + num13 >> -num16;
                            -- 				}
                            -- 			}
                            -- 			else {
                            -- 				uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 				if (num16 >= 0) {
                            -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 				}
                            -- 				else {
                            -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 				}
                            -- 				num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 			}
                            -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 		}
                            -- 		else {
                            -- 			num17 = (int)(num6 - num5);
                            -- 			num7 = num7 + num13;
                            -- 			num18 = (int)(31u - num6 - 1u);
                            -- 			num7 = num7 << num18;
                            -- 			flag12 = flag5;
                            -- 			if (flag12) {
                            -- 				flag13 = num18 + num10 + num17 >= 0;
                            -- 				if (flag13) {
                            -- 					num7 = num7 + num12 << num18 + num10 + num17;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 				}
                            -- 			}
                            -- 			else {
                            -- 				flag14 = num18 + num10 + num17 >= 0;
                            -- 				if (flag14) {
                            -- 					num7 = num7 - num12 << num18 + num10 + num17;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 				}
                            -- 			}
                            -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 		}
                            -- 	}
                            -- 	flag15 = num7 == 0u;
                            -- 	if (flag15) {
                            -- 		result = new Posit32 (0u, true);
                            -- 	}
                            -- 	else {
                            -- 		regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 		System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 		remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 		exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 		result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_17\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_17\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_18\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_92\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_16\.

                            if (\Posit32::op_Addition(Posit32,Posit32).0.flag4\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_17\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_18\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_16\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_15\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_11\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_16\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_17\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.result\ := \Posit32::op_Addition(Posit32,Posit32).0.left\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_15\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_17\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_18\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = left.PositBits >> 31;
                        -- 	num2 = 0u - num;
                        -- 	left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 	num3 = right.PositBits >> 31;
                        -- 	num4 = 0u - num3;
                        -- 	right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 	lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 	lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 	num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 	num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 	flag5 = num == num3;
                        -- 	regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 	exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 	regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 	exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 	if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 		signBit = num == 1u;
                        -- 	}
                        -- 	else {
                        -- 		signBit = num3 == 1u;
                        -- 	}
                        -- 	num7 = 0u;
                        -- 	num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 	num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 	num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 	if (num10 >= 0) {
                        -- 		num11 = num8;
                        -- 	}
                        -- 	else {
                        -- 		num11 = num9;
                        -- 	}
                        -- 	num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 	num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 	flag6 = num10 == 0;
                        -- 	if (flag6) {
                        -- 		flag7 = flag5;
                        -- 		if (flag7) {
                        -- 			num7 = 0u + num12 + num13;
                        -- 		}
                        -- 		else {
                        -- 			flag8 = num12 >= num13;
                        -- 			if (flag8) {
                        -- 				num7 = num7 + num12 - num13;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 + num13 - num12;
                        -- 			}
                        -- 		}
                        -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 	}
                        -- 	else {
                        -- 		flag9 = num10 > 0;
                        -- 		if (flag9) {
                        -- 			num14 = (int)(num5 - num6);
                        -- 			num7 = num7 + num12;
                        -- 			num15 = (int)(31u - num5 - 1u);
                        -- 			num7 = num7 << num15;
                        -- 			num16 = num15 - num10 + num14;
                        -- 			flag10 = flag5;
                        -- 			if (flag10) {
                        -- 				flag11 = num16 >= 0;
                        -- 				if (flag11) {
                        -- 					num7 = num7 + num13 << num16;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 + num13 >> -num16;
                        -- 				}
                        -- 			}
                        -- 			else {
                        -- 				uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 				if (num16 >= 0) {
                        -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 				}
                        -- 				else {
                        -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 				}
                        -- 				num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 			}
                        -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 		}
                        -- 		else {
                        -- 			num17 = (int)(num6 - num5);
                        -- 			num7 = num7 + num13;
                        -- 			num18 = (int)(31u - num6 - 1u);
                        -- 			num7 = num7 << num18;
                        -- 			flag12 = flag5;
                        -- 			if (flag12) {
                        -- 				flag13 = num18 + num10 + num17 >= 0;
                        -- 				if (flag13) {
                        -- 					num7 = num7 + num12 << num18 + num10 + num17;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 				}
                        -- 			}
                        -- 			else {
                        -- 				flag14 = num18 + num10 + num17 >= 0;
                        -- 				if (flag14) {
                        -- 					num7 = num7 - num12 << num18 + num10 + num17;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 				}
                        -- 			}
                        -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 		}
                        -- 	}
                        -- 	flag15 = num7 == 0u;
                        -- 	if (flag15) {
                        -- 		result = new Posit32 (0u, true);
                        -- 	}
                        -- 	else {
                        -- 		regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 		System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 		remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 		exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 		result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = left.PositBits >> 31;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.0\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).0.left\.\PositBits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).0.num\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0u - num;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.1\ := to_unsigned(0, 32) - \Posit32::op_Addition(Posit32,Posit32).0.num\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num2\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::op_Addition(Posit32,Posit32).0.left2\.\IsNull\ := false;
                        \Posit32::op_Addition(Posit32,Posit32).0.left2\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.2\ := \Posit32::op_Addition(Posit32,Posit32).0.left\.\PositBits\ xor \Posit32::op_Addition(Posit32,Posit32).0.num2\;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0.6928
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_19\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.3\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.2\ + \Posit32::op_Addition(Posit32,Posit32).0.num\;
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.left2\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.3\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_20\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.left2\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = right.PositBits >> 31;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.4\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).0.right\.\PositBits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                            \Posit32::op_Addition(Posit32,Posit32).0.num3\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 0u - num3;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.5\ := to_unsigned(0, 32) - \Posit32::op_Addition(Posit32,Posit32).0.num3\;
                            \Posit32::op_Addition(Posit32,Posit32).0.num4\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit32::op_Addition(Posit32,Posit32).0.right2\.\IsNull\ := false;
                            \Posit32::op_Addition(Posit32,Posit32).0.right2\.\PositBits\ := to_unsigned(0, 32);
                            -- Invoking the target's constructor.
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.6\ := \Posit32::op_Addition(Posit32,Posit32).0.right\.\PositBits\ xor \Posit32::op_Addition(Posit32,Posit32).0.num4\;
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6928
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_21\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.6\ + \Posit32::op_Addition(Posit32,Posit32).0.num3\;
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_22\;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_22\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.7\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_23\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_23\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.right2\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 
                            -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.left2\.\PositBits\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_24\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.4\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.lengthOfRunOfBits\ := \Posit32::op_Addition(Posit32,Posit32).0.return.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_25\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_26\ => 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.right2\.\PositBits\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_27\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_27\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.5\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.lengthOfRunOfBits2\ := \Posit32::op_Addition(Posit32,Posit32).0.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.lengthOfRunOfBits\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_28\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.6\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.num5\ := \Posit32::op_Addition(Posit32,Posit32).0.return.6\;
                            -- The following section was transformed from the .NET statement below:
                            -- num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_29\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_29\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_30\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_30\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.lengthOfRunOfBits2\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_31\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_31\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.7\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.num6\ := \Posit32::op_Addition(Posit32,Posit32).0.return.7\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag5 = num == num3;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.8\ := \Posit32::op_Addition(Posit32,Posit32).0.num\ = \Posit32::op_Addition(Posit32,Posit32).0.num3\;
                            \Posit32::op_Addition(Posit32,Posit32).0.flag5\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 
                            -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.lengthOfRunOfBits\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_32\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_32\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.8\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.regimeKValueWithoutSignCheck\ := \Posit32::op_Addition(Posit32,Posit32).0.return.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.num5\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_33\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.9\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.exponentValueWithoutSignCheck\ := \Posit32::op_Addition(Posit32,Posit32).0.return.9\;
                            -- The following section was transformed from the .NET statement below:
                            -- regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_34\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_34\ => 
                        -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.lengthOfRunOfBits2\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_35\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_35\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.10\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.regimeKValueWithoutSignCheck2\ := \Posit32::op_Addition(Posit32,Posit32).0.return.10\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.right2\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.num6\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_36\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.11\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.exponentValueWithoutSignCheck2\ := \Posit32::op_Addition(Posit32,Posit32).0.return.11\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 	signBit = num == 1u;
                            -- }
                            -- else {
                            -- 	signBit = num3 == 1u;
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32).left.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32).right.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.right2\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_37\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_37\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.12\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32).return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_39\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_39\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_40\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_40\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_38\.

                            if (\Posit32::op_Addition(Posit32,Posit32).0.return.12\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_39\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_40\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_38\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = 0u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.regimeKValueWithoutSignCheck\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.exponentValueWithoutSignCheck\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(2, 8);
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_41\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_39\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	signBit = num == 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = num == 1u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.9\ := \Posit32::op_Addition(Posit32,Posit32).0.num\ = to_unsigned(1, 32);
                        \Posit32::op_Addition(Posit32,Posit32).0.signBit\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.9\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_37\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_39\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_40\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	signBit = num3 == 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = num3 == 1u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.10\ := \Posit32::op_Addition(Posit32,Posit32).0.num3\ = to_unsigned(1, 32);
                        \Posit32::op_Addition(Posit32,Posit32).0.signBit\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.10\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_37\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_40\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_41\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.13\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.num8\ := \Posit32::op_Addition(Posit32,Posit32).0.return.13\;
                            -- The following section was transformed from the .NET statement below:
                            -- num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_42\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_43\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_43\ => 
                        -- Starting state machine invocation for the following method: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.regimeKValueWithoutSignCheck2\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.exponentValueWithoutSignCheck2\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(2, 8);
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_44\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_44\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.14\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.num9\ := \Posit32::op_Addition(Posit32,Posit32).0.return.14\;
                            -- The following section was transformed from the .NET statement below:
                            -- num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.11\ := SmartResize((\Posit32::op_Addition(Posit32,Posit32).0.num8\), 32) - SmartResize((\Posit32::op_Addition(Posit32,Posit32).0.num9\), 32);
                            \Posit32::op_Addition(Posit32,Posit32).0.num10\ := (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.11\);
                            -- The following section was transformed from the .NET statement below:
                            -- if (num10 >= 0) {
                            -- 	num11 = num8;
                            -- }
                            -- else {
                            -- 	num11 = num9;
                            -- }
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.12\ := \Posit32::op_Addition(Posit32,Posit32).0.num10\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_46\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_46\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_47\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_47\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_45\.

                            if (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.12\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_46\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_47\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5911
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_45\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.left2\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.num5\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_48\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_46\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num11 = num8;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = num8;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.num11\ := \Posit32::op_Addition(Posit32,Posit32).0.num8\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_44\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_46\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_45\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_47\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num11 = num9;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = num9;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.num11\ := \Posit32::op_Addition(Posit32,Posit32).0.num9\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_44\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_47\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_45\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_48\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.15\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.num12\ := \Posit32::op_Addition(Posit32,Posit32).0.return.15\;
                            -- The following section was transformed from the .NET statement below:
                            -- num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_49\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_49\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_50\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_50\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.num6\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_51\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_51\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.16\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.num13\ := \Posit32::op_Addition(Posit32,Posit32).0.return.16\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag6 = num10 == 0;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.13\ := \Posit32::op_Addition(Posit32,Posit32).0.num10\ = to_signed(0, 32);
                            \Posit32::op_Addition(Posit32,Posit32).0.flag6\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.13\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag6) {
                            -- 	flag7 = flag5;
                            -- 	if (flag7) {
                            -- 		num7 = 0u + num12 + num13;
                            -- 	}
                            -- 	else {
                            -- 		flag8 = num12 >= num13;
                            -- 		if (flag8) {
                            -- 			num7 = num7 + num12 - num13;
                            -- 		}
                            -- 		else {
                            -- 			num7 = num7 + num13 - num12;
                            -- 		}
                            -- 	}
                            -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- }
                            -- else {
                            -- 	flag9 = num10 > 0;
                            -- 	if (flag9) {
                            -- 		num14 = (int)(num5 - num6);
                            -- 		num7 = num7 + num12;
                            -- 		num15 = (int)(31u - num5 - 1u);
                            -- 		num7 = num7 << num15;
                            -- 		num16 = num15 - num10 + num14;
                            -- 		flag10 = flag5;
                            -- 		if (flag10) {
                            -- 			flag11 = num16 >= 0;
                            -- 			if (flag11) {
                            -- 				num7 = num7 + num13 << num16;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 + num13 >> -num16;
                            -- 			}
                            -- 		}
                            -- 		else {
                            -- 			uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 			if (num16 >= 0) {
                            -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 			}
                            -- 			else {
                            -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 			}
                            -- 			num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 		}
                            -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 	}
                            -- 	else {
                            -- 		num17 = (int)(num6 - num5);
                            -- 		num7 = num7 + num13;
                            -- 		num18 = (int)(31u - num6 - 1u);
                            -- 		num7 = num7 << num18;
                            -- 		flag12 = flag5;
                            -- 		if (flag12) {
                            -- 			flag13 = num18 + num10 + num17 >= 0;
                            -- 			if (flag13) {
                            -- 				num7 = num7 + num12 << num18 + num10 + num17;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 			}
                            -- 		}
                            -- 		else {
                            -- 			flag14 = num18 + num10 + num17 >= 0;
                            -- 			if (flag14) {
                            -- 				num7 = num7 - num12 << num18 + num10 + num17;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 			}
                            -- 		}
                            -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_53\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_60\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_61\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_62\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_52\.

                            if (\Posit32::op_Addition(Posit32,Posit32).0.flag6\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_53\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_61\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_52\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_51\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag15 = num7 == 0u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.72\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ = to_unsigned(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).0.flag15\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.72\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag15) {
                        -- 	result = new Posit32 (0u, true);
                        -- }
                        -- else {
                        -- 	regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 	System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 	remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 	exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 	result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_93\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_94\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_95\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_97\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_92\.

                        if (\Posit32::op_Addition(Posit32,Posit32).0.flag15\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_93\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_95\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_53\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_51\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag7 = flag5;
                        -- 	if (flag7) {
                        -- 		num7 = 0u + num12 + num13;
                        -- 	}
                        -- 	else {
                        -- 		flag8 = num12 >= num13;
                        -- 		if (flag8) {
                        -- 			num7 = num7 + num12 - num13;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num13 - num12;
                        -- 		}
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag7 = flag5;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.flag7\ := \Posit32::op_Addition(Posit32,Posit32).0.flag5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag7) {
                        -- 	num7 = 0u + num12 + num13;
                        -- }
                        -- else {
                        -- 	flag8 = num12 >= num13;
                        -- 	if (flag8) {
                        -- 		num7 = num7 + num12 - num13;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 - num12;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_55\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_55\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_56\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_57\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_54\.

                        if (\Posit32::op_Addition(Posit32,Posit32).0.flag7\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_55\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_56\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_54\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_53\.
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_60\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_55\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_53\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = 0u + num12 + num13;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = 0u + num12 + num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.14\ := \Posit32::op_Addition(Posit32,Posit32).0.num12\ + \Posit32::op_Addition(Posit32,Posit32).0.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.15\ := to_unsigned(0, 32) + \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.14\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.15\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_53\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_55\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_54\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_56\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_53\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag8 = num12 >= num13;
                        -- 	if (flag8) {
                        -- 		num7 = num7 + num12 - num13;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 - num12;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag8 = num12 >= num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.16\ := \Posit32::op_Addition(Posit32,Posit32).0.num12\ >= \Posit32::op_Addition(Posit32,Posit32).0.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).0.flag8\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.16\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag8) {
                        -- 	num7 = num7 + num12 - num13;
                        -- }
                        -- else {
                        -- 	num7 = num7 + num13 - num12;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_58\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_58\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_59\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_59\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_57\.

                        if (\Posit32::op_Addition(Posit32,Posit32).0.flag8\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_58\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_59\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_57\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_56\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_53\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_57\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_54\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_58\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_56\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num12 - num13;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12 - num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.17\ := \Posit32::op_Addition(Posit32,Posit32).0.num12\ - \Posit32::op_Addition(Posit32,Posit32).0.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.18\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ + \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.17\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.18\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_56\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_58\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_57\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_59\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_56\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num13 - num12;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13 - num12;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.19\ := \Posit32::op_Addition(Posit32,Posit32).0.num13\ - \Posit32::op_Addition(Posit32,Posit32).0.num12\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.20\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ + \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.19\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.20\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_56\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_59\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_57\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_60\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.17\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.21\ := SmartResize(\Posit32::op_Addition(Posit32,Posit32).0.return.17\, 32) - \Posit32::op_Addition(Posit32,Posit32).0.num5\;
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.22\ := signed(SmartResize(\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.21\ - to_unsigned(1, 32), 16));
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.23\ := SmartResize(SmartResize((\Posit32::op_Addition(Posit32,Posit32).0.num11\), 32) + signed(((\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.22\))), 16);
                            \Posit32::op_Addition(Posit32,Posit32).0.num11\ := (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.23\);
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_51\.
                            if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_60\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_52\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_61\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_51\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag9 = num10 > 0;
                        -- 	if (flag9) {
                        -- 		num14 = (int)(num5 - num6);
                        -- 		num7 = num7 + num12;
                        -- 		num15 = (int)(31u - num5 - 1u);
                        -- 		num7 = num7 << num15;
                        -- 		num16 = num15 - num10 + num14;
                        -- 		flag10 = flag5;
                        -- 		if (flag10) {
                        -- 			flag11 = num16 >= 0;
                        -- 			if (flag11) {
                        -- 				num7 = num7 + num13 << num16;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 + num13 >> -num16;
                        -- 			}
                        -- 		}
                        -- 		else {
                        -- 			uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 			if (num16 >= 0) {
                        -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 			}
                        -- 			else {
                        -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 			}
                        -- 			num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 		}
                        -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 	}
                        -- 	else {
                        -- 		num17 = (int)(num6 - num5);
                        -- 		num7 = num7 + num13;
                        -- 		num18 = (int)(31u - num6 - 1u);
                        -- 		num7 = num7 << num18;
                        -- 		flag12 = flag5;
                        -- 		if (flag12) {
                        -- 			flag13 = num18 + num10 + num17 >= 0;
                        -- 			if (flag13) {
                        -- 				num7 = num7 + num12 << num18 + num10 + num17;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 			}
                        -- 		}
                        -- 		else {
                        -- 			flag14 = num18 + num10 + num17 >= 0;
                        -- 			if (flag14) {
                        -- 				num7 = num7 - num12 << num18 + num10 + num17;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 			}
                        -- 		}
                        -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag9 = num10 > 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.24\ := \Posit32::op_Addition(Posit32,Posit32).0.num10\ > to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).0.flag9\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.24\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag9) {
                        -- 	num14 = (int)(num5 - num6);
                        -- 	num7 = num7 + num12;
                        -- 	num15 = (int)(31u - num5 - 1u);
                        -- 	num7 = num7 << num15;
                        -- 	num16 = num15 - num10 + num14;
                        -- 	flag10 = flag5;
                        -- 	if (flag10) {
                        -- 		flag11 = num16 >= 0;
                        -- 		if (flag11) {
                        -- 			num7 = num7 + num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num13 >> -num16;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 		if (num16 >= 0) {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 		}
                        -- 		num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- else {
                        -- 	num17 = (int)(num6 - num5);
                        -- 	num7 = num7 + num13;
                        -- 	num18 = (int)(31u - num6 - 1u);
                        -- 	num7 = num7 << num18;
                        -- 	flag12 = flag5;
                        -- 	if (flag12) {
                        -- 		flag13 = num18 + num10 + num17 >= 0;
                        -- 		if (flag13) {
                        -- 			num7 = num7 + num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag14 = num18 + num10 + num17 >= 0;
                        -- 		if (flag14) {
                        -- 			num7 = num7 - num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_63\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_75\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_76\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_91\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_62\.

                        if (\Posit32::op_Addition(Posit32,Posit32).0.flag9\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_63\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_76\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_62\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_61\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_51\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_62\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_52\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_63\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_61\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num14 = (int)(num5 - num6);
                        -- 	num7 = num7 + num12;
                        -- 	num15 = (int)(31u - num5 - 1u);
                        -- 	num7 = num7 << num15;
                        -- 	num16 = num15 - num10 + num14;
                        -- 	flag10 = flag5;
                        -- 	if (flag10) {
                        -- 		flag11 = num16 >= 0;
                        -- 		if (flag11) {
                        -- 			num7 = num7 + num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num13 >> -num16;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 		if (num16 >= 0) {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 		}
                        -- 		num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num14 = (int)(num5 - num6);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.25\ := signed(\Posit32::op_Addition(Posit32,Posit32).0.num5\ - \Posit32::op_Addition(Posit32,Posit32).0.num6\);
                        \Posit32::op_Addition(Posit32,Posit32).0.num14\ := (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.25\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.26\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ + \Posit32::op_Addition(Posit32,Posit32).0.num12\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.26\;
                        -- The following section was transformed from the .NET statement below:
                        -- num15 = (int)(31u - num5 - 1u);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.27\ := to_unsigned(31, 32) - \Posit32::op_Addition(Posit32,Posit32).0.num5\;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_64\;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_64\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.28\ := signed(\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.27\ - to_unsigned(1, 32));
                        \Posit32::op_Addition(Posit32,Posit32).0.num15\ := (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.28\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 << num15;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.29\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).0.num7\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).0.num15\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.29\;
                        -- The following section was transformed from the .NET statement below:
                        -- num16 = num15 - num10 + num14;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.30\ := \Posit32::op_Addition(Posit32,Posit32).0.num15\ - \Posit32::op_Addition(Posit32,Posit32).0.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_65\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_65\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.31\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.30\ + \Posit32::op_Addition(Posit32,Posit32).0.num14\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num16\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.31\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag10 = flag5;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.flag10\ := \Posit32::op_Addition(Posit32,Posit32).0.flag5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag10) {
                        -- 	flag11 = num16 >= 0;
                        -- 	if (flag11) {
                        -- 		num7 = num7 + num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 >> -num16;
                        -- 	}
                        -- }
                        -- else {
                        -- 	uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	if (num16 >= 0) {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 	}
                        -- 	num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_67\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_68\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_71\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_72\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_66\.

                        if (\Posit32::op_Addition(Posit32,Posit32).0.flag10\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_67\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_71\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_66\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_65\.
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_75\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_67\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_65\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag11 = num16 >= 0;
                        -- 	if (flag11) {
                        -- 		num7 = num7 + num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 >> -num16;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag11 = num16 >= 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.32\ := \Posit32::op_Addition(Posit32,Posit32).0.num16\ >= to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).0.flag11\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.32\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag11) {
                        -- 	num7 = num7 + num13 << num16;
                        -- }
                        -- else {
                        -- 	num7 = num7 + num13 >> -num16;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_69\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_69\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_70\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_70\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_68\.

                        if (\Posit32::op_Addition(Posit32,Posit32).0.flag11\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_69\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_70\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_68\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_67\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_65\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_68\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_66\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_69\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_67\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num13 << num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13 << num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.33\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).0.num13\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).0.num16\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.34\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ + \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.33\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.34\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_67\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_69\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_68\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_70\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_67\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num13 >> -num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13 >> -num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.35\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).0.num13\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).0.num16\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.36\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ + \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.35\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.36\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_67\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_70\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_68\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_71\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_65\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	if (num16 >= 0) {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 	}
                        -- 	num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num16 >= 0) {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- }
                        -- else {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- }
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.37\ := \Posit32::op_Addition(Posit32,Posit32).0.num16\ >= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_73\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_73\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_74\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_74\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_72\.

                        if (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.37\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_73\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_74\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_72\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_71\.
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.40\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ - \Posit32::op_Addition(Posit32,Posit32).0.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.40\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_65\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_72\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_66\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_73\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_71\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.38\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).0.num13\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).0.num16\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).0.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.38\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_71\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_73\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_72\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_74\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_71\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.39\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).0.num13\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).0.num16\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).0.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.39\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_71\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_74\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_72\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_75\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.18\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.41\ := SmartResize(signed(SmartResize((\Posit32::op_Addition(Posit32,Posit32).0.return.18\), 32)) - to_signed(31, 32), 16);
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.42\ := SmartResize(SmartResize((\Posit32::op_Addition(Posit32,Posit32).0.num11\), 32) + signed(SmartResize(((\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.41\)), 32)), 16);
                            \Posit32::op_Addition(Posit32,Posit32).0.num11\ := (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.42\);
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_61\.
                            if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_75\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_62\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_76\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_61\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num17 = (int)(num6 - num5);
                        -- 	num7 = num7 + num13;
                        -- 	num18 = (int)(31u - num6 - 1u);
                        -- 	num7 = num7 << num18;
                        -- 	flag12 = flag5;
                        -- 	if (flag12) {
                        -- 		flag13 = num18 + num10 + num17 >= 0;
                        -- 		if (flag13) {
                        -- 			num7 = num7 + num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag14 = num18 + num10 + num17 >= 0;
                        -- 		if (flag14) {
                        -- 			num7 = num7 - num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num17 = (int)(num6 - num5);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.43\ := signed(\Posit32::op_Addition(Posit32,Posit32).0.num6\ - \Posit32::op_Addition(Posit32,Posit32).0.num5\);
                        \Posit32::op_Addition(Posit32,Posit32).0.num17\ := (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.43\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.44\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ + \Posit32::op_Addition(Posit32,Posit32).0.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.44\;
                        -- The following section was transformed from the .NET statement below:
                        -- num18 = (int)(31u - num6 - 1u);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.45\ := to_unsigned(31, 32) - \Posit32::op_Addition(Posit32,Posit32).0.num6\;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_77\;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_77\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.46\ := signed(\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.45\ - to_unsigned(1, 32));
                        \Posit32::op_Addition(Posit32,Posit32).0.num18\ := (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.46\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 << num18;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.47\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).0.num7\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).0.num18\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.47\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag12 = flag5;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.flag12\ := \Posit32::op_Addition(Posit32,Posit32).0.flag5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag12) {
                        -- 	flag13 = num18 + num10 + num17 >= 0;
                        -- 	if (flag13) {
                        -- 		num7 = num7 + num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- else {
                        -- 	flag14 = num18 + num10 + num17 >= 0;
                        -- 	if (flag14) {
                        -- 		num7 = num7 - num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_79\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_80\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_85\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_86\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_78\.

                        if (\Posit32::op_Addition(Posit32,Posit32).0.flag12\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_79\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_85\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_78\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_77\.
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_91\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_79\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_77\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag13 = num18 + num10 + num17 >= 0;
                        -- 	if (flag13) {
                        -- 		num7 = num7 + num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag13 = num18 + num10 + num17 >= 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.48\ := \Posit32::op_Addition(Posit32,Posit32).0.num18\ + \Posit32::op_Addition(Posit32,Posit32).0.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.49\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.48\ + \Posit32::op_Addition(Posit32,Posit32).0.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.50\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.49\ >= to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).0.flag13\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.50\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag13) {
                        -- 	num7 = num7 + num12 << num18 + num10 + num17;
                        -- }
                        -- else {
                        -- 	num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_81\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_82\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_83\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_84\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_80\.

                        if (\Posit32::op_Addition(Posit32,Posit32).0.flag13\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_81\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_83\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9067
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_80\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_79\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_77\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_80\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_78\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_81\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_79\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num12 << num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12 << num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.51\ := \Posit32::op_Addition(Posit32,Posit32).0.num18\ + \Posit32::op_Addition(Posit32,Posit32).0.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.52\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.51\ + \Posit32::op_Addition(Posit32,Posit32).0.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.53\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).0.num12\, to_integer(unsigned(SmartResize(\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.52\, 5))));
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_82\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_82\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.54\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ + \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.53\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.54\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_79\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_82\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_80\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_83\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_79\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.55\ := \Posit32::op_Addition(Posit32,Posit32).0.num18\ + \Posit32::op_Addition(Posit32,Posit32).0.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.56\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.55\ + \Posit32::op_Addition(Posit32,Posit32).0.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.57\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).0.num12\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.56\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_84\;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_84\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.58\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ + \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.57\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.58\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_79\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_84\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_80\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_85\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_77\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag14 = num18 + num10 + num17 >= 0;
                        -- 	if (flag14) {
                        -- 		num7 = num7 - num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag14 = num18 + num10 + num17 >= 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.59\ := \Posit32::op_Addition(Posit32,Posit32).0.num18\ + \Posit32::op_Addition(Posit32,Posit32).0.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.60\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.59\ + \Posit32::op_Addition(Posit32,Posit32).0.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.61\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.60\ >= to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).0.flag14\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.61\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag14) {
                        -- 	num7 = num7 - num12 << num18 + num10 + num17;
                        -- }
                        -- else {
                        -- 	num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_87\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_88\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).0._State_89\ and ends in state \Posit32::op_Addition(Posit32,Posit32).0._State_90\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).0._State_86\.

                        if (\Posit32::op_Addition(Posit32,Posit32).0.flag14\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_87\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_89\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9067
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_86\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_85\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_77\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_86\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_78\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_87\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_85\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 - num12 << num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 - num12 << num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.62\ := \Posit32::op_Addition(Posit32,Posit32).0.num18\ + \Posit32::op_Addition(Posit32,Posit32).0.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.63\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.62\ + \Posit32::op_Addition(Posit32,Posit32).0.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.64\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).0.num12\, to_integer(unsigned(SmartResize(\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.63\, 5))));
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_88\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_88\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.65\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ - \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.64\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.65\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_85\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_88\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_86\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_89\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_85\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.66\ := \Posit32::op_Addition(Posit32,Posit32).0.num18\ + \Posit32::op_Addition(Posit32,Posit32).0.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.67\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.66\ + \Posit32::op_Addition(Posit32,Posit32).0.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.68\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).0.num12\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.67\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_90\;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_90\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.69\ := \Posit32::op_Addition(Posit32,Posit32).0.num7\ - \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.68\;
                        \Posit32::op_Addition(Posit32,Posit32).0.num7\ := \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.69\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_85\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_90\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_86\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_91\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.19\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.70\ := SmartResize(signed(SmartResize((\Posit32::op_Addition(Posit32,Posit32).0.return.19\), 32)) - to_signed(31, 32), 16);
                            \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.71\ := SmartResize(SmartResize((\Posit32::op_Addition(Posit32,Posit32).0.num11\), 32) + signed(SmartResize(((\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.70\)), 32)), 16);
                            \Posit32::op_Addition(Posit32,Posit32).0.num11\ := (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.71\);
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_61\.
                            if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_91\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_62\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_92\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_52\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_15\.
                        if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_92\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_93\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new Posit32 (0u, true);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit32 (0u, true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::op_Addition(Posit32,Posit32).0.result\.\IsNull\ := false;
                        \Posit32::op_Addition(Posit32,Posit32).0.result\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.result\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_94\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_94\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.result\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_52\.
                            if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_94\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_92\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_95\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).0._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 	System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 	remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 	exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 	result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.73\ := SmartResize((\Posit32::op_Addition(Posit32,Posit32).0.num11\), 32) / to_signed(4, 32);
                        \Posit32::op_Addition(Posit32,Posit32).0.regimeKValue\ := (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.73\);
                        -- The following section was transformed from the .NET statement below:
                        -- System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ := SmartResize((\Posit32::op_Addition(Posit32,Posit32).0.num11\), 32);
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.74\ := \Posit32::op_Addition(Posit32,Posit32).0.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ / to_signed(4, 32);
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.75\ := SmartResize(\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.74\ * to_signed(4, 32), 32);
                        \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.76\ := unsigned(\Posit32::op_Addition(Posit32,Posit32).0.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ - \Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.75\);
                        \Posit32::op_Addition(Posit32,Posit32).0.exponentBits\ := (\Posit32::op_Addition(Posit32,Posit32).0.binaryOperationResult.76\);
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::op_Addition(Posit32,Posit32).0.result\.\IsNull\ := false;
                        \Posit32::op_Addition(Posit32,Posit32).0.result\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.signBit\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.regimeKValue\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.exponentBits\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_96\;
                        -- Clock cycles needed to complete this state (approximation): 0.6156
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_96\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.return.20\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.result\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.return.20\;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_97\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).0._State_97\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).0.result\ := \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).0._State_52\.
                            if (\Posit32::op_Addition(Posit32,Posit32).0._State\ = \Posit32::op_Addition(Posit32,Posit32).0._State_97\) then 
                                \Posit32::op_Addition(Posit32,Posit32).0._State\ := \Posit32::op_Addition(Posit32,Posit32).0._State_92\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 state machine end


    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 state machine start
    \Posit32::op_Addition(Posit32,Posit32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::op_Addition(Posit32,Posit32).1._State\: \Posit32::op_Addition(Posit32,Posit32).1._States\ := \Posit32::op_Addition(Posit32,Posit32).1._State_0\;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.left\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.result\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag2\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag3\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag4\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.left2\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.right2\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.lengthOfRunOfBits\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.lengthOfRunOfBits2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag5\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.regimeKValueWithoutSignCheck\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.exponentValueWithoutSignCheck\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.regimeKValueWithoutSignCheck2\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.exponentValueWithoutSignCheck2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.signBit\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num8\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num9\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num11\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag6\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag7\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag8\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag9\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag10\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag11\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.num18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag12\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag13\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag14\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.flag15\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.exponentBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.0\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.1\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.2\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.3\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.4\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.5\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.8\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.8\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.10\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.12\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.9\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.10\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.13\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.14\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.12\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.16\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.13\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.14\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.16\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.17\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.18\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.19\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.20\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.17\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.21\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.22\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.23\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.24\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.25\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.26\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.27\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.29\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.30\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.31\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.32\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.33\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.34\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.35\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.36\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.37\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.38\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.39\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.40\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.18\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.41\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.42\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.43\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.44\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.45\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.46\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.47\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.48\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.49\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.50\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.51\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.52\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.53\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.54\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.55\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.56\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.57\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.58\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.59\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.60\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.61\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.62\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.63\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.64\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.65\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.66\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.67\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.68\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.69\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.19\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.70\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.71\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.72\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.73\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.74\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.75\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.76\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).1.return.20\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::op_Addition(Posit32,Posit32).1._Finished\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_0\;
                \Posit32::op_Addition(Posit32,Posit32).1.flag\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.flag2\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.flag3\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.flag4\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.num\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.num2\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.num3\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.num4\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.lengthOfRunOfBits\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.lengthOfRunOfBits2\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.num5\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.num6\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.flag5\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.regimeKValueWithoutSignCheck\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.exponentValueWithoutSignCheck\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.regimeKValueWithoutSignCheck2\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.exponentValueWithoutSignCheck2\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.signBit\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.num7\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.num8\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).1.num9\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).1.num10\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.num11\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).1.num12\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.num13\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.flag6\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.flag7\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.flag8\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.flag9\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.num14\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.num15\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.num16\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.flag10\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.flag11\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.num17\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.num18\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.flag12\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.flag13\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.flag14\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.flag15\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.regimeKValue\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.exponentBits\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.return.0\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.return.1\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.return.2\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.return.3\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.4\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.6\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.return.4\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.return.5\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.return.6\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.return.7\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.8\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.return.8\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.return.9\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.return.10\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.return.11\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.return.12\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.9\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.10\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.return.13\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).1.return.14\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.11\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.12\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.return.15\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.return.16\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.13\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.14\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.15\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.16\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.17\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.18\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.19\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.20\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.return.17\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.21\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.22\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.23\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.24\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.25\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.26\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.27\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.28\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.29\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.30\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.31\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.32\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.33\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.34\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.35\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.36\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.37\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.38\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.39\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.40\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.return.18\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.41\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.42\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.43\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.44\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.45\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.46\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.47\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.48\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.49\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.50\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.51\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.52\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.53\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.54\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.55\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.56\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.57\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.58\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.59\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.60\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.61\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.62\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.63\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.64\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.65\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.66\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.67\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.68\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.69\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.return.19\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.70\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.71\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.72\ := false;
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.73\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.74\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.75\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.76\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).1.return.20\ := to_unsigned(0, 32);
            else 
                case \Posit32::op_Addition(Posit32,Posit32).1._State\ is 
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._Started\ = true) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._Started\ = true) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._Finished\ <= true;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).1._Finished\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_2\ => 
                        \Posit32::op_Addition(Posit32,Posit32).1.left\ := \Posit32::op_Addition(Posit32,Posit32).1.left.parameter.In\;
                        \Posit32::op_Addition(Posit32,Posit32).1.right\ := \Posit32::op_Addition(Posit32,Posit32).1.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 left2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 right2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte lengthOfRunOfBits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte lengthOfRunOfBits2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte regimeKValueWithoutSignCheck;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentValueWithoutSignCheck;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte regimeKValueWithoutSignCheck2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentValueWithoutSignCheck2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool signBit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- short num8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- short num9;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num10;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- short num11;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num12;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num13;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag9;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num14;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num15;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num16;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag10;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag11;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num17;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num18;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag12;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag13;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag14;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag15;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int regimeKValue;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentBits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = Lombiq.Arithmetics.Posit32.IsNaN (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.left\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.0\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.flag\ := \Posit32::op_Addition(Posit32,Posit32).1.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	result = left;
                            -- }
                            -- else {
                            -- 	flag2 = Lombiq.Arithmetics.Posit32.IsNaN (right);
                            -- 	if (flag2) {
                            -- 		result = right;
                            -- 	}
                            -- 	else {
                            -- 		flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                            -- 		if (flag3) {
                            -- 			result = right;
                            -- 		}
                            -- 		else {
                            -- 			flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                            -- 			if (flag4) {
                            -- 				result = left;
                            -- 			}
                            -- 			else {
                            -- 				num = left.PositBits >> 31;
                            -- 				num2 = 0u - num;
                            -- 				left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 				num3 = right.PositBits >> 31;
                            -- 				num4 = 0u - num3;
                            -- 				right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 				lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 				lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 				num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 				num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 				flag5 = num == num3;
                            -- 				regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 				exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 				regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 				exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 				if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 					signBit = num == 1u;
                            -- 				}
                            -- 				else {
                            -- 					signBit = num3 == 1u;
                            -- 				}
                            -- 				num7 = 0u;
                            -- 				num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 				num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 				num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 				if (num10 >= 0) {
                            -- 					num11 = num8;
                            -- 				}
                            -- 				else {
                            -- 					num11 = num9;
                            -- 				}
                            -- 				num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 				num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 				flag6 = num10 == 0;
                            -- 				if (flag6) {
                            -- 					flag7 = flag5;
                            -- 					if (flag7) {
                            -- 						num7 = 0u + num12 + num13;
                            -- 					}
                            -- 					else {
                            -- 						flag8 = num12 >= num13;
                            -- 						if (flag8) {
                            -- 							num7 = num7 + num12 - num13;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 + num13 - num12;
                            -- 						}
                            -- 					}
                            -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 				}
                            -- 				else {
                            -- 					flag9 = num10 > 0;
                            -- 					if (flag9) {
                            -- 						num14 = (int)(num5 - num6);
                            -- 						num7 = num7 + num12;
                            -- 						num15 = (int)(31u - num5 - 1u);
                            -- 						num7 = num7 << num15;
                            -- 						num16 = num15 - num10 + num14;
                            -- 						flag10 = flag5;
                            -- 						if (flag10) {
                            -- 							flag11 = num16 >= 0;
                            -- 							if (flag11) {
                            -- 								num7 = num7 + num13 << num16;
                            -- 							}
                            -- 							else {
                            -- 								num7 = num7 + num13 >> -num16;
                            -- 							}
                            -- 						}
                            -- 						else {
                            -- 							uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 							if (num16 >= 0) {
                            -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 							}
                            -- 							else {
                            -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 							}
                            -- 							num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 						}
                            -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 					}
                            -- 					else {
                            -- 						num17 = (int)(num6 - num5);
                            -- 						num7 = num7 + num13;
                            -- 						num18 = (int)(31u - num6 - 1u);
                            -- 						num7 = num7 << num18;
                            -- 						flag12 = flag5;
                            -- 						if (flag12) {
                            -- 							flag13 = num18 + num10 + num17 >= 0;
                            -- 							if (flag13) {
                            -- 								num7 = num7 + num12 << num18 + num10 + num17;
                            -- 							}
                            -- 							else {
                            -- 								num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 							}
                            -- 						}
                            -- 						else {
                            -- 							flag14 = num18 + num10 + num17 >= 0;
                            -- 							if (flag14) {
                            -- 								num7 = num7 - num12 << num18 + num10 + num17;
                            -- 							}
                            -- 							else {
                            -- 								num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 							}
                            -- 						}
                            -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 					}
                            -- 				}
                            -- 				flag15 = num7 == 0u;
                            -- 				if (flag15) {
                            -- 					result = new Posit32 (0u, true);
                            -- 				}
                            -- 				else {
                            -- 					regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 					System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 					remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 					exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 					result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 				}
                            -- 			}
                            -- 		}
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_5\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_5\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_6\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_8\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_4\.

                            if (\Posit32::op_Addition(Posit32,Posit32).1.flag\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_5\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.return\ <= \Posit32::op_Addition(Posit32,Posit32).1.result\;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.result\ := \Posit32::op_Addition(Posit32,Posit32).1.left\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_3\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_5\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag2 = Lombiq.Arithmetics.Posit32.IsNaN (right);
                        -- 	if (flag2) {
                        -- 		result = right;
                        -- 	}
                        -- 	else {
                        -- 		flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                        -- 		if (flag3) {
                        -- 			result = right;
                        -- 		}
                        -- 		else {
                        -- 			flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 			if (flag4) {
                        -- 				result = left;
                        -- 			}
                        -- 			else {
                        -- 				num = left.PositBits >> 31;
                        -- 				num2 = 0u - num;
                        -- 				left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 				num3 = right.PositBits >> 31;
                        -- 				num4 = 0u - num3;
                        -- 				right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 				lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 				lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 				num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 				num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 				flag5 = num == num3;
                        -- 				regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 				exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 				regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 				exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 				if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 					signBit = num == 1u;
                        -- 				}
                        -- 				else {
                        -- 					signBit = num3 == 1u;
                        -- 				}
                        -- 				num7 = 0u;
                        -- 				num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 				num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 				num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 				if (num10 >= 0) {
                        -- 					num11 = num8;
                        -- 				}
                        -- 				else {
                        -- 					num11 = num9;
                        -- 				}
                        -- 				num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 				num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 				flag6 = num10 == 0;
                        -- 				if (flag6) {
                        -- 					flag7 = flag5;
                        -- 					if (flag7) {
                        -- 						num7 = 0u + num12 + num13;
                        -- 					}
                        -- 					else {
                        -- 						flag8 = num12 >= num13;
                        -- 						if (flag8) {
                        -- 							num7 = num7 + num12 - num13;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 + num13 - num12;
                        -- 						}
                        -- 					}
                        -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 				}
                        -- 				else {
                        -- 					flag9 = num10 > 0;
                        -- 					if (flag9) {
                        -- 						num14 = (int)(num5 - num6);
                        -- 						num7 = num7 + num12;
                        -- 						num15 = (int)(31u - num5 - 1u);
                        -- 						num7 = num7 << num15;
                        -- 						num16 = num15 - num10 + num14;
                        -- 						flag10 = flag5;
                        -- 						if (flag10) {
                        -- 							flag11 = num16 >= 0;
                        -- 							if (flag11) {
                        -- 								num7 = num7 + num13 << num16;
                        -- 							}
                        -- 							else {
                        -- 								num7 = num7 + num13 >> -num16;
                        -- 							}
                        -- 						}
                        -- 						else {
                        -- 							uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 							if (num16 >= 0) {
                        -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 							}
                        -- 							else {
                        -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 							}
                        -- 							num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 						}
                        -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 					}
                        -- 					else {
                        -- 						num17 = (int)(num6 - num5);
                        -- 						num7 = num7 + num13;
                        -- 						num18 = (int)(31u - num6 - 1u);
                        -- 						num7 = num7 << num18;
                        -- 						flag12 = flag5;
                        -- 						if (flag12) {
                        -- 							flag13 = num18 + num10 + num17 >= 0;
                        -- 							if (flag13) {
                        -- 								num7 = num7 + num12 << num18 + num10 + num17;
                        -- 							}
                        -- 							else {
                        -- 								num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 							}
                        -- 						}
                        -- 						else {
                        -- 							flag14 = num18 + num10 + num17 >= 0;
                        -- 							if (flag14) {
                        -- 								num7 = num7 - num12 << num18 + num10 + num17;
                        -- 							}
                        -- 							else {
                        -- 								num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 							}
                        -- 						}
                        -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 					}
                        -- 				}
                        -- 				flag15 = num7 == 0u;
                        -- 				if (flag15) {
                        -- 					result = new Posit32 (0u, true);
                        -- 				}
                        -- 				else {
                        -- 					regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 					System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 					remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 					exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 					result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 				}
                        -- 			}
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = Lombiq.Arithmetics.Posit32.IsNaN (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.right\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.1\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.flag2\ := \Posit32::op_Addition(Posit32,Posit32).1.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag2) {
                            -- 	result = right;
                            -- }
                            -- else {
                            -- 	flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                            -- 	if (flag3) {
                            -- 		result = right;
                            -- 	}
                            -- 	else {
                            -- 		flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                            -- 		if (flag4) {
                            -- 			result = left;
                            -- 		}
                            -- 		else {
                            -- 			num = left.PositBits >> 31;
                            -- 			num2 = 0u - num;
                            -- 			left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 			num3 = right.PositBits >> 31;
                            -- 			num4 = 0u - num3;
                            -- 			right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 			lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 			lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 			num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 			num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 			flag5 = num == num3;
                            -- 			regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 			exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 			regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 			exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 			if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 				signBit = num == 1u;
                            -- 			}
                            -- 			else {
                            -- 				signBit = num3 == 1u;
                            -- 			}
                            -- 			num7 = 0u;
                            -- 			num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 			num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 			num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 			if (num10 >= 0) {
                            -- 				num11 = num8;
                            -- 			}
                            -- 			else {
                            -- 				num11 = num9;
                            -- 			}
                            -- 			num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 			num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 			flag6 = num10 == 0;
                            -- 			if (flag6) {
                            -- 				flag7 = flag5;
                            -- 				if (flag7) {
                            -- 					num7 = 0u + num12 + num13;
                            -- 				}
                            -- 				else {
                            -- 					flag8 = num12 >= num13;
                            -- 					if (flag8) {
                            -- 						num7 = num7 + num12 - num13;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 + num13 - num12;
                            -- 					}
                            -- 				}
                            -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 			}
                            -- 			else {
                            -- 				flag9 = num10 > 0;
                            -- 				if (flag9) {
                            -- 					num14 = (int)(num5 - num6);
                            -- 					num7 = num7 + num12;
                            -- 					num15 = (int)(31u - num5 - 1u);
                            -- 					num7 = num7 << num15;
                            -- 					num16 = num15 - num10 + num14;
                            -- 					flag10 = flag5;
                            -- 					if (flag10) {
                            -- 						flag11 = num16 >= 0;
                            -- 						if (flag11) {
                            -- 							num7 = num7 + num13 << num16;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 + num13 >> -num16;
                            -- 						}
                            -- 					}
                            -- 					else {
                            -- 						uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 						if (num16 >= 0) {
                            -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 						}
                            -- 						else {
                            -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 						}
                            -- 						num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 					}
                            -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 				}
                            -- 				else {
                            -- 					num17 = (int)(num6 - num5);
                            -- 					num7 = num7 + num13;
                            -- 					num18 = (int)(31u - num6 - 1u);
                            -- 					num7 = num7 << num18;
                            -- 					flag12 = flag5;
                            -- 					if (flag12) {
                            -- 						flag13 = num18 + num10 + num17 >= 0;
                            -- 						if (flag13) {
                            -- 							num7 = num7 + num12 << num18 + num10 + num17;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 						}
                            -- 					}
                            -- 					else {
                            -- 						flag14 = num18 + num10 + num17 >= 0;
                            -- 						if (flag14) {
                            -- 							num7 = num7 - num12 << num18 + num10 + num17;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 						}
                            -- 					}
                            -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 				}
                            -- 			}
                            -- 			flag15 = num7 == 0u;
                            -- 			if (flag15) {
                            -- 				result = new Posit32 (0u, true);
                            -- 			}
                            -- 			else {
                            -- 				regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 				System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 				remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 				exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 				result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 			}
                            -- 		}
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_9\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_9\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_10\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_12\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_8\.

                            if (\Posit32::op_Addition(Posit32,Posit32).1.flag2\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_9\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_8\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_7\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_3\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_8\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_9\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = right;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = right;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.result\ := \Posit32::op_Addition(Posit32,Posit32).1.right\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_7\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_9\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_10\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                        -- 	if (flag3) {
                        -- 		result = right;
                        -- 	}
                        -- 	else {
                        -- 		flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 		if (flag4) {
                        -- 			result = left;
                        -- 		}
                        -- 		else {
                        -- 			num = left.PositBits >> 31;
                        -- 			num2 = 0u - num;
                        -- 			left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 			num3 = right.PositBits >> 31;
                        -- 			num4 = 0u - num3;
                        -- 			right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 			lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 			lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 			num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 			num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 			flag5 = num == num3;
                        -- 			regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 			exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 			regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 			exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 			if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 				signBit = num == 1u;
                        -- 			}
                        -- 			else {
                        -- 				signBit = num3 == 1u;
                        -- 			}
                        -- 			num7 = 0u;
                        -- 			num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 			num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 			num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 			if (num10 >= 0) {
                        -- 				num11 = num8;
                        -- 			}
                        -- 			else {
                        -- 				num11 = num9;
                        -- 			}
                        -- 			num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 			num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 			flag6 = num10 == 0;
                        -- 			if (flag6) {
                        -- 				flag7 = flag5;
                        -- 				if (flag7) {
                        -- 					num7 = 0u + num12 + num13;
                        -- 				}
                        -- 				else {
                        -- 					flag8 = num12 >= num13;
                        -- 					if (flag8) {
                        -- 						num7 = num7 + num12 - num13;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 + num13 - num12;
                        -- 					}
                        -- 				}
                        -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 			}
                        -- 			else {
                        -- 				flag9 = num10 > 0;
                        -- 				if (flag9) {
                        -- 					num14 = (int)(num5 - num6);
                        -- 					num7 = num7 + num12;
                        -- 					num15 = (int)(31u - num5 - 1u);
                        -- 					num7 = num7 << num15;
                        -- 					num16 = num15 - num10 + num14;
                        -- 					flag10 = flag5;
                        -- 					if (flag10) {
                        -- 						flag11 = num16 >= 0;
                        -- 						if (flag11) {
                        -- 							num7 = num7 + num13 << num16;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 + num13 >> -num16;
                        -- 						}
                        -- 					}
                        -- 					else {
                        -- 						uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 						if (num16 >= 0) {
                        -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 						}
                        -- 						else {
                        -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 						}
                        -- 						num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 					}
                        -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 				}
                        -- 				else {
                        -- 					num17 = (int)(num6 - num5);
                        -- 					num7 = num7 + num13;
                        -- 					num18 = (int)(31u - num6 - 1u);
                        -- 					num7 = num7 << num18;
                        -- 					flag12 = flag5;
                        -- 					if (flag12) {
                        -- 						flag13 = num18 + num10 + num17 >= 0;
                        -- 						if (flag13) {
                        -- 							num7 = num7 + num12 << num18 + num10 + num17;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 						}
                        -- 					}
                        -- 					else {
                        -- 						flag14 = num18 + num10 + num17 >= 0;
                        -- 						if (flag14) {
                        -- 							num7 = num7 - num12 << num18 + num10 + num17;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 						}
                        -- 					}
                        -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 				}
                        -- 			}
                        -- 			flag15 = num7 == 0u;
                        -- 			if (flag15) {
                        -- 				result = new Posit32 (0u, true);
                        -- 			}
                        -- 			else {
                        -- 				regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 				System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 				remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 				exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 				result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 			}
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.left\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.2\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.flag3\ := \Posit32::op_Addition(Posit32,Posit32).1.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag3) {
                            -- 	result = right;
                            -- }
                            -- else {
                            -- 	flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                            -- 	if (flag4) {
                            -- 		result = left;
                            -- 	}
                            -- 	else {
                            -- 		num = left.PositBits >> 31;
                            -- 		num2 = 0u - num;
                            -- 		left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 		num3 = right.PositBits >> 31;
                            -- 		num4 = 0u - num3;
                            -- 		right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 		lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 		lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 		num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 		num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 		flag5 = num == num3;
                            -- 		regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 		exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 		regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 		exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 		if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 			signBit = num == 1u;
                            -- 		}
                            -- 		else {
                            -- 			signBit = num3 == 1u;
                            -- 		}
                            -- 		num7 = 0u;
                            -- 		num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 		num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 		num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 		if (num10 >= 0) {
                            -- 			num11 = num8;
                            -- 		}
                            -- 		else {
                            -- 			num11 = num9;
                            -- 		}
                            -- 		num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 		num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 		flag6 = num10 == 0;
                            -- 		if (flag6) {
                            -- 			flag7 = flag5;
                            -- 			if (flag7) {
                            -- 				num7 = 0u + num12 + num13;
                            -- 			}
                            -- 			else {
                            -- 				flag8 = num12 >= num13;
                            -- 				if (flag8) {
                            -- 					num7 = num7 + num12 - num13;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 + num13 - num12;
                            -- 				}
                            -- 			}
                            -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 		}
                            -- 		else {
                            -- 			flag9 = num10 > 0;
                            -- 			if (flag9) {
                            -- 				num14 = (int)(num5 - num6);
                            -- 				num7 = num7 + num12;
                            -- 				num15 = (int)(31u - num5 - 1u);
                            -- 				num7 = num7 << num15;
                            -- 				num16 = num15 - num10 + num14;
                            -- 				flag10 = flag5;
                            -- 				if (flag10) {
                            -- 					flag11 = num16 >= 0;
                            -- 					if (flag11) {
                            -- 						num7 = num7 + num13 << num16;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 + num13 >> -num16;
                            -- 					}
                            -- 				}
                            -- 				else {
                            -- 					uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 					if (num16 >= 0) {
                            -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 					}
                            -- 					else {
                            -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 					}
                            -- 					num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 				}
                            -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 			}
                            -- 			else {
                            -- 				num17 = (int)(num6 - num5);
                            -- 				num7 = num7 + num13;
                            -- 				num18 = (int)(31u - num6 - 1u);
                            -- 				num7 = num7 << num18;
                            -- 				flag12 = flag5;
                            -- 				if (flag12) {
                            -- 					flag13 = num18 + num10 + num17 >= 0;
                            -- 					if (flag13) {
                            -- 						num7 = num7 + num12 << num18 + num10 + num17;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 					}
                            -- 				}
                            -- 				else {
                            -- 					flag14 = num18 + num10 + num17 >= 0;
                            -- 					if (flag14) {
                            -- 						num7 = num7 - num12 << num18 + num10 + num17;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 					}
                            -- 				}
                            -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 			}
                            -- 		}
                            -- 		flag15 = num7 == 0u;
                            -- 		if (flag15) {
                            -- 			result = new Posit32 (0u, true);
                            -- 		}
                            -- 		else {
                            -- 			regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 			System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 			remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 			exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 			result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 		}
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_13\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_13\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_14\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_16\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_12\.

                            if (\Posit32::op_Addition(Posit32,Posit32).1.flag3\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_13\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_14\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_12\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_11\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_7\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_12\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_13\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = right;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = right;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.result\ := \Posit32::op_Addition(Posit32,Posit32).1.right\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_11\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_13\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_14\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 	if (flag4) {
                        -- 		result = left;
                        -- 	}
                        -- 	else {
                        -- 		num = left.PositBits >> 31;
                        -- 		num2 = 0u - num;
                        -- 		left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 		num3 = right.PositBits >> 31;
                        -- 		num4 = 0u - num3;
                        -- 		right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 		lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 		lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 		num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 		num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 		flag5 = num == num3;
                        -- 		regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 		exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 		regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 		exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 		if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 			signBit = num == 1u;
                        -- 		}
                        -- 		else {
                        -- 			signBit = num3 == 1u;
                        -- 		}
                        -- 		num7 = 0u;
                        -- 		num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 		num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 		num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 		if (num10 >= 0) {
                        -- 			num11 = num8;
                        -- 		}
                        -- 		else {
                        -- 			num11 = num9;
                        -- 		}
                        -- 		num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 		num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 		flag6 = num10 == 0;
                        -- 		if (flag6) {
                        -- 			flag7 = flag5;
                        -- 			if (flag7) {
                        -- 				num7 = 0u + num12 + num13;
                        -- 			}
                        -- 			else {
                        -- 				flag8 = num12 >= num13;
                        -- 				if (flag8) {
                        -- 					num7 = num7 + num12 - num13;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 + num13 - num12;
                        -- 				}
                        -- 			}
                        -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 		}
                        -- 		else {
                        -- 			flag9 = num10 > 0;
                        -- 			if (flag9) {
                        -- 				num14 = (int)(num5 - num6);
                        -- 				num7 = num7 + num12;
                        -- 				num15 = (int)(31u - num5 - 1u);
                        -- 				num7 = num7 << num15;
                        -- 				num16 = num15 - num10 + num14;
                        -- 				flag10 = flag5;
                        -- 				if (flag10) {
                        -- 					flag11 = num16 >= 0;
                        -- 					if (flag11) {
                        -- 						num7 = num7 + num13 << num16;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 + num13 >> -num16;
                        -- 					}
                        -- 				}
                        -- 				else {
                        -- 					uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 					if (num16 >= 0) {
                        -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 					}
                        -- 					else {
                        -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 					}
                        -- 					num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 				}
                        -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 			}
                        -- 			else {
                        -- 				num17 = (int)(num6 - num5);
                        -- 				num7 = num7 + num13;
                        -- 				num18 = (int)(31u - num6 - 1u);
                        -- 				num7 = num7 << num18;
                        -- 				flag12 = flag5;
                        -- 				if (flag12) {
                        -- 					flag13 = num18 + num10 + num17 >= 0;
                        -- 					if (flag13) {
                        -- 						num7 = num7 + num12 << num18 + num10 + num17;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 					}
                        -- 				}
                        -- 				else {
                        -- 					flag14 = num18 + num10 + num17 >= 0;
                        -- 					if (flag14) {
                        -- 						num7 = num7 - num12 << num18 + num10 + num17;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 					}
                        -- 				}
                        -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 			}
                        -- 		}
                        -- 		flag15 = num7 == 0u;
                        -- 		if (flag15) {
                        -- 			result = new Posit32 (0u, true);
                        -- 		}
                        -- 		else {
                        -- 			regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 			System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 			remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 			exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 			result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.right\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_15\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.3\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.flag4\ := \Posit32::op_Addition(Posit32,Posit32).1.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag4) {
                            -- 	result = left;
                            -- }
                            -- else {
                            -- 	num = left.PositBits >> 31;
                            -- 	num2 = 0u - num;
                            -- 	left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 	num3 = right.PositBits >> 31;
                            -- 	num4 = 0u - num3;
                            -- 	right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 	lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 	lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 	num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 	num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 	flag5 = num == num3;
                            -- 	regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 	exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 	regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 	exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 	if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 		signBit = num == 1u;
                            -- 	}
                            -- 	else {
                            -- 		signBit = num3 == 1u;
                            -- 	}
                            -- 	num7 = 0u;
                            -- 	num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 	num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 	num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 	if (num10 >= 0) {
                            -- 		num11 = num8;
                            -- 	}
                            -- 	else {
                            -- 		num11 = num9;
                            -- 	}
                            -- 	num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 	num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 	flag6 = num10 == 0;
                            -- 	if (flag6) {
                            -- 		flag7 = flag5;
                            -- 		if (flag7) {
                            -- 			num7 = 0u + num12 + num13;
                            -- 		}
                            -- 		else {
                            -- 			flag8 = num12 >= num13;
                            -- 			if (flag8) {
                            -- 				num7 = num7 + num12 - num13;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 + num13 - num12;
                            -- 			}
                            -- 		}
                            -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 	}
                            -- 	else {
                            -- 		flag9 = num10 > 0;
                            -- 		if (flag9) {
                            -- 			num14 = (int)(num5 - num6);
                            -- 			num7 = num7 + num12;
                            -- 			num15 = (int)(31u - num5 - 1u);
                            -- 			num7 = num7 << num15;
                            -- 			num16 = num15 - num10 + num14;
                            -- 			flag10 = flag5;
                            -- 			if (flag10) {
                            -- 				flag11 = num16 >= 0;
                            -- 				if (flag11) {
                            -- 					num7 = num7 + num13 << num16;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 + num13 >> -num16;
                            -- 				}
                            -- 			}
                            -- 			else {
                            -- 				uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 				if (num16 >= 0) {
                            -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 				}
                            -- 				else {
                            -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 				}
                            -- 				num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 			}
                            -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 		}
                            -- 		else {
                            -- 			num17 = (int)(num6 - num5);
                            -- 			num7 = num7 + num13;
                            -- 			num18 = (int)(31u - num6 - 1u);
                            -- 			num7 = num7 << num18;
                            -- 			flag12 = flag5;
                            -- 			if (flag12) {
                            -- 				flag13 = num18 + num10 + num17 >= 0;
                            -- 				if (flag13) {
                            -- 					num7 = num7 + num12 << num18 + num10 + num17;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 				}
                            -- 			}
                            -- 			else {
                            -- 				flag14 = num18 + num10 + num17 >= 0;
                            -- 				if (flag14) {
                            -- 					num7 = num7 - num12 << num18 + num10 + num17;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 				}
                            -- 			}
                            -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 		}
                            -- 	}
                            -- 	flag15 = num7 == 0u;
                            -- 	if (flag15) {
                            -- 		result = new Posit32 (0u, true);
                            -- 	}
                            -- 	else {
                            -- 		regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 		System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 		remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 		exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 		result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_17\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_17\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_18\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_92\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_16\.

                            if (\Posit32::op_Addition(Posit32,Posit32).1.flag4\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_17\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_18\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_16\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_15\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_11\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_16\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_17\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.result\ := \Posit32::op_Addition(Posit32,Posit32).1.left\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_15\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_17\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_18\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = left.PositBits >> 31;
                        -- 	num2 = 0u - num;
                        -- 	left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 	num3 = right.PositBits >> 31;
                        -- 	num4 = 0u - num3;
                        -- 	right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 	lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 	lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 	num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 	num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 	flag5 = num == num3;
                        -- 	regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 	exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 	regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 	exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 	if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 		signBit = num == 1u;
                        -- 	}
                        -- 	else {
                        -- 		signBit = num3 == 1u;
                        -- 	}
                        -- 	num7 = 0u;
                        -- 	num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 	num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 	num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 	if (num10 >= 0) {
                        -- 		num11 = num8;
                        -- 	}
                        -- 	else {
                        -- 		num11 = num9;
                        -- 	}
                        -- 	num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 	num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 	flag6 = num10 == 0;
                        -- 	if (flag6) {
                        -- 		flag7 = flag5;
                        -- 		if (flag7) {
                        -- 			num7 = 0u + num12 + num13;
                        -- 		}
                        -- 		else {
                        -- 			flag8 = num12 >= num13;
                        -- 			if (flag8) {
                        -- 				num7 = num7 + num12 - num13;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 + num13 - num12;
                        -- 			}
                        -- 		}
                        -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 	}
                        -- 	else {
                        -- 		flag9 = num10 > 0;
                        -- 		if (flag9) {
                        -- 			num14 = (int)(num5 - num6);
                        -- 			num7 = num7 + num12;
                        -- 			num15 = (int)(31u - num5 - 1u);
                        -- 			num7 = num7 << num15;
                        -- 			num16 = num15 - num10 + num14;
                        -- 			flag10 = flag5;
                        -- 			if (flag10) {
                        -- 				flag11 = num16 >= 0;
                        -- 				if (flag11) {
                        -- 					num7 = num7 + num13 << num16;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 + num13 >> -num16;
                        -- 				}
                        -- 			}
                        -- 			else {
                        -- 				uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 				if (num16 >= 0) {
                        -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 				}
                        -- 				else {
                        -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 				}
                        -- 				num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 			}
                        -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 		}
                        -- 		else {
                        -- 			num17 = (int)(num6 - num5);
                        -- 			num7 = num7 + num13;
                        -- 			num18 = (int)(31u - num6 - 1u);
                        -- 			num7 = num7 << num18;
                        -- 			flag12 = flag5;
                        -- 			if (flag12) {
                        -- 				flag13 = num18 + num10 + num17 >= 0;
                        -- 				if (flag13) {
                        -- 					num7 = num7 + num12 << num18 + num10 + num17;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 				}
                        -- 			}
                        -- 			else {
                        -- 				flag14 = num18 + num10 + num17 >= 0;
                        -- 				if (flag14) {
                        -- 					num7 = num7 - num12 << num18 + num10 + num17;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 				}
                        -- 			}
                        -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 		}
                        -- 	}
                        -- 	flag15 = num7 == 0u;
                        -- 	if (flag15) {
                        -- 		result = new Posit32 (0u, true);
                        -- 	}
                        -- 	else {
                        -- 		regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 		System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 		remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 		exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 		result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = left.PositBits >> 31;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.0\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).1.left\.\PositBits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).1.num\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0u - num;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.1\ := to_unsigned(0, 32) - \Posit32::op_Addition(Posit32,Posit32).1.num\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num2\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::op_Addition(Posit32,Posit32).1.left2\.\IsNull\ := false;
                        \Posit32::op_Addition(Posit32,Posit32).1.left2\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.2\ := \Posit32::op_Addition(Posit32,Posit32).1.left\.\PositBits\ xor \Posit32::op_Addition(Posit32,Posit32).1.num2\;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0.6928
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_19\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.3\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.2\ + \Posit32::op_Addition(Posit32,Posit32).1.num\;
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.left2\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.3\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_20\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.left2\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = right.PositBits >> 31;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.4\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).1.right\.\PositBits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                            \Posit32::op_Addition(Posit32,Posit32).1.num3\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 0u - num3;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.5\ := to_unsigned(0, 32) - \Posit32::op_Addition(Posit32,Posit32).1.num3\;
                            \Posit32::op_Addition(Posit32,Posit32).1.num4\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit32::op_Addition(Posit32,Posit32).1.right2\.\IsNull\ := false;
                            \Posit32::op_Addition(Posit32,Posit32).1.right2\.\PositBits\ := to_unsigned(0, 32);
                            -- Invoking the target's constructor.
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.6\ := \Posit32::op_Addition(Posit32,Posit32).1.right\.\PositBits\ xor \Posit32::op_Addition(Posit32,Posit32).1.num4\;
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6928
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_21\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.6\ + \Posit32::op_Addition(Posit32,Posit32).1.num3\;
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_22\;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_22\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.7\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_23\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_23\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.right2\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 
                            -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.left2\.\PositBits\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_24\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.4\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.lengthOfRunOfBits\ := \Posit32::op_Addition(Posit32,Posit32).1.return.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_25\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_26\ => 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.right2\.\PositBits\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_27\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_27\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.5\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.lengthOfRunOfBits2\ := \Posit32::op_Addition(Posit32,Posit32).1.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.lengthOfRunOfBits\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_28\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.6\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.num5\ := \Posit32::op_Addition(Posit32,Posit32).1.return.6\;
                            -- The following section was transformed from the .NET statement below:
                            -- num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_29\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_29\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_30\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_30\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.lengthOfRunOfBits2\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_31\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_31\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.7\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.num6\ := \Posit32::op_Addition(Posit32,Posit32).1.return.7\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag5 = num == num3;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.8\ := \Posit32::op_Addition(Posit32,Posit32).1.num\ = \Posit32::op_Addition(Posit32,Posit32).1.num3\;
                            \Posit32::op_Addition(Posit32,Posit32).1.flag5\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 
                            -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.lengthOfRunOfBits\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_32\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_32\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.8\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.regimeKValueWithoutSignCheck\ := \Posit32::op_Addition(Posit32,Posit32).1.return.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.num5\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_33\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.9\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.exponentValueWithoutSignCheck\ := \Posit32::op_Addition(Posit32,Posit32).1.return.9\;
                            -- The following section was transformed from the .NET statement below:
                            -- regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_34\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_34\ => 
                        -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.lengthOfRunOfBits2\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_35\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_35\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.10\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.regimeKValueWithoutSignCheck2\ := \Posit32::op_Addition(Posit32,Posit32).1.return.10\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.right2\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.num6\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_36\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.11\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.exponentValueWithoutSignCheck2\ := \Posit32::op_Addition(Posit32,Posit32).1.return.11\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 	signBit = num == 1u;
                            -- }
                            -- else {
                            -- 	signBit = num3 == 1u;
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32).left.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32).right.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.right2\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_37\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_37\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.12\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32).return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_39\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_39\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_40\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_40\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_38\.

                            if (\Posit32::op_Addition(Posit32,Posit32).1.return.12\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_39\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_40\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_38\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = 0u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.regimeKValueWithoutSignCheck\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.exponentValueWithoutSignCheck\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(2, 8);
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_41\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_39\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	signBit = num == 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = num == 1u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.9\ := \Posit32::op_Addition(Posit32,Posit32).1.num\ = to_unsigned(1, 32);
                        \Posit32::op_Addition(Posit32,Posit32).1.signBit\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.9\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_37\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_39\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_40\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	signBit = num3 == 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = num3 == 1u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.10\ := \Posit32::op_Addition(Posit32,Posit32).1.num3\ = to_unsigned(1, 32);
                        \Posit32::op_Addition(Posit32,Posit32).1.signBit\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.10\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_37\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_40\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_41\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.13\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.num8\ := \Posit32::op_Addition(Posit32,Posit32).1.return.13\;
                            -- The following section was transformed from the .NET statement below:
                            -- num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_42\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_43\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_43\ => 
                        -- Starting state machine invocation for the following method: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.regimeKValueWithoutSignCheck2\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.exponentValueWithoutSignCheck2\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(2, 8);
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_44\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_44\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.14\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.num9\ := \Posit32::op_Addition(Posit32,Posit32).1.return.14\;
                            -- The following section was transformed from the .NET statement below:
                            -- num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.11\ := SmartResize((\Posit32::op_Addition(Posit32,Posit32).1.num8\), 32) - SmartResize((\Posit32::op_Addition(Posit32,Posit32).1.num9\), 32);
                            \Posit32::op_Addition(Posit32,Posit32).1.num10\ := (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.11\);
                            -- The following section was transformed from the .NET statement below:
                            -- if (num10 >= 0) {
                            -- 	num11 = num8;
                            -- }
                            -- else {
                            -- 	num11 = num9;
                            -- }
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.12\ := \Posit32::op_Addition(Posit32,Posit32).1.num10\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_46\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_46\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_47\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_47\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_45\.

                            if (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.12\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_46\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_47\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5911
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_45\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.left2\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.num5\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_48\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_46\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num11 = num8;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = num8;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.num11\ := \Posit32::op_Addition(Posit32,Posit32).1.num8\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_44\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_46\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_45\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_47\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num11 = num9;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = num9;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.num11\ := \Posit32::op_Addition(Posit32,Posit32).1.num9\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_44\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_47\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_45\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_48\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.15\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.num12\ := \Posit32::op_Addition(Posit32,Posit32).1.return.15\;
                            -- The following section was transformed from the .NET statement below:
                            -- num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_49\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_49\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_50\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_50\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.num6\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_51\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_51\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.16\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.num13\ := \Posit32::op_Addition(Posit32,Posit32).1.return.16\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag6 = num10 == 0;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.13\ := \Posit32::op_Addition(Posit32,Posit32).1.num10\ = to_signed(0, 32);
                            \Posit32::op_Addition(Posit32,Posit32).1.flag6\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.13\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag6) {
                            -- 	flag7 = flag5;
                            -- 	if (flag7) {
                            -- 		num7 = 0u + num12 + num13;
                            -- 	}
                            -- 	else {
                            -- 		flag8 = num12 >= num13;
                            -- 		if (flag8) {
                            -- 			num7 = num7 + num12 - num13;
                            -- 		}
                            -- 		else {
                            -- 			num7 = num7 + num13 - num12;
                            -- 		}
                            -- 	}
                            -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- }
                            -- else {
                            -- 	flag9 = num10 > 0;
                            -- 	if (flag9) {
                            -- 		num14 = (int)(num5 - num6);
                            -- 		num7 = num7 + num12;
                            -- 		num15 = (int)(31u - num5 - 1u);
                            -- 		num7 = num7 << num15;
                            -- 		num16 = num15 - num10 + num14;
                            -- 		flag10 = flag5;
                            -- 		if (flag10) {
                            -- 			flag11 = num16 >= 0;
                            -- 			if (flag11) {
                            -- 				num7 = num7 + num13 << num16;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 + num13 >> -num16;
                            -- 			}
                            -- 		}
                            -- 		else {
                            -- 			uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 			if (num16 >= 0) {
                            -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 			}
                            -- 			else {
                            -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 			}
                            -- 			num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 		}
                            -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 	}
                            -- 	else {
                            -- 		num17 = (int)(num6 - num5);
                            -- 		num7 = num7 + num13;
                            -- 		num18 = (int)(31u - num6 - 1u);
                            -- 		num7 = num7 << num18;
                            -- 		flag12 = flag5;
                            -- 		if (flag12) {
                            -- 			flag13 = num18 + num10 + num17 >= 0;
                            -- 			if (flag13) {
                            -- 				num7 = num7 + num12 << num18 + num10 + num17;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 			}
                            -- 		}
                            -- 		else {
                            -- 			flag14 = num18 + num10 + num17 >= 0;
                            -- 			if (flag14) {
                            -- 				num7 = num7 - num12 << num18 + num10 + num17;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 			}
                            -- 		}
                            -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_53\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_60\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_61\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_62\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_52\.

                            if (\Posit32::op_Addition(Posit32,Posit32).1.flag6\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_53\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_61\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_52\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_51\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag15 = num7 == 0u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.72\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ = to_unsigned(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).1.flag15\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.72\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag15) {
                        -- 	result = new Posit32 (0u, true);
                        -- }
                        -- else {
                        -- 	regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 	System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 	remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 	exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 	result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_93\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_94\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_95\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_97\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_92\.

                        if (\Posit32::op_Addition(Posit32,Posit32).1.flag15\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_93\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_95\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_53\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_51\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag7 = flag5;
                        -- 	if (flag7) {
                        -- 		num7 = 0u + num12 + num13;
                        -- 	}
                        -- 	else {
                        -- 		flag8 = num12 >= num13;
                        -- 		if (flag8) {
                        -- 			num7 = num7 + num12 - num13;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num13 - num12;
                        -- 		}
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag7 = flag5;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.flag7\ := \Posit32::op_Addition(Posit32,Posit32).1.flag5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag7) {
                        -- 	num7 = 0u + num12 + num13;
                        -- }
                        -- else {
                        -- 	flag8 = num12 >= num13;
                        -- 	if (flag8) {
                        -- 		num7 = num7 + num12 - num13;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 - num12;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_55\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_55\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_56\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_57\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_54\.

                        if (\Posit32::op_Addition(Posit32,Posit32).1.flag7\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_55\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_56\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_54\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_53\.
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_60\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_55\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_53\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = 0u + num12 + num13;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = 0u + num12 + num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.14\ := \Posit32::op_Addition(Posit32,Posit32).1.num12\ + \Posit32::op_Addition(Posit32,Posit32).1.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.15\ := to_unsigned(0, 32) + \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.14\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.15\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_53\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_55\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_54\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_56\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_53\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag8 = num12 >= num13;
                        -- 	if (flag8) {
                        -- 		num7 = num7 + num12 - num13;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 - num12;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag8 = num12 >= num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.16\ := \Posit32::op_Addition(Posit32,Posit32).1.num12\ >= \Posit32::op_Addition(Posit32,Posit32).1.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).1.flag8\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.16\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag8) {
                        -- 	num7 = num7 + num12 - num13;
                        -- }
                        -- else {
                        -- 	num7 = num7 + num13 - num12;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_58\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_58\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_59\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_59\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_57\.

                        if (\Posit32::op_Addition(Posit32,Posit32).1.flag8\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_58\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_59\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_57\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_56\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_53\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_57\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_54\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_58\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_56\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num12 - num13;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12 - num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.17\ := \Posit32::op_Addition(Posit32,Posit32).1.num12\ - \Posit32::op_Addition(Posit32,Posit32).1.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.18\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ + \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.17\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.18\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_56\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_58\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_57\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_59\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_56\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num13 - num12;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13 - num12;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.19\ := \Posit32::op_Addition(Posit32,Posit32).1.num13\ - \Posit32::op_Addition(Posit32,Posit32).1.num12\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.20\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ + \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.19\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.20\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_56\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_59\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_57\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_60\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.17\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.21\ := SmartResize(\Posit32::op_Addition(Posit32,Posit32).1.return.17\, 32) - \Posit32::op_Addition(Posit32,Posit32).1.num5\;
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.22\ := signed(SmartResize(\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.21\ - to_unsigned(1, 32), 16));
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.23\ := SmartResize(SmartResize((\Posit32::op_Addition(Posit32,Posit32).1.num11\), 32) + signed(((\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.22\))), 16);
                            \Posit32::op_Addition(Posit32,Posit32).1.num11\ := (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.23\);
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_51\.
                            if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_60\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_52\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_61\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_51\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag9 = num10 > 0;
                        -- 	if (flag9) {
                        -- 		num14 = (int)(num5 - num6);
                        -- 		num7 = num7 + num12;
                        -- 		num15 = (int)(31u - num5 - 1u);
                        -- 		num7 = num7 << num15;
                        -- 		num16 = num15 - num10 + num14;
                        -- 		flag10 = flag5;
                        -- 		if (flag10) {
                        -- 			flag11 = num16 >= 0;
                        -- 			if (flag11) {
                        -- 				num7 = num7 + num13 << num16;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 + num13 >> -num16;
                        -- 			}
                        -- 		}
                        -- 		else {
                        -- 			uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 			if (num16 >= 0) {
                        -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 			}
                        -- 			else {
                        -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 			}
                        -- 			num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 		}
                        -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 	}
                        -- 	else {
                        -- 		num17 = (int)(num6 - num5);
                        -- 		num7 = num7 + num13;
                        -- 		num18 = (int)(31u - num6 - 1u);
                        -- 		num7 = num7 << num18;
                        -- 		flag12 = flag5;
                        -- 		if (flag12) {
                        -- 			flag13 = num18 + num10 + num17 >= 0;
                        -- 			if (flag13) {
                        -- 				num7 = num7 + num12 << num18 + num10 + num17;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 			}
                        -- 		}
                        -- 		else {
                        -- 			flag14 = num18 + num10 + num17 >= 0;
                        -- 			if (flag14) {
                        -- 				num7 = num7 - num12 << num18 + num10 + num17;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 			}
                        -- 		}
                        -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag9 = num10 > 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.24\ := \Posit32::op_Addition(Posit32,Posit32).1.num10\ > to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).1.flag9\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.24\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag9) {
                        -- 	num14 = (int)(num5 - num6);
                        -- 	num7 = num7 + num12;
                        -- 	num15 = (int)(31u - num5 - 1u);
                        -- 	num7 = num7 << num15;
                        -- 	num16 = num15 - num10 + num14;
                        -- 	flag10 = flag5;
                        -- 	if (flag10) {
                        -- 		flag11 = num16 >= 0;
                        -- 		if (flag11) {
                        -- 			num7 = num7 + num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num13 >> -num16;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 		if (num16 >= 0) {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 		}
                        -- 		num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- else {
                        -- 	num17 = (int)(num6 - num5);
                        -- 	num7 = num7 + num13;
                        -- 	num18 = (int)(31u - num6 - 1u);
                        -- 	num7 = num7 << num18;
                        -- 	flag12 = flag5;
                        -- 	if (flag12) {
                        -- 		flag13 = num18 + num10 + num17 >= 0;
                        -- 		if (flag13) {
                        -- 			num7 = num7 + num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag14 = num18 + num10 + num17 >= 0;
                        -- 		if (flag14) {
                        -- 			num7 = num7 - num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_63\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_75\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_76\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_91\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_62\.

                        if (\Posit32::op_Addition(Posit32,Posit32).1.flag9\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_63\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_76\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_62\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_61\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_51\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_62\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_52\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_63\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_61\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num14 = (int)(num5 - num6);
                        -- 	num7 = num7 + num12;
                        -- 	num15 = (int)(31u - num5 - 1u);
                        -- 	num7 = num7 << num15;
                        -- 	num16 = num15 - num10 + num14;
                        -- 	flag10 = flag5;
                        -- 	if (flag10) {
                        -- 		flag11 = num16 >= 0;
                        -- 		if (flag11) {
                        -- 			num7 = num7 + num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num13 >> -num16;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 		if (num16 >= 0) {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 		}
                        -- 		num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num14 = (int)(num5 - num6);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.25\ := signed(\Posit32::op_Addition(Posit32,Posit32).1.num5\ - \Posit32::op_Addition(Posit32,Posit32).1.num6\);
                        \Posit32::op_Addition(Posit32,Posit32).1.num14\ := (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.25\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.26\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ + \Posit32::op_Addition(Posit32,Posit32).1.num12\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.26\;
                        -- The following section was transformed from the .NET statement below:
                        -- num15 = (int)(31u - num5 - 1u);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.27\ := to_unsigned(31, 32) - \Posit32::op_Addition(Posit32,Posit32).1.num5\;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_64\;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_64\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.28\ := signed(\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.27\ - to_unsigned(1, 32));
                        \Posit32::op_Addition(Posit32,Posit32).1.num15\ := (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.28\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 << num15;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.29\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).1.num7\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).1.num15\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.29\;
                        -- The following section was transformed from the .NET statement below:
                        -- num16 = num15 - num10 + num14;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.30\ := \Posit32::op_Addition(Posit32,Posit32).1.num15\ - \Posit32::op_Addition(Posit32,Posit32).1.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_65\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_65\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.31\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.30\ + \Posit32::op_Addition(Posit32,Posit32).1.num14\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num16\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.31\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag10 = flag5;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.flag10\ := \Posit32::op_Addition(Posit32,Posit32).1.flag5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag10) {
                        -- 	flag11 = num16 >= 0;
                        -- 	if (flag11) {
                        -- 		num7 = num7 + num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 >> -num16;
                        -- 	}
                        -- }
                        -- else {
                        -- 	uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	if (num16 >= 0) {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 	}
                        -- 	num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_67\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_68\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_71\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_72\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_66\.

                        if (\Posit32::op_Addition(Posit32,Posit32).1.flag10\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_67\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_71\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_66\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_65\.
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_75\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_67\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_65\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag11 = num16 >= 0;
                        -- 	if (flag11) {
                        -- 		num7 = num7 + num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 >> -num16;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag11 = num16 >= 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.32\ := \Posit32::op_Addition(Posit32,Posit32).1.num16\ >= to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).1.flag11\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.32\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag11) {
                        -- 	num7 = num7 + num13 << num16;
                        -- }
                        -- else {
                        -- 	num7 = num7 + num13 >> -num16;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_69\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_69\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_70\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_70\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_68\.

                        if (\Posit32::op_Addition(Posit32,Posit32).1.flag11\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_69\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_70\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_68\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_67\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_65\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_68\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_66\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_69\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_67\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num13 << num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13 << num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.33\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).1.num13\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).1.num16\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.34\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ + \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.33\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.34\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_67\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_69\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_68\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_70\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_67\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num13 >> -num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13 >> -num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.35\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).1.num13\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).1.num16\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.36\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ + \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.35\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.36\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_67\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_70\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_68\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_71\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_65\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	if (num16 >= 0) {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 	}
                        -- 	num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num16 >= 0) {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- }
                        -- else {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- }
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.37\ := \Posit32::op_Addition(Posit32,Posit32).1.num16\ >= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_73\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_73\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_74\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_74\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_72\.

                        if (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.37\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_73\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_74\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_72\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_71\.
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.40\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ - \Posit32::op_Addition(Posit32,Posit32).1.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.40\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_65\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_72\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_66\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_73\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_71\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.38\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).1.num13\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).1.num16\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).1.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.38\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_71\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_73\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_72\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_74\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_71\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.39\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).1.num13\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).1.num16\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).1.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.39\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_71\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_74\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_72\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_75\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.18\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.41\ := SmartResize(signed(SmartResize((\Posit32::op_Addition(Posit32,Posit32).1.return.18\), 32)) - to_signed(31, 32), 16);
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.42\ := SmartResize(SmartResize((\Posit32::op_Addition(Posit32,Posit32).1.num11\), 32) + signed(SmartResize(((\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.41\)), 32)), 16);
                            \Posit32::op_Addition(Posit32,Posit32).1.num11\ := (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.42\);
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_61\.
                            if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_75\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_62\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_76\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_61\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num17 = (int)(num6 - num5);
                        -- 	num7 = num7 + num13;
                        -- 	num18 = (int)(31u - num6 - 1u);
                        -- 	num7 = num7 << num18;
                        -- 	flag12 = flag5;
                        -- 	if (flag12) {
                        -- 		flag13 = num18 + num10 + num17 >= 0;
                        -- 		if (flag13) {
                        -- 			num7 = num7 + num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag14 = num18 + num10 + num17 >= 0;
                        -- 		if (flag14) {
                        -- 			num7 = num7 - num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num17 = (int)(num6 - num5);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.43\ := signed(\Posit32::op_Addition(Posit32,Posit32).1.num6\ - \Posit32::op_Addition(Posit32,Posit32).1.num5\);
                        \Posit32::op_Addition(Posit32,Posit32).1.num17\ := (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.43\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.44\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ + \Posit32::op_Addition(Posit32,Posit32).1.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.44\;
                        -- The following section was transformed from the .NET statement below:
                        -- num18 = (int)(31u - num6 - 1u);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.45\ := to_unsigned(31, 32) - \Posit32::op_Addition(Posit32,Posit32).1.num6\;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_77\;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_77\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.46\ := signed(\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.45\ - to_unsigned(1, 32));
                        \Posit32::op_Addition(Posit32,Posit32).1.num18\ := (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.46\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 << num18;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.47\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).1.num7\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).1.num18\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.47\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag12 = flag5;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.flag12\ := \Posit32::op_Addition(Posit32,Posit32).1.flag5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag12) {
                        -- 	flag13 = num18 + num10 + num17 >= 0;
                        -- 	if (flag13) {
                        -- 		num7 = num7 + num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- else {
                        -- 	flag14 = num18 + num10 + num17 >= 0;
                        -- 	if (flag14) {
                        -- 		num7 = num7 - num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_79\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_80\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_85\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_86\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_78\.

                        if (\Posit32::op_Addition(Posit32,Posit32).1.flag12\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_79\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_85\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_78\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_77\.
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_91\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_79\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_77\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag13 = num18 + num10 + num17 >= 0;
                        -- 	if (flag13) {
                        -- 		num7 = num7 + num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag13 = num18 + num10 + num17 >= 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.48\ := \Posit32::op_Addition(Posit32,Posit32).1.num18\ + \Posit32::op_Addition(Posit32,Posit32).1.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.49\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.48\ + \Posit32::op_Addition(Posit32,Posit32).1.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.50\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.49\ >= to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).1.flag13\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.50\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag13) {
                        -- 	num7 = num7 + num12 << num18 + num10 + num17;
                        -- }
                        -- else {
                        -- 	num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_81\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_82\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_83\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_84\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_80\.

                        if (\Posit32::op_Addition(Posit32,Posit32).1.flag13\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_81\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_83\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9067
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_80\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_79\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_77\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_80\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_78\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_81\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_79\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num12 << num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12 << num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.51\ := \Posit32::op_Addition(Posit32,Posit32).1.num18\ + \Posit32::op_Addition(Posit32,Posit32).1.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.52\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.51\ + \Posit32::op_Addition(Posit32,Posit32).1.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.53\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).1.num12\, to_integer(unsigned(SmartResize(\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.52\, 5))));
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_82\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_82\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.54\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ + \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.53\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.54\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_79\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_82\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_80\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_83\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_79\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.55\ := \Posit32::op_Addition(Posit32,Posit32).1.num18\ + \Posit32::op_Addition(Posit32,Posit32).1.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.56\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.55\ + \Posit32::op_Addition(Posit32,Posit32).1.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.57\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).1.num12\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.56\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_84\;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_84\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.58\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ + \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.57\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.58\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_79\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_84\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_80\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_85\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_77\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag14 = num18 + num10 + num17 >= 0;
                        -- 	if (flag14) {
                        -- 		num7 = num7 - num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag14 = num18 + num10 + num17 >= 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.59\ := \Posit32::op_Addition(Posit32,Posit32).1.num18\ + \Posit32::op_Addition(Posit32,Posit32).1.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.60\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.59\ + \Posit32::op_Addition(Posit32,Posit32).1.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.61\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.60\ >= to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).1.flag14\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.61\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag14) {
                        -- 	num7 = num7 - num12 << num18 + num10 + num17;
                        -- }
                        -- else {
                        -- 	num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_87\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_88\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).1._State_89\ and ends in state \Posit32::op_Addition(Posit32,Posit32).1._State_90\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).1._State_86\.

                        if (\Posit32::op_Addition(Posit32,Posit32).1.flag14\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_87\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_89\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9067
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_86\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_85\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_77\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_86\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_78\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_87\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_85\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 - num12 << num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 - num12 << num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.62\ := \Posit32::op_Addition(Posit32,Posit32).1.num18\ + \Posit32::op_Addition(Posit32,Posit32).1.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.63\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.62\ + \Posit32::op_Addition(Posit32,Posit32).1.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.64\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).1.num12\, to_integer(unsigned(SmartResize(\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.63\, 5))));
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_88\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_88\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.65\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ - \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.64\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.65\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_85\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_88\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_86\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_89\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_85\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.66\ := \Posit32::op_Addition(Posit32,Posit32).1.num18\ + \Posit32::op_Addition(Posit32,Posit32).1.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.67\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.66\ + \Posit32::op_Addition(Posit32,Posit32).1.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.68\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).1.num12\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.67\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_90\;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_90\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.69\ := \Posit32::op_Addition(Posit32,Posit32).1.num7\ - \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.68\;
                        \Posit32::op_Addition(Posit32,Posit32).1.num7\ := \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.69\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_85\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_90\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_86\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_91\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.19\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.70\ := SmartResize(signed(SmartResize((\Posit32::op_Addition(Posit32,Posit32).1.return.19\), 32)) - to_signed(31, 32), 16);
                            \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.71\ := SmartResize(SmartResize((\Posit32::op_Addition(Posit32,Posit32).1.num11\), 32) + signed(SmartResize(((\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.70\)), 32)), 16);
                            \Posit32::op_Addition(Posit32,Posit32).1.num11\ := (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.71\);
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_61\.
                            if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_91\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_62\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_92\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_52\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_15\.
                        if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_92\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_93\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new Posit32 (0u, true);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit32 (0u, true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::op_Addition(Posit32,Posit32).1.result\.\IsNull\ := false;
                        \Posit32::op_Addition(Posit32,Posit32).1.result\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.result\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_94\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_94\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.result\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_52\.
                            if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_94\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_92\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_95\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).1._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 	System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 	remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 	exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 	result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.73\ := SmartResize((\Posit32::op_Addition(Posit32,Posit32).1.num11\), 32) / to_signed(4, 32);
                        \Posit32::op_Addition(Posit32,Posit32).1.regimeKValue\ := (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.73\);
                        -- The following section was transformed from the .NET statement below:
                        -- System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ := SmartResize((\Posit32::op_Addition(Posit32,Posit32).1.num11\), 32);
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.74\ := \Posit32::op_Addition(Posit32,Posit32).1.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ / to_signed(4, 32);
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.75\ := SmartResize(\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.74\ * to_signed(4, 32), 32);
                        \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.76\ := unsigned(\Posit32::op_Addition(Posit32,Posit32).1.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ - \Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.75\);
                        \Posit32::op_Addition(Posit32,Posit32).1.exponentBits\ := (\Posit32::op_Addition(Posit32,Posit32).1.binaryOperationResult.76\);
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::op_Addition(Posit32,Posit32).1.result\.\IsNull\ := false;
                        \Posit32::op_Addition(Posit32,Posit32).1.result\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.signBit\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.regimeKValue\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.exponentBits\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_96\;
                        -- Clock cycles needed to complete this state (approximation): 0.6156
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_96\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.return.20\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.result\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.return.20\;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_97\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).1._State_97\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).1.result\ := \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).1._State_52\.
                            if (\Posit32::op_Addition(Posit32,Posit32).1._State\ = \Posit32::op_Addition(Posit32,Posit32).1._State_97\) then 
                                \Posit32::op_Addition(Posit32,Posit32).1._State\ := \Posit32::op_Addition(Posit32,Posit32).1._State_92\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 state machine end


    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 state machine start
    \Posit32::op_Addition(Posit32,Posit32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::op_Addition(Posit32,Posit32).2._State\: \Posit32::op_Addition(Posit32,Posit32).2._States\ := \Posit32::op_Addition(Posit32,Posit32).2._State_0\;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.left\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.result\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag2\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag3\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag4\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.left2\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.right2\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.lengthOfRunOfBits\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.lengthOfRunOfBits2\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag5\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.regimeKValueWithoutSignCheck\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.exponentValueWithoutSignCheck\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.regimeKValueWithoutSignCheck2\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.exponentValueWithoutSignCheck2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.signBit\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num8\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num9\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num11\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag6\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag7\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag8\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag9\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag10\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag11\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.num18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag12\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag13\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag14\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.flag15\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.exponentBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.0\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.1\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.2\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.3\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.4\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.5\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.8\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.8\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.10\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.12\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.9\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.10\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.13\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.14\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.12\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.16\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.13\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.14\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.16\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.17\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.18\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.19\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.20\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.17\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.21\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.22\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.23\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.24\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.25\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.26\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.27\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.29\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.30\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.31\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.32\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.33\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.34\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.35\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.36\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.37\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.38\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.39\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.40\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.18\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.41\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.42\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.43\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.44\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.45\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.46\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.47\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.48\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.49\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.50\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.51\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.52\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.53\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.54\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.55\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.56\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.57\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.58\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.59\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.60\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.61\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.62\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.63\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.64\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.65\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.66\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.67\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.68\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.69\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.19\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.70\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.71\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.72\: boolean := false;
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.73\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.74\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.75\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.76\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Addition(Posit32,Posit32).2.return.20\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::op_Addition(Posit32,Posit32).2._Finished\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_0\;
                \Posit32::op_Addition(Posit32,Posit32).2.flag\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.flag2\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.flag3\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.flag4\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.num\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.num2\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.num3\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.num4\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.lengthOfRunOfBits\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.lengthOfRunOfBits2\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.num5\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.num6\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.flag5\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.regimeKValueWithoutSignCheck\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.exponentValueWithoutSignCheck\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.regimeKValueWithoutSignCheck2\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.exponentValueWithoutSignCheck2\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.signBit\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.num7\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.num8\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).2.num9\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).2.num10\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.num11\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).2.num12\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.num13\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.flag6\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.flag7\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.flag8\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.flag9\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.num14\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.num15\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.num16\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.flag10\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.flag11\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.num17\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.num18\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.flag12\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.flag13\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.flag14\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.flag15\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.regimeKValue\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.exponentBits\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.return.0\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.return.1\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.return.2\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.return.3\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.1\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.2\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.4\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.6\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.return.4\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.return.5\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.return.6\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.return.7\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.8\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.return.8\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.return.9\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.return.10\ := to_signed(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.return.11\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.return.12\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.9\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.10\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.return.13\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).2.return.14\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.11\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.12\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.return.15\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.return.16\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.13\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.14\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.15\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.16\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.17\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.18\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.19\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.20\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.return.17\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.21\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.22\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.23\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.24\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.25\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.26\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.27\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.28\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.29\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.30\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.31\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.32\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.33\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.34\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.35\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.36\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.37\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.38\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.39\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.40\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.return.18\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.41\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.42\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.43\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.44\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.45\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.46\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.47\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.48\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.49\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.50\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.51\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.52\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.53\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.54\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.55\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.56\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.57\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.58\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.59\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.60\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.61\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.62\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.63\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.64\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.65\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.66\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.67\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.68\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.69\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.return.19\ := to_unsigned(0, 8);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.70\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.71\ := to_signed(0, 16);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.72\ := false;
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.73\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.74\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.75\ := to_signed(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.76\ := to_unsigned(0, 32);
                \Posit32::op_Addition(Posit32,Posit32).2.return.20\ := to_unsigned(0, 32);
            else 
                case \Posit32::op_Addition(Posit32,Posit32).2._State\ is 
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._Started\ = true) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._Started\ = true) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._Finished\ <= true;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).2._Finished\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_2\ => 
                        \Posit32::op_Addition(Posit32,Posit32).2.left\ := \Posit32::op_Addition(Posit32,Posit32).2.left.parameter.In\;
                        \Posit32::op_Addition(Posit32,Posit32).2.right\ := \Posit32::op_Addition(Posit32,Posit32).2.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 left2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 right2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte lengthOfRunOfBits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte lengthOfRunOfBits2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte regimeKValueWithoutSignCheck;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentValueWithoutSignCheck;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- sbyte regimeKValueWithoutSignCheck2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentValueWithoutSignCheck2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool signBit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- short num8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- short num9;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num10;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- short num11;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num12;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num13;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag9;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num14;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num15;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num16;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag10;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag11;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num17;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num18;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag12;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag13;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag14;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag15;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int regimeKValue;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentBits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = Lombiq.Arithmetics.Posit32.IsNaN (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.left\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.0\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.flag\ := \Posit32::op_Addition(Posit32,Posit32).2.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	result = left;
                            -- }
                            -- else {
                            -- 	flag2 = Lombiq.Arithmetics.Posit32.IsNaN (right);
                            -- 	if (flag2) {
                            -- 		result = right;
                            -- 	}
                            -- 	else {
                            -- 		flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                            -- 		if (flag3) {
                            -- 			result = right;
                            -- 		}
                            -- 		else {
                            -- 			flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                            -- 			if (flag4) {
                            -- 				result = left;
                            -- 			}
                            -- 			else {
                            -- 				num = left.PositBits >> 31;
                            -- 				num2 = 0u - num;
                            -- 				left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 				num3 = right.PositBits >> 31;
                            -- 				num4 = 0u - num3;
                            -- 				right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 				lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 				lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 				num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 				num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 				flag5 = num == num3;
                            -- 				regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 				exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 				regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 				exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 				if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 					signBit = num == 1u;
                            -- 				}
                            -- 				else {
                            -- 					signBit = num3 == 1u;
                            -- 				}
                            -- 				num7 = 0u;
                            -- 				num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 				num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 				num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 				if (num10 >= 0) {
                            -- 					num11 = num8;
                            -- 				}
                            -- 				else {
                            -- 					num11 = num9;
                            -- 				}
                            -- 				num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 				num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 				flag6 = num10 == 0;
                            -- 				if (flag6) {
                            -- 					flag7 = flag5;
                            -- 					if (flag7) {
                            -- 						num7 = 0u + num12 + num13;
                            -- 					}
                            -- 					else {
                            -- 						flag8 = num12 >= num13;
                            -- 						if (flag8) {
                            -- 							num7 = num7 + num12 - num13;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 + num13 - num12;
                            -- 						}
                            -- 					}
                            -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 				}
                            -- 				else {
                            -- 					flag9 = num10 > 0;
                            -- 					if (flag9) {
                            -- 						num14 = (int)(num5 - num6);
                            -- 						num7 = num7 + num12;
                            -- 						num15 = (int)(31u - num5 - 1u);
                            -- 						num7 = num7 << num15;
                            -- 						num16 = num15 - num10 + num14;
                            -- 						flag10 = flag5;
                            -- 						if (flag10) {
                            -- 							flag11 = num16 >= 0;
                            -- 							if (flag11) {
                            -- 								num7 = num7 + num13 << num16;
                            -- 							}
                            -- 							else {
                            -- 								num7 = num7 + num13 >> -num16;
                            -- 							}
                            -- 						}
                            -- 						else {
                            -- 							uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 							if (num16 >= 0) {
                            -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 							}
                            -- 							else {
                            -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 							}
                            -- 							num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 						}
                            -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 					}
                            -- 					else {
                            -- 						num17 = (int)(num6 - num5);
                            -- 						num7 = num7 + num13;
                            -- 						num18 = (int)(31u - num6 - 1u);
                            -- 						num7 = num7 << num18;
                            -- 						flag12 = flag5;
                            -- 						if (flag12) {
                            -- 							flag13 = num18 + num10 + num17 >= 0;
                            -- 							if (flag13) {
                            -- 								num7 = num7 + num12 << num18 + num10 + num17;
                            -- 							}
                            -- 							else {
                            -- 								num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 							}
                            -- 						}
                            -- 						else {
                            -- 							flag14 = num18 + num10 + num17 >= 0;
                            -- 							if (flag14) {
                            -- 								num7 = num7 - num12 << num18 + num10 + num17;
                            -- 							}
                            -- 							else {
                            -- 								num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 							}
                            -- 						}
                            -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 					}
                            -- 				}
                            -- 				flag15 = num7 == 0u;
                            -- 				if (flag15) {
                            -- 					result = new Posit32 (0u, true);
                            -- 				}
                            -- 				else {
                            -- 					regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 					System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 					remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 					exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 					result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 				}
                            -- 			}
                            -- 		}
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_5\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_5\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_6\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_8\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_4\.

                            if (\Posit32::op_Addition(Posit32,Posit32).2.flag\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_5\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_4\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.return\ <= \Posit32::op_Addition(Posit32,Posit32).2.result\;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_5\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.result\ := \Posit32::op_Addition(Posit32,Posit32).2.left\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_3\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_5\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_6\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag2 = Lombiq.Arithmetics.Posit32.IsNaN (right);
                        -- 	if (flag2) {
                        -- 		result = right;
                        -- 	}
                        -- 	else {
                        -- 		flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                        -- 		if (flag3) {
                        -- 			result = right;
                        -- 		}
                        -- 		else {
                        -- 			flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 			if (flag4) {
                        -- 				result = left;
                        -- 			}
                        -- 			else {
                        -- 				num = left.PositBits >> 31;
                        -- 				num2 = 0u - num;
                        -- 				left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 				num3 = right.PositBits >> 31;
                        -- 				num4 = 0u - num3;
                        -- 				right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 				lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 				lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 				num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 				num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 				flag5 = num == num3;
                        -- 				regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 				exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 				regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 				exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 				if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 					signBit = num == 1u;
                        -- 				}
                        -- 				else {
                        -- 					signBit = num3 == 1u;
                        -- 				}
                        -- 				num7 = 0u;
                        -- 				num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 				num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 				num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 				if (num10 >= 0) {
                        -- 					num11 = num8;
                        -- 				}
                        -- 				else {
                        -- 					num11 = num9;
                        -- 				}
                        -- 				num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 				num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 				flag6 = num10 == 0;
                        -- 				if (flag6) {
                        -- 					flag7 = flag5;
                        -- 					if (flag7) {
                        -- 						num7 = 0u + num12 + num13;
                        -- 					}
                        -- 					else {
                        -- 						flag8 = num12 >= num13;
                        -- 						if (flag8) {
                        -- 							num7 = num7 + num12 - num13;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 + num13 - num12;
                        -- 						}
                        -- 					}
                        -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 				}
                        -- 				else {
                        -- 					flag9 = num10 > 0;
                        -- 					if (flag9) {
                        -- 						num14 = (int)(num5 - num6);
                        -- 						num7 = num7 + num12;
                        -- 						num15 = (int)(31u - num5 - 1u);
                        -- 						num7 = num7 << num15;
                        -- 						num16 = num15 - num10 + num14;
                        -- 						flag10 = flag5;
                        -- 						if (flag10) {
                        -- 							flag11 = num16 >= 0;
                        -- 							if (flag11) {
                        -- 								num7 = num7 + num13 << num16;
                        -- 							}
                        -- 							else {
                        -- 								num7 = num7 + num13 >> -num16;
                        -- 							}
                        -- 						}
                        -- 						else {
                        -- 							uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 							if (num16 >= 0) {
                        -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 							}
                        -- 							else {
                        -- 								conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 							}
                        -- 							num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 						}
                        -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 					}
                        -- 					else {
                        -- 						num17 = (int)(num6 - num5);
                        -- 						num7 = num7 + num13;
                        -- 						num18 = (int)(31u - num6 - 1u);
                        -- 						num7 = num7 << num18;
                        -- 						flag12 = flag5;
                        -- 						if (flag12) {
                        -- 							flag13 = num18 + num10 + num17 >= 0;
                        -- 							if (flag13) {
                        -- 								num7 = num7 + num12 << num18 + num10 + num17;
                        -- 							}
                        -- 							else {
                        -- 								num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 							}
                        -- 						}
                        -- 						else {
                        -- 							flag14 = num18 + num10 + num17 >= 0;
                        -- 							if (flag14) {
                        -- 								num7 = num7 - num12 << num18 + num10 + num17;
                        -- 							}
                        -- 							else {
                        -- 								num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 							}
                        -- 						}
                        -- 						num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 					}
                        -- 				}
                        -- 				flag15 = num7 == 0u;
                        -- 				if (flag15) {
                        -- 					result = new Posit32 (0u, true);
                        -- 				}
                        -- 				else {
                        -- 					regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 					System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 					remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 					exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 					result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 				}
                        -- 			}
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = Lombiq.Arithmetics.Posit32.IsNaN (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.right\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsNaN()
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.1\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.flag2\ := \Posit32::op_Addition(Posit32,Posit32).2.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag2) {
                            -- 	result = right;
                            -- }
                            -- else {
                            -- 	flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                            -- 	if (flag3) {
                            -- 		result = right;
                            -- 	}
                            -- 	else {
                            -- 		flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                            -- 		if (flag4) {
                            -- 			result = left;
                            -- 		}
                            -- 		else {
                            -- 			num = left.PositBits >> 31;
                            -- 			num2 = 0u - num;
                            -- 			left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 			num3 = right.PositBits >> 31;
                            -- 			num4 = 0u - num3;
                            -- 			right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 			lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 			lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 			num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 			num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 			flag5 = num == num3;
                            -- 			regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 			exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 			regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 			exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 			if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 				signBit = num == 1u;
                            -- 			}
                            -- 			else {
                            -- 				signBit = num3 == 1u;
                            -- 			}
                            -- 			num7 = 0u;
                            -- 			num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 			num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 			num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 			if (num10 >= 0) {
                            -- 				num11 = num8;
                            -- 			}
                            -- 			else {
                            -- 				num11 = num9;
                            -- 			}
                            -- 			num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 			num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 			flag6 = num10 == 0;
                            -- 			if (flag6) {
                            -- 				flag7 = flag5;
                            -- 				if (flag7) {
                            -- 					num7 = 0u + num12 + num13;
                            -- 				}
                            -- 				else {
                            -- 					flag8 = num12 >= num13;
                            -- 					if (flag8) {
                            -- 						num7 = num7 + num12 - num13;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 + num13 - num12;
                            -- 					}
                            -- 				}
                            -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 			}
                            -- 			else {
                            -- 				flag9 = num10 > 0;
                            -- 				if (flag9) {
                            -- 					num14 = (int)(num5 - num6);
                            -- 					num7 = num7 + num12;
                            -- 					num15 = (int)(31u - num5 - 1u);
                            -- 					num7 = num7 << num15;
                            -- 					num16 = num15 - num10 + num14;
                            -- 					flag10 = flag5;
                            -- 					if (flag10) {
                            -- 						flag11 = num16 >= 0;
                            -- 						if (flag11) {
                            -- 							num7 = num7 + num13 << num16;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 + num13 >> -num16;
                            -- 						}
                            -- 					}
                            -- 					else {
                            -- 						uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 						if (num16 >= 0) {
                            -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 						}
                            -- 						else {
                            -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 						}
                            -- 						num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 					}
                            -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 				}
                            -- 				else {
                            -- 					num17 = (int)(num6 - num5);
                            -- 					num7 = num7 + num13;
                            -- 					num18 = (int)(31u - num6 - 1u);
                            -- 					num7 = num7 << num18;
                            -- 					flag12 = flag5;
                            -- 					if (flag12) {
                            -- 						flag13 = num18 + num10 + num17 >= 0;
                            -- 						if (flag13) {
                            -- 							num7 = num7 + num12 << num18 + num10 + num17;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 						}
                            -- 					}
                            -- 					else {
                            -- 						flag14 = num18 + num10 + num17 >= 0;
                            -- 						if (flag14) {
                            -- 							num7 = num7 - num12 << num18 + num10 + num17;
                            -- 						}
                            -- 						else {
                            -- 							num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 						}
                            -- 					}
                            -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 				}
                            -- 			}
                            -- 			flag15 = num7 == 0u;
                            -- 			if (flag15) {
                            -- 				result = new Posit32 (0u, true);
                            -- 			}
                            -- 			else {
                            -- 				regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 				System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 				remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 				exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 				result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 			}
                            -- 		}
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_9\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_9\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_10\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_12\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_8\.

                            if (\Posit32::op_Addition(Posit32,Posit32).2.flag2\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_9\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_8\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_7\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_3\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_8\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_9\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = right;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = right;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.result\ := \Posit32::op_Addition(Posit32,Posit32).2.right\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_7\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_9\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_10\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                        -- 	if (flag3) {
                        -- 		result = right;
                        -- 	}
                        -- 	else {
                        -- 		flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 		if (flag4) {
                        -- 			result = left;
                        -- 		}
                        -- 		else {
                        -- 			num = left.PositBits >> 31;
                        -- 			num2 = 0u - num;
                        -- 			left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 			num3 = right.PositBits >> 31;
                        -- 			num4 = 0u - num3;
                        -- 			right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 			lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 			lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 			num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 			num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 			flag5 = num == num3;
                        -- 			regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 			exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 			regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 			exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 			if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 				signBit = num == 1u;
                        -- 			}
                        -- 			else {
                        -- 				signBit = num3 == 1u;
                        -- 			}
                        -- 			num7 = 0u;
                        -- 			num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 			num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 			num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 			if (num10 >= 0) {
                        -- 				num11 = num8;
                        -- 			}
                        -- 			else {
                        -- 				num11 = num9;
                        -- 			}
                        -- 			num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 			num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 			flag6 = num10 == 0;
                        -- 			if (flag6) {
                        -- 				flag7 = flag5;
                        -- 				if (flag7) {
                        -- 					num7 = 0u + num12 + num13;
                        -- 				}
                        -- 				else {
                        -- 					flag8 = num12 >= num13;
                        -- 					if (flag8) {
                        -- 						num7 = num7 + num12 - num13;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 + num13 - num12;
                        -- 					}
                        -- 				}
                        -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 			}
                        -- 			else {
                        -- 				flag9 = num10 > 0;
                        -- 				if (flag9) {
                        -- 					num14 = (int)(num5 - num6);
                        -- 					num7 = num7 + num12;
                        -- 					num15 = (int)(31u - num5 - 1u);
                        -- 					num7 = num7 << num15;
                        -- 					num16 = num15 - num10 + num14;
                        -- 					flag10 = flag5;
                        -- 					if (flag10) {
                        -- 						flag11 = num16 >= 0;
                        -- 						if (flag11) {
                        -- 							num7 = num7 + num13 << num16;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 + num13 >> -num16;
                        -- 						}
                        -- 					}
                        -- 					else {
                        -- 						uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 						if (num16 >= 0) {
                        -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 						}
                        -- 						else {
                        -- 							conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 						}
                        -- 						num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 					}
                        -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 				}
                        -- 				else {
                        -- 					num17 = (int)(num6 - num5);
                        -- 					num7 = num7 + num13;
                        -- 					num18 = (int)(31u - num6 - 1u);
                        -- 					num7 = num7 << num18;
                        -- 					flag12 = flag5;
                        -- 					if (flag12) {
                        -- 						flag13 = num18 + num10 + num17 >= 0;
                        -- 						if (flag13) {
                        -- 							num7 = num7 + num12 << num18 + num10 + num17;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 						}
                        -- 					}
                        -- 					else {
                        -- 						flag14 = num18 + num10 + num17 >= 0;
                        -- 						if (flag14) {
                        -- 							num7 = num7 - num12 << num18 + num10 + num17;
                        -- 						}
                        -- 						else {
                        -- 							num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 						}
                        -- 					}
                        -- 					num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 				}
                        -- 			}
                        -- 			flag15 = num7 == 0u;
                        -- 			if (flag15) {
                        -- 				result = new Posit32 (0u, true);
                        -- 			}
                        -- 			else {
                        -- 				regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 				System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 				remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 				exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 				result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 			}
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = Lombiq.Arithmetics.Posit32.IsZero (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.left\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.2\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.flag3\ := \Posit32::op_Addition(Posit32,Posit32).2.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag3) {
                            -- 	result = right;
                            -- }
                            -- else {
                            -- 	flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                            -- 	if (flag4) {
                            -- 		result = left;
                            -- 	}
                            -- 	else {
                            -- 		num = left.PositBits >> 31;
                            -- 		num2 = 0u - num;
                            -- 		left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 		num3 = right.PositBits >> 31;
                            -- 		num4 = 0u - num3;
                            -- 		right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 		lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 		lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 		num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 		num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 		flag5 = num == num3;
                            -- 		regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 		exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 		regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 		exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 		if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 			signBit = num == 1u;
                            -- 		}
                            -- 		else {
                            -- 			signBit = num3 == 1u;
                            -- 		}
                            -- 		num7 = 0u;
                            -- 		num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 		num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 		num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 		if (num10 >= 0) {
                            -- 			num11 = num8;
                            -- 		}
                            -- 		else {
                            -- 			num11 = num9;
                            -- 		}
                            -- 		num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 		num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 		flag6 = num10 == 0;
                            -- 		if (flag6) {
                            -- 			flag7 = flag5;
                            -- 			if (flag7) {
                            -- 				num7 = 0u + num12 + num13;
                            -- 			}
                            -- 			else {
                            -- 				flag8 = num12 >= num13;
                            -- 				if (flag8) {
                            -- 					num7 = num7 + num12 - num13;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 + num13 - num12;
                            -- 				}
                            -- 			}
                            -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 		}
                            -- 		else {
                            -- 			flag9 = num10 > 0;
                            -- 			if (flag9) {
                            -- 				num14 = (int)(num5 - num6);
                            -- 				num7 = num7 + num12;
                            -- 				num15 = (int)(31u - num5 - 1u);
                            -- 				num7 = num7 << num15;
                            -- 				num16 = num15 - num10 + num14;
                            -- 				flag10 = flag5;
                            -- 				if (flag10) {
                            -- 					flag11 = num16 >= 0;
                            -- 					if (flag11) {
                            -- 						num7 = num7 + num13 << num16;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 + num13 >> -num16;
                            -- 					}
                            -- 				}
                            -- 				else {
                            -- 					uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 					if (num16 >= 0) {
                            -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 					}
                            -- 					else {
                            -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 					}
                            -- 					num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 				}
                            -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 			}
                            -- 			else {
                            -- 				num17 = (int)(num6 - num5);
                            -- 				num7 = num7 + num13;
                            -- 				num18 = (int)(31u - num6 - 1u);
                            -- 				num7 = num7 << num18;
                            -- 				flag12 = flag5;
                            -- 				if (flag12) {
                            -- 					flag13 = num18 + num10 + num17 >= 0;
                            -- 					if (flag13) {
                            -- 						num7 = num7 + num12 << num18 + num10 + num17;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 					}
                            -- 				}
                            -- 				else {
                            -- 					flag14 = num18 + num10 + num17 >= 0;
                            -- 					if (flag14) {
                            -- 						num7 = num7 - num12 << num18 + num10 + num17;
                            -- 					}
                            -- 					else {
                            -- 						num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 					}
                            -- 				}
                            -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 			}
                            -- 		}
                            -- 		flag15 = num7 == 0u;
                            -- 		if (flag15) {
                            -- 			result = new Posit32 (0u, true);
                            -- 		}
                            -- 		else {
                            -- 			regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 			System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 			remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 			exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 			result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 		}
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_13\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_13\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_14\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_16\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_12\.

                            if (\Posit32::op_Addition(Posit32,Posit32).2.flag3\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_13\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_14\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_12\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_11\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_7\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_12\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_13\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = right;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = right;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.result\ := \Posit32::op_Addition(Posit32,Posit32).2.right\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_11\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_13\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_14\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 	if (flag4) {
                        -- 		result = left;
                        -- 	}
                        -- 	else {
                        -- 		num = left.PositBits >> 31;
                        -- 		num2 = 0u - num;
                        -- 		left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 		num3 = right.PositBits >> 31;
                        -- 		num4 = 0u - num3;
                        -- 		right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 		lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 		lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 		num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 		num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 		flag5 = num == num3;
                        -- 		regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 		exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 		regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 		exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 		if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 			signBit = num == 1u;
                        -- 		}
                        -- 		else {
                        -- 			signBit = num3 == 1u;
                        -- 		}
                        -- 		num7 = 0u;
                        -- 		num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 		num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 		num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 		if (num10 >= 0) {
                        -- 			num11 = num8;
                        -- 		}
                        -- 		else {
                        -- 			num11 = num9;
                        -- 		}
                        -- 		num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 		num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 		flag6 = num10 == 0;
                        -- 		if (flag6) {
                        -- 			flag7 = flag5;
                        -- 			if (flag7) {
                        -- 				num7 = 0u + num12 + num13;
                        -- 			}
                        -- 			else {
                        -- 				flag8 = num12 >= num13;
                        -- 				if (flag8) {
                        -- 					num7 = num7 + num12 - num13;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 + num13 - num12;
                        -- 				}
                        -- 			}
                        -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 		}
                        -- 		else {
                        -- 			flag9 = num10 > 0;
                        -- 			if (flag9) {
                        -- 				num14 = (int)(num5 - num6);
                        -- 				num7 = num7 + num12;
                        -- 				num15 = (int)(31u - num5 - 1u);
                        -- 				num7 = num7 << num15;
                        -- 				num16 = num15 - num10 + num14;
                        -- 				flag10 = flag5;
                        -- 				if (flag10) {
                        -- 					flag11 = num16 >= 0;
                        -- 					if (flag11) {
                        -- 						num7 = num7 + num13 << num16;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 + num13 >> -num16;
                        -- 					}
                        -- 				}
                        -- 				else {
                        -- 					uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 					if (num16 >= 0) {
                        -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 					}
                        -- 					else {
                        -- 						conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 					}
                        -- 					num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 				}
                        -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 			}
                        -- 			else {
                        -- 				num17 = (int)(num6 - num5);
                        -- 				num7 = num7 + num13;
                        -- 				num18 = (int)(31u - num6 - 1u);
                        -- 				num7 = num7 << num18;
                        -- 				flag12 = flag5;
                        -- 				if (flag12) {
                        -- 					flag13 = num18 + num10 + num17 >= 0;
                        -- 					if (flag13) {
                        -- 						num7 = num7 + num12 << num18 + num10 + num17;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 					}
                        -- 				}
                        -- 				else {
                        -- 					flag14 = num18 + num10 + num17 >= 0;
                        -- 					if (flag14) {
                        -- 						num7 = num7 - num12 << num18 + num10 + num17;
                        -- 					}
                        -- 					else {
                        -- 						num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 					}
                        -- 				}
                        -- 				num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 			}
                        -- 		}
                        -- 		flag15 = num7 == 0u;
                        -- 		if (flag15) {
                        -- 			result = new Posit32 (0u, true);
                        -- 		}
                        -- 		else {
                        -- 			regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 			System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 			remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 			exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 			result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.right\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_15\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.3\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.flag4\ := \Posit32::op_Addition(Posit32,Posit32).2.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag4) {
                            -- 	result = left;
                            -- }
                            -- else {
                            -- 	num = left.PositBits >> 31;
                            -- 	num2 = 0u - num;
                            -- 	left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                            -- 	num3 = right.PositBits >> 31;
                            -- 	num4 = 0u - num3;
                            -- 	right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 	lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 	lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 	num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 	num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 	flag5 = num == num3;
                            -- 	regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 	exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 	regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 	exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 	if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 		signBit = num == 1u;
                            -- 	}
                            -- 	else {
                            -- 		signBit = num3 == 1u;
                            -- 	}
                            -- 	num7 = 0u;
                            -- 	num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                            -- 	num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 	num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 	if (num10 >= 0) {
                            -- 		num11 = num8;
                            -- 	}
                            -- 	else {
                            -- 		num11 = num9;
                            -- 	}
                            -- 	num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                            -- 	num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 	flag6 = num10 == 0;
                            -- 	if (flag6) {
                            -- 		flag7 = flag5;
                            -- 		if (flag7) {
                            -- 			num7 = 0u + num12 + num13;
                            -- 		}
                            -- 		else {
                            -- 			flag8 = num12 >= num13;
                            -- 			if (flag8) {
                            -- 				num7 = num7 + num12 - num13;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 + num13 - num12;
                            -- 			}
                            -- 		}
                            -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- 	}
                            -- 	else {
                            -- 		flag9 = num10 > 0;
                            -- 		if (flag9) {
                            -- 			num14 = (int)(num5 - num6);
                            -- 			num7 = num7 + num12;
                            -- 			num15 = (int)(31u - num5 - 1u);
                            -- 			num7 = num7 << num15;
                            -- 			num16 = num15 - num10 + num14;
                            -- 			flag10 = flag5;
                            -- 			if (flag10) {
                            -- 				flag11 = num16 >= 0;
                            -- 				if (flag11) {
                            -- 					num7 = num7 + num13 << num16;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 + num13 >> -num16;
                            -- 				}
                            -- 			}
                            -- 			else {
                            -- 				uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 				if (num16 >= 0) {
                            -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 				}
                            -- 				else {
                            -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 				}
                            -- 				num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 			}
                            -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 		}
                            -- 		else {
                            -- 			num17 = (int)(num6 - num5);
                            -- 			num7 = num7 + num13;
                            -- 			num18 = (int)(31u - num6 - 1u);
                            -- 			num7 = num7 << num18;
                            -- 			flag12 = flag5;
                            -- 			if (flag12) {
                            -- 				flag13 = num18 + num10 + num17 >= 0;
                            -- 				if (flag13) {
                            -- 					num7 = num7 + num12 << num18 + num10 + num17;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 				}
                            -- 			}
                            -- 			else {
                            -- 				flag14 = num18 + num10 + num17 >= 0;
                            -- 				if (flag14) {
                            -- 					num7 = num7 - num12 << num18 + num10 + num17;
                            -- 				}
                            -- 				else {
                            -- 					num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 				}
                            -- 			}
                            -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 		}
                            -- 	}
                            -- 	flag15 = num7 == 0u;
                            -- 	if (flag15) {
                            -- 		result = new Posit32 (0u, true);
                            -- 	}
                            -- 	else {
                            -- 		regimeKValue = (int)((System.Int32)(num11) / 4);
                            -- 		System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                            -- 		remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                            -- 		exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                            -- 		result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_17\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_17\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_18\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_92\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_16\.

                            if (\Posit32::op_Addition(Posit32,Posit32).2.flag4\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_17\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_18\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_16\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_15\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_11\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_16\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_17\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.result\ := \Posit32::op_Addition(Posit32,Posit32).2.left\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_15\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_17\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_18\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = left.PositBits >> 31;
                        -- 	num2 = 0u - num;
                        -- 	left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 	num3 = right.PositBits >> 31;
                        -- 	num4 = 0u - num3;
                        -- 	right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                        -- 	lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                        -- 	lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                        -- 	num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 	num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 	flag5 = num == num3;
                        -- 	regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                        -- 	exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                        -- 	regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                        -- 	exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                        -- 	if (Posit32.op_GreaterThan (left2, right2)) {
                        -- 		signBit = num == 1u;
                        -- 	}
                        -- 	else {
                        -- 		signBit = num3 == 1u;
                        -- 	}
                        -- 	num7 = 0u;
                        -- 	num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 	num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                        -- 	num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                        -- 	if (num10 >= 0) {
                        -- 		num11 = num8;
                        -- 	}
                        -- 	else {
                        -- 		num11 = num9;
                        -- 	}
                        -- 	num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 	num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                        -- 	flag6 = num10 == 0;
                        -- 	if (flag6) {
                        -- 		flag7 = flag5;
                        -- 		if (flag7) {
                        -- 			num7 = 0u + num12 + num13;
                        -- 		}
                        -- 		else {
                        -- 			flag8 = num12 >= num13;
                        -- 			if (flag8) {
                        -- 				num7 = num7 + num12 - num13;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 + num13 - num12;
                        -- 			}
                        -- 		}
                        -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 	}
                        -- 	else {
                        -- 		flag9 = num10 > 0;
                        -- 		if (flag9) {
                        -- 			num14 = (int)(num5 - num6);
                        -- 			num7 = num7 + num12;
                        -- 			num15 = (int)(31u - num5 - 1u);
                        -- 			num7 = num7 << num15;
                        -- 			num16 = num15 - num10 + num14;
                        -- 			flag10 = flag5;
                        -- 			if (flag10) {
                        -- 				flag11 = num16 >= 0;
                        -- 				if (flag11) {
                        -- 					num7 = num7 + num13 << num16;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 + num13 >> -num16;
                        -- 				}
                        -- 			}
                        -- 			else {
                        -- 				uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 				if (num16 >= 0) {
                        -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 				}
                        -- 				else {
                        -- 					conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 				}
                        -- 				num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 			}
                        -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 		}
                        -- 		else {
                        -- 			num17 = (int)(num6 - num5);
                        -- 			num7 = num7 + num13;
                        -- 			num18 = (int)(31u - num6 - 1u);
                        -- 			num7 = num7 << num18;
                        -- 			flag12 = flag5;
                        -- 			if (flag12) {
                        -- 				flag13 = num18 + num10 + num17 >= 0;
                        -- 				if (flag13) {
                        -- 					num7 = num7 + num12 << num18 + num10 + num17;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 				}
                        -- 			}
                        -- 			else {
                        -- 				flag14 = num18 + num10 + num17 >= 0;
                        -- 				if (flag14) {
                        -- 					num7 = num7 - num12 << num18 + num10 + num17;
                        -- 				}
                        -- 				else {
                        -- 					num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 				}
                        -- 			}
                        -- 			num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 		}
                        -- 	}
                        -- 	flag15 = num7 == 0u;
                        -- 	if (flag15) {
                        -- 		result = new Posit32 (0u, true);
                        -- 	}
                        -- 	else {
                        -- 		regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 		System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 		remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 		exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 		result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = left.PositBits >> 31;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.0\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).2.left\.\PositBits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).2.num\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0u - num;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.1\ := to_unsigned(0, 32) - \Posit32::op_Addition(Posit32,Posit32).2.num\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num2\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- left2 = new Posit32 (left.PositBits ^ num2 + num, true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::op_Addition(Posit32,Posit32).2.left2\.\IsNull\ := false;
                        \Posit32::op_Addition(Posit32,Posit32).2.left2\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.2\ := \Posit32::op_Addition(Posit32,Posit32).2.left\.\PositBits\ xor \Posit32::op_Addition(Posit32,Posit32).2.num2\;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0.6928
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_19\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.3\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.2\ + \Posit32::op_Addition(Posit32,Posit32).2.num\;
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.left2\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.3\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_20\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.left2\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = right.PositBits >> 31;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.4\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).2.right\.\PositBits\, to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                            \Posit32::op_Addition(Posit32,Posit32).2.num3\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 0u - num3;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.5\ := to_unsigned(0, 32) - \Posit32::op_Addition(Posit32,Posit32).2.num3\;
                            \Posit32::op_Addition(Posit32,Posit32).2.num4\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- right2 = new Posit32 (right.PositBits ^ num4 + num3, true);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit32::op_Addition(Posit32,Posit32).2.right2\.\IsNull\ := false;
                            \Posit32::op_Addition(Posit32,Posit32).2.right2\.\PositBits\ := to_unsigned(0, 32);
                            -- Invoking the target's constructor.
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.6\ := \Posit32::op_Addition(Posit32,Posit32).2.right\.\PositBits\ xor \Posit32::op_Addition(Posit32,Posit32).2.num4\;
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6928
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_21\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.6\ + \Posit32::op_Addition(Posit32,Posit32).2.num3\;
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_22\;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_22\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.7\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_23\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_23\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.right2\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- lengthOfRunOfBits = Posit32.LengthOfRunOfBits (left2.PositBits, 31);
                            -- 
                            -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.left2\.\PositBits\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_24\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.4\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.lengthOfRunOfBits\ := \Posit32::op_Addition(Posit32,Posit32).2.return.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- lengthOfRunOfBits2 = Posit32.LengthOfRunOfBits (right2.PositBits, 31);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_25\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_26\ => 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.right2\.\PositBits\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\ <= to_unsigned(31, 8);
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_27\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_27\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.5\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.lengthOfRunOfBits2\ := \Posit32::op_Addition(Posit32,Posit32).2.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- num5 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.lengthOfRunOfBits\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_28\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.6\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.num5\ := \Posit32::op_Addition(Posit32,Posit32).2.return.6\;
                            -- The following section was transformed from the .NET statement below:
                            -- num6 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_29\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_29\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_30\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_30\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.lengthOfRunOfBits2\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_31\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_31\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.7\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.num6\ := \Posit32::op_Addition(Posit32,Posit32).2.return.7\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag5 = num == num3;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.8\ := \Posit32::op_Addition(Posit32,Posit32).2.num\ = \Posit32::op_Addition(Posit32,Posit32).2.num3\;
                            \Posit32::op_Addition(Posit32,Posit32).2.flag5\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- regimeKValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (left2, lengthOfRunOfBits);
                            -- 
                            -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.lengthOfRunOfBits\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_32\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_32\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.8\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.regimeKValueWithoutSignCheck\ := \Posit32::op_Addition(Posit32,Posit32).2.return.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValueWithoutSignCheck = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (left2, num5);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.num5\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_33\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.9\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.exponentValueWithoutSignCheck\ := \Posit32::op_Addition(Posit32,Posit32).2.return.9\;
                            -- The following section was transformed from the .NET statement below:
                            -- regimeKValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetRegimeKValueWithoutSignCheck (right2, lengthOfRunOfBits2);
                            -- 
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_34\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_34\ => 
                        -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.lengthOfRunOfBits2\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_35\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_35\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.10\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.regimeKValueWithoutSignCheck2\ := \Posit32::op_Addition(Posit32,Posit32).2.return.10\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValueWithoutSignCheck2 = Lombiq.Arithmetics.Posit32.GetExponentValueWithoutSignCheck (right2, num6);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.right2\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.num6\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_36\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.11\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.exponentValueWithoutSignCheck2\ := \Posit32::op_Addition(Posit32,Posit32).2.return.11\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (Posit32.op_GreaterThan (left2, right2)) {
                            -- 	signBit = num == 1u;
                            -- }
                            -- else {
                            -- 	signBit = num3 == 1u;
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32).left.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.left2\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32).right.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.right2\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_37\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_37\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.12\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32).return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_39\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_39\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_40\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_40\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_38\.

                            if (\Posit32::op_Addition(Posit32,Posit32).2.return.12\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_39\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_40\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_38\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = 0u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := to_unsigned(0, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- num8 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck, exponentValueWithoutSignCheck, 2);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.regimeKValueWithoutSignCheck\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.exponentValueWithoutSignCheck\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(2, 8);
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_41\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_39\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	signBit = num == 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = num == 1u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.9\ := \Posit32::op_Addition(Posit32,Posit32).2.num\ = to_unsigned(1, 32);
                        \Posit32::op_Addition(Posit32,Posit32).2.signBit\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.9\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_37\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_39\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_40\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_37\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	signBit = num3 == 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = num3 == 1u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.10\ := \Posit32::op_Addition(Posit32,Posit32).2.num3\ = to_unsigned(1, 32);
                        \Posit32::op_Addition(Posit32,Posit32).2.signBit\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.10\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_37\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_40\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_41\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.13\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.num8\ := \Posit32::op_Addition(Posit32,Posit32).2.return.13\;
                            -- The following section was transformed from the .NET statement below:
                            -- num9 = Posit32.CalculateScaleFactor (regimeKValueWithoutSignCheck2, exponentValueWithoutSignCheck2, 2);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_42\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_43\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_43\ => 
                        -- Starting state machine invocation for the following method: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.regimeKValueWithoutSignCheck2\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.exponentValueWithoutSignCheck2\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(2, 8);
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_44\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_44\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.14\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.num9\ := \Posit32::op_Addition(Posit32,Posit32).2.return.14\;
                            -- The following section was transformed from the .NET statement below:
                            -- num10 = (int)((System.Int32)(num8) - (System.Int32)(num9));
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.11\ := SmartResize((\Posit32::op_Addition(Posit32,Posit32).2.num8\), 32) - SmartResize((\Posit32::op_Addition(Posit32,Posit32).2.num9\), 32);
                            \Posit32::op_Addition(Posit32,Posit32).2.num10\ := (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.11\);
                            -- The following section was transformed from the .NET statement below:
                            -- if (num10 >= 0) {
                            -- 	num11 = num8;
                            -- }
                            -- else {
                            -- 	num11 = num9;
                            -- }
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.12\ := \Posit32::op_Addition(Posit32,Posit32).2.num10\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_46\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_46\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_47\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_47\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_45\.

                            if (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.12\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_46\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_47\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.5911
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_45\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- num12 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left2, num5);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.left2\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.num5\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_48\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_46\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num11 = num8;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = num8;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.num11\ := \Posit32::op_Addition(Posit32,Posit32).2.num8\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_44\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_46\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_45\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_47\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num11 = num9;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = num9;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.num11\ := \Posit32::op_Addition(Posit32,Posit32).2.num9\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_44\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_47\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_45\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_48\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.15\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.num12\ := \Posit32::op_Addition(Posit32,Posit32).2.return.15\;
                            -- The following section was transformed from the .NET statement below:
                            -- num13 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right2, num6);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_49\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_49\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_50\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_50\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.right2\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.num6\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_51\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_51\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.16\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.num13\ := \Posit32::op_Addition(Posit32,Posit32).2.return.16\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag6 = num10 == 0;
                            -- 
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.13\ := \Posit32::op_Addition(Posit32,Posit32).2.num10\ = to_signed(0, 32);
                            \Posit32::op_Addition(Posit32,Posit32).2.flag6\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.13\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag6) {
                            -- 	flag7 = flag5;
                            -- 	if (flag7) {
                            -- 		num7 = 0u + num12 + num13;
                            -- 	}
                            -- 	else {
                            -- 		flag8 = num12 >= num13;
                            -- 		if (flag8) {
                            -- 			num7 = num7 + num12 - num13;
                            -- 		}
                            -- 		else {
                            -- 			num7 = num7 + num13 - num12;
                            -- 		}
                            -- 	}
                            -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                            -- }
                            -- else {
                            -- 	flag9 = num10 > 0;
                            -- 	if (flag9) {
                            -- 		num14 = (int)(num5 - num6);
                            -- 		num7 = num7 + num12;
                            -- 		num15 = (int)(31u - num5 - 1u);
                            -- 		num7 = num7 << num15;
                            -- 		num16 = num15 - num10 + num14;
                            -- 		flag10 = flag5;
                            -- 		if (flag10) {
                            -- 			flag11 = num16 >= 0;
                            -- 			if (flag11) {
                            -- 				num7 = num7 + num13 << num16;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 + num13 >> -num16;
                            -- 			}
                            -- 		}
                            -- 		else {
                            -- 			uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 			if (num16 >= 0) {
                            -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                            -- 			}
                            -- 			else {
                            -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                            -- 			}
                            -- 			num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                            -- 		}
                            -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 	}
                            -- 	else {
                            -- 		num17 = (int)(num6 - num5);
                            -- 		num7 = num7 + num13;
                            -- 		num18 = (int)(31u - num6 - 1u);
                            -- 		num7 = num7 << num18;
                            -- 		flag12 = flag5;
                            -- 		if (flag12) {
                            -- 			flag13 = num18 + num10 + num17 >= 0;
                            -- 			if (flag13) {
                            -- 				num7 = num7 + num12 << num18 + num10 + num17;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 + num12 >> -num18 + num10 + num17;
                            -- 			}
                            -- 		}
                            -- 		else {
                            -- 			flag14 = num18 + num10 + num17 >= 0;
                            -- 			if (flag14) {
                            -- 				num7 = num7 - num12 << num18 + num10 + num17;
                            -- 			}
                            -- 			else {
                            -- 				num7 = num7 - num12 >> -num18 + num10 + num17;
                            -- 			}
                            -- 		}
                            -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_53\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_60\.
                            --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_61\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_62\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_52\.

                            if (\Posit32::op_Addition(Posit32,Posit32).2.flag6\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_53\;
                            else 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_61\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_52\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_51\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag15 = num7 == 0u;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.72\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ = to_unsigned(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).2.flag15\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.72\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag15) {
                        -- 	result = new Posit32 (0u, true);
                        -- }
                        -- else {
                        -- 	regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 	System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 	remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 	exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 	result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_93\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_94\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_95\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_97\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_92\.

                        if (\Posit32::op_Addition(Posit32,Posit32).2.flag15\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_93\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_95\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_53\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_51\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag7 = flag5;
                        -- 	if (flag7) {
                        -- 		num7 = 0u + num12 + num13;
                        -- 	}
                        -- 	else {
                        -- 		flag8 = num12 >= num13;
                        -- 		if (flag8) {
                        -- 			num7 = num7 + num12 - num13;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num13 - num12;
                        -- 		}
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag7 = flag5;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.flag7\ := \Posit32::op_Addition(Posit32,Posit32).2.flag5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag7) {
                        -- 	num7 = 0u + num12 + num13;
                        -- }
                        -- else {
                        -- 	flag8 = num12 >= num13;
                        -- 	if (flag8) {
                        -- 		num7 = num7 + num12 - num13;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 - num12;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_55\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_55\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_56\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_57\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_54\.

                        if (\Posit32::op_Addition(Posit32,Posit32).2.flag7\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_55\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_56\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_54\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_53\.
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((uint)Posit32.GetMostSignificantOnePosition (num7) - num5 - 1u)));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_60\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_55\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_53\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = 0u + num12 + num13;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = 0u + num12 + num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.14\ := \Posit32::op_Addition(Posit32,Posit32).2.num12\ + \Posit32::op_Addition(Posit32,Posit32).2.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.15\ := to_unsigned(0, 32) + \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.14\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.15\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_53\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_55\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_54\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_56\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_53\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag8 = num12 >= num13;
                        -- 	if (flag8) {
                        -- 		num7 = num7 + num12 - num13;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 - num12;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag8 = num12 >= num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.16\ := \Posit32::op_Addition(Posit32,Posit32).2.num12\ >= \Posit32::op_Addition(Posit32,Posit32).2.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).2.flag8\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.16\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag8) {
                        -- 	num7 = num7 + num12 - num13;
                        -- }
                        -- else {
                        -- 	num7 = num7 + num13 - num12;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_58\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_58\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_59\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_59\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_57\.

                        if (\Posit32::op_Addition(Posit32,Posit32).2.flag8\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_58\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_59\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_57\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_56\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_53\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_57\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_54\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_58\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_56\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num12 - num13;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12 - num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.17\ := \Posit32::op_Addition(Posit32,Posit32).2.num12\ - \Posit32::op_Addition(Posit32,Posit32).2.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.18\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ + \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.17\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.18\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_56\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_58\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_57\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_59\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_56\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num13 - num12;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13 - num12;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.19\ := \Posit32::op_Addition(Posit32,Posit32).2.num13\ - \Posit32::op_Addition(Posit32,Posit32).2.num12\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.20\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ + \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.19\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.20\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_56\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_59\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_57\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_60\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.17\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.21\ := SmartResize(\Posit32::op_Addition(Posit32,Posit32).2.return.17\, 32) - \Posit32::op_Addition(Posit32,Posit32).2.num5\;
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.22\ := signed(SmartResize(\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.21\ - to_unsigned(1, 32), 16));
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.23\ := SmartResize(SmartResize((\Posit32::op_Addition(Posit32,Posit32).2.num11\), 32) + signed(((\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.22\))), 16);
                            \Posit32::op_Addition(Posit32,Posit32).2.num11\ := (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.23\);
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_51\.
                            if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_60\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_52\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_61\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_51\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag9 = num10 > 0;
                        -- 	if (flag9) {
                        -- 		num14 = (int)(num5 - num6);
                        -- 		num7 = num7 + num12;
                        -- 		num15 = (int)(31u - num5 - 1u);
                        -- 		num7 = num7 << num15;
                        -- 		num16 = num15 - num10 + num14;
                        -- 		flag10 = flag5;
                        -- 		if (flag10) {
                        -- 			flag11 = num16 >= 0;
                        -- 			if (flag11) {
                        -- 				num7 = num7 + num13 << num16;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 + num13 >> -num16;
                        -- 			}
                        -- 		}
                        -- 		else {
                        -- 			uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 			if (num16 >= 0) {
                        -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 			}
                        -- 			else {
                        -- 				conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 			}
                        -- 			num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 		}
                        -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 	}
                        -- 	else {
                        -- 		num17 = (int)(num6 - num5);
                        -- 		num7 = num7 + num13;
                        -- 		num18 = (int)(31u - num6 - 1u);
                        -- 		num7 = num7 << num18;
                        -- 		flag12 = flag5;
                        -- 		if (flag12) {
                        -- 			flag13 = num18 + num10 + num17 >= 0;
                        -- 			if (flag13) {
                        -- 				num7 = num7 + num12 << num18 + num10 + num17;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 			}
                        -- 		}
                        -- 		else {
                        -- 			flag14 = num18 + num10 + num17 >= 0;
                        -- 			if (flag14) {
                        -- 				num7 = num7 - num12 << num18 + num10 + num17;
                        -- 			}
                        -- 			else {
                        -- 				num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 			}
                        -- 		}
                        -- 		num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag9 = num10 > 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.24\ := \Posit32::op_Addition(Posit32,Posit32).2.num10\ > to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).2.flag9\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.24\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag9) {
                        -- 	num14 = (int)(num5 - num6);
                        -- 	num7 = num7 + num12;
                        -- 	num15 = (int)(31u - num5 - 1u);
                        -- 	num7 = num7 << num15;
                        -- 	num16 = num15 - num10 + num14;
                        -- 	flag10 = flag5;
                        -- 	if (flag10) {
                        -- 		flag11 = num16 >= 0;
                        -- 		if (flag11) {
                        -- 			num7 = num7 + num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num13 >> -num16;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 		if (num16 >= 0) {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 		}
                        -- 		num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- else {
                        -- 	num17 = (int)(num6 - num5);
                        -- 	num7 = num7 + num13;
                        -- 	num18 = (int)(31u - num6 - 1u);
                        -- 	num7 = num7 << num18;
                        -- 	flag12 = flag5;
                        -- 	if (flag12) {
                        -- 		flag13 = num18 + num10 + num17 >= 0;
                        -- 		if (flag13) {
                        -- 			num7 = num7 + num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag14 = num18 + num10 + num17 >= 0;
                        -- 		if (flag14) {
                        -- 			num7 = num7 - num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_63\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_75\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_76\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_91\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_62\.

                        if (\Posit32::op_Addition(Posit32,Posit32).2.flag9\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_63\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_76\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_62\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_61\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_51\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_62\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_52\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_63\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_61\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num14 = (int)(num5 - num6);
                        -- 	num7 = num7 + num12;
                        -- 	num15 = (int)(31u - num5 - 1u);
                        -- 	num7 = num7 << num15;
                        -- 	num16 = num15 - num10 + num14;
                        -- 	flag10 = flag5;
                        -- 	if (flag10) {
                        -- 		flag11 = num16 >= 0;
                        -- 		if (flag11) {
                        -- 			num7 = num7 + num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num13 >> -num16;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 		if (num16 >= 0) {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 		}
                        -- 		else {
                        -- 			conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 		}
                        -- 		num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num14 = (int)(num5 - num6);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.25\ := signed(\Posit32::op_Addition(Posit32,Posit32).2.num5\ - \Posit32::op_Addition(Posit32,Posit32).2.num6\);
                        \Posit32::op_Addition(Posit32,Posit32).2.num14\ := (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.25\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.26\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ + \Posit32::op_Addition(Posit32,Posit32).2.num12\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.26\;
                        -- The following section was transformed from the .NET statement below:
                        -- num15 = (int)(31u - num5 - 1u);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.27\ := to_unsigned(31, 32) - \Posit32::op_Addition(Posit32,Posit32).2.num5\;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_64\;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_64\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.28\ := signed(\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.27\ - to_unsigned(1, 32));
                        \Posit32::op_Addition(Posit32,Posit32).2.num15\ := (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.28\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 << num15;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.29\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).2.num7\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).2.num15\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.29\;
                        -- The following section was transformed from the .NET statement below:
                        -- num16 = num15 - num10 + num14;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.30\ := \Posit32::op_Addition(Posit32,Posit32).2.num15\ - \Posit32::op_Addition(Posit32,Posit32).2.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_65\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_65\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.31\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.30\ + \Posit32::op_Addition(Posit32,Posit32).2.num14\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num16\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.31\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag10 = flag5;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.flag10\ := \Posit32::op_Addition(Posit32,Posit32).2.flag5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag10) {
                        -- 	flag11 = num16 >= 0;
                        -- 	if (flag11) {
                        -- 		num7 = num7 + num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 >> -num16;
                        -- 	}
                        -- }
                        -- else {
                        -- 	uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	if (num16 >= 0) {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 	}
                        -- 	num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_67\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_68\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_71\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_72\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_66\.

                        if (\Posit32::op_Addition(Posit32,Posit32).2.flag10\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_67\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_71\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_66\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_65\.
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_75\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_67\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_65\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag11 = num16 >= 0;
                        -- 	if (flag11) {
                        -- 		num7 = num7 + num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num13 >> -num16;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag11 = num16 >= 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.32\ := \Posit32::op_Addition(Posit32,Posit32).2.num16\ >= to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).2.flag11\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.32\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag11) {
                        -- 	num7 = num7 + num13 << num16;
                        -- }
                        -- else {
                        -- 	num7 = num7 + num13 >> -num16;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_69\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_69\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_70\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_70\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_68\.

                        if (\Posit32::op_Addition(Posit32,Posit32).2.flag11\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_69\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_70\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_68\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_67\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_65\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_68\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_66\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_69\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_67\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num13 << num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13 << num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.33\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).2.num13\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).2.num16\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.34\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ + \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.33\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.34\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_67\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_69\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_68\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_70\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_67\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num13 >> -num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13 >> -num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.35\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).2.num13\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).2.num16\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.36\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ + \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.35\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.36\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_67\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_70\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_68\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6542
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_71\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_65\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 	if (num16 >= 0) {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 	}
                        -- 	else {
                        -- 		conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 	}
                        -- 	num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num16 >= 0) {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- }
                        -- else {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- }
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.37\ := \Posit32::op_Addition(Posit32,Posit32).2.num16\ >= to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_73\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_73\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_74\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_74\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_72\.

                        if (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.37\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_73\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_74\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_72\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_71\.
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 - conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.40\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ - \Posit32::op_Addition(Posit32,Posit32).2.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.40\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_65\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_72\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_66\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_73\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_71\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 << num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.38\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).2.num13\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).2.num16\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).2.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.38\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_71\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_73\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_72\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_74\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_71\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e = num13 >> -num16;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.39\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).2.num13\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).2.num16\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).2.conditional8d1e1bd784c94ce0888656c04f776836d5de4df99b2d1ee4411eb3dbe9626a9e\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.39\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_71\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_74\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_72\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3386
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_75\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.18\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.41\ := SmartResize(signed(SmartResize((\Posit32::op_Addition(Posit32,Posit32).2.return.18\), 32)) - to_signed(31, 32), 16);
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.42\ := SmartResize(SmartResize((\Posit32::op_Addition(Posit32,Posit32).2.num11\), 32) + signed(SmartResize(((\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.41\)), 32)), 16);
                            \Posit32::op_Addition(Posit32,Posit32).2.num11\ := (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.42\);
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_61\.
                            if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_75\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_62\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_76\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_61\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num17 = (int)(num6 - num5);
                        -- 	num7 = num7 + num13;
                        -- 	num18 = (int)(31u - num6 - 1u);
                        -- 	num7 = num7 << num18;
                        -- 	flag12 = flag5;
                        -- 	if (flag12) {
                        -- 		flag13 = num18 + num10 + num17 >= 0;
                        -- 		if (flag13) {
                        -- 			num7 = num7 + num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		flag14 = num18 + num10 + num17 >= 0;
                        -- 		if (flag14) {
                        -- 			num7 = num7 - num12 << num18 + num10 + num17;
                        -- 		}
                        -- 		else {
                        -- 			num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 		}
                        -- 	}
                        -- 	num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num17 = (int)(num6 - num5);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.43\ := signed(\Posit32::op_Addition(Posit32,Posit32).2.num6\ - \Posit32::op_Addition(Posit32,Posit32).2.num5\);
                        \Posit32::op_Addition(Posit32,Posit32).2.num17\ := (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.43\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num13;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.44\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ + \Posit32::op_Addition(Posit32,Posit32).2.num13\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.44\;
                        -- The following section was transformed from the .NET statement below:
                        -- num18 = (int)(31u - num6 - 1u);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.45\ := to_unsigned(31, 32) - \Posit32::op_Addition(Posit32,Posit32).2.num6\;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_77\;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_77\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.46\ := signed(\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.45\ - to_unsigned(1, 32));
                        \Posit32::op_Addition(Posit32,Posit32).2.num18\ := (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.46\);
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 << num18;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.47\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).2.num7\, to_integer(unsigned(SmartResize(unsigned(\Posit32::op_Addition(Posit32,Posit32).2.num18\), 5))));
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.47\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag12 = flag5;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.flag12\ := \Posit32::op_Addition(Posit32,Posit32).2.flag5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag12) {
                        -- 	flag13 = num18 + num10 + num17 >= 0;
                        -- 	if (flag13) {
                        -- 		num7 = num7 + num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- else {
                        -- 	flag14 = num18 + num10 + num17 >= 0;
                        -- 	if (flag14) {
                        -- 		num7 = num7 - num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_79\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_80\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_85\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_86\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_78\.

                        if (\Posit32::op_Addition(Posit32,Posit32).2.flag12\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_79\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_85\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.4156
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_78\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_77\.
                        -- The following section was transformed from the .NET statement below:
                        -- num11 = (System.Int16)((System.Int32)(num11) + (System.Int32)((short)((System.Int32)(Posit32.GetMostSignificantOnePosition (num7)) - 31)));
                        -- 
                        -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_91\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_79\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_77\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag13 = num18 + num10 + num17 >= 0;
                        -- 	if (flag13) {
                        -- 		num7 = num7 + num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag13 = num18 + num10 + num17 >= 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.48\ := \Posit32::op_Addition(Posit32,Posit32).2.num18\ + \Posit32::op_Addition(Posit32,Posit32).2.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.49\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.48\ + \Posit32::op_Addition(Posit32,Posit32).2.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.50\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.49\ >= to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).2.flag13\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.50\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag13) {
                        -- 	num7 = num7 + num12 << num18 + num10 + num17;
                        -- }
                        -- else {
                        -- 	num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_81\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_82\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_83\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_84\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_80\.

                        if (\Posit32::op_Addition(Posit32,Posit32).2.flag13\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_81\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_83\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9067
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_80\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_79\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_77\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_80\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_78\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_81\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_79\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num12 << num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12 << num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.51\ := \Posit32::op_Addition(Posit32,Posit32).2.num18\ + \Posit32::op_Addition(Posit32,Posit32).2.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.52\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.51\ + \Posit32::op_Addition(Posit32,Posit32).2.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.53\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).2.num12\, to_integer(unsigned(SmartResize(\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.52\, 5))));
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_82\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_82\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.54\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ + \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.53\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.54\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_79\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_82\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_80\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_83\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_79\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 + num12 >> -num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.55\ := \Posit32::op_Addition(Posit32,Posit32).2.num18\ + \Posit32::op_Addition(Posit32,Posit32).2.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.56\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.55\ + \Posit32::op_Addition(Posit32,Posit32).2.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.57\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).2.num12\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.56\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_84\;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_84\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.58\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ + \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.57\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.58\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_79\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_84\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_80\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_85\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_77\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag14 = num18 + num10 + num17 >= 0;
                        -- 	if (flag14) {
                        -- 		num7 = num7 - num12 << num18 + num10 + num17;
                        -- 	}
                        -- 	else {
                        -- 		num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag14 = num18 + num10 + num17 >= 0;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.59\ := \Posit32::op_Addition(Posit32,Posit32).2.num18\ + \Posit32::op_Addition(Posit32,Posit32).2.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.60\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.59\ + \Posit32::op_Addition(Posit32,Posit32).2.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.61\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.60\ >= to_signed(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).2.flag14\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.61\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag14) {
                        -- 	num7 = num7 - num12 << num18 + num10 + num17;
                        -- }
                        -- else {
                        -- 	num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_87\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_88\.
                        --     * The false branch starts in state \Posit32::op_Addition(Posit32,Posit32).2._State_89\ and ends in state \Posit32::op_Addition(Posit32,Posit32).2._State_90\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Addition(Posit32,Posit32).2._State_86\.

                        if (\Posit32::op_Addition(Posit32,Posit32).2.flag14\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_87\;
                        else 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_89\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9067
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_86\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_85\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_77\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_86\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_78\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_87\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_85\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 - num12 << num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 - num12 << num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.62\ := \Posit32::op_Addition(Posit32,Posit32).2.num18\ + \Posit32::op_Addition(Posit32,Posit32).2.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.63\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.62\ + \Posit32::op_Addition(Posit32,Posit32).2.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.64\ := shift_left(\Posit32::op_Addition(Posit32,Posit32).2.num12\, to_integer(unsigned(SmartResize(\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.63\, 5))));
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_88\;
                        -- Clock cycles needed to complete this state (approximation): 0.7312
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_88\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.65\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ - \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.64\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.65\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_85\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_88\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_86\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_89\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_85\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num7 = num7 - num12 >> -num18 + num10 + num17;
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.66\ := \Posit32::op_Addition(Posit32,Posit32).2.num18\ + \Posit32::op_Addition(Posit32,Posit32).2.num10\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.67\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.66\ + \Posit32::op_Addition(Posit32,Posit32).2.num17\;
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.68\ := shift_right(\Posit32::op_Addition(Posit32,Posit32).2.num12\, to_integer(unsigned(SmartResize(-\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.67\, 5) and "11111")));
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_90\;
                        -- Clock cycles needed to complete this state (approximation): 0.9698
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_90\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.69\ := \Posit32::op_Addition(Posit32,Posit32).2.num7\ - \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.68\;
                        \Posit32::op_Addition(Posit32,Posit32).2.num7\ := \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.69\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_85\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_90\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_86\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_91\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.19\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.70\ := SmartResize(signed(SmartResize((\Posit32::op_Addition(Posit32,Posit32).2.return.19\), 32)) - to_signed(31, 32), 16);
                            \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.71\ := SmartResize(SmartResize((\Posit32::op_Addition(Posit32,Posit32).2.num11\), 32) + signed(SmartResize(((\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.70\)), 32)), 16);
                            \Posit32::op_Addition(Posit32,Posit32).2.num11\ := (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.71\);
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_61\.
                            if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_91\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_62\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6312
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_92\ => 
                        -- State after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_52\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_15\.
                        if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_92\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_93\ => 
                        -- True branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new Posit32 (0u, true);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit32 (0u, true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::op_Addition(Posit32,Posit32).2.result\.\IsNull\ := false;
                        \Posit32::op_Addition(Posit32,Posit32).2.result\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.result\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_94\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_94\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.result\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_52\.
                            if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_94\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_92\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_95\ => 
                        -- False branch of the if-else started in state \Posit32::op_Addition(Posit32,Posit32).2._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 	System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 	remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 	exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 	result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue = (int)((System.Int32)(num11) / 4);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.73\ := SmartResize((\Posit32::op_Addition(Posit32,Posit32).2.num11\), 32) / to_signed(4, 32);
                        \Posit32::op_Addition(Posit32,Posit32).2.regimeKValue\ := (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.73\);
                        -- The following section was transformed from the .NET statement below:
                        -- System.Int32 remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 = (System.Int32)(num11);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ := SmartResize((\Posit32::op_Addition(Posit32,Posit32).2.num11\), 32);
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = (uint)(remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 - remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467 / 4 * 4);
                        -- 
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.74\ := \Posit32::op_Addition(Posit32,Posit32).2.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ / to_signed(4, 32);
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.75\ := SmartResize(\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.74\ * to_signed(4, 32), 32);
                        \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.76\ := unsigned(\Posit32::op_Addition(Posit32,Posit32).2.remainderOperandc0c8cd63c23feb19b8c0e2c926c3416c2ee07f9db160f1920a9143835788e467\ - \Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.75\);
                        \Posit32::op_Addition(Posit32,Posit32).2.exponentBits\ := (\Posit32::op_Addition(Posit32,Posit32).2.binaryOperationResult.76\);
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, num7), true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::op_Addition(Posit32,Posit32).2.result\.\IsNull\ := false;
                        \Posit32::op_Addition(Posit32,Posit32).2.result\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.signBit\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.regimeKValue\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.exponentBits\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.num7\;
                        \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= true;
                        \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_96\;
                        -- Clock cycles needed to complete this state (approximation): 0.6156
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_96\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.return.20\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.result\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.return.20\;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                            \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_97\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Addition(Posit32,Posit32).2._State_97\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Addition(Posit32,Posit32).2.result\ := \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_Addition(Posit32,Posit32).2._State_52\.
                            if (\Posit32::op_Addition(Posit32,Posit32).2._State\ = \Posit32::op_Addition(Posit32,Posit32).2._State_97\) then 
                                \Posit32::op_Addition(Posit32,Posit32).2._State\ := \Posit32::op_Addition(Posit32,Posit32).2._State_92\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 state machine start
    \Posit32::op_GreaterThan(Posit32,Posit32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0._State\: \Posit32::op_GreaterThan(Posit32,Posit32).0._States\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_0\;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0.left\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0.flag\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0.result\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0.return.0\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0.return.1\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0.return.2\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0.return.3\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.2\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::op_GreaterThan(Posit32,Posit32).0._Finished\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.return\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_0\;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.flag\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.result\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.return.0\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.return.1\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.0\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.return.2\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.return.3\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.1\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.2\ := false;
            else 
                case \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ is 
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).0._Started\ = true) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).0._Started\ = true) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).0._Finished\ <= true;
                        else 
                            \Posit32::op_GreaterThan(Posit32,Posit32).0._Finished\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_2\ => 
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.left\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.left.parameter.In\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.right\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = Lombiq.Arithmetics.Posit32.IsPositive (left) != Lombiq.Arithmetics.Posit32.IsPositive (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).0.left\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.return.0\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).0.right\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.return.1\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().return.0\;
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.0\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.return.0\ /= \Posit32::op_GreaterThan(Posit32,Posit32).0.return.1\;
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.flag\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	result = Lombiq.Arithmetics.Posit32.IsPositive (left);
                            -- }
                            -- else {
                            -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (left)) {
                            -- 		result = left.PositBits > right.PositBits;
                            -- 	}
                            -- 	else {
                            -- 		result = left.PositBits <= right.PositBits;
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_8\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_9\.
                            --     * The false branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_10\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_13\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_GreaterThan(Posit32,Posit32).0._State_7\.

                            if (\Posit32::op_GreaterThan(Posit32,Posit32).0.flag\) then 
                                \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_8\;
                            else 
                                \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1238
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_7\ => 
                        -- State after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.return\ <= \Posit32::op_GreaterThan(Posit32,Posit32).0.result\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_8\ => 
                        -- True branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Lombiq.Arithmetics.Posit32.IsPositive (left);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Lombiq.Arithmetics.Posit32.IsPositive (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).0.left\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.return.2\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().return.0\;
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.result\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.return.2\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_6\.
                            if (\Posit32::op_GreaterThan(Posit32,Posit32).0._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).0._State_9\) then 
                                \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_10\ => 
                        -- False branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (left)) {
                        -- 		result = left.PositBits > right.PositBits;
                        -- 	}
                        -- 	else {
                        -- 		result = left.PositBits <= right.PositBits;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (left)) {
                        -- 	result = left.PositBits > right.PositBits;
                        -- }
                        -- else {
                        -- 	result = left.PositBits <= right.PositBits;
                        -- }
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_11\ => 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).0.left\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.return.3\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_14\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_14\.
                            --     * The false branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_15\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_15\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_GreaterThan(Posit32,Posit32).0._State_13\.

                            if (\Posit32::op_GreaterThan(Posit32,Posit32).0.return.3\) then 
                                \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_14\;
                            else 
                                \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_15\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_13\ => 
                        -- State after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_12\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_6\.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).0._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).0._State_13\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_14\ => 
                        -- True branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left.PositBits > right.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left.PositBits > right.PositBits;
                        -- 
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.1\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.left\.\PositBits\ > \Posit32::op_GreaterThan(Posit32,Posit32).0.right\.\PositBits\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.result\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.1\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_12\.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).0._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).0._State_14\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_GreaterThan(Posit32,Posit32).0._State_15\ => 
                        -- False branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left.PositBits <= right.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left.PositBits <= right.PositBits;
                        -- 
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.2\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.left\.\PositBits\ <= \Posit32::op_GreaterThan(Posit32,Posit32).0.right\.\PositBits\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).0.result\ := \Posit32::op_GreaterThan(Posit32,Posit32).0.binaryOperationResult.2\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).0._State_12\.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).0._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).0._State_15\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).0._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 state machine start
    \Posit32::op_GreaterThan(Posit32,Posit32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1._State\: \Posit32::op_GreaterThan(Posit32,Posit32).1._States\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_0\;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1.left\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1.flag\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1.result\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1.return.0\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1.return.1\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1.return.2\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1.return.3\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.2\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::op_GreaterThan(Posit32,Posit32).1._Finished\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.return\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_0\;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.flag\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.result\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.return.0\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.return.1\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.0\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.return.2\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.return.3\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.1\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.2\ := false;
            else 
                case \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ is 
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).1._Started\ = true) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).1._Started\ = true) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).1._Finished\ <= true;
                        else 
                            \Posit32::op_GreaterThan(Posit32,Posit32).1._Finished\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_2\ => 
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.left\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.left.parameter.In\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.right\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = Lombiq.Arithmetics.Posit32.IsPositive (left) != Lombiq.Arithmetics.Posit32.IsPositive (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).1.left\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.return.0\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).1.right\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.return.1\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().return.0\;
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.0\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.return.0\ /= \Posit32::op_GreaterThan(Posit32,Posit32).1.return.1\;
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.flag\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	result = Lombiq.Arithmetics.Posit32.IsPositive (left);
                            -- }
                            -- else {
                            -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (left)) {
                            -- 		result = left.PositBits > right.PositBits;
                            -- 	}
                            -- 	else {
                            -- 		result = left.PositBits <= right.PositBits;
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_8\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_9\.
                            --     * The false branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_10\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_13\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_GreaterThan(Posit32,Posit32).1._State_7\.

                            if (\Posit32::op_GreaterThan(Posit32,Posit32).1.flag\) then 
                                \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_8\;
                            else 
                                \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1238
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_7\ => 
                        -- State after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.return\ <= \Posit32::op_GreaterThan(Posit32,Posit32).1.result\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_8\ => 
                        -- True branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Lombiq.Arithmetics.Posit32.IsPositive (left);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Lombiq.Arithmetics.Posit32.IsPositive (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).1.left\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.return.2\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().return.0\;
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.result\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.return.2\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_6\.
                            if (\Posit32::op_GreaterThan(Posit32,Posit32).1._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).1._State_9\) then 
                                \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_10\ => 
                        -- False branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (left)) {
                        -- 		result = left.PositBits > right.PositBits;
                        -- 	}
                        -- 	else {
                        -- 		result = left.PositBits <= right.PositBits;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (left)) {
                        -- 	result = left.PositBits > right.PositBits;
                        -- }
                        -- else {
                        -- 	result = left.PositBits <= right.PositBits;
                        -- }
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_11\ => 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).1.left\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.return.3\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_14\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_14\.
                            --     * The false branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_15\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_15\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_GreaterThan(Posit32,Posit32).1._State_13\.

                            if (\Posit32::op_GreaterThan(Posit32,Posit32).1.return.3\) then 
                                \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_14\;
                            else 
                                \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_15\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_13\ => 
                        -- State after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_12\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_6\.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).1._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).1._State_13\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_14\ => 
                        -- True branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left.PositBits > right.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left.PositBits > right.PositBits;
                        -- 
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.1\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.left\.\PositBits\ > \Posit32::op_GreaterThan(Posit32,Posit32).1.right\.\PositBits\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.result\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.1\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_12\.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).1._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).1._State_14\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_GreaterThan(Posit32,Posit32).1._State_15\ => 
                        -- False branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left.PositBits <= right.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left.PositBits <= right.PositBits;
                        -- 
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.2\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.left\.\PositBits\ <= \Posit32::op_GreaterThan(Posit32,Posit32).1.right\.\PositBits\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).1.result\ := \Posit32::op_GreaterThan(Posit32,Posit32).1.binaryOperationResult.2\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).1._State_12\.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).1._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).1._State_15\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).1._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).1._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 state machine start
    \Posit32::op_GreaterThan(Posit32,Posit32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2._State\: \Posit32::op_GreaterThan(Posit32,Posit32).2._States\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_0\;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2.left\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2.flag\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2.result\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2.return.0\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2.return.1\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2.return.2\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2.return.3\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.2\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::op_GreaterThan(Posit32,Posit32).2._Finished\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.return\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_0\;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.flag\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.result\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.return.0\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.return.1\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.0\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.return.2\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.return.3\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.1\ := false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.2\ := false;
            else 
                case \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ is 
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).2._Started\ = true) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).2._Started\ = true) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).2._Finished\ <= true;
                        else 
                            \Posit32::op_GreaterThan(Posit32,Posit32).2._Finished\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_2\ => 
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.left\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.left.parameter.In\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.right\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = Lombiq.Arithmetics.Posit32.IsPositive (left) != Lombiq.Arithmetics.Posit32.IsPositive (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).2.left\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.return.0\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).2.right\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.return.1\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().return.0\;
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.0\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.return.0\ /= \Posit32::op_GreaterThan(Posit32,Posit32).2.return.1\;
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.flag\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	result = Lombiq.Arithmetics.Posit32.IsPositive (left);
                            -- }
                            -- else {
                            -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (left)) {
                            -- 		result = left.PositBits > right.PositBits;
                            -- 	}
                            -- 	else {
                            -- 		result = left.PositBits <= right.PositBits;
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_8\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_9\.
                            --     * The false branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_10\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_13\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_GreaterThan(Posit32,Posit32).2._State_7\.

                            if (\Posit32::op_GreaterThan(Posit32,Posit32).2.flag\) then 
                                \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_8\;
                            else 
                                \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1238
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_7\ => 
                        -- State after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.return\ <= \Posit32::op_GreaterThan(Posit32,Posit32).2.result\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_8\ => 
                        -- True branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Lombiq.Arithmetics.Posit32.IsPositive (left);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Lombiq.Arithmetics.Posit32.IsPositive (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).2.left\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.return.2\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().return.0\;
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.result\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.return.2\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_6\.
                            if (\Posit32::op_GreaterThan(Posit32,Posit32).2._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).2._State_9\) then 
                                \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_10\ => 
                        -- False branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (left)) {
                        -- 		result = left.PositBits > right.PositBits;
                        -- 	}
                        -- 	else {
                        -- 		result = left.PositBits <= right.PositBits;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (left)) {
                        -- 	result = left.PositBits > right.PositBits;
                        -- }
                        -- else {
                        -- 	result = left.PositBits <= right.PositBits;
                        -- }
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_11\ => 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).2.left\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ = \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.return.3\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_14\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_14\.
                            --     * The false branch starts in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_15\ and ends in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_15\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_GreaterThan(Posit32,Posit32).2._State_13\.

                            if (\Posit32::op_GreaterThan(Posit32,Posit32).2.return.3\) then 
                                \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_14\;
                            else 
                                \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_15\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_13\ => 
                        -- State after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_12\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_6\.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).2._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).2._State_13\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_14\ => 
                        -- True branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left.PositBits > right.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left.PositBits > right.PositBits;
                        -- 
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.1\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.left\.\PositBits\ > \Posit32::op_GreaterThan(Posit32,Posit32).2.right\.\PositBits\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.result\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.1\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_12\.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).2._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).2._State_14\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2755
                    when \Posit32::op_GreaterThan(Posit32,Posit32).2._State_15\ => 
                        -- False branch of the if-else started in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left.PositBits <= right.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left.PositBits <= right.PositBits;
                        -- 
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.2\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.left\.\PositBits\ <= \Posit32::op_GreaterThan(Posit32,Posit32).2.right\.\PositBits\;
                        \Posit32::op_GreaterThan(Posit32,Posit32).2.result\ := \Posit32::op_GreaterThan(Posit32,Posit32).2.binaryOperationResult.2\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_GreaterThan(Posit32,Posit32).2._State_12\.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).2._State\ = \Posit32::op_GreaterThan(Posit32,Posit32).2._State_15\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).2._State\ := \Posit32::op_GreaterThan(Posit32,Posit32).2._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.261
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 state machine end


    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 state machine start
    \Posit32::op_Multiply(Posit32,Posit32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::op_Multiply(Posit32,Posit32).0._State\: \Posit32::op_Multiply(Posit32,Posit32).0._States\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_0\;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.left\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.right\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.flag\: boolean := false;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.result\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.flag2\: boolean := false;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.flag3\: boolean := false;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.signBit\: boolean := false;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.num3\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.num4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.fractionBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.num5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.exponentBits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.0\: boolean := false;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.1\: boolean := false;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.2\: boolean := false;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.3\: boolean := false;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.1\: boolean := false;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.4\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.5\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.2\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.10\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.11\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.13\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.14\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.15\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.16\: signed(15 downto 0) := to_signed(0, 16);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.16\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Multiply(Posit32,Posit32).0.return.17\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::op_Multiply(Posit32,Posit32).0._Finished\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64).bits.parameter.Out.0\ <= to_unsigned(0, 64);
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64)._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= to_signed(0, 8);
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_0\;
                \Posit32::op_Multiply(Posit32,Posit32).0.flag\ := false;
                \Posit32::op_Multiply(Posit32,Posit32).0.flag2\ := false;
                \Posit32::op_Multiply(Posit32,Posit32).0.flag3\ := false;
                \Posit32::op_Multiply(Posit32,Posit32).0.signBit\ := false;
                \Posit32::op_Multiply(Posit32,Posit32).0.num\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.num2\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.num3\ := to_unsigned(0, 64);
                \Posit32::op_Multiply(Posit32,Posit32).0.num4\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.fractionBits\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.num5\ := to_signed(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.regimeKValue\ := to_signed(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.exponentBits\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.0\ := false;
                \Posit32::op_Multiply(Posit32,Posit32).0.return.1\ := false;
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.0\ := false;
                \Posit32::op_Multiply(Posit32,Posit32).0.return.2\ := false;
                \Posit32::op_Multiply(Posit32,Posit32).0.return.3\ := false;
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.1\ := false;
                \Posit32::op_Multiply(Posit32,Posit32).0.return.6\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.7\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.8\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.9\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.2\ := to_unsigned(0, 64);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.10\ := to_unsigned(0, 8);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.4\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.9\ := to_signed(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.11\ := to_signed(0, 8);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.12\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.13\ := to_signed(0, 16);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.14\ := to_signed(0, 8);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.15\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.16\ := to_signed(0, 16);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.11\ := to_signed(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.12\ := to_signed(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.13\ := to_signed(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.14\ := to_signed(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.15\ := to_signed(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.16\ := to_unsigned(0, 32);
                \Posit32::op_Multiply(Posit32,Posit32).0.return.17\ := to_unsigned(0, 32);
            else 
                case \Posit32::op_Multiply(Posit32,Posit32).0._State\ is 
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::op_Multiply(Posit32,Posit32).0._Started\ = true) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::op_Multiply(Posit32,Posit32).0._Started\ = true) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0._Finished\ <= true;
                        else 
                            \Posit32::op_Multiply(Posit32,Posit32).0._Finished\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_2\ => 
                        \Posit32::op_Multiply(Posit32,Posit32).0.left\ := \Posit32::op_Multiply(Posit32,Posit32).0.left.parameter.In\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.right\ := \Posit32::op_Multiply(Posit32,Posit32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit32 result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool signBit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ulong num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint fractionBits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int regimeKValue;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentBits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = Lombiq.Arithmetics.Posit32.IsZero (left) || Lombiq.Arithmetics.Posit32.IsZero (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.left\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ <= true;
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.0\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.right\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ <= true;
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsZero()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.1\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().return.0\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.0\ := \Posit32::op_Multiply(Posit32,Posit32).0.return.0\ or \Posit32::op_Multiply(Posit32,Posit32).0.return.1\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.flag\ := \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	result = new Posit32 (0);
                            -- }
                            -- else {
                            -- 	flag2 = Lombiq.Arithmetics.Posit32.IsPositive (left);
                            -- 	flag3 = Lombiq.Arithmetics.Posit32.IsPositive (right);
                            -- 	signBit = flag2 != flag3;
                            -- 	left = Posit32.Abs (left);
                            -- 	right = Posit32.Abs (right);
                            -- 	num = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left);
                            -- 	num2 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right);
                            -- 	num3 = (ulong)Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left) * (ulong)Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right);
                            -- 	num4 = (uint)Posit32.GetMostSignificantOnePosition (num3) - num + num2 + 1u;
                            -- 	fractionBits = (uint)(num3 >> (int)(num + 1u + num2 + 1u - 32u));
                            -- 	num5 = (int)((System.Int32)(Posit32.CalculateScaleFactor (Lombiq.Arithmetics.Posit32.GetRegimeKValue (left), Lombiq.Arithmetics.Posit32.GetExponentValue (left), 2)) + (System.Int32)(Posit32.CalculateScaleFactor (Lombiq.Arithmetics.Posit32.GetRegimeKValue (right), Lombiq.Arithmetics.Posit32.GetExponentValue (right), 2)));
                            -- 	num5 = num5 + (int)num4;
                            -- 	regimeKValue = num5 / 4;
                            -- 	exponentBits = (uint)(num5 - num5 / 4 * 4);
                            -- 	result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, fractionBits), true);
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Multiply(Posit32,Posit32).0._State_8\ and ends in state \Posit32::op_Multiply(Posit32,Posit32).0._State_9\.
                            --     * The false branch starts in state \Posit32::op_Multiply(Posit32,Posit32).0._State_10\ and ends in state \Posit32::op_Multiply(Posit32,Posit32).0._State_38\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Multiply(Posit32,Posit32).0._State_7\.

                            if (\Posit32::op_Multiply(Posit32,Posit32).0.flag\) then 
                                \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_8\;
                            else 
                                \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_7\ => 
                        -- State after the if-else which was started in state \Posit32::op_Multiply(Posit32,Posit32).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::op_Multiply(Posit32,Posit32).0.return\ <= \Posit32::op_Multiply(Posit32,Posit32).0.result\;
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_8\ => 
                        -- True branch of the if-else started in state \Posit32::op_Multiply(Posit32,Posit32).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new Posit32 (0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit32 (0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::op_Multiply(Posit32,Posit32).0.result\.\IsNull\ := false;
                        \Posit32::op_Multiply(Posit32,Posit32).0.result\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.result\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Started.0\ <= true;
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32)
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.result\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_Multiply(Posit32,Posit32).0._State_6\.
                            if (\Posit32::op_Multiply(Posit32,Posit32).0._State\ = \Posit32::op_Multiply(Posit32,Posit32).0._State_9\) then 
                                \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_10\ => 
                        -- False branch of the if-else started in state \Posit32::op_Multiply(Posit32,Posit32).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag2 = Lombiq.Arithmetics.Posit32.IsPositive (left);
                        -- 	flag3 = Lombiq.Arithmetics.Posit32.IsPositive (right);
                        -- 	signBit = flag2 != flag3;
                        -- 	left = Posit32.Abs (left);
                        -- 	right = Posit32.Abs (right);
                        -- 	num = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left);
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right);
                        -- 	num3 = (ulong)Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left) * (ulong)Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right);
                        -- 	num4 = (uint)Posit32.GetMostSignificantOnePosition (num3) - num + num2 + 1u;
                        -- 	fractionBits = (uint)(num3 >> (int)(num + 1u + num2 + 1u - 32u));
                        -- 	num5 = (int)((System.Int32)(Posit32.CalculateScaleFactor (Lombiq.Arithmetics.Posit32.GetRegimeKValue (left), Lombiq.Arithmetics.Posit32.GetExponentValue (left), 2)) + (System.Int32)(Posit32.CalculateScaleFactor (Lombiq.Arithmetics.Posit32.GetRegimeKValue (right), Lombiq.Arithmetics.Posit32.GetExponentValue (right), 2)));
                        -- 	num5 = num5 + (int)num4;
                        -- 	regimeKValue = num5 / 4;
                        -- 	exponentBits = (uint)(num5 - num5 / 4 * 4);
                        -- 	result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, fractionBits), true);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = Lombiq.Arithmetics.Posit32.IsPositive (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.left\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.2\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().return.0\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.flag2\ := \Posit32::op_Multiply(Posit32,Posit32).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = Lombiq.Arithmetics.Posit32.IsPositive (right);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_12\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_13\ => 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.right\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.3\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().return.0\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.flag3\ := \Posit32::op_Multiply(Posit32,Posit32).0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- signBit = flag2 != flag3;
                            -- 
                            \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.1\ := \Posit32::op_Multiply(Posit32,Posit32).0.flag2\ /= \Posit32::op_Multiply(Posit32,Posit32).0.flag3\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.signBit\ := \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- left = Posit32.Abs (left);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::Abs(Lombiq.Arithmetics.Posit32)
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32).input.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.left\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Started.0\ <= true;
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1238
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::Abs(Lombiq.Arithmetics.Posit32)
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.4\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32).return.0\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.left\ := \Posit32::op_Multiply(Posit32,Posit32).0.return.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- right = Posit32.Abs (right);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_16\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_17\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_17\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::Abs(Lombiq.Arithmetics.Posit32)
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32).input.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.right\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Started.0\ <= true;
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_18\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_18\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::Abs(Lombiq.Arithmetics.Posit32)
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.5\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32).return.0\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.right\ := \Posit32::op_Multiply(Posit32,Posit32).0.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (left);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck()
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.left\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= true;
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_19\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.6\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().return.0\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.num\ := \Posit32::op_Multiply(Posit32,Posit32).0.return.6\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = Lombiq.Arithmetics.Posit32.FractionSizeWithoutSignCheck (right);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_20\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_21\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_21\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck()
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.right\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= true;
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_22\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_22\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.7\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().return.0\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.num2\ := \Posit32::op_Multiply(Posit32,Posit32).0.return.7\;
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = (ulong)Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (left) * (ulong)Lombiq.Arithmetics.Posit32.FractionWithHiddenBitWithoutSignCheck (right);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck()
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.left\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Started.0\ <= true;
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_23\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.8\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_24\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_25\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_25\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck()
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.right\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Started.0\ <= true;
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_26\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.9\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck().return.0\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.2\ := SmartResize(SmartResize(\Posit32::op_Multiply(Posit32,Posit32).0.return.8\, 64) * SmartResize(\Posit32::op_Multiply(Posit32,Posit32).0.return.9\, 64), 64);
                            \Posit32::op_Multiply(Posit32,Posit32).0.num3\ := \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = (uint)Posit32.GetMostSignificantOnePosition (num3) - num + num2 + 1u;
                            -- 
                            -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64)
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64).bits.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.num3\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64)._Started.0\ <= true;
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7632
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_27\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64)
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64)._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64)._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64)._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.10\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64).return.0\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.3\ := \Posit32::op_Multiply(Posit32,Posit32).0.num\ + \Posit32::op_Multiply(Posit32,Posit32).0.num2\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.4\ := \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.3\ + to_unsigned(1, 32);
                            \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.5\ := SmartResize(\Posit32::op_Multiply(Posit32,Posit32).0.return.10\, 32) - \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.4\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.num4\ := \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- fractionBits = (uint)(num3 >> (int)(num + 1u + num2 + 1u - 32u));
                            -- 
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_28\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.6\ := \Posit32::op_Multiply(Posit32,Posit32).0.num\ + to_unsigned(1, 32);
                        \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.7\ := \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.6\ + \Posit32::op_Multiply(Posit32,Posit32).0.num2\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.8\ := \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.7\ + to_unsigned(1, 32);
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_29\;
                        -- Clock cycles needed to complete this state (approximation): 0.9468
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_29\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.9\ := signed(\Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.8\ - to_unsigned(32, 32));
                        \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.10\ := SmartResize(shift_right(\Posit32::op_Multiply(Posit32,Posit32).0.num3\, to_integer(unsigned(SmartResize((\Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.9\), 6) and "111111"))), 32);
                        \Posit32::op_Multiply(Posit32,Posit32).0.fractionBits\ := (\Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.10\);
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = (int)((System.Int32)(Posit32.CalculateScaleFactor (Lombiq.Arithmetics.Posit32.GetRegimeKValue (left), Lombiq.Arithmetics.Posit32.GetExponentValue (left), 2)) + (System.Int32)(Posit32.CalculateScaleFactor (Lombiq.Arithmetics.Posit32.GetRegimeKValue (right), Lombiq.Arithmetics.Posit32.GetExponentValue (right), 2)));
                        -- 
                        -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.left\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Started.0\ <= true;
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_30\;
                        -- Clock cycles needed to complete this state (approximation): 0.589
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_30\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.11\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().return.0\;
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.left\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Started.0\ <= true;
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_31\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_31\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.12\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().return.0\;
                            -- Starting state machine invocation for the following method: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.return.11\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.return.12\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(2, 8);
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= true;
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_32\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_32\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.13\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\;
                            -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.right\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Started.0\ <= true;
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_33\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.14\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().return.0\;
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.right\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Started.0\ <= true;
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_34\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_34\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.15\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().return.0\;
                            -- Starting state machine invocation for the following method: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.return.14\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.return.15\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(2, 8);
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= true;
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_35\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte)
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.16\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.11\ := SmartResize(SmartResize((\Posit32::op_Multiply(Posit32,Posit32).0.return.13\), 32) + SmartResize((\Posit32::op_Multiply(Posit32,Posit32).0.return.16\), 32), 32);
                            \Posit32::op_Multiply(Posit32,Posit32).0.num5\ := (\Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.11\);
                            -- The following section was transformed from the .NET statement below:
                            -- num5 = num5 + (int)num4;
                            -- 
                            \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.12\ := \Posit32::op_Multiply(Posit32,Posit32).0.num5\ + signed(\Posit32::op_Multiply(Posit32,Posit32).0.num4\);
                            \Posit32::op_Multiply(Posit32,Posit32).0.num5\ := \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.12\;
                            -- The following section was transformed from the .NET statement below:
                            -- regimeKValue = num5 / 4;
                            -- 
                            \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.13\ := \Posit32::op_Multiply(Posit32,Posit32).0.num5\ / to_signed(4, 32);
                            \Posit32::op_Multiply(Posit32,Posit32).0.regimeKValue\ := \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.13\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentBits = (uint)(num5 - num5 / 4 * 4);
                            -- 
                            \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.14\ := \Posit32::op_Multiply(Posit32,Posit32).0.num5\ / to_signed(4, 32);
                            \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.15\ := SmartResize(\Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.14\ * to_signed(4, 32), 32);
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9312
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_36\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.16\ := unsigned(\Posit32::op_Multiply(Posit32,Posit32).0.num5\ - \Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.15\);
                        \Posit32::op_Multiply(Posit32,Posit32).0.exponentBits\ := (\Posit32::op_Multiply(Posit32,Posit32).0.binaryOperationResult.16\);
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit32 (Posit32.AssemblePositBitsWithRounding (signBit, regimeKValue, exponentBits, fractionBits), true);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit32::op_Multiply(Posit32,Posit32).0.result\.\IsNull\ := false;
                        \Posit32::op_Multiply(Posit32,Posit32).0.result\.\PositBits\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.signBit\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.regimeKValue\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.exponentBits\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.fractionBits\;
                        \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= true;
                        \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_37\;
                        -- Clock cycles needed to complete this state (approximation): 0.3156
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_37\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32)
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.return.17\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.result\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.return.17\;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\ <= True;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= true;
                            \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Multiply(Posit32,Posit32).0._State_38\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean)
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ <= false;
                            \Posit32::op_Multiply(Posit32,Posit32).0.result\ := \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_Multiply(Posit32,Posit32).0._State_6\.
                            if (\Posit32::op_Multiply(Posit32,Posit32).0._State\ = \Posit32::op_Multiply(Posit32,Posit32).0._State_38\) then 
                                \Posit32::op_Multiply(Posit32,Posit32).0._State\ := \Posit32::op_Multiply(Posit32,Posit32).0._State_7\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 state machine end


    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 state machine start
    \Posit32::op_Explicit(Posit32).0._StateMachine\: process (\Clock\) 
        Variable \Posit32::op_Explicit(Posit32).0._State\: \Posit32::op_Explicit(Posit32).0._States\ := \Posit32::op_Explicit(Posit32).0._State_0\;
        Variable \Posit32::op_Explicit(Posit32).0.x\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Explicit(Posit32).0.flag\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).0.result\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Explicit(Posit32).0.num\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).0.flag2\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).0.mostSignificantOnePosition\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Explicit(Posit32).0.flag3\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).0.return.0\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.2\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.3\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).0.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).0.return.3\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.5\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.6\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.7\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).0.return.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.8\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).0.return.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.11\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Explicit(Posit32).0.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).0.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).0.return.6\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).0.return.7\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::op_Explicit(Posit32).0._Finished\ <= false;
                \Posit32::op_Explicit(Posit32).0.return\ <= to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_0\;
                \Posit32::op_Explicit(Posit32).0.flag\ := false;
                \Posit32::op_Explicit(Posit32).0.result\ := to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).0.num\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).0.flag2\ := false;
                \Posit32::op_Explicit(Posit32).0.mostSignificantOnePosition\ := to_unsigned(0, 8);
                \Posit32::op_Explicit(Posit32).0.flag3\ := false;
                \Posit32::op_Explicit(Posit32).0.num2\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\ := false;
                \Posit32::op_Explicit(Posit32).0.return.0\ := to_signed(0, 8);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).0.return.1\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.2\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.3\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.4\ := false;
                \Posit32::op_Explicit(Posit32).0.return.2\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).0.return.3\ := to_unsigned(0, 8);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.5\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.6\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.7\ := false;
                \Posit32::op_Explicit(Posit32).0.return.4\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.8\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.9\ := to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).0.return.5\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.11\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.12\ := to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).0.binaryOperationResult.13\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).0.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).0.return.6\ := false;
                \Posit32::op_Explicit(Posit32).0.return.7\ := false;
            else 
                case \Posit32::op_Explicit(Posit32).0._State\ is 
                    when \Posit32::op_Explicit(Posit32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::op_Explicit(Posit32).0._Started\ = true) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::op_Explicit(Posit32).0._Started\ = true) then 
                            \Posit32::op_Explicit(Posit32).0._Finished\ <= true;
                        else 
                            \Posit32::op_Explicit(Posit32).0._Finished\ <= false;
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_2\ => 
                        \Posit32::op_Explicit(Posit32).0.x\ := \Posit32::op_Explicit(Posit32).0.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- long num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte mostSignificantOnePosition;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = x.PositBits == 0u;
                        -- 
                        \Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\ := \Posit32::op_Explicit(Posit32).0.x\.\PositBits\ = to_unsigned(0, 32);
                        \Posit32::op_Explicit(Posit32).0.flag\ := \Posit32::op_Explicit(Posit32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = 0;
                        -- }
                        -- else {
                        -- 	num = (long)((System.Int32)(Lombiq.Arithmetics.Posit32.GetRegimeKValue (x)) * 4) + (long)((ulong)Lombiq.Arithmetics.Posit32.GetExponentValue (x));
                        -- 	flag2 = num + 1L <= 31L;
                        -- 	if (flag2) {
                        -- 		mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 		flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 		if (flag3) {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		else {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 		}
                        -- 		else {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 		}
                        -- 		result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- 	}
                        -- 	else {
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			result = 2147483647;
                        -- 		}
                        -- 		else {
                        -- 			result = -2147483648;
                        -- 		}
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Explicit(Posit32).0._State_4\ and ends in state \Posit32::op_Explicit(Posit32).0._State_4\.
                        --     * The false branch starts in state \Posit32::op_Explicit(Posit32).0._State_5\ and ends in state \Posit32::op_Explicit(Posit32).0._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).0._State_3\.

                        if (\Posit32::op_Explicit(Posit32).0.flag\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_4\;
                        else 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Explicit(Posit32).0._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::op_Explicit(Posit32).0.return\ <= \Posit32::op_Explicit(Posit32).0.result\;
                        \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = 0;
                        -- 
                        \Posit32::op_Explicit(Posit32).0.result\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_2\.
                        if (\Posit32::op_Explicit(Posit32).0._State\ = \Posit32::op_Explicit(Posit32).0._State_4\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_5\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = (long)((System.Int32)(Lombiq.Arithmetics.Posit32.GetRegimeKValue (x)) * 4) + (long)((ulong)Lombiq.Arithmetics.Posit32.GetExponentValue (x));
                        -- 	flag2 = num + 1L <= 31L;
                        -- 	if (flag2) {
                        -- 		mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 		flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 		if (flag3) {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		else {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 		}
                        -- 		else {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 		}
                        -- 		result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- 	}
                        -- 	else {
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			result = 2147483647;
                        -- 		}
                        -- 		else {
                        -- 			result = -2147483648;
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (long)((System.Int32)(Lombiq.Arithmetics.Posit32.GetRegimeKValue (x)) * 4) + (long)((ulong)Lombiq.Arithmetics.Posit32.GetExponentValue (x));
                        -- 
                        -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                        \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).0.x\;
                        \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Started.0\ = \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).0.return.0\ := \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue().return.0\;
                            \Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\ := SmartResize(SmartResize((\Posit32::op_Explicit(Posit32).0.return.0\), 32) * to_signed(4, 32), 64);
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).0.x\;
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Started.0\ <= true;
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::op_Explicit(Posit32).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Started.0\ = \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).0.return.1\ := \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue().return.0\;
                            \Posit32::op_Explicit(Posit32).0.binaryOperationResult.2\ := (\Posit32::op_Explicit(Posit32).0.binaryOperationResult.1\) + signed((SmartResize(\Posit32::op_Explicit(Posit32).0.return.1\, 64)));
                            \Posit32::op_Explicit(Posit32).0.num\ := \Posit32::op_Explicit(Posit32).0.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = num + 1L <= 31L;
                            -- 
                            \Posit32::op_Explicit(Posit32).0.binaryOperationResult.3\ := \Posit32::op_Explicit(Posit32).0.num\ + to_signed(1, 64);
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7796
                    when \Posit32::op_Explicit(Posit32).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Explicit(Posit32).0.binaryOperationResult.4\ := \Posit32::op_Explicit(Posit32).0.binaryOperationResult.3\ <= to_signed(31, 64);
                        \Posit32::op_Explicit(Posit32).0.flag2\ := \Posit32::op_Explicit(Posit32).0.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 	flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 	if (flag3) {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	else {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 	}
                        -- 	else {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 	}
                        -- 	result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- }
                        -- else {
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		result = 2147483647;
                        -- 	}
                        -- 	else {
                        -- 		result = -2147483648;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Explicit(Posit32).0._State_10\ and ends in state \Posit32::op_Explicit(Posit32).0._State_22\.
                        --     * The false branch starts in state \Posit32::op_Explicit(Posit32).0._State_25\ and ends in state \Posit32::op_Explicit(Posit32).0._State_27\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).0._State_9\.

                        if (\Posit32::op_Explicit(Posit32).0.flag2\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_10\;
                        else 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2897
                    when \Posit32::op_Explicit(Posit32).0._State_9\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_8\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_2\.
                        if (\Posit32::op_Explicit(Posit32).0._State\ = \Posit32::op_Explicit(Posit32).0._State_9\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_10\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 	flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 	if (flag3) {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	else {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 	}
                        -- 	else {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 	}
                        -- 	result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).0.x\;
                        \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ = \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).0.return.2\ := \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).0.return.2\;
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).0.return.3\ := \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Explicit(Posit32).0.mostSignificantOnePosition\ := \Posit32::op_Explicit(Posit32).0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                            -- 
                            \Posit32::op_Explicit(Posit32).0.binaryOperationResult.5\ := \Posit32::op_Explicit(Posit32).0.num\ - signed((SmartResize(\Posit32::op_Explicit(Posit32).0.mostSignificantOnePosition\, 64)));
                            \Posit32::op_Explicit(Posit32).0.binaryOperationResult.6\ := \Posit32::op_Explicit(Posit32).0.binaryOperationResult.5\ + to_signed(1, 64);
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7796
                    when \Posit32::op_Explicit(Posit32).0._State_13\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Explicit(Posit32).0.binaryOperationResult.7\ := \Posit32::op_Explicit(Posit32).0.binaryOperationResult.6\ >= to_signed(0, 64);
                        \Posit32::op_Explicit(Posit32).0.flag3\ := \Posit32::op_Explicit(Posit32).0.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- else {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Explicit(Posit32).0._State_15\ and ends in state \Posit32::op_Explicit(Posit32).0._State_16\.
                        --     * The false branch starts in state \Posit32::op_Explicit(Posit32).0._State_17\ and ends in state \Posit32::op_Explicit(Posit32).0._State_20\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).0._State_14\.

                        if (\Posit32::op_Explicit(Posit32).0.flag3\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_15\;
                        else 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2999
                    when \Posit32::op_Explicit(Posit32).0._State_14\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- }
                        -- else {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).0.x\;
                        \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_21\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_15\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).0.x\;
                        \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_16\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_16\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ = \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).0.return.4\ := \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().return.0\;
                            \Posit32::op_Explicit(Posit32).0.binaryOperationResult.8\ := \Posit32::op_Explicit(Posit32).0.num\ - signed((SmartResize(\Posit32::op_Explicit(Posit32).0.mostSignificantOnePosition\, 64)));
                            \Posit32::op_Explicit(Posit32).0.binaryOperationResult.9\ := SmartResize(\Posit32::op_Explicit(Posit32).0.binaryOperationResult.8\ + to_signed(1, 64), 32);
                            \Posit32::op_Explicit(Posit32).0.binaryOperationResult.10\ := shift_left(\Posit32::op_Explicit(Posit32).0.return.4\, to_integer(unsigned(SmartResize((\Posit32::op_Explicit(Posit32).0.binaryOperationResult.9\), 5))));
                            \Posit32::op_Explicit(Posit32).0.num2\ := \Posit32::op_Explicit(Posit32).0.binaryOperationResult.10\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_13\.
                            if (\Posit32::op_Explicit(Posit32).0._State\ = \Posit32::op_Explicit(Posit32).0._State_16\) then 
                                \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_14\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8796
                    when \Posit32::op_Explicit(Posit32).0._State_17\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_18\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_18\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).0.x\;
                        \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_19\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ = \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).0.return.5\ := \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().return.0\;
                            \Posit32::op_Explicit(Posit32).0.binaryOperationResult.11\ := \Posit32::op_Explicit(Posit32).0.num\ - signed((SmartResize(\Posit32::op_Explicit(Posit32).0.mostSignificantOnePosition\, 64)));
                            \Posit32::op_Explicit(Posit32).0.binaryOperationResult.12\ := SmartResize(\Posit32::op_Explicit(Posit32).0.binaryOperationResult.11\ + to_signed(1, 64), 32);
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8796
                    when \Posit32::op_Explicit(Posit32).0._State_20\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Explicit(Posit32).0.binaryOperationResult.13\ := shift_right(\Posit32::op_Explicit(Posit32).0.return.5\, to_integer(unsigned(SmartResize(-(\Posit32::op_Explicit(Posit32).0.binaryOperationResult.12\), 5) and "11111")));
                        \Posit32::op_Explicit(Posit32).0.num2\ := \Posit32::op_Explicit(Posit32).0.binaryOperationResult.13\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_13\.
                        if (\Posit32::op_Explicit(Posit32).0._State\ = \Posit32::op_Explicit(Posit32).0._State_20\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2386
                    when \Posit32::op_Explicit(Posit32).0._State_21\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Started.0\ = \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).0.return.6\ := \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Explicit(Posit32).0._State_23\ and ends in state \Posit32::op_Explicit(Posit32).0._State_23\.
                            --     * The false branch starts in state \Posit32::op_Explicit(Posit32).0._State_24\ and ends in state \Posit32::op_Explicit(Posit32).0._State_24\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).0._State_22\.

                            if (\Posit32::op_Explicit(Posit32).0.return.6\) then 
                                \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_23\;
                            else 
                                \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_24\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_22\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- 
                        \Posit32::op_Explicit(Posit32).0.result\ := signed((\Posit32::op_Explicit(Posit32).0.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\));
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_8\.
                        if (\Posit32::op_Explicit(Posit32).0._State\ = \Posit32::op_Explicit(Posit32).0._State_22\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_23\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).0._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 
                        \Posit32::op_Explicit(Posit32).0.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\ := \Posit32::op_Explicit(Posit32).0.num2\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_21\.
                        if (\Posit32::op_Explicit(Posit32).0._State\ = \Posit32::op_Explicit(Posit32).0._State_23\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_24\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).0._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 
                        \Posit32::op_Explicit(Posit32).0.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\ := unsigned((signed(SmartResize(-signed(SmartResize((SmartResize(\Posit32::op_Explicit(Posit32).0.num2\, 64)), 32)), 32))));
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_21\.
                        if (\Posit32::op_Explicit(Posit32).0._State\ = \Posit32::op_Explicit(Posit32).0._State_24\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::op_Explicit(Posit32).0._State_25\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		result = 2147483647;
                        -- 	}
                        -- 	else {
                        -- 		result = -2147483648;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 	result = 2147483647;
                        -- }
                        -- else {
                        -- 	result = -2147483648;
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).0.x\;
                        \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_26\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Started.0\ = \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).0.return.7\ := \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Explicit(Posit32).0._State_28\ and ends in state \Posit32::op_Explicit(Posit32).0._State_28\.
                            --     * The false branch starts in state \Posit32::op_Explicit(Posit32).0._State_29\ and ends in state \Posit32::op_Explicit(Posit32).0._State_29\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).0._State_27\.

                            if (\Posit32::op_Explicit(Posit32).0.return.7\) then 
                                \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_28\;
                            else 
                                \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_29\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_27\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_26\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_8\.
                        if (\Posit32::op_Explicit(Posit32).0._State\ = \Posit32::op_Explicit(Posit32).0._State_27\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_28\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = 2147483647;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = 2147483647;
                        -- 
                        \Posit32::op_Explicit(Posit32).0.result\ := to_signed(2147483647, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_26\.
                        if (\Posit32::op_Explicit(Posit32).0._State\ = \Posit32::op_Explicit(Posit32).0._State_28\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).0._State_29\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = -2147483648;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = -2147483648;
                        -- 
                        \Posit32::op_Explicit(Posit32).0.result\ := to_signed(-2147483648, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).0._State_26\.
                        if (\Posit32::op_Explicit(Posit32).0._State\ = \Posit32::op_Explicit(Posit32).0._State_29\) then 
                            \Posit32::op_Explicit(Posit32).0._State\ := \Posit32::op_Explicit(Posit32).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 state machine end


    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).1 state machine start
    \Posit32::op_Explicit(Posit32).1._StateMachine\: process (\Clock\) 
        Variable \Posit32::op_Explicit(Posit32).1._State\: \Posit32::op_Explicit(Posit32).1._States\ := \Posit32::op_Explicit(Posit32).1._State_0\;
        Variable \Posit32::op_Explicit(Posit32).1.x\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Explicit(Posit32).1.flag\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).1.result\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Explicit(Posit32).1.num\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).1.flag2\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).1.mostSignificantOnePosition\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Explicit(Posit32).1.flag3\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).1.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).1.return.0\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.1\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).1.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.2\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.3\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).1.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).1.return.3\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.5\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.6\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.7\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).1.return.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.8\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).1.return.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.11\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Explicit(Posit32).1.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).1.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).1.return.6\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).1.return.7\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::op_Explicit(Posit32).1._Finished\ <= false;
                \Posit32::op_Explicit(Posit32).1.return\ <= to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_0\;
                \Posit32::op_Explicit(Posit32).1.flag\ := false;
                \Posit32::op_Explicit(Posit32).1.result\ := to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).1.num\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).1.flag2\ := false;
                \Posit32::op_Explicit(Posit32).1.mostSignificantOnePosition\ := to_unsigned(0, 8);
                \Posit32::op_Explicit(Posit32).1.flag3\ := false;
                \Posit32::op_Explicit(Posit32).1.num2\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.0\ := false;
                \Posit32::op_Explicit(Posit32).1.return.0\ := to_signed(0, 8);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.1\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).1.return.1\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.2\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.3\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.4\ := false;
                \Posit32::op_Explicit(Posit32).1.return.2\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).1.return.3\ := to_unsigned(0, 8);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.5\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.6\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.7\ := false;
                \Posit32::op_Explicit(Posit32).1.return.4\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.8\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.9\ := to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.10\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).1.return.5\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.11\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.12\ := to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).1.binaryOperationResult.13\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).1.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).1.return.6\ := false;
                \Posit32::op_Explicit(Posit32).1.return.7\ := false;
            else 
                case \Posit32::op_Explicit(Posit32).1._State\ is 
                    when \Posit32::op_Explicit(Posit32).1._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::op_Explicit(Posit32).1._Started\ = true) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::op_Explicit(Posit32).1._Started\ = true) then 
                            \Posit32::op_Explicit(Posit32).1._Finished\ <= true;
                        else 
                            \Posit32::op_Explicit(Posit32).1._Finished\ <= false;
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_2\ => 
                        \Posit32::op_Explicit(Posit32).1.x\ := \Posit32::op_Explicit(Posit32).1.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- long num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte mostSignificantOnePosition;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = x.PositBits == 0u;
                        -- 
                        \Posit32::op_Explicit(Posit32).1.binaryOperationResult.0\ := \Posit32::op_Explicit(Posit32).1.x\.\PositBits\ = to_unsigned(0, 32);
                        \Posit32::op_Explicit(Posit32).1.flag\ := \Posit32::op_Explicit(Posit32).1.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = 0;
                        -- }
                        -- else {
                        -- 	num = (long)((System.Int32)(Lombiq.Arithmetics.Posit32.GetRegimeKValue (x)) * 4) + (long)((ulong)Lombiq.Arithmetics.Posit32.GetExponentValue (x));
                        -- 	flag2 = num + 1L <= 31L;
                        -- 	if (flag2) {
                        -- 		mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 		flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 		if (flag3) {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		else {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 		}
                        -- 		else {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 		}
                        -- 		result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- 	}
                        -- 	else {
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			result = 2147483647;
                        -- 		}
                        -- 		else {
                        -- 			result = -2147483648;
                        -- 		}
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Explicit(Posit32).1._State_4\ and ends in state \Posit32::op_Explicit(Posit32).1._State_4\.
                        --     * The false branch starts in state \Posit32::op_Explicit(Posit32).1._State_5\ and ends in state \Posit32::op_Explicit(Posit32).1._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).1._State_3\.

                        if (\Posit32::op_Explicit(Posit32).1.flag\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_4\;
                        else 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Explicit(Posit32).1._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::op_Explicit(Posit32).1.return\ <= \Posit32::op_Explicit(Posit32).1.result\;
                        \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = 0;
                        -- 
                        \Posit32::op_Explicit(Posit32).1.result\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_2\.
                        if (\Posit32::op_Explicit(Posit32).1._State\ = \Posit32::op_Explicit(Posit32).1._State_4\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_5\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).1._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = (long)((System.Int32)(Lombiq.Arithmetics.Posit32.GetRegimeKValue (x)) * 4) + (long)((ulong)Lombiq.Arithmetics.Posit32.GetExponentValue (x));
                        -- 	flag2 = num + 1L <= 31L;
                        -- 	if (flag2) {
                        -- 		mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 		flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 		if (flag3) {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		else {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 		}
                        -- 		else {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 		}
                        -- 		result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- 	}
                        -- 	else {
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			result = 2147483647;
                        -- 		}
                        -- 		else {
                        -- 			result = -2147483648;
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (long)((System.Int32)(Lombiq.Arithmetics.Posit32.GetRegimeKValue (x)) * 4) + (long)((ulong)Lombiq.Arithmetics.Posit32.GetExponentValue (x));
                        -- 
                        -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                        \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).1.x\;
                        \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Started.0\ = \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).1.return.0\ := \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue().return.0\;
                            \Posit32::op_Explicit(Posit32).1.binaryOperationResult.1\ := SmartResize(SmartResize((\Posit32::op_Explicit(Posit32).1.return.0\), 32) * to_signed(4, 32), 64);
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).1.x\;
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Started.0\ <= true;
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::op_Explicit(Posit32).1._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Started.0\ = \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).1.return.1\ := \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue().return.0\;
                            \Posit32::op_Explicit(Posit32).1.binaryOperationResult.2\ := (\Posit32::op_Explicit(Posit32).1.binaryOperationResult.1\) + signed((SmartResize(\Posit32::op_Explicit(Posit32).1.return.1\, 64)));
                            \Posit32::op_Explicit(Posit32).1.num\ := \Posit32::op_Explicit(Posit32).1.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = num + 1L <= 31L;
                            -- 
                            \Posit32::op_Explicit(Posit32).1.binaryOperationResult.3\ := \Posit32::op_Explicit(Posit32).1.num\ + to_signed(1, 64);
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7796
                    when \Posit32::op_Explicit(Posit32).1._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Explicit(Posit32).1.binaryOperationResult.4\ := \Posit32::op_Explicit(Posit32).1.binaryOperationResult.3\ <= to_signed(31, 64);
                        \Posit32::op_Explicit(Posit32).1.flag2\ := \Posit32::op_Explicit(Posit32).1.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 	flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 	if (flag3) {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	else {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 	}
                        -- 	else {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 	}
                        -- 	result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- }
                        -- else {
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		result = 2147483647;
                        -- 	}
                        -- 	else {
                        -- 		result = -2147483648;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Explicit(Posit32).1._State_10\ and ends in state \Posit32::op_Explicit(Posit32).1._State_22\.
                        --     * The false branch starts in state \Posit32::op_Explicit(Posit32).1._State_25\ and ends in state \Posit32::op_Explicit(Posit32).1._State_27\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).1._State_9\.

                        if (\Posit32::op_Explicit(Posit32).1.flag2\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_10\;
                        else 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2897
                    when \Posit32::op_Explicit(Posit32).1._State_9\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_8\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_2\.
                        if (\Posit32::op_Explicit(Posit32).1._State\ = \Posit32::op_Explicit(Posit32).1._State_9\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_10\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).1._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 	flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 	if (flag3) {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	else {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 	}
                        -- 	else {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 	}
                        -- 	result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).1.x\;
                        \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\ = \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).1.return.2\ := \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).1.return.2\;
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).1.return.3\ := \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Explicit(Posit32).1.mostSignificantOnePosition\ := \Posit32::op_Explicit(Posit32).1.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                            -- 
                            \Posit32::op_Explicit(Posit32).1.binaryOperationResult.5\ := \Posit32::op_Explicit(Posit32).1.num\ - signed((SmartResize(\Posit32::op_Explicit(Posit32).1.mostSignificantOnePosition\, 64)));
                            \Posit32::op_Explicit(Posit32).1.binaryOperationResult.6\ := \Posit32::op_Explicit(Posit32).1.binaryOperationResult.5\ + to_signed(1, 64);
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7796
                    when \Posit32::op_Explicit(Posit32).1._State_13\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Explicit(Posit32).1.binaryOperationResult.7\ := \Posit32::op_Explicit(Posit32).1.binaryOperationResult.6\ >= to_signed(0, 64);
                        \Posit32::op_Explicit(Posit32).1.flag3\ := \Posit32::op_Explicit(Posit32).1.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- else {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Explicit(Posit32).1._State_15\ and ends in state \Posit32::op_Explicit(Posit32).1._State_16\.
                        --     * The false branch starts in state \Posit32::op_Explicit(Posit32).1._State_17\ and ends in state \Posit32::op_Explicit(Posit32).1._State_20\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).1._State_14\.

                        if (\Posit32::op_Explicit(Posit32).1.flag3\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_15\;
                        else 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2999
                    when \Posit32::op_Explicit(Posit32).1._State_14\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- }
                        -- else {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).1.x\;
                        \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_21\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_15\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).1._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).1.x\;
                        \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_16\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_16\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\ = \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).1.return.4\ := \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit().return.0\;
                            \Posit32::op_Explicit(Posit32).1.binaryOperationResult.8\ := \Posit32::op_Explicit(Posit32).1.num\ - signed((SmartResize(\Posit32::op_Explicit(Posit32).1.mostSignificantOnePosition\, 64)));
                            \Posit32::op_Explicit(Posit32).1.binaryOperationResult.9\ := SmartResize(\Posit32::op_Explicit(Posit32).1.binaryOperationResult.8\ + to_signed(1, 64), 32);
                            \Posit32::op_Explicit(Posit32).1.binaryOperationResult.10\ := shift_left(\Posit32::op_Explicit(Posit32).1.return.4\, to_integer(unsigned(SmartResize((\Posit32::op_Explicit(Posit32).1.binaryOperationResult.9\), 5))));
                            \Posit32::op_Explicit(Posit32).1.num2\ := \Posit32::op_Explicit(Posit32).1.binaryOperationResult.10\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_13\.
                            if (\Posit32::op_Explicit(Posit32).1._State\ = \Posit32::op_Explicit(Posit32).1._State_16\) then 
                                \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_14\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8796
                    when \Posit32::op_Explicit(Posit32).1._State_17\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).1._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_18\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_18\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).1.x\;
                        \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_19\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\ = \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).1.return.5\ := \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit().return.0\;
                            \Posit32::op_Explicit(Posit32).1.binaryOperationResult.11\ := \Posit32::op_Explicit(Posit32).1.num\ - signed((SmartResize(\Posit32::op_Explicit(Posit32).1.mostSignificantOnePosition\, 64)));
                            \Posit32::op_Explicit(Posit32).1.binaryOperationResult.12\ := SmartResize(\Posit32::op_Explicit(Posit32).1.binaryOperationResult.11\ + to_signed(1, 64), 32);
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8796
                    when \Posit32::op_Explicit(Posit32).1._State_20\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Explicit(Posit32).1.binaryOperationResult.13\ := shift_right(\Posit32::op_Explicit(Posit32).1.return.5\, to_integer(unsigned(SmartResize(-(\Posit32::op_Explicit(Posit32).1.binaryOperationResult.12\), 5) and "11111")));
                        \Posit32::op_Explicit(Posit32).1.num2\ := \Posit32::op_Explicit(Posit32).1.binaryOperationResult.13\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_13\.
                        if (\Posit32::op_Explicit(Posit32).1._State\ = \Posit32::op_Explicit(Posit32).1._State_20\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2386
                    when \Posit32::op_Explicit(Posit32).1._State_21\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Started.0\ = \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).1.return.6\ := \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Explicit(Posit32).1._State_23\ and ends in state \Posit32::op_Explicit(Posit32).1._State_23\.
                            --     * The false branch starts in state \Posit32::op_Explicit(Posit32).1._State_24\ and ends in state \Posit32::op_Explicit(Posit32).1._State_24\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).1._State_22\.

                            if (\Posit32::op_Explicit(Posit32).1.return.6\) then 
                                \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_23\;
                            else 
                                \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_24\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_22\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- 
                        \Posit32::op_Explicit(Posit32).1.result\ := signed((\Posit32::op_Explicit(Posit32).1.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\));
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_8\.
                        if (\Posit32::op_Explicit(Posit32).1._State\ = \Posit32::op_Explicit(Posit32).1._State_22\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_23\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).1._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 
                        \Posit32::op_Explicit(Posit32).1.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\ := \Posit32::op_Explicit(Posit32).1.num2\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_21\.
                        if (\Posit32::op_Explicit(Posit32).1._State\ = \Posit32::op_Explicit(Posit32).1._State_23\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_24\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).1._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 
                        \Posit32::op_Explicit(Posit32).1.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\ := unsigned((signed(SmartResize(-signed(SmartResize((SmartResize(\Posit32::op_Explicit(Posit32).1.num2\, 64)), 32)), 32))));
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_21\.
                        if (\Posit32::op_Explicit(Posit32).1._State\ = \Posit32::op_Explicit(Posit32).1._State_24\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::op_Explicit(Posit32).1._State_25\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).1._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		result = 2147483647;
                        -- 	}
                        -- 	else {
                        -- 		result = -2147483648;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 	result = 2147483647;
                        -- }
                        -- else {
                        -- 	result = -2147483648;
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).1.x\;
                        \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_26\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Started.0\ = \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).1.return.7\ := \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Explicit(Posit32).1._State_28\ and ends in state \Posit32::op_Explicit(Posit32).1._State_28\.
                            --     * The false branch starts in state \Posit32::op_Explicit(Posit32).1._State_29\ and ends in state \Posit32::op_Explicit(Posit32).1._State_29\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).1._State_27\.

                            if (\Posit32::op_Explicit(Posit32).1.return.7\) then 
                                \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_28\;
                            else 
                                \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_29\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_27\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_26\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_8\.
                        if (\Posit32::op_Explicit(Posit32).1._State\ = \Posit32::op_Explicit(Posit32).1._State_27\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_28\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).1._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = 2147483647;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = 2147483647;
                        -- 
                        \Posit32::op_Explicit(Posit32).1.result\ := to_signed(2147483647, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_26\.
                        if (\Posit32::op_Explicit(Posit32).1._State\ = \Posit32::op_Explicit(Posit32).1._State_28\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).1._State_29\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).1._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = -2147483648;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = -2147483648;
                        -- 
                        \Posit32::op_Explicit(Posit32).1.result\ := to_signed(-2147483648, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).1._State_26\.
                        if (\Posit32::op_Explicit(Posit32).1._State\ = \Posit32::op_Explicit(Posit32).1._State_29\) then 
                            \Posit32::op_Explicit(Posit32).1._State\ := \Posit32::op_Explicit(Posit32).1._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).1 state machine end


    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).2 state machine start
    \Posit32::op_Explicit(Posit32).2._StateMachine\: process (\Clock\) 
        Variable \Posit32::op_Explicit(Posit32).2._State\: \Posit32::op_Explicit(Posit32).2._States\ := \Posit32::op_Explicit(Posit32).2._State_0\;
        Variable \Posit32::op_Explicit(Posit32).2.x\: \Lombiq.Arithmetics.Posit32\;
        Variable \Posit32::op_Explicit(Posit32).2.flag\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).2.result\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Explicit(Posit32).2.num\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).2.flag2\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).2.mostSignificantOnePosition\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Explicit(Posit32).2.flag3\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).2.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.0\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).2.return.0\: signed(7 downto 0) := to_signed(0, 8);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.1\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).2.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.2\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.3\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.4\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).2.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).2.return.3\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.5\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.6\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.7\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).2.return.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.8\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).2.return.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.11\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit32::op_Explicit(Posit32).2.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).2.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit32::op_Explicit(Posit32).2.return.6\: boolean := false;
        Variable \Posit32::op_Explicit(Posit32).2.return.7\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit32::op_Explicit(Posit32).2._Finished\ <= false;
                \Posit32::op_Explicit(Posit32).2.return\ <= to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Started.0\ <= false;
                \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_0\;
                \Posit32::op_Explicit(Posit32).2.flag\ := false;
                \Posit32::op_Explicit(Posit32).2.result\ := to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).2.num\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).2.flag2\ := false;
                \Posit32::op_Explicit(Posit32).2.mostSignificantOnePosition\ := to_unsigned(0, 8);
                \Posit32::op_Explicit(Posit32).2.flag3\ := false;
                \Posit32::op_Explicit(Posit32).2.num2\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.0\ := false;
                \Posit32::op_Explicit(Posit32).2.return.0\ := to_signed(0, 8);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.1\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).2.return.1\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.2\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.3\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.4\ := false;
                \Posit32::op_Explicit(Posit32).2.return.2\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).2.return.3\ := to_unsigned(0, 8);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.5\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.6\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.7\ := false;
                \Posit32::op_Explicit(Posit32).2.return.4\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.8\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.9\ := to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.10\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).2.return.5\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.11\ := to_signed(0, 64);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.12\ := to_signed(0, 32);
                \Posit32::op_Explicit(Posit32).2.binaryOperationResult.13\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).2.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\ := to_unsigned(0, 32);
                \Posit32::op_Explicit(Posit32).2.return.6\ := false;
                \Posit32::op_Explicit(Posit32).2.return.7\ := false;
            else 
                case \Posit32::op_Explicit(Posit32).2._State\ is 
                    when \Posit32::op_Explicit(Posit32).2._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit32::op_Explicit(Posit32).2._Started\ = true) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit32::op_Explicit(Posit32).2._Started\ = true) then 
                            \Posit32::op_Explicit(Posit32).2._Finished\ <= true;
                        else 
                            \Posit32::op_Explicit(Posit32).2._Finished\ <= false;
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_2\ => 
                        \Posit32::op_Explicit(Posit32).2.x\ := \Posit32::op_Explicit(Posit32).2.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- long num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte mostSignificantOnePosition;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = x.PositBits == 0u;
                        -- 
                        \Posit32::op_Explicit(Posit32).2.binaryOperationResult.0\ := \Posit32::op_Explicit(Posit32).2.x\.\PositBits\ = to_unsigned(0, 32);
                        \Posit32::op_Explicit(Posit32).2.flag\ := \Posit32::op_Explicit(Posit32).2.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = 0;
                        -- }
                        -- else {
                        -- 	num = (long)((System.Int32)(Lombiq.Arithmetics.Posit32.GetRegimeKValue (x)) * 4) + (long)((ulong)Lombiq.Arithmetics.Posit32.GetExponentValue (x));
                        -- 	flag2 = num + 1L <= 31L;
                        -- 	if (flag2) {
                        -- 		mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 		flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 		if (flag3) {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		else {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 		}
                        -- 		else {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 		}
                        -- 		result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- 	}
                        -- 	else {
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			result = 2147483647;
                        -- 		}
                        -- 		else {
                        -- 			result = -2147483648;
                        -- 		}
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Explicit(Posit32).2._State_4\ and ends in state \Posit32::op_Explicit(Posit32).2._State_4\.
                        --     * The false branch starts in state \Posit32::op_Explicit(Posit32).2._State_5\ and ends in state \Posit32::op_Explicit(Posit32).2._State_9\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).2._State_3\.

                        if (\Posit32::op_Explicit(Posit32).2.flag\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_4\;
                        else 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2751
                    when \Posit32::op_Explicit(Posit32).2._State_3\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit32::op_Explicit(Posit32).2.return\ <= \Posit32::op_Explicit(Posit32).2.result\;
                        \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_4\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = 0;
                        -- 
                        \Posit32::op_Explicit(Posit32).2.result\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_2\.
                        if (\Posit32::op_Explicit(Posit32).2._State\ = \Posit32::op_Explicit(Posit32).2._State_4\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_5\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).2._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = (long)((System.Int32)(Lombiq.Arithmetics.Posit32.GetRegimeKValue (x)) * 4) + (long)((ulong)Lombiq.Arithmetics.Posit32.GetExponentValue (x));
                        -- 	flag2 = num + 1L <= 31L;
                        -- 	if (flag2) {
                        -- 		mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 		flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 		if (flag3) {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		else {
                        -- 			num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 		}
                        -- 		uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 		}
                        -- 		else {
                        -- 			conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 		}
                        -- 		result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- 	}
                        -- 	else {
                        -- 		if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 			result = 2147483647;
                        -- 		}
                        -- 		else {
                        -- 			result = -2147483648;
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = (long)((System.Int32)(Lombiq.Arithmetics.Posit32.GetRegimeKValue (x)) * 4) + (long)((ulong)Lombiq.Arithmetics.Posit32.GetExponentValue (x));
                        -- 
                        -- Starting state machine invocation for the following method: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                        \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).2.x\;
                        \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue()
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Started.0\ = \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).2.return.0\ := \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue().return.0\;
                            \Posit32::op_Explicit(Posit32).2.binaryOperationResult.1\ := SmartResize(SmartResize((\Posit32::op_Explicit(Posit32).2.return.0\), 32) * to_signed(4, 32), 64);
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).2.x\;
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Started.0\ <= true;
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::op_Explicit(Posit32).2._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue()
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Started.0\ = \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).2.return.1\ := \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue().return.0\;
                            \Posit32::op_Explicit(Posit32).2.binaryOperationResult.2\ := (\Posit32::op_Explicit(Posit32).2.binaryOperationResult.1\) + signed((SmartResize(\Posit32::op_Explicit(Posit32).2.return.1\, 64)));
                            \Posit32::op_Explicit(Posit32).2.num\ := \Posit32::op_Explicit(Posit32).2.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = num + 1L <= 31L;
                            -- 
                            \Posit32::op_Explicit(Posit32).2.binaryOperationResult.3\ := \Posit32::op_Explicit(Posit32).2.num\ + to_signed(1, 64);
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7796
                    when \Posit32::op_Explicit(Posit32).2._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Explicit(Posit32).2.binaryOperationResult.4\ := \Posit32::op_Explicit(Posit32).2.binaryOperationResult.3\ <= to_signed(31, 64);
                        \Posit32::op_Explicit(Posit32).2.flag2\ := \Posit32::op_Explicit(Posit32).2.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 	flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 	if (flag3) {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	else {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 	}
                        -- 	else {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 	}
                        -- 	result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- }
                        -- else {
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		result = 2147483647;
                        -- 	}
                        -- 	else {
                        -- 		result = -2147483648;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Explicit(Posit32).2._State_10\ and ends in state \Posit32::op_Explicit(Posit32).2._State_22\.
                        --     * The false branch starts in state \Posit32::op_Explicit(Posit32).2._State_25\ and ends in state \Posit32::op_Explicit(Posit32).2._State_27\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).2._State_9\.

                        if (\Posit32::op_Explicit(Posit32).2.flag2\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_10\;
                        else 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2897
                    when \Posit32::op_Explicit(Posit32).2._State_9\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_8\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_2\.
                        if (\Posit32::op_Explicit(Posit32).2._State\ = \Posit32::op_Explicit(Posit32).2._State_9\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_10\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).2._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 	flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                        -- 	if (flag3) {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	else {
                        -- 		num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 	}
                        -- 	uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 	}
                        -- 	else {
                        -- 		conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 	}
                        -- 	result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- mostSignificantOnePosition = Posit32.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).2.x\;
                        \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\ = \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).2.return.2\ := \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).2.return.2\;
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= true;
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32)
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).2.return.3\ := \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\;
                            \Posit32::op_Explicit(Posit32).2.mostSignificantOnePosition\ := \Posit32::op_Explicit(Posit32).2.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = num - (long)((ulong)mostSignificantOnePosition) + 1L >= 0L;
                            -- 
                            \Posit32::op_Explicit(Posit32).2.binaryOperationResult.5\ := \Posit32::op_Explicit(Posit32).2.num\ - signed((SmartResize(\Posit32::op_Explicit(Posit32).2.mostSignificantOnePosition\, 64)));
                            \Posit32::op_Explicit(Posit32).2.binaryOperationResult.6\ := \Posit32::op_Explicit(Posit32).2.binaryOperationResult.5\ + to_signed(1, 64);
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7796
                    when \Posit32::op_Explicit(Posit32).2._State_13\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Explicit(Posit32).2.binaryOperationResult.7\ := \Posit32::op_Explicit(Posit32).2.binaryOperationResult.6\ >= to_signed(0, 64);
                        \Posit32::op_Explicit(Posit32).2.flag3\ := \Posit32::op_Explicit(Posit32).2.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- else {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit32::op_Explicit(Posit32).2._State_15\ and ends in state \Posit32::op_Explicit(Posit32).2._State_16\.
                        --     * The false branch starts in state \Posit32::op_Explicit(Posit32).2._State_17\ and ends in state \Posit32::op_Explicit(Posit32).2._State_20\.
                        --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).2._State_14\.

                        if (\Posit32::op_Explicit(Posit32).2.flag3\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_15\;
                        else 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2999
                    when \Posit32::op_Explicit(Posit32).2._State_14\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- }
                        -- else {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).2.x\;
                        \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_21\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_15\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).2._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) << (int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).2.x\;
                        \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_16\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_16\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\ = \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).2.return.4\ := \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit().return.0\;
                            \Posit32::op_Explicit(Posit32).2.binaryOperationResult.8\ := \Posit32::op_Explicit(Posit32).2.num\ - signed((SmartResize(\Posit32::op_Explicit(Posit32).2.mostSignificantOnePosition\, 64)));
                            \Posit32::op_Explicit(Posit32).2.binaryOperationResult.9\ := SmartResize(\Posit32::op_Explicit(Posit32).2.binaryOperationResult.8\ + to_signed(1, 64), 32);
                            \Posit32::op_Explicit(Posit32).2.binaryOperationResult.10\ := shift_left(\Posit32::op_Explicit(Posit32).2.return.4\, to_integer(unsigned(SmartResize((\Posit32::op_Explicit(Posit32).2.binaryOperationResult.9\), 5))));
                            \Posit32::op_Explicit(Posit32).2.num2\ := \Posit32::op_Explicit(Posit32).2.binaryOperationResult.10\;
                            -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_13\.
                            if (\Posit32::op_Explicit(Posit32).2._State\ = \Posit32::op_Explicit(Posit32).2._State_16\) then 
                                \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_14\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8796
                    when \Posit32::op_Explicit(Posit32).2._State_17\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).2._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Lombiq.Arithmetics.Posit32.FractionWithHiddenBit (x) >> -(int)(num - (long)((ulong)mostSignificantOnePosition) + 1L);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_18\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_18\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).2.x\;
                        \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_19\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_19\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit()
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\ = \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).2.return.5\ := \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit().return.0\;
                            \Posit32::op_Explicit(Posit32).2.binaryOperationResult.11\ := \Posit32::op_Explicit(Posit32).2.num\ - signed((SmartResize(\Posit32::op_Explicit(Posit32).2.mostSignificantOnePosition\, 64)));
                            \Posit32::op_Explicit(Posit32).2.binaryOperationResult.12\ := SmartResize(\Posit32::op_Explicit(Posit32).2.binaryOperationResult.11\ + to_signed(1, 64), 32);
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_20\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8796
                    when \Posit32::op_Explicit(Posit32).2._State_20\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit32::op_Explicit(Posit32).2.binaryOperationResult.13\ := shift_right(\Posit32::op_Explicit(Posit32).2.return.5\, to_integer(unsigned(SmartResize(-(\Posit32::op_Explicit(Posit32).2.binaryOperationResult.12\), 5) and "11111")));
                        \Posit32::op_Explicit(Posit32).2.num2\ := \Posit32::op_Explicit(Posit32).2.binaryOperationResult.13\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_13\.
                        if (\Posit32::op_Explicit(Posit32).2._State\ = \Posit32::op_Explicit(Posit32).2._State_20\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2386
                    when \Posit32::op_Explicit(Posit32).2._State_21\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Started.0\ = \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).2.return.6\ := \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Explicit(Posit32).2._State_23\ and ends in state \Posit32::op_Explicit(Posit32).2._State_23\.
                            --     * The false branch starts in state \Posit32::op_Explicit(Posit32).2._State_24\ and ends in state \Posit32::op_Explicit(Posit32).2._State_24\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).2._State_22\.

                            if (\Posit32::op_Explicit(Posit32).2.return.6\) then 
                                \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_23\;
                            else 
                                \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_24\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_22\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = (int)(conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991);
                        -- 
                        \Posit32::op_Explicit(Posit32).2.result\ := signed((\Posit32::op_Explicit(Posit32).2.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\));
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_8\.
                        if (\Posit32::op_Explicit(Posit32).2._State\ = \Posit32::op_Explicit(Posit32).2._State_22\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_23\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).2._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = num2;
                        -- 
                        \Posit32::op_Explicit(Posit32).2.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\ := \Posit32::op_Explicit(Posit32).2.num2\;
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_21\.
                        if (\Posit32::op_Explicit(Posit32).2._State\ = \Posit32::op_Explicit(Posit32).2._State_23\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_24\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).2._State_21\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991 = (uint)((int)-(int)((ulong)num2));
                        -- 
                        \Posit32::op_Explicit(Posit32).2.conditional46f72256568950ca092e33aea839c31ac6e2a698e2e753f2286e124f37fe6991\ := unsigned((signed(SmartResize(-signed(SmartResize((SmartResize(\Posit32::op_Explicit(Posit32).2.num2\, 64)), 32)), 32))));
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_21\.
                        if (\Posit32::op_Explicit(Posit32).2._State\ = \Posit32::op_Explicit(Posit32).2._State_24\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1
                    when \Posit32::op_Explicit(Posit32).2._State_25\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).2._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 		result = 2147483647;
                        -- 	}
                        -- 	else {
                        -- 		result = -2147483648;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit32.IsPositive (x)) {
                        -- 	result = 2147483647;
                        -- }
                        -- else {
                        -- 	result = -2147483648;
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().this.parameter.Out.0\ <= \Posit32::op_Explicit(Posit32).2.x\;
                        \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Started.0\ <= true;
                        \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_26\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit32::IsPositive()
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Started.0\ = \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Finished.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Started.0\ <= false;
                            \Posit32::op_Explicit(Posit32).2.return.7\ := \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit32::op_Explicit(Posit32).2._State_28\ and ends in state \Posit32::op_Explicit(Posit32).2._State_28\.
                            --     * The false branch starts in state \Posit32::op_Explicit(Posit32).2._State_29\ and ends in state \Posit32::op_Explicit(Posit32).2._State_29\.
                            --     * Execution after either branch will continue in the following state: \Posit32::op_Explicit(Posit32).2._State_27\.

                            if (\Posit32::op_Explicit(Posit32).2.return.7\) then 
                                \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_28\;
                            else 
                                \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_29\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_27\ => 
                        -- State after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_26\.
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_8\.
                        if (\Posit32::op_Explicit(Posit32).2._State\ = \Posit32::op_Explicit(Posit32).2._State_27\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_28\ => 
                        -- True branch of the if-else started in state \Posit32::op_Explicit(Posit32).2._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = 2147483647;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = 2147483647;
                        -- 
                        \Posit32::op_Explicit(Posit32).2.result\ := to_signed(2147483647, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_26\.
                        if (\Posit32::op_Explicit(Posit32).2._State\ = \Posit32::op_Explicit(Posit32).2._State_28\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit32::op_Explicit(Posit32).2._State_29\ => 
                        -- False branch of the if-else started in state \Posit32::op_Explicit(Posit32).2._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = -2147483648;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = -2147483648;
                        -- 
                        \Posit32::op_Explicit(Posit32).2.result\ := to_signed(-2147483648, 32);
                        -- Going to the state after the if-else which was started in state \Posit32::op_Explicit(Posit32).2._State_26\.
                        if (\Posit32::op_Explicit(Posit32).2._State\ = \Posit32::op_Explicit(Posit32).2._State_29\) then 
                            \Posit32::op_Explicit(Posit32).2._State\ := \Posit32::op_Explicit(Posit32).2._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).2 state machine end


    -- System.Void Hast::ExternalInvocationProxy() start
    \Finished\ <= \FinishedInternal\;
    \Hast::ExternalInvocationProxy()\: process (\Clock\) 
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \FinishedInternal\ <= false;
                \Hast::ExternalInvocationProxy().Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().Posit32Calculator::CalculatePowerOfReal(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory)._Started.0\ <= false;
                \Hast::ExternalInvocationProxy().Posit32Calculator::AddPositsInArray(SimpleMemory)._Started.0\ <= false;
            else 
                if (\Started\ = true and \FinishedInternal\ = false) then 
                    -- Starting the state machine corresponding to the given member ID.
                    case \MemberId\ is 
                        when 0 => 
                            if (\Hast::ExternalInvocationProxy().Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 1 => 
                            if (\Hast::ExternalInvocationProxy().Posit32Calculator::CalculatePowerOfReal(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().Posit32Calculator::CalculatePowerOfReal(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().Posit32Calculator::CalculatePowerOfReal(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().Posit32Calculator::CalculatePowerOfReal(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().Posit32Calculator::CalculatePowerOfReal(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 2 => 
                            if (\Hast::ExternalInvocationProxy().Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when 3 => 
                            if (\Hast::ExternalInvocationProxy().Posit32Calculator::AddPositsInArray(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().Posit32Calculator::AddPositsInArray(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().Posit32Calculator::AddPositsInArray(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().Posit32Calculator::AddPositsInArray(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().Posit32Calculator::AddPositsInArray(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when others => 
                            null;
                    end case;
                else 
                    -- Waiting for Started to be pulled back to zero that signals the framework noting the finish.
                    if (\Started\ = false and \FinishedInternal\ = true) then 
                        \FinishedInternal\ <= false;
                    end if;
                end if;
            end if;
        end if;
    end process;
    -- System.Void Hast::ExternalInvocationProxy() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32) start
    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Finished.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Finished.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Finished.0\ <= false;
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(0) := \Posit32::.ctor(Int32).1._Started\ = true and \Posit32::.ctor(Int32).2._Started\ = true and \Posit32::.ctor(Int32).0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(1) := \Posit32::.ctor(Int32).2._Started\ = true and \Posit32::.ctor(Int32).1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(2) := \Posit32::.ctor(Int32).2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).0
                case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Started.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 0;
                                    \Posit32::.ctor(Int32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(Int32).0.this.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).0.value.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 1;
                                    \Posit32::.ctor(Int32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(Int32).1.this.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).1.value.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 2;
                                    \Posit32::.ctor(Int32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(Int32).2.this.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).2.value.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).0._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(Int32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).1._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(Int32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).2._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::.ctor(Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).1
                case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Started.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 0;
                                    \Posit32::.ctor(Int32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(Int32).0.this.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).0.value.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 1;
                                    \Posit32::.ctor(Int32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(Int32).1.this.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).1.value.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 2;
                                    \Posit32::.ctor(Int32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(Int32).2.this.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).2.value.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).0._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(Int32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).1._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(Int32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).2._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::.ctor(Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).2
                case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Started.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 0;
                                    \Posit32::.ctor(Int32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(Int32).0.this.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).0.value.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 1;
                                    \Posit32::.ctor(Int32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(Int32).1.this.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).1.value.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 2;
                                    \Posit32::.ctor(Int32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(Int32).2.this.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).2.value.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).0._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(Int32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).1._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(Int32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).2._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::.ctor(Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\) then 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 0;
                                    \Posit32::.ctor(Int32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(Int32).0.this.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).0.value.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 1;
                                    \Posit32::.ctor(Int32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(Int32).1.this.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).1.value.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 2;
                                    \Posit32::.ctor(Int32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(Int32).2.this.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).2.value.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).0._Started\ <= false;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(Int32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).1._Started\ <= false;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(Int32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).2._Started\ <= false;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::.ctor(Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Started.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::.ctor(Int32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(Int32).0.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).0.value.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::.ctor(Int32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(Int32).1.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).1.value.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::.ctor(Int32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(Int32).2.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).this.parameter.Out.0\;
                                    \Posit32::.ctor(Int32).2.value.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).value.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).0._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(Int32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).1._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(Int32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Finished.0\ <= true;
                                    \Posit32::.ctor(Int32).2._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32).this.parameter.In.0\ <= \Posit32::.ctor(Int32).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(Int32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(Int32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32) start
    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(0) := \Posit32::op_Addition(Posit32,Posit32).1._Started\ = true and \Posit32::op_Addition(Posit32,Posit32).2._Started\ = true and \Posit32::op_Addition(Posit32,Posit32).0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(1) := \Posit32::op_Addition(Posit32,Posit32).2._Started\ = true and \Posit32::op_Addition(Posit32,Posit32).1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(2) := \Posit32::op_Addition(Posit32,Posit32).2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).0
                case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 0;
                                    \Posit32::op_Addition(Posit32,Posit32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(0) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.left.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).0.right.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 1;
                                    \Posit32::op_Addition(Posit32,Posit32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(1) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.left.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).1.right.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 2;
                                    \Posit32::op_Addition(Posit32,Posit32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(2) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.left.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).2.right.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).0._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).1._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).2._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).1
                case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Started.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 0;
                                    \Posit32::op_Addition(Posit32,Posit32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(0) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.left.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).0.right.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 1;
                                    \Posit32::op_Addition(Posit32,Posit32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(1) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.left.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).1.right.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 2;
                                    \Posit32::op_Addition(Posit32,Posit32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(2) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.left.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).2.right.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).0._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).1._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).2._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).2
                case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Started.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 0;
                                    \Posit32::op_Addition(Posit32,Posit32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(0) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.left.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).0.right.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 1;
                                    \Posit32::op_Addition(Posit32,Posit32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(1) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.left.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).1.right.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 2;
                                    \Posit32::op_Addition(Posit32,Posit32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(2) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.left.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).2.right.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).0._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).1._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).2._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\) then 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 0;
                                    \Posit32::op_Addition(Posit32,Posit32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(0) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.left.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).0.right.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 1;
                                    \Posit32::op_Addition(Posit32,Posit32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(1) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.left.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).1.right.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 2;
                                    \Posit32::op_Addition(Posit32,Posit32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(2) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.left.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).2.right.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).0._Started\ <= false;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).1._Started\ <= false;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).2._Started\ <= false;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.Posit32Calculator::AddPositsInArray(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\) then 
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\ := 0;
                                    \Posit32::op_Addition(Posit32,Posit32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(0) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.left.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).0.right.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\ := 1;
                                    \Posit32::op_Addition(Posit32,Posit32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(1) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.left.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).1.right.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\ := 2;
                                    \Posit32::op_Addition(Posit32,Posit32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).targetAvailableIndicator\(2) := false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.left.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).left.parameter.Out.0\;
                                    \Posit32::op_Addition(Posit32,Posit32).2.right.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).right.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).0._Started\ <= false;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).1._Started\ <= false;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::op_Addition(Posit32,Posit32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Addition(Posit32,Posit32).2._Started\ <= false;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32).return.0\ <= \Posit32::op_Addition(Posit32,Posit32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::op_Addition(Posit32,Posit32).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::op_Addition(Posit32,Posit32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32) end


    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32) start
    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(0) := \Posit32::op_Explicit(Posit32).1._Started\ = true and \Posit32::op_Explicit(Posit32).2._Started\ = true and \Posit32::op_Explicit(Posit32).0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(1) := \Posit32::op_Explicit(Posit32).2._Started\ = true and \Posit32::op_Explicit(Posit32).1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(2) := \Posit32::op_Explicit(Posit32).2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).0
                case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Started.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 0;
                                    \Posit32::op_Explicit(Posit32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(0) := false;
                                    \Posit32::op_Explicit(Posit32).0.x.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 1;
                                    \Posit32::op_Explicit(Posit32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(1) := false;
                                    \Posit32::op_Explicit(Posit32).1.x.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ := 2;
                                    \Posit32::op_Explicit(Posit32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(2) := false;
                                    \Posit32::op_Explicit(Posit32).2.x.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::op_Explicit(Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).0._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::op_Explicit(Posit32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).1._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::op_Explicit(Posit32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).2._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).1
                case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Started.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 0;
                                    \Posit32::op_Explicit(Posit32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(0) := false;
                                    \Posit32::op_Explicit(Posit32).0.x.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 1;
                                    \Posit32::op_Explicit(Posit32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(1) := false;
                                    \Posit32::op_Explicit(Posit32).1.x.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ := 2;
                                    \Posit32::op_Explicit(Posit32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(2) := false;
                                    \Posit32::op_Explicit(Posit32).2.x.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::op_Explicit(Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).0._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::op_Explicit(Posit32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).1._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::op_Explicit(Posit32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).2._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32).2
                case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Started.0\) then 
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 0;
                                    \Posit32::op_Explicit(Posit32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(0) := false;
                                    \Posit32::op_Explicit(Posit32).0.x.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 1;
                                    \Posit32::op_Explicit(Posit32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(1) := false;
                                    \Posit32::op_Explicit(Posit32).1.x.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ := 2;
                                    \Posit32::op_Explicit(Posit32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(2) := false;
                                    \Posit32::op_Explicit(Posit32).2.x.parameter.In\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::op_Explicit(Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).0._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::op_Explicit(Posit32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).1._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::op_Explicit(Posit32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).2._Started\ <= false;
                                    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Started.0\) then 
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 0;
                                    \Posit32::op_Explicit(Posit32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(0) := false;
                                    \Posit32::op_Explicit(Posit32).0.x.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 1;
                                    \Posit32::op_Explicit(Posit32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(1) := false;
                                    \Posit32::op_Explicit(Posit32).1.x.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ := 2;
                                    \Posit32::op_Explicit(Posit32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).targetAvailableIndicator\(2) := false;
                                    \Posit32::op_Explicit(Posit32).2.x.parameter.In\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32).x.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::op_Explicit(Posit32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).0._Started\ <= false;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::op_Explicit(Posit32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).1._Started\ <= false;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::op_Explicit(Posit32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= true;
                                    \Posit32::op_Explicit(Posit32).2._Started\ <= false;
                                    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32).return.0\ <= \Posit32::op_Explicit(Posit32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::op_Explicit(Posit32).Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit32::op_Explicit(Posit32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean) start
    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(0) := \Posit32::.ctor(UInt32,Boolean).1._Started\ = true and \Posit32::.ctor(UInt32,Boolean).2._Started\ = true and \Posit32::.ctor(UInt32,Boolean).0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(1) := \Posit32::.ctor(UInt32,Boolean).2._Started\ = true and \Posit32::.ctor(UInt32,Boolean).1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(2) := \Posit32::.ctor(UInt32,Boolean).2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculatePowerOfReal(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\) then 
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningIndex.0\ := 0;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningIndex.0\ := 1;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(UInt32,Boolean).1.this.parameter.In\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.bits.parameter.In\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.fromBitMask.parameter.In\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningIndex.0\ := 2;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(UInt32,Boolean).2.this.parameter.In\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.bits.parameter.In\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.fromBitMask.parameter.In\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(UInt32,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= false;
                                    \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(UInt32,Boolean).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= false;
                                    \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(UInt32,Boolean).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= false;
                                    \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Hast.Samples.SampleAssembly.Posit32Calculator::AddPositsInArray(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0
                case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\) then 
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\ := 0;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\ := 1;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(UInt32,Boolean).1.this.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.bits.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.fromBitMask.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\ := 2;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(UInt32,Boolean).2.this.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.bits.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.fromBitMask.parameter.In\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(UInt32,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= false;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(UInt32,Boolean).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= false;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(UInt32,Boolean).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := AfterFinished;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= false;
                                    \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32Calculator::AddPositsInArray(SimpleMemory).0.runningState.0\ := WaitingForStarted;
                            \Posit32Calculator::AddPositsInArray(SimpleMemory).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::Abs(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\) then 
                            \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\ <= \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\ <= \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\ <= \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(UInt32,Boolean).1.this.parameter.In\ <= \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.bits.parameter.In\ <= \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.fromBitMask.parameter.In\ <= \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(UInt32,Boolean).2.this.parameter.In\ <= \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.bits.parameter.In\ <= \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.fromBitMask.parameter.In\ <= \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(UInt32,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= false;
                                    \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(UInt32,Boolean).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= false;
                                    \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(UInt32,Boolean).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= false;
                                    \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::Abs(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::Abs(Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(UInt32,Boolean).1.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.fromBitMask.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(UInt32,Boolean).2.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.fromBitMask.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(UInt32,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(UInt32,Boolean).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(UInt32,Boolean).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1
                case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 1;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(UInt32,Boolean).1.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.fromBitMask.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 2;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(UInt32,Boolean).2.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.fromBitMask.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(UInt32,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(UInt32,Boolean).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(UInt32,Boolean).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2
                case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 1;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(UInt32,Boolean).1.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.fromBitMask.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 2;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(UInt32,Boolean).2.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.fromBitMask.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(UInt32,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(UInt32,Boolean).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(UInt32,Boolean).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(0) := false;
                                    \Posit32::.ctor(UInt32,Boolean).0.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.bits.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).0.fromBitMask.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(1) := false;
                                    \Posit32::.ctor(UInt32,Boolean).1.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.bits.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).1.fromBitMask.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).targetAvailableIndicator\(2) := false;
                                    \Posit32::.ctor(UInt32,Boolean).2.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.bits.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).bits.parameter.Out.0\;
                                    \Posit32::.ctor(UInt32,Boolean).2.fromBitMask.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).fromBitMask.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::.ctor(UInt32,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).0._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).0.this.parameter.Out\;
                                end if;
                            when 1 => 
                                if (\Posit32::.ctor(UInt32,Boolean).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).1._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).1.this.parameter.Out\;
                                end if;
                            when 2 => 
                                if (\Posit32::.ctor(UInt32,Boolean).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= true;
                                    \Posit32::.ctor(UInt32,Boolean).2._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean).this.parameter.In.0\ <= \Posit32::.ctor(UInt32,Boolean).2.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::.ctor(UInt32,Boolean).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::.ctor(UInt32,Boolean)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32,System.Boolean) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculatePowerOfReal(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit32::op_Multiply(Posit32,Posit32).0._Started\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32)._Started.0\;
    \Posit32::op_Multiply(Posit32,Posit32).0.left.parameter.In\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32).left.parameter.Out.0\;
    \Posit32::op_Multiply(Posit32,Posit32).0.right.parameter.In\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32).right.parameter.Out.0\;
    \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32)._Finished.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0._Finished\;
    \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.Posit32::op_Multiply(Posit32,Posit32).return.0\ <= \Posit32::op_Multiply(Posit32,Posit32).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32) end


    -- System.Void Hast::InternalInvocationProxy().System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._Started\ <= \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.0\;
    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.upToNumberObject.parameter.In\ <= \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.0\;
    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Finished.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0._Finished\;
    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).return.0\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).0.return\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#1):
    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._Started\ <= \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.1\;
    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.upToNumberObject.parameter.In\ <= \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.1\;
    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Finished.1\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1._Finished\;
    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).return.1\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).1.return\;
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#2):
    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._Started\ <= \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Started.2\;
    \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.upToNumberObject.parameter.In\ <= \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).upToNumberObject.parameter.Out.2\;
    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32)._Finished.2\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2._Finished\;
    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).return.2\ <= \Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(Int32).2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Int32 Hast.Samples.SampleAssembly.Posit32Calculator/<>c::<ParallelizedCalculateIntegerSumUpToNumbers>b__13_0(System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32) start
    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForStarted;
                \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ = true and \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ = true and \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ = true and \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).1
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).2
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).0
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::EncodeRegimeBits(Int32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).1
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::EncodeRegimeBits(Int32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32).2
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::EncodeRegimeBits(Int32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::EncodeRegimeBits(Int32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).1
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).2
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).1
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).2
                case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 0;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0.bits.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 1;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1.bits.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 2;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2.bits.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetMostSignificantOnePosition(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetMostSignificantOnePosition(UInt32).2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetMostSignificantOnePosition(UInt32).Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetMostSignificantOnePosition(UInt32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32) start
    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(0) := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ = true and \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ = true and \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(1) := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ = true and \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(2) := \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).0
                case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\) then 
                            \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\ := 0;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\ := 1;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\ := 2;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits.parameter.In\ <= \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= false;
                                    \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= false;
                                    \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= false;
                                    \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(UInt32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).1
                case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\) then 
                            \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\ := 0;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\ := 1;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\ := 2;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits.parameter.In\ <= \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= false;
                                    \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= false;
                                    \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= false;
                                    \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(UInt32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32).2
                case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\) then 
                            \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\ := 0;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\ := 1;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\ := 2;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits.parameter.In\ <= \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= false;
                                    \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= false;
                                    \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= false;
                                    \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::.ctor(UInt32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(UInt32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1
                case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 1;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 2;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2
                case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 1;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 2;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.signBit.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.regimeKValue.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.exponentBits.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.fractionBits.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.signBit.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.regimeKValue.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.exponentBits.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.fractionBits.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.signBit.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).signBit.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.regimeKValue.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).regimeKValue.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.exponentBits.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).exponentBits.parameter.Out.0\;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.fractionBits.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).fractionBits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= true;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).return.0\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0 (#0):
    \Posit32::.ctor(UInt32).0._Started\ <= \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Started.0\;
    \Posit32::.ctor(UInt32).0.this.parameter.In\ <= \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.Out.0\;
    \Posit32::.ctor(UInt32).0.value.parameter.In\ <= \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).value.parameter.Out.0\;
    \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32)._Finished.0\ <= \Posit32::.ctor(UInt32).0._Finished\;
    \Posit32::.ctor(Int32).0.Posit32::.ctor(UInt32).this.parameter.In.0\ <= \Posit32::.ctor(UInt32).0.this.parameter.Out\;
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).1 (#1):
    \Posit32::.ctor(UInt32).1._Started\ <= \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Started.0\;
    \Posit32::.ctor(UInt32).1.this.parameter.In\ <= \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).this.parameter.Out.0\;
    \Posit32::.ctor(UInt32).1.value.parameter.In\ <= \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).value.parameter.Out.0\;
    \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32)._Finished.0\ <= \Posit32::.ctor(UInt32).1._Finished\;
    \Posit32::.ctor(Int32).1.Posit32::.ctor(UInt32).this.parameter.In.0\ <= \Posit32::.ctor(UInt32).1.this.parameter.Out\;
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).2 (#2):
    \Posit32::.ctor(UInt32).2._Started\ <= \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Started.0\;
    \Posit32::.ctor(UInt32).2.this.parameter.In\ <= \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).this.parameter.Out.0\;
    \Posit32::.ctor(UInt32).2.value.parameter.In\ <= \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).value.parameter.Out.0\;
    \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32)._Finished.0\ <= \Posit32::.ctor(UInt32).2._Finished\;
    \Posit32::.ctor(Int32).2.Posit32::.ctor(UInt32).this.parameter.In.0\ <= \Posit32::.ctor(UInt32).2.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit32::.ctor(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32) start
    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForStarted;
                \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := \Posit32::GetTwosComplement(UInt32).1._Started\ = true and \Posit32::GetTwosComplement(UInt32).2._Started\ = true and \Posit32::GetTwosComplement(UInt32).0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := \Posit32::GetTwosComplement(UInt32).2._Started\ = true and \Posit32::GetTwosComplement(UInt32).1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := \Posit32::GetTwosComplement(UInt32).2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).0
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(Int32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).1
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(Int32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit32::.ctor(System.Int32).2
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningState.0\ := AfterFinished;
                                    \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::.ctor(Int32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::.ctor(Int32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).1
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).2
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit32::GetRegimeKValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().1
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForStarted;
                            \Posit32::GetRegimeKValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().2
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForStarted;
                            \Posit32::GetRegimeKValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::ExponentSize().0.runningState.0\ := WaitingForStarted;
                            \Posit32::ExponentSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().1
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().1.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().2
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::GetExponentValue().2.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSize().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().1
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().1.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSize().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().2
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionSize().2.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSize().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().0.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().1
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().1.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().2
                case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 0;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(0) := false;
                                    \Posit32::GetTwosComplement(UInt32).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 1;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(1) := false;
                                    \Posit32::GetTwosComplement(UInt32).1.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 2;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).targetAvailableIndicator\(2) := false;
                                    \Posit32::GetTwosComplement(UInt32).2.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32).bits.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetTwosComplement(UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetTwosComplement(UInt32).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetTwosComplement(UInt32).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= true;
                                    \Posit32::GetTwosComplement(UInt32).2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32).return.0\ <= \Posit32::GetTwosComplement(UInt32).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetTwosComplement(UInt32).Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().2.Posit32::GetTwosComplement(UInt32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::GetTwosComplement(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32) start
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 (#0):
    \Posit32::EncodeRegimeBits(Int32).0._Started\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Started.0\;
    \Posit32::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32)._Finished.0\ <= \Posit32::EncodeRegimeBits(Int32).0._Finished\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::EncodeRegimeBits(Int32).return.0\ <= \Posit32::EncodeRegimeBits(Int32).0.return\;
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).1 (#1):
    \Posit32::EncodeRegimeBits(Int32).1._Started\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32)._Started.0\;
    \Posit32::EncodeRegimeBits(Int32).1.regimeKValue.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32)._Finished.0\ <= \Posit32::EncodeRegimeBits(Int32).1._Finished\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::EncodeRegimeBits(Int32).return.0\ <= \Posit32::EncodeRegimeBits(Int32).1.return\;
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).2 (#2):
    \Posit32::EncodeRegimeBits(Int32).2._Started\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32)._Started.0\;
    \Posit32::EncodeRegimeBits(Int32).2.regimeKValue.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32)._Finished.0\ <= \Posit32::EncodeRegimeBits(Int32).2._Finished\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::EncodeRegimeBits(Int32).return.0\ <= \Posit32::EncodeRegimeBits(Int32).2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::EncodeRegimeBits(System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte) start
    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ = true and \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ = true and \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ = true and \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).1
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).2
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit32::GetRegimeKValue().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().1
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForStarted;
                            \Posit32::GetRegimeKValue().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().2
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForStarted;
                            \Posit32::GetRegimeKValue().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::ExponentSize().0.runningState.0\ := WaitingForStarted;
                            \Posit32::ExponentSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSize().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().1
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().1.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSize().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().2
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSize().2.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSize().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().0
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSizeWithoutSignCheck().0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().1
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().1.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSizeWithoutSignCheck().1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck().2
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::FractionSizeWithoutSignCheck().2.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSizeWithoutSignCheck().2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2
                case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0.startingPosition.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 1;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1.startingPosition.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 2;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.bits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).bits.parameter.Out.0\;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2.startingPosition.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).startingPosition.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::LengthOfRunOfBits(UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::LengthOfRunOfBits(UInt32,Byte).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte).return.0\ <= \Posit32::LengthOfRunOfBits(UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::LengthOfRunOfBits(UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::LengthOfRunOfBits(UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::LengthOfRunOfBits(System.UInt32,System.Byte) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16) start
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).0 (#0):
    \Posit32::SetZero(UInt32,UInt16).0._Started\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Started.0\;
    \Posit32::SetZero(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\;
    \Posit32::SetZero(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16)._Finished.0\ <= \Posit32::SetZero(UInt32,UInt16).0._Finished\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).0.Posit32::SetZero(UInt32,UInt16).return.0\ <= \Posit32::SetZero(UInt32,UInt16).0.return\;
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).1 (#1):
    \Posit32::SetZero(UInt32,UInt16).1._Started\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16)._Started.0\;
    \Posit32::SetZero(UInt32,UInt16).1.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\;
    \Posit32::SetZero(UInt32,UInt16).1.index.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16)._Finished.0\ <= \Posit32::SetZero(UInt32,UInt16).1._Finished\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).1.Posit32::SetZero(UInt32,UInt16).return.0\ <= \Posit32::SetZero(UInt32,UInt16).1.return\;
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit32::AssemblePositBitsWithRounding(System.Boolean,System.Int32,System.UInt32,System.UInt32).2 (#2):
    \Posit32::SetZero(UInt32,UInt16).2._Started\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16)._Started.0\;
    \Posit32::SetZero(UInt32,UInt16).2.bits.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16).bits.parameter.Out.0\;
    \Posit32::SetZero(UInt32,UInt16).2.index.parameter.In\ <= \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16).index.parameter.Out.0\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16)._Finished.0\ <= \Posit32::SetZero(UInt32,UInt16).2._Finished\;
    \Posit32::AssemblePositBitsWithRounding(Boolean,Int32,UInt32,UInt32).2.Posit32::SetZero(UInt32,UInt16).return.0\ <= \Posit32::SetZero(UInt32,UInt16).2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::SetZero(System.UInt32,System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit32::IsPositive() start
    \Hast::InternalInvocationProxy().Posit32::IsPositive()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForStarted;
                \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::ExponentSize().0.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::GetExponentValue().0.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::GetExponentValue().1.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::GetExponentValue().2.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::FractionSize().0.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::FractionSize().1.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::FractionSize().2.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := \Posit32::IsPositive().1._Started\ = true and \Posit32::IsPositive().2._Started\ = true and \Posit32::IsPositive().0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := \Posit32::IsPositive().2._Started\ = true and \Posit32::IsPositive().1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := \Posit32::IsPositive().2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::GetRegimeKValue().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::GetRegimeKValue().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::GetRegimeKValue().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::GetRegimeKValue().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit32::GetRegimeKValue().0.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().1
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::GetRegimeKValue().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::GetRegimeKValue().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::GetRegimeKValue().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::GetRegimeKValue().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().1.runningState.0\ := WaitingForStarted;
                            \Posit32::GetRegimeKValue().1.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue().2
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::GetRegimeKValue().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::GetRegimeKValue().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::GetRegimeKValue().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::GetRegimeKValue().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetRegimeKValue().2.runningState.0\ := WaitingForStarted;
                            \Posit32::GetRegimeKValue().2.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Byte Lombiq.Arithmetics.Posit32::ExponentSize().0
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::ExponentSize().0.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::ExponentSize().0.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::ExponentSize().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::ExponentSize().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::ExponentSize().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::ExponentSize().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::ExponentSize().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::ExponentSize().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::ExponentSize().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::ExponentSize().0.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::ExponentSize().0.runningState.0\ := WaitingForStarted;
                            \Posit32::ExponentSize().0.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().0.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::GetExponentValue().0.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::GetExponentValue().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::GetExponentValue().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::GetExponentValue().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().0.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().0.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().1
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().1.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::GetExponentValue().1.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::GetExponentValue().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::GetExponentValue().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::GetExponentValue().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::GetExponentValue().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::GetExponentValue().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::GetExponentValue().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().1.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().1.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().1.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().2
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().2.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::GetExponentValue().2.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::GetExponentValue().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::GetExponentValue().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::GetExponentValue().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::GetExponentValue().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::GetExponentValue().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::GetExponentValue().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().2.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::GetExponentValue().2.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().2.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().0
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSize().0.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::FractionSize().0.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::FractionSize().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::FractionSize().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::FractionSize().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::FractionSize().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::FractionSize().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::FractionSize().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSize().0.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSize().0.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().1
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSize().1.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::FractionSize().1.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::FractionSize().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::FractionSize().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::FractionSize().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::FractionSize().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::FractionSize().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::FractionSize().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSize().1.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().1.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSize().1.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize().2
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionSize().2.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::FractionSize().2.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::FractionSize().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::FractionSize().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::FractionSize().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::FractionSize().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::FractionSize().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionSize().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::FractionSize().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionSize().2.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionSize().2.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionSize().2.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().0.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().1
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().1.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().2
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().2.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_GreaterThan(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::op_GreaterThan(Posit32,Posit32).1.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_GreaterThan(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::op_GreaterThan(Posit32,Posit32).2.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).0.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).1
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).1.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).2
                case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 0;
                                    \Posit32::IsPositive().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsPositive().0.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 1;
                                    \Posit32::IsPositive().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsPositive().1.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 2;
                                    \Posit32::IsPositive().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsPositive().2.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsPositive().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsPositive().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Finished.0\ <= true;
                                    \Posit32::IsPositive().2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive().return.0\ <= \Posit32::IsPositive().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsPositive().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).2.Posit32::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit32::IsPositive() end


    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::ExponentSize() start
    \Hast::InternalInvocationProxy().Posit32::ExponentSize()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().1.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().2.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).1.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).2.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).2.runningState.0\ := WaitingForStarted;
                \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Finished.0\ <= false;
                \Posit32::GetExponentValue().1.Posit32::ExponentSize()._Finished.0\ <= false;
                \Posit32::GetExponentValue().2.Posit32::ExponentSize()._Finished.0\ <= false;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Finished.0\ <= false;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Finished.0\ <= false;
                \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0
                case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\) then 
                            \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().0.runningIndex.0\ := 0;
                            \Posit32::ExponentSize().0._Started\ <= true;
                            \Posit32::ExponentSize().0.this.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::ExponentSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::ExponentSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Finished.0\ <= true;
                                    \Posit32::ExponentSize().0._Started\ <= false;
                                    \Posit32::GetExponentValue().0.Posit32::ExponentSize().return.0\ <= \Posit32::ExponentSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().0.Posit32::ExponentSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().0.Posit32::ExponentSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().1
                case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().1.Posit32::ExponentSize()._Started.0\) then 
                            \Posit32::GetExponentValue().1.Posit32::ExponentSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().1.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().1.runningIndex.0\ := 0;
                            \Posit32::ExponentSize().0._Started\ <= true;
                            \Posit32::ExponentSize().0.this.parameter.In\ <= \Posit32::GetExponentValue().1.Posit32::ExponentSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::ExponentSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().1.Posit32::ExponentSize()._Finished.0\ <= true;
                                    \Posit32::ExponentSize().0._Started\ <= false;
                                    \Posit32::GetExponentValue().1.Posit32::ExponentSize().return.0\ <= \Posit32::ExponentSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().1.Posit32::ExponentSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().1.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().1.Posit32::ExponentSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().2
                case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().2.Posit32::ExponentSize()._Started.0\) then 
                            \Posit32::GetExponentValue().2.Posit32::ExponentSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().2.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().2.runningIndex.0\ := 0;
                            \Posit32::ExponentSize().0._Started\ <= true;
                            \Posit32::ExponentSize().0.this.parameter.In\ <= \Posit32::GetExponentValue().2.Posit32::ExponentSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::ExponentSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().2.Posit32::ExponentSize()._Finished.0\ <= true;
                                    \Posit32::ExponentSize().0._Started\ <= false;
                                    \Posit32::GetExponentValue().2.Posit32::ExponentSize().return.0\ <= \Posit32::ExponentSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().2.Posit32::ExponentSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValue().2.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().2.Posit32::ExponentSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).0
                case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Started.0\) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).0.runningIndex.0\ := 0;
                            \Posit32::ExponentSize().0._Started\ <= true;
                            \Posit32::ExponentSize().0.this.parameter.In\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::ExponentSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Finished.0\ <= true;
                                    \Posit32::ExponentSize().0._Started\ <= false;
                                    \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize().return.0\ <= \Posit32::ExponentSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.Posit32::ExponentSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).1
                case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Started.0\) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).1.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).1.runningIndex.0\ := 0;
                            \Posit32::ExponentSize().0._Started\ <= true;
                            \Posit32::ExponentSize().0.this.parameter.In\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::ExponentSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Finished.0\ <= true;
                                    \Posit32::ExponentSize().0._Started\ <= false;
                                    \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize().return.0\ <= \Posit32::ExponentSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.Posit32::ExponentSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32).2
                case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Started.0\) then 
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).2.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).2.runningIndex.0\ := 0;
                            \Posit32::ExponentSize().0._Started\ <= true;
                            \Posit32::ExponentSize().0.this.parameter.In\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::ExponentSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Finished.0\ <= true;
                                    \Posit32::ExponentSize().0._Started\ <= false;
                                    \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize().return.0\ <= \Posit32::ExponentSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::ExponentSize().Posit32::GetExponentValueWithoutSignCheck(UInt32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.Posit32::ExponentSize()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::ExponentSize() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize() start
    \Hast::InternalInvocationProxy().Posit32::FractionSize()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForStarted;
                \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\ <= false;
                \Posit32::GetExponentValue().1.Posit32::FractionSize()._Finished.0\ <= false;
                \Posit32::GetExponentValue().2.Posit32::FractionSize()._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(0) := \Posit32::FractionSize().1._Started\ = true and \Posit32::FractionSize().2._Started\ = true and \Posit32::FractionSize().0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(1) := \Posit32::FractionSize().2._Started\ = true and \Posit32::FractionSize().1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(2) := \Posit32::FractionSize().2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().0
                case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\) then 
                            \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningIndex.0\ := 0;
                                    \Posit32::FractionSize().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(0) := false;
                                    \Posit32::FractionSize().0.this.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::FractionSize().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningIndex.0\ := 1;
                                    \Posit32::FractionSize().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(1) := false;
                                    \Posit32::FractionSize().1.this.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::FractionSize().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningIndex.0\ := 2;
                                    \Posit32::FractionSize().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(2) := false;
                                    \Posit32::FractionSize().2.this.parameter.In\ <= \Posit32::GetExponentValue().0.Posit32::FractionSize().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().0._Started\ <= false;
                                    \Posit32::GetExponentValue().0.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::FractionSize().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().1._Started\ <= false;
                                    \Posit32::GetExponentValue().0.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::FractionSize().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().2._Started\ <= false;
                                    \Posit32::GetExponentValue().0.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().0.Posit32::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().0.Posit32::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().1
                case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().1.Posit32::FractionSize()._Started.0\) then 
                            \Posit32::GetExponentValue().1.Posit32::FractionSize()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningIndex.0\ := 0;
                                    \Posit32::FractionSize().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(0) := false;
                                    \Posit32::FractionSize().0.this.parameter.In\ <= \Posit32::GetExponentValue().1.Posit32::FractionSize().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningIndex.0\ := 1;
                                    \Posit32::FractionSize().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(1) := false;
                                    \Posit32::FractionSize().1.this.parameter.In\ <= \Posit32::GetExponentValue().1.Posit32::FractionSize().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningIndex.0\ := 2;
                                    \Posit32::FractionSize().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(2) := false;
                                    \Posit32::FractionSize().2.this.parameter.In\ <= \Posit32::GetExponentValue().1.Posit32::FractionSize().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().1.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().0._Started\ <= false;
                                    \Posit32::GetExponentValue().1.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::FractionSize().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().1.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().1._Started\ <= false;
                                    \Posit32::GetExponentValue().1.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::FractionSize().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().1.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().2._Started\ <= false;
                                    \Posit32::GetExponentValue().1.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().1.Posit32::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().1.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().1.Posit32::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue().2
                case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::GetExponentValue().2.Posit32::FractionSize()._Started.0\) then 
                            \Posit32::GetExponentValue().2.Posit32::FractionSize()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningIndex.0\ := 0;
                                    \Posit32::FractionSize().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(0) := false;
                                    \Posit32::FractionSize().0.this.parameter.In\ <= \Posit32::GetExponentValue().2.Posit32::FractionSize().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningIndex.0\ := 1;
                                    \Posit32::FractionSize().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(1) := false;
                                    \Posit32::FractionSize().1.this.parameter.In\ <= \Posit32::GetExponentValue().2.Posit32::FractionSize().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningIndex.0\ := 2;
                                    \Posit32::FractionSize().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(2) := false;
                                    \Posit32::FractionSize().2.this.parameter.In\ <= \Posit32::GetExponentValue().2.Posit32::FractionSize().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().2.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().0._Started\ <= false;
                                    \Posit32::GetExponentValue().2.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::FractionSize().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().2.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().1._Started\ <= false;
                                    \Posit32::GetExponentValue().2.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::FractionSize().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningState.0\ := AfterFinished;
                                    \Posit32::GetExponentValue().2.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().2._Started\ <= false;
                                    \Posit32::GetExponentValue().2.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::GetExponentValue().2.Posit32::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::GetExponentValue().2.runningState.0\ := WaitingForStarted;
                            \Posit32::GetExponentValue().2.Posit32::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                                    \Posit32::FractionSize().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(0) := false;
                                    \Posit32::FractionSize().0.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 1;
                                    \Posit32::FractionSize().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(1) := false;
                                    \Posit32::FractionSize().1.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 2;
                                    \Posit32::FractionSize().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(2) := false;
                                    \Posit32::FractionSize().2.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::FractionSize().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::FractionSize().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().0.Posit32::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().1
                case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 0;
                                    \Posit32::FractionSize().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(0) := false;
                                    \Posit32::FractionSize().0.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 1;
                                    \Posit32::FractionSize().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(1) := false;
                                    \Posit32::FractionSize().1.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 2;
                                    \Posit32::FractionSize().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(2) := false;
                                    \Posit32::FractionSize().2.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::FractionSize().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::FractionSize().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().1.Posit32::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().2
                case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 0;
                                    \Posit32::FractionSize().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(0) := false;
                                    \Posit32::FractionSize().0.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 1;
                                    \Posit32::FractionSize().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(1) := false;
                                    \Posit32::FractionSize().1.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 2;
                                    \Posit32::FractionSize().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().targetAvailableIndicator\(2) := false;
                                    \Posit32::FractionSize().2.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::FractionSize().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::FractionSize().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Finished.0\ <= true;
                                    \Posit32::FractionSize().2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize().return.0\ <= \Posit32::FractionSize().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSize().Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().2.Posit32::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionSize() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16) start
    \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().1.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().2.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.runningState.0\ := WaitingForStarted;
                \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \Posit32::SetOne(UInt32,UInt16).0._Started\ <= true;
                            \Posit32::SetOne(UInt32,UInt16).0.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::SetOne(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= true;
                                    \Posit32::SetOne(UInt32,UInt16).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16).return.0\ <= \Posit32::SetOne(UInt32,UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().1
                case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().1.runningIndex.0\ := 0;
                            \Posit32::SetOne(UInt32,UInt16).0._Started\ <= true;
                            \Posit32::SetOne(UInt32,UInt16).0.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::SetOne(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= true;
                                    \Posit32::SetOne(UInt32,UInt16).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16).return.0\ <= \Posit32::SetOne(UInt32,UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().1.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit().2
                case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Started.0\) then 
                            \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().2.runningIndex.0\ := 0;
                            \Posit32::SetOne(UInt32,UInt16).0._Started\ <= true;
                            \Posit32::SetOne(UInt32,UInt16).0.this.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::SetOne(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= true;
                                    \Posit32::SetOne(UInt32,UInt16).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16).return.0\ <= \Posit32::SetOne(UInt32,UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBit().2.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBit().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().0
                case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Started.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningIndex.0\ := 0;
                            \Posit32::SetOne(UInt32,UInt16).0._Started\ <= true;
                            \Posit32::SetOne(UInt32,UInt16).0.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::SetOne(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= true;
                                    \Posit32::SetOne(UInt32,UInt16).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16).return.0\ <= \Posit32::SetOne(UInt32,UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().1
                case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Started.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningIndex.0\ := 0;
                            \Posit32::SetOne(UInt32,UInt16).0._Started\ <= true;
                            \Posit32::SetOne(UInt32,UInt16).0.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::SetOne(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= true;
                                    \Posit32::SetOne(UInt32,UInt16).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16).return.0\ <= \Posit32::SetOne(UInt32,UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().2
                case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Started.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningIndex.0\ := 0;
                            \Posit32::SetOne(UInt32,UInt16).0._Started\ <= true;
                            \Posit32::SetOne(UInt32,UInt16).0.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::SetOne(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= true;
                                    \Posit32::SetOne(UInt32,UInt16).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16).return.0\ <= \Posit32::SetOne(UInt32,UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).0
                case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Started.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.runningIndex.0\ := 0;
                            \Posit32::SetOne(UInt32,UInt16).0._Started\ <= true;
                            \Posit32::SetOne(UInt32,UInt16).0.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::SetOne(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= true;
                                    \Posit32::SetOne(UInt32,UInt16).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16).return.0\ <= \Posit32::SetOne(UInt32,UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).1
                case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Started.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.runningIndex.0\ := 0;
                            \Posit32::SetOne(UInt32,UInt16).0._Started\ <= true;
                            \Posit32::SetOne(UInt32,UInt16).0.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::SetOne(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= true;
                                    \Posit32::SetOne(UInt32,UInt16).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16).return.0\ <= \Posit32::SetOne(UInt32,UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32).2
                case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Started.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.runningIndex.0\ := 0;
                            \Posit32::SetOne(UInt32,UInt16).0._Started\ <= true;
                            \Posit32::SetOne(UInt32,UInt16).0.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).this.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.bits.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).bits.parameter.Out.0\;
                            \Posit32::SetOne(UInt32,UInt16).0.index.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::SetOne(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= true;
                                    \Posit32::SetOne(UInt32,UInt16).0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16).return.0\ <= \Posit32::SetOne(UInt32,UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::SetOne(UInt32,UInt16).Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.Posit32::SetOne(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::SetOne(System.UInt32,System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck() start
    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
                \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(0) := \Posit32::FractionSizeWithoutSignCheck().1._Started\ = true and \Posit32::FractionSizeWithoutSignCheck().2._Started\ = true and \Posit32::FractionSizeWithoutSignCheck().0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(1) := \Posit32::FractionSizeWithoutSignCheck().2._Started\ = true and \Posit32::FractionSizeWithoutSignCheck().1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(2) := \Posit32::FractionSizeWithoutSignCheck().2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().0
                case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Started.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningIndex.0\ := 0;
                                    \Posit32::FractionSizeWithoutSignCheck().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(0) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().0.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningIndex.0\ := 1;
                                    \Posit32::FractionSizeWithoutSignCheck().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(1) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().1.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningIndex.0\ := 2;
                                    \Posit32::FractionSizeWithoutSignCheck().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(2) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().2.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().0.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().1
                case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Started.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningIndex.0\ := 0;
                                    \Posit32::FractionSizeWithoutSignCheck().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(0) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().0.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningIndex.0\ := 1;
                                    \Posit32::FractionSizeWithoutSignCheck().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(1) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().1.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningIndex.0\ := 2;
                                    \Posit32::FractionSizeWithoutSignCheck().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(2) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().2.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().1.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().1.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck().2
                case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Started.0\) then 
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningIndex.0\ := 0;
                                    \Posit32::FractionSizeWithoutSignCheck().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(0) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().0.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningIndex.0\ := 1;
                                    \Posit32::FractionSizeWithoutSignCheck().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(1) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().1.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningIndex.0\ := 2;
                                    \Posit32::FractionSizeWithoutSignCheck().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(2) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().2.this.parameter.In\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().0._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().1._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := AfterFinished;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().2._Started\ <= false;
                                    \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::FractionWithHiddenBitWithoutSignCheck().2.runningState.0\ := WaitingForStarted;
                            \Posit32::FractionWithHiddenBitWithoutSignCheck().2.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Started.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::FractionSizeWithoutSignCheck().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(0) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().0.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::FractionSizeWithoutSignCheck().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(1) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().1.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::FractionSizeWithoutSignCheck().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().targetAvailableIndicator\(2) := false;
                                    \Posit32::FractionSizeWithoutSignCheck().2.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().0._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().1._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::FractionSizeWithoutSignCheck().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= true;
                                    \Posit32::FractionSizeWithoutSignCheck().2._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck().return.0\ <= \Posit32::FractionSizeWithoutSignCheck().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::FractionSizeWithoutSignCheck().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck() end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit32::IsNaN() start
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::IsNaN().0._Started\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Started.0\;
    \Posit32::IsNaN().0.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN().this.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN()._Finished.0\ <= \Posit32::IsNaN().0._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsNaN().return.0\ <= \Posit32::IsNaN().0.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 (#1):
    \Posit32::IsNaN().1._Started\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Started.0\;
    \Posit32::IsNaN().1.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN().this.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN()._Finished.0\ <= \Posit32::IsNaN().1._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsNaN().return.0\ <= \Posit32::IsNaN().1.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 (#2):
    \Posit32::IsNaN().2._Started\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Started.0\;
    \Posit32::IsNaN().2.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN().this.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN()._Finished.0\ <= \Posit32::IsNaN().2._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsNaN().return.0\ <= \Posit32::IsNaN().2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit32::IsNaN() end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit32::IsZero() start
    \Hast::InternalInvocationProxy().Posit32::IsZero()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Finished.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(0) := \Posit32::IsZero().1._Started\ = true and \Posit32::IsZero().2._Started\ = true and \Posit32::IsZero().0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(1) := \Posit32::IsZero().2._Started\ = true and \Posit32::IsZero().1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(2) := \Posit32::IsZero().2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::IsZero().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsZero().0.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::IsZero().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsZero().1.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::IsZero().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsZero().2.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsZero().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().return.0\ <= \Posit32::IsZero().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsZero().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().return.0\ <= \Posit32::IsZero().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsZero().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero().return.0\ <= \Posit32::IsZero().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1
                case \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                                    \Posit32::IsZero().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsZero().0.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 1;
                                    \Posit32::IsZero().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsZero().1.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 2;
                                    \Posit32::IsZero().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsZero().2.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsZero().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().return.0\ <= \Posit32::IsZero().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsZero().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().return.0\ <= \Posit32::IsZero().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsZero().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero().return.0\ <= \Posit32::IsZero().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::IsZero()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2
                case \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                                    \Posit32::IsZero().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsZero().0.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 1;
                                    \Posit32::IsZero().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsZero().1.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 2;
                                    \Posit32::IsZero().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsZero().2.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsZero().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().return.0\ <= \Posit32::IsZero().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsZero().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().return.0\ <= \Posit32::IsZero().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsZero().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero().return.0\ <= \Posit32::IsZero().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::IsZero()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Started.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::IsZero().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(0) := false;
                                    \Posit32::IsZero().0.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::IsZero().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(1) := false;
                                    \Posit32::IsZero().1.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::IsZero().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().targetAvailableIndicator\(2) := false;
                                    \Posit32::IsZero().2.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::IsZero().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().0._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().return.0\ <= \Posit32::IsZero().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::IsZero().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().1._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().return.0\ <= \Posit32::IsZero().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::IsZero().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= true;
                                    \Posit32::IsZero().2._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero().return.0\ <= \Posit32::IsZero().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::IsZero().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::IsZero()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit32::IsZero() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte) start
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::FractionSizeWithoutSignCheck(Byte).0._Started\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\;
    \Posit32::FractionSizeWithoutSignCheck(Byte).0.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\;
    \Posit32::FractionSizeWithoutSignCheck(Byte).0.lengthOfRunOfBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\ <= \Posit32::FractionSizeWithoutSignCheck(Byte).0._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\ <= \Posit32::FractionSizeWithoutSignCheck(Byte).0.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 (#1):
    \Posit32::FractionSizeWithoutSignCheck(Byte).1._Started\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\;
    \Posit32::FractionSizeWithoutSignCheck(Byte).1.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\;
    \Posit32::FractionSizeWithoutSignCheck(Byte).1.lengthOfRunOfBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\ <= \Posit32::FractionSizeWithoutSignCheck(Byte).1._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\ <= \Posit32::FractionSizeWithoutSignCheck(Byte).1.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 (#2):
    \Posit32::FractionSizeWithoutSignCheck(Byte).2._Started\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Started.0\;
    \Posit32::FractionSizeWithoutSignCheck(Byte).2.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).this.parameter.Out.0\;
    \Posit32::FractionSizeWithoutSignCheck(Byte).2.lengthOfRunOfBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte)._Finished.0\ <= \Posit32::FractionSizeWithoutSignCheck(Byte).2._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionSizeWithoutSignCheck(Byte).return.0\ <= \Posit32::FractionSizeWithoutSignCheck(Byte).2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionSizeWithoutSignCheck(System.Byte) end


    -- System.Void Hast::InternalInvocationProxy().System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte) start
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._Started\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\;
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\;
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.lengthOfRunOfBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\ <= \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\ <= \Posit32::GetRegimeKValueWithoutSignCheck(Byte).0.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 (#1):
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._Started\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\;
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\;
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.lengthOfRunOfBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\ <= \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\ <= \Posit32::GetRegimeKValueWithoutSignCheck(Byte).1.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 (#2):
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._Started\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Started.0\;
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).this.parameter.Out.0\;
    \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.lengthOfRunOfBits.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).lengthOfRunOfBits.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte)._Finished.0\ <= \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetRegimeKValueWithoutSignCheck(Byte).return.0\ <= \Posit32::GetRegimeKValueWithoutSignCheck(Byte).2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValueWithoutSignCheck(System.Byte) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32) start
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._Started\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\;
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\;
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.fractionSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).0._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).0.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 (#1):
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._Started\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\;
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\;
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.fractionSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).1._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).1.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 (#2):
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._Started\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Started.0\;
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).this.parameter.Out.0\;
    \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.fractionSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32)._Finished.0\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).2._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::GetExponentValueWithoutSignCheck(UInt32).return.0\ <= \Posit32::GetExponentValueWithoutSignCheck(UInt32).2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValueWithoutSignCheck(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32) start
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::op_GreaterThan(Posit32,Posit32).0._Started\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\;
    \Posit32::op_GreaterThan(Posit32,Posit32).0.left.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32).left.parameter.Out.0\;
    \Posit32::op_GreaterThan(Posit32,Posit32).0.right.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32).right.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32)._Finished.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).0._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::op_GreaterThan(Posit32,Posit32).return.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).0.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 (#1):
    \Posit32::op_GreaterThan(Posit32,Posit32).1._Started\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\;
    \Posit32::op_GreaterThan(Posit32,Posit32).1.left.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32).left.parameter.Out.0\;
    \Posit32::op_GreaterThan(Posit32,Posit32).1.right.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32).right.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32)._Finished.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).1._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::op_GreaterThan(Posit32,Posit32).return.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).1.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 (#2):
    \Posit32::op_GreaterThan(Posit32,Posit32).2._Started\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32)._Started.0\;
    \Posit32::op_GreaterThan(Posit32,Posit32).2.left.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32).left.parameter.Out.0\;
    \Posit32::op_GreaterThan(Posit32,Posit32).2.right.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32).right.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32)._Finished.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).2._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::op_GreaterThan(Posit32,Posit32).return.0\ <= \Posit32::op_GreaterThan(Posit32,Posit32).2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit32::op_GreaterThan(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32) end


    -- System.Void Hast::InternalInvocationProxy().System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte) start
    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
                \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(0) := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ = true and \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ = true and \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(1) := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ = true and \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(2) := \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.exponentValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.maximumExponentSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.exponentValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.maximumExponentSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.exponentValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.maximumExponentSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1
                case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 0;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.exponentValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.maximumExponentSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 1;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.exponentValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.maximumExponentSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ := 2;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.exponentValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.maximumExponentSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).1.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2
                case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\) then 
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 0;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.exponentValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.maximumExponentSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 1;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.exponentValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.maximumExponentSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ := 2;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.regimeKValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.exponentValue.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.maximumExponentSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ <= false;
                                    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Addition(Posit32,Posit32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Addition(Posit32,Posit32).2.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(0) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.regimeKValue.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.exponentValue.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.maximumExponentSize.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(1) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.regimeKValue.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.exponentValue.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.maximumExponentSize.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).targetAvailableIndicator\(2) := false;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.regimeKValue.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).regimeKValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.exponentValue.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).exponentValue.parameter.Out.0\;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.maximumExponentSize.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= true;
                                    \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte).return.0\ <= \Posit32::CalculateScaleFactor(SByte,UInt32,Byte).2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::CalculateScaleFactor(SByte,UInt32,Byte).Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::CalculateScaleFactor(SByte,UInt32,Byte)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Int16 Lombiq.Arithmetics.Posit32::CalculateScaleFactor(System.SByte,System.UInt32,System.Byte) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32) start
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._Started\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\;
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\;
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.fractionSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).0.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).1 (#1):
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._Started\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\;
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\;
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.fractionSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).1.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).1.return\;
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Addition(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).2 (#2):
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._Started\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Started.0\;
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.this.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).this.parameter.Out.0\;
    \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.fractionSize.parameter.In\ <= \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).fractionSize.parameter.Out.0\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32)._Finished.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2._Finished\;
    \Posit32::op_Addition(Posit32,Posit32).2.Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).return.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck(UInt32).2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck(System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::Abs(Lombiq.Arithmetics.Posit32) start
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::Abs(Posit32).0._Started\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Started.0\;
    \Posit32::Abs(Posit32).0.input.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32).input.parameter.Out.0\;
    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32)._Finished.0\ <= \Posit32::Abs(Posit32).0._Finished\;
    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::Abs(Posit32).return.0\ <= \Posit32::Abs(Posit32).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::Abs(Lombiq.Arithmetics.Posit32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck() start
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::FractionWithHiddenBitWithoutSignCheck().0._Started\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Started.0\;
    \Posit32::FractionWithHiddenBitWithoutSignCheck().0.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck().this.parameter.Out.0\;
    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck()._Finished.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0._Finished\;
    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::FractionWithHiddenBitWithoutSignCheck().return.0\ <= \Posit32::FractionWithHiddenBitWithoutSignCheck().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBitWithoutSignCheck() end


    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64) start
    -- Signal connections for Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::GetMostSignificantOnePosition(UInt64).0._Started\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64)._Started.0\;
    \Posit32::GetMostSignificantOnePosition(UInt64).0.bits.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64).bits.parameter.Out.0\;
    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64)._Finished.0\ <= \Posit32::GetMostSignificantOnePosition(UInt64).0._Finished\;
    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetMostSignificantOnePosition(UInt64).return.0\ <= \Posit32::GetMostSignificantOnePosition(UInt64).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Byte Lombiq.Arithmetics.Posit32::GetMostSignificantOnePosition(System.UInt64) end


    -- System.Void Hast::InternalInvocationProxy().System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue() start
    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForStarted;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(0) := \Posit32::GetRegimeKValue().1._Started\ = true and \Posit32::GetRegimeKValue().2._Started\ = true and \Posit32::GetRegimeKValue().0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(1) := \Posit32::GetRegimeKValue().2._Started\ = true and \Posit32::GetRegimeKValue().1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(2) := \Posit32::GetRegimeKValue().2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Started.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::GetRegimeKValue().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(0) := false;
                                    \Posit32::GetRegimeKValue().0.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::GetRegimeKValue().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(1) := false;
                                    \Posit32::GetRegimeKValue().1.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::GetRegimeKValue().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(2) := false;
                                    \Posit32::GetRegimeKValue().2.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetRegimeKValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().0._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetRegimeKValue().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().1._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetRegimeKValue().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().2._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::GetRegimeKValue().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(0) := false;
                                    \Posit32::GetRegimeKValue().0.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::GetRegimeKValue().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(1) := false;
                                    \Posit32::GetRegimeKValue().1.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::GetRegimeKValue().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(2) := false;
                                    \Posit32::GetRegimeKValue().2.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetRegimeKValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetRegimeKValue().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetRegimeKValue().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetRegimeKValue()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).1
                case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 0;
                                    \Posit32::GetRegimeKValue().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(0) := false;
                                    \Posit32::GetRegimeKValue().0.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 1;
                                    \Posit32::GetRegimeKValue().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(1) := false;
                                    \Posit32::GetRegimeKValue().1.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 2;
                                    \Posit32::GetRegimeKValue().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(2) := false;
                                    \Posit32::GetRegimeKValue().2.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetRegimeKValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetRegimeKValue().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetRegimeKValue().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetRegimeKValue()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).2
                case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 0;
                                    \Posit32::GetRegimeKValue().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(0) := false;
                                    \Posit32::GetRegimeKValue().0.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 1;
                                    \Posit32::GetRegimeKValue().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(1) := false;
                                    \Posit32::GetRegimeKValue().1.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 2;
                                    \Posit32::GetRegimeKValue().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().targetAvailableIndicator\(2) := false;
                                    \Posit32::GetRegimeKValue().2.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetRegimeKValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetRegimeKValue().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetRegimeKValue().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit32::GetRegimeKValue().2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue().return.0\ <= \Posit32::GetRegimeKValue().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetRegimeKValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetRegimeKValue()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.SByte Lombiq.Arithmetics.Posit32::GetRegimeKValue() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue() start
    \Hast::InternalInvocationProxy().Posit32::GetExponentValue()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\: \InternalInvocationProxy_boolean_Array\(2 downto 0) := (others => false);
        Variable \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\: integer range 0 to 2 := 0;
        Variable \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\ := (others => false);
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForStarted;
                \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Finished.0\ <= false;
                \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Finished.0\ <= false;
            else 
                -- Building a boolean array where each of the elements will indicate whether the component with the given index should be started next.
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(0) := \Posit32::GetExponentValue().1._Started\ = true and \Posit32::GetExponentValue().2._Started\ = true and \Posit32::GetExponentValue().0._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(1) := \Posit32::GetExponentValue().2._Started\ = true and \Posit32::GetExponentValue().1._Started\ = false;
                \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(2) := \Posit32::GetExponentValue().2._Started\ = false;

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit32 Lombiq.Arithmetics.Posit32::op_Multiply(Lombiq.Arithmetics.Posit32,Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Started.0\) then 
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::GetExponentValue().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(0) := false;
                                    \Posit32::GetExponentValue().0.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::GetExponentValue().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(1) := false;
                                    \Posit32::GetExponentValue().1.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::GetExponentValue().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(2) := false;
                                    \Posit32::GetExponentValue().2.this.parameter.In\ <= \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetExponentValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().0._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetExponentValue().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().1._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetExponentValue().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().2._Started\ <= false;
                                    \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Multiply(Posit32,Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Multiply(Posit32,Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0
                case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 0;
                                    \Posit32::GetExponentValue().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(0) := false;
                                    \Posit32::GetExponentValue().0.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 1;
                                    \Posit32::GetExponentValue().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(1) := false;
                                    \Posit32::GetExponentValue().1.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\ := 2;
                                    \Posit32::GetExponentValue().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(2) := false;
                                    \Posit32::GetExponentValue().2.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetExponentValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetExponentValue().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetExponentValue().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).0.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).0.Posit32::GetExponentValue()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).1
                case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 0;
                                    \Posit32::GetExponentValue().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(0) := false;
                                    \Posit32::GetExponentValue().0.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 1;
                                    \Posit32::GetExponentValue().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(1) := false;
                                    \Posit32::GetExponentValue().1.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\ := 2;
                                    \Posit32::GetExponentValue().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(2) := false;
                                    \Posit32::GetExponentValue().2.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetExponentValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetExponentValue().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetExponentValue().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).1.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).1.Posit32::GetExponentValue()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).2
                case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Started.0\) then 
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Finished.0\ <= false;
                            case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\ is 
                                when (false, false, true) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 0;
                                    \Posit32::GetExponentValue().0._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(0) := false;
                                    \Posit32::GetExponentValue().0.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when (false, true, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 1;
                                    \Posit32::GetExponentValue().1._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(1) := false;
                                    \Posit32::GetExponentValue().1.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when (true, false, false) => 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForFinished;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\ := 2;
                                    \Posit32::GetExponentValue().2._Started\ <= true;
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().targetAvailableIndicator\(2) := false;
                                    \Posit32::GetExponentValue().2.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue().this.parameter.Out.0\;
                                when others => 
                                    null;
                            end case;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit32::GetExponentValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().0._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().0.return\;
                                end if;
                            when 1 => 
                                if (\Posit32::GetExponentValue().1._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().1._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().1.return\;
                                end if;
                            when 2 => 
                                if (\Posit32::GetExponentValue().2._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := AfterFinished;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Finished.0\ <= true;
                                    \Posit32::GetExponentValue().2._Started\ <= false;
                                    \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue().return.0\ <= \Posit32::GetExponentValue().2.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit32::GetExponentValue().Posit32::op_Explicit(Posit32).2.runningState.0\ := WaitingForStarted;
                            \Posit32::op_Explicit(Posit32).2.Posit32::GetExponentValue()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::GetExponentValue() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit() start
    -- Signal connections for System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).0 (#0):
    \Posit32::FractionWithHiddenBit().0._Started\ <= \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Started.0\;
    \Posit32::FractionWithHiddenBit().0.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().this.parameter.Out.0\;
    \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit()._Finished.0\ <= \Posit32::FractionWithHiddenBit().0._Finished\;
    \Posit32::op_Explicit(Posit32).0.Posit32::FractionWithHiddenBit().return.0\ <= \Posit32::FractionWithHiddenBit().0.return\;
    -- Signal connections for System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).1 (#1):
    \Posit32::FractionWithHiddenBit().1._Started\ <= \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Started.0\;
    \Posit32::FractionWithHiddenBit().1.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit().this.parameter.Out.0\;
    \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit()._Finished.0\ <= \Posit32::FractionWithHiddenBit().1._Finished\;
    \Posit32::op_Explicit(Posit32).1.Posit32::FractionWithHiddenBit().return.0\ <= \Posit32::FractionWithHiddenBit().1.return\;
    -- Signal connections for System.Int32 Lombiq.Arithmetics.Posit32::op_Explicit(Lombiq.Arithmetics.Posit32).2 (#2):
    \Posit32::FractionWithHiddenBit().2._Started\ <= \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Started.0\;
    \Posit32::FractionWithHiddenBit().2.this.parameter.In\ <= \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit().this.parameter.Out.0\;
    \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit()._Finished.0\ <= \Posit32::FractionWithHiddenBit().2._Finished\;
    \Posit32::op_Explicit(Posit32).2.Posit32::FractionWithHiddenBit().return.0\ <= \Posit32::FractionWithHiddenBit().2.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit32::FractionWithHiddenBit() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Finished.0\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculatePowerOfReal(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().Posit32Calculator::CalculatePowerOfReal(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().Posit32Calculator::CalculatePowerOfReal(SimpleMemory)._Finished.0\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32Calculator::CalculatePowerOfReal(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory)._Finished.0\ <= \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32Calculator::AddPositsInArray(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \Posit32Calculator::AddPositsInArray(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().Posit32Calculator::AddPositsInArray(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().Posit32Calculator::AddPositsInArray(SimpleMemory)._Finished.0\ <= \Posit32Calculator::AddPositsInArray(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.Posit32Calculator::AddPositsInArray(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::SimpleMemoryOperationProxy() start
    \CellIndex\ <= to_integer(\Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\) when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ or \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.CellIndex\) when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.ReadEnable\ or \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.CellIndex\) when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ or \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ else to_integer(\Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.CellIndex\) when \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.ReadEnable\ or \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.WriteEnable\ else 0;
    \DataOut\ <= \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.DataOut\ when \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ else \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.DataOut\ when \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.WriteEnable\ else \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.DataOut\ when \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ else \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.DataOut\ when \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.WriteEnable\ else "00000000000000000000000000000000";
    \ReadEnable\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.ReadEnable\ or \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.ReadEnable\ or \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.ReadEnable\ or \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\;
    \WriteEnable\ <= \Posit32Calculator::CalculatePowerOfReal(SimpleMemory).0.SimpleMemory.WriteEnable\ or \Posit32Calculator::ParallelizedCalculateIntegerSumUpToNumbers(SimpleMemory).0.SimpleMemory.WriteEnable\ or \Posit32Calculator::AddPositsInArray(SimpleMemory).0.SimpleMemory.WriteEnable\ or \Posit32Calculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\;
    -- System.Void Hast::SimpleMemoryOperationProxy() end

end Imp;
