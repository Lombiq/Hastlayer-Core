-- Generated by Hastlayer (hastlayer.com) at <date and time removed for approval testing> for the following hardware entry points: 
-- * System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory)

-- VHDL libraries necessary for the generated code to work. These libraries are included here instead of being managed separately in the Hardware Framework so they can be more easily updated.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package TypeConversion is
    function SmartResize(input: unsigned; size: natural) return unsigned;
    function SmartResize(input: signed; size: natural) return signed;
    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned;
end TypeConversion;
        
package body TypeConversion is

    -- The .NET behavior is different than that of resize() ("To create a larger vector, the new [leftmost] bit 
    -- positions are filled with the sign bit(ARG'LEFT). When truncating, the sign bit is retained along with the 
    -- rightmost part.") when casting to a smaller type: "If the source type is larger than the destination type, 
    -- then the source value is truncated by discarding its "extra" most significant bits. The result is then 
    -- treated as a value of the destination type." Thus we need to simply truncate when casting down. See:
    -- https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions
    function SmartResize(input: unsigned; size: natural) return unsigned is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            -- Resize() is supposed to work with little endian numbers: "When truncating, the sign bit is retained
            -- along with the rightmost part." for signed numbers and "When truncating, the leftmost bits are 
            -- dropped." for unsigned ones. See: http://www.csee.umbc.edu/portal/help/VHDL/numeric_std.vhdl
            return resize(input, size);
        end if;
    end SmartResize;

    function SmartResize(input: signed; size: natural) return signed is
    begin
        if (size < input'LENGTH) then
            return input(size - 1 downto 0);
        else
            return resize(input, size);
        end if;
    end SmartResize;

    function ToUnsignedAndExpand(input: signed; size: natural) return unsigned is
        variable result: unsigned(size - 1 downto 0);
    begin
        if (input >= 0) then
            return resize(unsigned(input), size);
        else 
            result := (others => '1');
            result(input'LENGTH - 1 downto 0) := unsigned(input);
            return result;
        end if;
    end ToUnsignedAndExpand;

end TypeConversion;


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
        
package SimpleMemory is
    -- Data conversion functions:
    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned;
        
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector;
    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean;
        
    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector;
    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed;
end SimpleMemory;
        
package body SimpleMemory is

    function ConvertUInt32ToStdLogicVector(input: unsigned(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertUInt32ToStdLogicVector;
    
    function ConvertStdLogicVectorToUInt32(input : std_logic_vector) return unsigned is
    begin
        return unsigned(input);
    end ConvertStdLogicVectorToUInt32;
    
    function ConvertBooleanToStdLogicVector(input: boolean) return std_logic_vector is 
    begin
        case input is
            when true => return X"FFFFFFFF";
            when false => return X"00000000";
            when others => return X"00000000";
        end case;
    end ConvertBooleanToStdLogicVector;

    function ConvertStdLogicVectorToBoolean(input : std_logic_vector) return boolean is 
    begin
        -- In .NET a false is all zeros while a true is at least one 1 bit (or more), so using the same logic here.
        return not(input = X"00000000");
    end ConvertStdLogicVectorToBoolean;

    function ConvertInt32ToStdLogicVector(input: signed(31 downto 0)) return std_logic_vector is
    begin
        return std_logic_vector(input);
    end ConvertInt32ToStdLogicVector;

    function ConvertStdLogicVectorToInt32(input : std_logic_vector) return signed is
    begin
        return signed(input);
    end ConvertStdLogicVectorToInt32;

end SimpleMemory;

-- Hast_IP, logic generated from the input .NET assemblies starts here.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library work;
use work.TypeConversion.all;
library work;
use work.SimpleMemory.all;

entity Hast_IP is 
    port(
        \DataIn\: In std_logic_vector(31 downto 0);
        \DataOut\: Out std_logic_vector(31 downto 0);
        \CellIndex\: Out integer;
        \ReadEnable\: Out boolean;
        \WriteEnable\: Out boolean;
        \ReadsDone\: In boolean;
        \WritesDone\: In boolean;
        \MemberId\: In integer;
        \Reset\: In std_logic;
        \Started\: In boolean;
        \Finished\: Out boolean;
        \Clock\: In std_logic
    );
    -- (Hast_IP ID removed for approval testing.)
    -- (Date and time removed for approval testing.)
    -- Generated by Hastlayer - hastlayer.com

    -- Hast_IP's simple interface makes it suitable to plug it into any hardware implementation. The meaning and usage of the ports are as below:
    -- * MemberId: Each transformed .NET hardware entry point member (i.e. methods that are configured to be available to be called from the host PC) has a unique zero-based numeric ID. When selecting which one to execute this ID should be used. 
    -- * Started: Indicates whether the execution of a given hardware entry point member is started. Used in the following way:
    --     1. Started is set to TRUE by the consuming framework, after which the execution of the given member starts internally. The Finished port will be initially set to FALSE.
    --     2. Once the execution is finished, the Finished port will be set to TRUE.
    --     3. The consuming framework sets Started to FALSE, after which Finished will also be set to FALSE.
    -- * Finished: Indicates whether the execution of a given hardware entry point member is complete. See the documentation of the Started port above on how it is used.
    -- * Reset: Synchronous reset.
    -- * Clock: The main clock.
    -- * DataIn: Data read out from the memory (usually on-board DDR RAM, but depends on the framework) should be assigned to this port by the framework. The width of this port is always 32b, independent of the hardware platform (if the bus to the memory is wider then caching needs to be implemented in the framework to make use of it). Inputs of the algorithm implemented in Hast_IP all come through this port.
    -- * DataOut: Data to be written to the memory is assigned to this port. The width of this port is always 32b, independent of the hardware platform (if the bus to the memory is wider then caching needs to be implemented in the framework to make use of it). Outputs of the algorithm implemented in Hast_IP all go through this port.
    -- * CellIndex: Zero-based index of the SimpleMemory memory cell currently being read or written. Transformed code in Hastlayer can access memory in a simplified fashion by addressing 32b "cells", the accessible physical memory space being divided up in such individually addressable cells.
    -- * ReadEnable: Indicates whether a memory read operation is initiated. The process of a memory read is as following:
    --     1. ReadEnable is FALSE by default. It's set to TRUE when a memory read is started. CellIndex is set to the index of the memory cell to be read out.
    --     2. Waiting for ReadsDone to be TRUE.
    --     3. Once ReadsDone is TRUE, data from DataIn will be read out and ReadEnable set to FALSE.
    -- * WriteEnable: Indicates whether a memory write operation is initiated. The process of a memory write is as following:
    --     1. WriteEnable is FALSE by default. It's set to TRUE when a memory write is started. CellIndex is set to the index of the memory cell to be written and the output data is assigned to DataOut.
    --     2. Waiting for WritesDone to be TRUE.
    --     3. Once WritesDone is TRUE, WriteEnable is set to FALSE.
    -- * ReadsDone: Indicates whether a memory read operation is completed.
    -- * WritesDone: Indicates whether a memory write operation is completed.

end Hast_IP;

architecture Imp of Hast_IP is 
    -- This IP was generated by Hastlayer from .NET code to mimic the original logic. Note the following:
    -- * For each member (methods, functions, properties) in .NET a state machine was generated. Each state machine's name corresponds to 
    --   the original member's name.
    -- * Inputs and outputs are passed between state machines as shared objects.
    -- * There are operations that take multiple clock cycles like interacting with the memory and long-running arithmetic operations 
    --   (modulo, division, multiplication). These are awaited in subsequent states but be aware that some states can take more 
    --   than one clock cycle to produce their output.
    -- * The ExternalInvocationProxy process dispatches invocations that were started from the outside to the state machines.
    -- * The InternalInvocationProxy processes dispatch invocations between state machines.

    -- Custom inter-dependent type declarations start
    type \unsigned32_Array\ is array (integer range <>) of unsigned(31 downto 0);
    type \Lombiq.Arithmetics.BitMask\ is record 
        \IsNull\: boolean;
        \Size\: unsigned(15 downto 0);
        \SegmentCount\: unsigned(15 downto 0);
        \Segments\: \unsigned32_Array\(0 to 0);
    end record;
    type \Lombiq.Arithmetics.PositEnvironment\ is record 
        \IsNull\: boolean;
        \MaximumExponentSize\: unsigned(7 downto 0);
        \Size\: unsigned(15 downto 0);
        \Useed\: unsigned(31 downto 0);
        \FirstRegimeBitIndex\: unsigned(15 downto 0);
        \SignBitMask\: \Lombiq.Arithmetics.BitMask\;
        \FirstRegimeBitBitMask\: \Lombiq.Arithmetics.BitMask\;
        \EmptyBitMask\: \Lombiq.Arithmetics.BitMask\;
        \MaxValueBitMask\: \Lombiq.Arithmetics.BitMask\;
        \MinValueBitMask\: \Lombiq.Arithmetics.BitMask\;
        \NaNBitMask\: \Lombiq.Arithmetics.BitMask\;
        \QuireSize\: unsigned(31 downto 0);
    end record;
    type \Lombiq.Arithmetics.Posit\ is record 
        \IsNull\: boolean;
        \_environment\: \Lombiq.Arithmetics.PositEnvironment\;
        \PositBits\: \Lombiq.Arithmetics.BitMask\;
    end record;
    -- Custom inter-dependent type declarations end


    -- System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations start
    -- State machine states:
    type \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._States\ is (
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_1\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_2\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_3\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_6\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_7\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_8\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_9\, 
        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_10\);
    -- Signals:
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\: signed(31 downto 0) := to_signed(0, 32);
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.DataOut\: std_logic_vector(31 downto 0) := (others => '0');
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.Out.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).value.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit).left.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit).right.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit)._Started.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit)._Started.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Finished.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory().return.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.In.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Finished.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit)._Finished.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit).return.0\: \Lombiq.Arithmetics.Posit\;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit)._Finished.0\: boolean := false;
    Signal \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit).return.0\: signed(31 downto 0) := to_signed(0, 32);
    -- System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 declarations end


    -- Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory().0 declarations start
    -- State machine states:
    type \PositCalculator::EnvironmentFactory().0._States\ is (
        \PositCalculator::EnvironmentFactory().0._State_0\, 
        \PositCalculator::EnvironmentFactory().0._State_1\, 
        \PositCalculator::EnvironmentFactory().0._State_2\, 
        \PositCalculator::EnvironmentFactory().0._State_3\);
    -- Signals:
    Signal \PositCalculator::EnvironmentFactory().0._Finished\: boolean := false;
    Signal \PositCalculator::EnvironmentFactory().0.return\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.Out.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).size.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).maximumExponentSize.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\: boolean := false;
    Signal \PositCalculator::EnvironmentFactory().0._Started\: boolean := false;
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.In.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory().0 declarations end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::.ctor(UInt32,UInt16).0._States\ is (
        \BitMask::.ctor(UInt32,UInt16).0._State_0\, 
        \BitMask::.ctor(UInt32,UInt16).0._State_1\, 
        \BitMask::.ctor(UInt32,UInt16).0._State_2\, 
        \BitMask::.ctor(UInt32,UInt16).0._State_3\, 
        \BitMask::.ctor(UInt32,UInt16).0._State_4\, 
        \BitMask::.ctor(UInt32,UInt16).0._State_5\, 
        \BitMask::.ctor(UInt32,UInt16).0._State_6\);
    -- Signals:
    Signal \BitMask::.ctor(UInt32,UInt16).0._Finished\: boolean := false;
    Signal \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt32,UInt16).0._Started\: boolean := false;
    Signal \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16).0 declarations end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::.ctor(UInt32[],UInt16).0._States\ is (
        \BitMask::.ctor(UInt32[],UInt16).0._State_0\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_1\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_2\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_3\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_4\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_5\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_6\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_7\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_8\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_9\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_10\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_11\, 
        \BitMask::.ctor(UInt32[],UInt16).0._State_12\);
    -- Signals:
    Signal \BitMask::.ctor(UInt32[],UInt16).0._Finished\: boolean := false;
    Signal \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::.ctor(UInt32[],UInt16).0._Started\: boolean := false;
    Signal \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16).0 declarations end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean).0 declarations start
    -- State machine states:
    type \BitMask::.ctor(UInt16,Boolean).0._States\ is (
        \BitMask::.ctor(UInt16,Boolean).0._State_0\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_1\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_2\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_3\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_4\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_5\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_6\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_7\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_8\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_9\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_10\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_11\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_12\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_13\, 
        \BitMask::.ctor(UInt16,Boolean).0._State_14\);
    -- Signals:
    Signal \BitMask::.ctor(UInt16,Boolean).0._Finished\: boolean := false;
    Signal \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt16,Boolean).0._Started\: boolean := false;
    Signal \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\: boolean := false;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean).0 declarations end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask::.ctor(BitMask).0._States\ is (
        \BitMask::.ctor(BitMask).0._State_0\, 
        \BitMask::.ctor(BitMask).0._State_1\, 
        \BitMask::.ctor(BitMask).0._State_2\);
    -- Signals:
    Signal \BitMask::.ctor(BitMask).0._Finished\: boolean := false;
    Signal \BitMask::.ctor(BitMask).0.this.parameter.Out\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(BitMask).0.source.parameter.Out\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(BitMask).0._Started\: boolean := false;
    Signal \BitMask::.ctor(BitMask).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::.ctor(BitMask).0.source.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::FromImmutableArray(UInt32[],UInt16).0._States\ is (
        \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_0\, 
        \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_1\, 
        \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_2\, 
        \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_3\);
    -- Signals:
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\: boolean := false;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\: boolean := false;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.In\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::SetOne(UInt16).0._States\ is (
        \BitMask::SetOne(UInt16).0._State_0\, 
        \BitMask::SetOne(UInt16).0._State_1\, 
        \BitMask::SetOne(UInt16).0._State_2\, 
        \BitMask::SetOne(UInt16).0._State_3\, 
        \BitMask::SetOne(UInt16).0._State_4\, 
        \BitMask::SetOne(UInt16).0._State_5\, 
        \BitMask::SetOne(UInt16).0._State_6\, 
        \BitMask::SetOne(UInt16).0._State_7\, 
        \BitMask::SetOne(UInt16).0._State_8\, 
        \BitMask::SetOne(UInt16).0._State_9\, 
        \BitMask::SetOne(UInt16).0._State_10\, 
        \BitMask::SetOne(UInt16).0._State_11\, 
        \BitMask::SetOne(UInt16).0._State_12\, 
        \BitMask::SetOne(UInt16).0._State_13\, 
        \BitMask::SetOne(UInt16).0._State_14\);
    -- Signals:
    Signal \BitMask::SetOne(UInt16).0._Finished\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0._Started\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.index.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\: boolean := false;
    Signal \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::SetZero(UInt16).0._States\ is (
        \BitMask::SetZero(UInt16).0._State_0\, 
        \BitMask::SetZero(UInt16).0._State_1\, 
        \BitMask::SetZero(UInt16).0._State_2\, 
        \BitMask::SetZero(UInt16).0._State_3\, 
        \BitMask::SetZero(UInt16).0._State_4\, 
        \BitMask::SetZero(UInt16).0._State_5\, 
        \BitMask::SetZero(UInt16).0._State_6\, 
        \BitMask::SetZero(UInt16).0._State_7\, 
        \BitMask::SetZero(UInt16).0._State_8\, 
        \BitMask::SetZero(UInt16).0._State_9\, 
        \BitMask::SetZero(UInt16).0._State_10\, 
        \BitMask::SetZero(UInt16).0._State_11\, 
        \BitMask::SetZero(UInt16).0._State_12\, 
        \BitMask::SetZero(UInt16).0._State_13\, 
        \BitMask::SetZero(UInt16).0._State_14\);
    -- Signals:
    Signal \BitMask::SetZero(UInt16).0._Finished\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0._Started\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.index.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\: boolean := false;
    Signal \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \Boolean BitMask::op_Equality(BitMask,BitMask).0._States\ is (
        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_0\, 
        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_1\, 
        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_2\, 
        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_3\, 
        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_4\, 
        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_5\, 
        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_6\, 
        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_7\, 
        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_8\, 
        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_9\);
    -- Signals:
    Signal \Boolean BitMask::op_Equality(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \Boolean BitMask::op_Equality(BitMask,BitMask).0.return\: boolean := false;
    Signal \Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\: boolean := false;
    Signal \Boolean BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \Boolean BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \Boolean BitMask::op_LessThan(BitMask,BitMask).0._States\ is (
        \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_0\, 
        \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_1\, 
        \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_2\, 
        \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_3\, 
        \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_4\, 
        \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_5\, 
        \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_6\, 
        \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_7\);
    -- Signals:
    Signal \Boolean BitMask::op_LessThan(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \Boolean BitMask::op_LessThan(BitMask,BitMask).0.return\: boolean := false;
    Signal \Boolean BitMask::op_LessThan(BitMask,BitMask).0._Started\: boolean := false;
    Signal \Boolean BitMask::op_LessThan(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \Boolean BitMask::op_LessThan(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._States\ is (
        \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_0\, 
        \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_1\, 
        \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_2\, 
        \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_3\);
    -- Signals:
    Signal \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return\: boolean := false;
    Signal \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\: boolean := false;
    Signal \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask).return.0\: boolean := false;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0 declarations start
    -- State machine states:
    type \BitMask BitMask::op_Addition(BitMask,UInt32).0._States\ is (
        \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_0\, 
        \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_1\, 
        \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_2\, 
        \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_3\, 
        \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_4\);
    -- Signals:
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0._Finished\: boolean := false;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0._Started\: boolean := false;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.right.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0 declarations start
    -- State machine states:
    type \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._States\ is (
        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_0\, 
        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_1\, 
        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_2\, 
        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_3\, 
        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_4\);
    -- Signals:
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._Finished\: boolean := false;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._Started\: boolean := false;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.right.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask BitMask::op_Addition(BitMask,BitMask).0._States\ is (
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_0\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_1\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_2\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_3\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_4\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_5\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_6\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_7\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_8\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_9\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_10\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_11\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_12\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_13\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_14\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_15\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_16\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_17\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_18\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_19\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_20\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_21\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_22\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_23\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_24\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_25\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_26\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_27\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_28\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_29\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_30\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_31\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_32\, 
        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_33\);
    -- Signals:
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0._Started\: boolean := false;
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._States\ is (
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_0\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_1\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_2\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_3\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_4\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_5\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_6\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_7\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_8\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_9\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_10\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_11\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_12\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_13\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_14\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_15\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_16\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_17\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_18\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_19\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_20\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_21\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_22\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_23\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_24\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_25\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_26\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_27\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_28\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_29\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_30\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_31\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_32\, 
        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_33\);
    -- Signals:
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Started\: boolean := false;
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._States\ is (
        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_0\, 
        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_1\, 
        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\, 
        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_3\, 
        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_4\, 
        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_5\, 
        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\, 
        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_7\, 
        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_8\, 
        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_9\);
    -- Signals:
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\: boolean := false;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\: boolean := false;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\: boolean := false;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.right.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\: boolean := false;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \BitMask BitMask::op_OnesComplement(BitMask).0._States\ is (
        \BitMask BitMask::op_OnesComplement(BitMask).0._State_0\, 
        \BitMask BitMask::op_OnesComplement(BitMask).0._State_1\, 
        \BitMask BitMask::op_OnesComplement(BitMask).0._State_2\, 
        \BitMask BitMask::op_OnesComplement(BitMask).0._State_3\, 
        \BitMask BitMask::op_OnesComplement(BitMask).0._State_4\, 
        \BitMask BitMask::op_OnesComplement(BitMask).0._State_5\);
    -- Signals:
    Signal \BitMask BitMask::op_OnesComplement(BitMask).0._Finished\: boolean := false;
    Signal \BitMask BitMask::op_OnesComplement(BitMask).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_OnesComplement(BitMask).0._Started\: boolean := false;
    Signal \BitMask BitMask::op_OnesComplement(BitMask).0.input.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0 declarations start
    -- State machine states:
    type \BitMask BitMask::op_RightShift(BitMask,Int32).0._States\ is (
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_0\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_1\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_2\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_3\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_4\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_5\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_6\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_7\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_8\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_9\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_10\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_11\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_12\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_13\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_14\, 
        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_15\);
    -- Signals:
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0._Finished\: boolean := false;
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\: boolean := false;
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0 declarations start
    -- State machine states:
    type \BitMask BitMask::op_LeftShift(BitMask,Int32).0._States\ is (
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_0\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_1\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_2\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_3\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_4\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_5\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_6\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_7\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_8\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_9\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_10\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_11\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_12\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_13\, 
        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_14\);
    -- Signals:
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\: boolean := false;
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\: boolean := false;
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\: boolean := false;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0 declarations end


    -- System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition().0 declarations start
    -- State machine states:
    type \BitMask::GetMostSignificantOnePosition().0._States\ is (
        \BitMask::GetMostSignificantOnePosition().0._State_0\, 
        \BitMask::GetMostSignificantOnePosition().0._State_1\, 
        \BitMask::GetMostSignificantOnePosition().0._State_2\, 
        \BitMask::GetMostSignificantOnePosition().0._State_3\, 
        \BitMask::GetMostSignificantOnePosition().0._State_4\, 
        \BitMask::GetMostSignificantOnePosition().0._State_5\, 
        \BitMask::GetMostSignificantOnePosition().0._State_6\, 
        \BitMask::GetMostSignificantOnePosition().0._State_7\, 
        \BitMask::GetMostSignificantOnePosition().0._State_8\, 
        \BitMask::GetMostSignificantOnePosition().0._State_9\);
    -- Signals:
    Signal \BitMask::GetMostSignificantOnePosition().0._Finished\: boolean := false;
    Signal \BitMask::GetMostSignificantOnePosition().0.return\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::GetMostSignificantOnePosition().0._Started\: boolean := false;
    Signal \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    -- System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::GetTwosComplement(UInt16).0._States\ is (
        \BitMask::GetTwosComplement(UInt16).0._State_0\, 
        \BitMask::GetTwosComplement(UInt16).0._State_1\, 
        \BitMask::GetTwosComplement(UInt16).0._State_2\, 
        \BitMask::GetTwosComplement(UInt16).0._State_3\, 
        \BitMask::GetTwosComplement(UInt16).0._State_4\, 
        \BitMask::GetTwosComplement(UInt16).0._State_5\, 
        \BitMask::GetTwosComplement(UInt16).0._State_6\, 
        \BitMask::GetTwosComplement(UInt16).0._State_7\);
    -- Signals:
    Signal \BitMask::GetTwosComplement(UInt16).0._Finished\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask).input.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask)._Started.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0._Started\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0 declarations end


    -- System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0 declarations start
    -- State machine states:
    type \BitMask::LengthOfRunOfBits(UInt16).0._States\ is (
        \BitMask::LengthOfRunOfBits(UInt16).0._State_0\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_1\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_2\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_3\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_4\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_5\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_6\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_7\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_8\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_9\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_10\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_11\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_12\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_13\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_14\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_15\, 
        \BitMask::LengthOfRunOfBits(UInt16).0._State_16\);
    -- Signals:
    Signal \BitMask::LengthOfRunOfBits(UInt16).0._Finished\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.return\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0._Started\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits().0 declarations start
    -- State machine states:
    type \BitMask::GetLowest32Bits().0._States\ is (
        \BitMask::GetLowest32Bits().0._State_0\, 
        \BitMask::GetLowest32Bits().0._State_1\, 
        \BitMask::GetLowest32Bits().0._State_2\);
    -- Signals:
    Signal \BitMask::GetLowest32Bits().0._Finished\: boolean := false;
    Signal \BitMask::GetLowest32Bits().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \BitMask::GetLowest32Bits().0._Started\: boolean := false;
    Signal \BitMask::GetLowest32Bits().0.this.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    -- System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits().0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \Posit::.ctor(PositEnvironment,BitMask).0._States\ is (
        \Posit::.ctor(PositEnvironment,BitMask).0._State_0\, 
        \Posit::.ctor(PositEnvironment,BitMask).0._State_1\, 
        \Posit::.ctor(PositEnvironment,BitMask).0._State_2\, 
        \Posit::.ctor(PositEnvironment,BitMask).0._State_3\);
    -- Signals:
    Signal \Posit::.ctor(PositEnvironment,BitMask).0._Finished\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.Out\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0._Started\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.In\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.bits.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0 declarations start
    -- State machine states:
    type \Posit::.ctor(PositEnvironment,UInt32).0._States\ is (
        \Posit::.ctor(PositEnvironment,UInt32).0._State_0\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_1\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_2\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_3\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_4\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_5\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_6\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_7\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_8\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_9\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_10\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_11\, 
        \Posit::.ctor(PositEnvironment,UInt32).0._State_12\);
    -- Signals:
    Signal \Posit::.ctor(PositEnvironment,UInt32).0._Finished\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.Out\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0._Started\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.In\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.value.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0 declarations end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32).0 declarations start
    -- State machine states:
    type \Posit::.ctor(PositEnvironment,Int32).0._States\ is (
        \Posit::.ctor(PositEnvironment,Int32).0._State_0\, 
        \Posit::.ctor(PositEnvironment,Int32).0._State_1\, 
        \Posit::.ctor(PositEnvironment,Int32).0._State_2\, 
        \Posit::.ctor(PositEnvironment,Int32).0._State_3\);
    -- Signals:
    Signal \Posit::.ctor(PositEnvironment,Int32).0._Finished\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.Out\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.Out\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.Out.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).value.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,Int32).0._Started\: boolean := false;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.In\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.value.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.In.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.In.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Finished.0\: boolean := false;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32).0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0 declarations start
    -- State machine states:
    type \Posit::IsPositive().0._States\ is (
        \Posit::IsPositive().0._State_0\, 
        \Posit::IsPositive().0._State_1\, 
        \Posit::IsPositive().0._State_2\, 
        \Posit::IsPositive().0._State_3\, 
        \Posit::IsPositive().0._State_4\, 
        \Posit::IsPositive().0._State_5\, 
        \Posit::IsPositive().0._State_6\);
    -- Signals:
    Signal \Posit::IsPositive().0._Finished\: boolean := false;
    Signal \Posit::IsPositive().0.return\: boolean := false;
    Signal \Posit::IsPositive().0.Posit::get_SignBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\: boolean := false;
    Signal \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::IsPositive().0.Posit::get_EmptyBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\: boolean := false;
    Signal \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::IsPositive().0._Started\: boolean := false;
    Signal \Posit::IsPositive().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsPositive().0.Posit::get_SignBitMask()._Finished.0\: boolean := false;
    Signal \Posit::IsPositive().0.Posit::get_SignBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\: boolean := false;
    Signal \Posit::IsPositive().0.Posit::get_EmptyBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\: boolean := false;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0 declarations start
    -- State machine states:
    type \Posit::IsNaN().0._States\ is (
        \Posit::IsNaN().0._State_0\, 
        \Posit::IsNaN().0._State_1\, 
        \Posit::IsNaN().0._State_2\, 
        \Posit::IsNaN().0._State_3\, 
        \Posit::IsNaN().0._State_4\);
    -- Signals:
    Signal \Posit::IsNaN().0._Finished\: boolean := false;
    Signal \Posit::IsNaN().0.return\: boolean := false;
    Signal \Posit::IsNaN().0.Posit::get_NaNBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\: boolean := false;
    Signal \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::IsNaN().0._Started\: boolean := false;
    Signal \Posit::IsNaN().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsNaN().0.Posit::get_NaNBitMask()._Finished.0\: boolean := false;
    Signal \Posit::IsNaN().0.Posit::get_NaNBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\: boolean := false;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0 declarations end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsZero().0 declarations start
    -- State machine states:
    type \Posit::IsZero().0._States\ is (
        \Posit::IsZero().0._State_0\, 
        \Posit::IsZero().0._State_1\, 
        \Posit::IsZero().0._State_2\, 
        \Posit::IsZero().0._State_3\, 
        \Posit::IsZero().0._State_4\);
    -- Signals:
    Signal \Posit::IsZero().0._Finished\: boolean := false;
    Signal \Posit::IsZero().0.return\: boolean := false;
    Signal \Posit::IsZero().0.Posit::get_EmptyBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\: boolean := false;
    Signal \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::IsZero().0._Started\: boolean := false;
    Signal \Posit::IsZero().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\: boolean := false;
    Signal \Posit::IsZero().0.Posit::get_EmptyBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\: boolean := false;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsZero().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0 declarations start
    -- State machine states:
    type \Posit::EncodeRegimeBits(Int32).0._States\ is (
        \Posit::EncodeRegimeBits(Int32).0._State_0\, 
        \Posit::EncodeRegimeBits(Int32).0._State_1\, 
        \Posit::EncodeRegimeBits(Int32).0._State_2\, 
        \Posit::EncodeRegimeBits(Int32).0._State_3\, 
        \Posit::EncodeRegimeBits(Int32).0._State_4\, 
        \Posit::EncodeRegimeBits(Int32).0._State_5\, 
        \Posit::EncodeRegimeBits(Int32).0._State_6\, 
        \Posit::EncodeRegimeBits(Int32).0._State_7\, 
        \Posit::EncodeRegimeBits(Int32).0._State_8\, 
        \Posit::EncodeRegimeBits(Int32).0._State_9\, 
        \Posit::EncodeRegimeBits(Int32).0._State_10\, 
        \Posit::EncodeRegimeBits(Int32).0._State_11\, 
        \Posit::EncodeRegimeBits(Int32).0._State_12\);
    -- Signals:
    Signal \Posit::EncodeRegimeBits(Int32).0._Finished\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32).right.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32)._Started.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0._Started\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32)._Finished.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations start
    -- State machine states:
    type \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._States\ is (
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_0\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_1\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_2\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_3\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_4\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_5\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_6\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_8\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_9\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_10\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_11\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_12\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_15\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_16\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_17\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_19\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_20\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_21\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_22\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_23\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_24\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_27\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_28\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_29\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_30\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_31\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_32\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_33\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_35\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_37\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_38\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_39\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_40\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_41\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_42\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_43\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_44\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_45\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_47\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_48\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_49\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_50\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_51\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_52\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_53\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_54\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_55\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_56\, 
        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_57\);
    -- Signals:
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit.parameter.In\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits.parameter.In\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 declarations end


    -- System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0 declarations start
    -- State machine states:
    type \Posit::GetRegimeKValue().0._States\ is (
        \Posit::GetRegimeKValue().0._State_0\, 
        \Posit::GetRegimeKValue().0._State_1\, 
        \Posit::GetRegimeKValue().0._State_2\, 
        \Posit::GetRegimeKValue().0._State_3\, 
        \Posit::GetRegimeKValue().0._State_4\, 
        \Posit::GetRegimeKValue().0._State_5\, 
        \Posit::GetRegimeKValue().0._State_6\, 
        \Posit::GetRegimeKValue().0._State_7\, 
        \Posit::GetRegimeKValue().0._State_8\, 
        \Posit::GetRegimeKValue().0._State_9\, 
        \Posit::GetRegimeKValue().0._State_10\, 
        \Posit::GetRegimeKValue().0._State_11\, 
        \Posit::GetRegimeKValue().0._State_12\, 
        \Posit::GetRegimeKValue().0._State_13\, 
        \Posit::GetRegimeKValue().0._State_14\, 
        \Posit::GetRegimeKValue().0._State_15\, 
        \Posit::GetRegimeKValue().0._State_16\, 
        \Posit::GetRegimeKValue().0._State_17\);
    -- Signals:
    Signal \Posit::GetRegimeKValue().0._Finished\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::GetRegimeKValue().0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0._Started\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0 declarations start
    -- State machine states:
    type \Posit::ExponentSize().0._States\ is (
        \Posit::ExponentSize().0._State_0\, 
        \Posit::ExponentSize().0._State_1\, 
        \Posit::ExponentSize().0._State_2\, 
        \Posit::ExponentSize().0._State_3\, 
        \Posit::ExponentSize().0._State_4\, 
        \Posit::ExponentSize().0._State_5\, 
        \Posit::ExponentSize().0._State_6\, 
        \Posit::ExponentSize().0._State_7\, 
        \Posit::ExponentSize().0._State_8\, 
        \Posit::ExponentSize().0._State_9\, 
        \Posit::ExponentSize().0._State_10\, 
        \Posit::ExponentSize().0._State_11\, 
        \Posit::ExponentSize().0._State_12\, 
        \Posit::ExponentSize().0._State_13\);
    -- Signals:
    Signal \Posit::ExponentSize().0._Finished\: boolean := false;
    Signal \Posit::ExponentSize().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::ExponentSize().0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::ExponentSize().0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\: boolean := false;
    Signal \Posit::ExponentSize().0._Started\: boolean := false;
    Signal \Posit::ExponentSize().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::ExponentSize().0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0 declarations start
    -- State machine states:
    type \Posit::GetExponentValue().0._States\ is (
        \Posit::GetExponentValue().0._State_0\, 
        \Posit::GetExponentValue().0._State_1\, 
        \Posit::GetExponentValue().0._State_2\, 
        \Posit::GetExponentValue().0._State_3\, 
        \Posit::GetExponentValue().0._State_4\, 
        \Posit::GetExponentValue().0._State_5\, 
        \Posit::GetExponentValue().0._State_6\, 
        \Posit::GetExponentValue().0._State_7\, 
        \Posit::GetExponentValue().0._State_8\, 
        \Posit::GetExponentValue().0._State_9\, 
        \Posit::GetExponentValue().0._State_10\, 
        \Posit::GetExponentValue().0._State_11\, 
        \Posit::GetExponentValue().0._State_12\, 
        \Posit::GetExponentValue().0._State_13\, 
        \Posit::GetExponentValue().0._State_14\, 
        \Posit::GetExponentValue().0._State_15\, 
        \Posit::GetExponentValue().0._State_16\);
    -- Signals:
    Signal \Posit::GetExponentValue().0._Finished\: boolean := false;
    Signal \Posit::GetExponentValue().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::GetExponentValue().0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.Posit::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.Posit::ExponentSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\: boolean := false;
    Signal \Posit::GetExponentValue().0._Started\: boolean := false;
    Signal \Posit::GetExponentValue().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.Posit::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::GetExponentValue().0.Posit::ExponentSize()._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.Posit::ExponentSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\: boolean := false;
    Signal \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    -- System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0 declarations end


    -- System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0 declarations start
    -- State machine states:
    type \Posit::FractionSize().0._States\ is (
        \Posit::FractionSize().0._State_0\, 
        \Posit::FractionSize().0._State_1\, 
        \Posit::FractionSize().0._State_2\, 
        \Posit::FractionSize().0._State_3\, 
        \Posit::FractionSize().0._State_4\, 
        \Posit::FractionSize().0._State_5\, 
        \Posit::FractionSize().0._State_6\, 
        \Posit::FractionSize().0._State_7\, 
        \Posit::FractionSize().0._State_8\, 
        \Posit::FractionSize().0._State_9\, 
        \Posit::FractionSize().0._State_10\, 
        \Posit::FractionSize().0._State_11\, 
        \Posit::FractionSize().0._State_12\);
    -- Signals:
    Signal \Posit::FractionSize().0._Finished\: boolean := false;
    Signal \Posit::FractionSize().0.return\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::FractionSize().0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::FractionSize().0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\: boolean := false;
    Signal \Posit::FractionSize().0._Started\: boolean := false;
    Signal \Posit::FractionSize().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::FractionSize().0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0 declarations start
    -- State machine states:
    type \Posit::FractionWithHiddenBit().0._States\ is (
        \Posit::FractionWithHiddenBit().0._State_0\, 
        \Posit::FractionWithHiddenBit().0._State_1\, 
        \Posit::FractionWithHiddenBit().0._State_2\, 
        \Posit::FractionWithHiddenBit().0._State_3\, 
        \Posit::FractionWithHiddenBit().0._State_4\, 
        \Posit::FractionWithHiddenBit().0._State_5\, 
        \Posit::FractionWithHiddenBit().0._State_6\, 
        \Posit::FractionWithHiddenBit().0._State_7\, 
        \Posit::FractionWithHiddenBit().0._State_8\, 
        \Posit::FractionWithHiddenBit().0._State_9\, 
        \Posit::FractionWithHiddenBit().0._State_10\, 
        \Posit::FractionWithHiddenBit().0._State_11\, 
        \Posit::FractionWithHiddenBit().0._State_12\, 
        \Posit::FractionWithHiddenBit().0._State_13\, 
        \Posit::FractionWithHiddenBit().0._State_14\, 
        \Posit::FractionWithHiddenBit().0._State_15\);
    -- Signals:
    Signal \Posit::FractionWithHiddenBit().0._Finished\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.Posit::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0._Started\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.Posit::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\: boolean := false;
    Signal \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0 declarations end


    -- System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte).0 declarations start
    -- State machine states:
    type \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._States\ is (
        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_0\, 
        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_1\, 
        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_2\);
    -- Signals:
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Finished\: boolean := false;
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Started\: boolean := false;
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue.parameter.In\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue.parameter.In\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    -- System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte).0 declarations end


    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 declarations start
    -- State machine states:
    type \Posit Posit::op_Addition(Posit,Posit).0._States\ is (
        \Posit Posit::op_Addition(Posit,Posit).0._State_0\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_1\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_2\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_3\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_4\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_5\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_6\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_7\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_8\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_9\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_10\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_11\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_12\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_13\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_14\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_15\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_16\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_17\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_18\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_19\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_20\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_21\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_22\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_23\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_24\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_25\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_26\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_27\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_28\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_29\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_30\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_31\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_32\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_33\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_34\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_35\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_36\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_37\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_38\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_39\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_40\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_41\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_42\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_43\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_44\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_45\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_46\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_47\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_48\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_49\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_50\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_51\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_52\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_53\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_54\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_55\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_56\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_57\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_58\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_59\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_60\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_61\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_62\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_63\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_64\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_65\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_66\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_67\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_68\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_69\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_70\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_71\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_72\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_73\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_74\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_75\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_76\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_77\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_78\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_79\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_80\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_81\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_82\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_83\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_84\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_85\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_86\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_87\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_88\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_89\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_90\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_91\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_92\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_93\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_94\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_95\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_96\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_97\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_98\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_99\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_100\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_101\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_102\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_103\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_104\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_105\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_106\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_107\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_108\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_109\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_110\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_111\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_112\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_113\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_114\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_115\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_116\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_117\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_118\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_119\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_120\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_121\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_122\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_123\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_124\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_125\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_126\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_127\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_128\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_129\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_130\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_131\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_132\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_133\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_134\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_135\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_136\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_137\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_138\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_139\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_140\, 
        \Posit Posit::op_Addition(Posit,Posit).0._State_141\);
    -- Signals:
    Signal \Posit Posit::op_Addition(Posit,Posit).0._Finished\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.return\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit).x.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0._Started\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.left.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.right.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().return.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit).return.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 declarations end


    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 declarations start
    -- State machine states:
    type \Posit Posit::op_UnaryNegation(Posit).0._States\ is (
        \Posit Posit::op_UnaryNegation(Posit).0._State_0\, 
        \Posit Posit::op_UnaryNegation(Posit).0._State_1\, 
        \Posit Posit::op_UnaryNegation(Posit).0._State_2\, 
        \Posit Posit::op_UnaryNegation(Posit).0._State_3\, 
        \Posit Posit::op_UnaryNegation(Posit).0._State_4\, 
        \Posit Posit::op_UnaryNegation(Posit).0._State_5\, 
        \Posit Posit::op_UnaryNegation(Posit).0._State_6\, 
        \Posit Posit::op_UnaryNegation(Posit).0._State_7\, 
        \Posit Posit::op_UnaryNegation(Posit).0._State_8\, 
        \Posit Posit::op_UnaryNegation(Posit).0._State_9\, 
        \Posit Posit::op_UnaryNegation(Posit).0._State_10\);
    -- Signals:
    Signal \Posit Posit::op_UnaryNegation(Posit).0._Finished\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.return\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0._Started\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.x.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Finished.0\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().return.0\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Finished.0\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero().return.0\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\: boolean := false;
    Signal \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 declarations end


    -- System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0 declarations start
    -- State machine states:
    type \Int32 Posit::op_Explicit(Posit).0._States\ is (
        \Int32 Posit::op_Explicit(Posit).0._State_0\, 
        \Int32 Posit::op_Explicit(Posit).0._State_1\, 
        \Int32 Posit::op_Explicit(Posit).0._State_2\, 
        \Int32 Posit::op_Explicit(Posit).0._State_3\, 
        \Int32 Posit::op_Explicit(Posit).0._State_4\, 
        \Int32 Posit::op_Explicit(Posit).0._State_5\, 
        \Int32 Posit::op_Explicit(Posit).0._State_6\, 
        \Int32 Posit::op_Explicit(Posit).0._State_7\, 
        \Int32 Posit::op_Explicit(Posit).0._State_8\, 
        \Int32 Posit::op_Explicit(Posit).0._State_9\, 
        \Int32 Posit::op_Explicit(Posit).0._State_10\, 
        \Int32 Posit::op_Explicit(Posit).0._State_11\, 
        \Int32 Posit::op_Explicit(Posit).0._State_12\, 
        \Int32 Posit::op_Explicit(Posit).0._State_13\, 
        \Int32 Posit::op_Explicit(Posit).0._State_14\, 
        \Int32 Posit::op_Explicit(Posit).0._State_15\, 
        \Int32 Posit::op_Explicit(Posit).0._State_16\, 
        \Int32 Posit::op_Explicit(Posit).0._State_17\, 
        \Int32 Posit::op_Explicit(Posit).0._State_18\, 
        \Int32 Posit::op_Explicit(Posit).0._State_19\, 
        \Int32 Posit::op_Explicit(Posit).0._State_20\, 
        \Int32 Posit::op_Explicit(Posit).0._State_21\, 
        \Int32 Posit::op_Explicit(Posit).0._State_22\, 
        \Int32 Posit::op_Explicit(Posit).0._State_23\);
    -- Signals:
    Signal \Int32 Posit::op_Explicit(Posit).0._Finished\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.return\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive().this.parameter.Out.0\: \Lombiq.Arithmetics.Posit\;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0._Started\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.x.parameter.In\: \Lombiq.Arithmetics.Posit\;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().return.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().return.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\: boolean := false;
    Signal \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive().return.0\: boolean := false;
    -- System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask().0 declarations start
    -- State machine states:
    type \Posit::get_SignBitMask().0._States\ is (
        \Posit::get_SignBitMask().0._State_0\, 
        \Posit::get_SignBitMask().0._State_1\, 
        \Posit::get_SignBitMask().0._State_2\);
    -- Signals:
    Signal \Posit::get_SignBitMask().0._Finished\: boolean := false;
    Signal \Posit::get_SignBitMask().0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::get_SignBitMask().0._Started\: boolean := false;
    Signal \Posit::get_SignBitMask().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask().0 declarations start
    -- State machine states:
    type \Posit::get_FirstRegimeBitBitMask().0._States\ is (
        \Posit::get_FirstRegimeBitBitMask().0._State_0\, 
        \Posit::get_FirstRegimeBitBitMask().0._State_1\, 
        \Posit::get_FirstRegimeBitBitMask().0._State_2\);
    -- Signals:
    Signal \Posit::get_FirstRegimeBitBitMask().0._Finished\: boolean := false;
    Signal \Posit::get_FirstRegimeBitBitMask().0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::get_FirstRegimeBitBitMask().0._Started\: boolean := false;
    Signal \Posit::get_FirstRegimeBitBitMask().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask().0 declarations start
    -- State machine states:
    type \Posit::get_EmptyBitMask().0._States\ is (
        \Posit::get_EmptyBitMask().0._State_0\, 
        \Posit::get_EmptyBitMask().0._State_1\, 
        \Posit::get_EmptyBitMask().0._State_2\);
    -- Signals:
    Signal \Posit::get_EmptyBitMask().0._Finished\: boolean := false;
    Signal \Posit::get_EmptyBitMask().0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::get_EmptyBitMask().0._Started\: boolean := false;
    Signal \Posit::get_EmptyBitMask().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask().0 declarations end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask().0 declarations start
    -- State machine states:
    type \Posit::get_NaNBitMask().0._States\ is (
        \Posit::get_NaNBitMask().0._State_0\, 
        \Posit::get_NaNBitMask().0._State_1\, 
        \Posit::get_NaNBitMask().0._State_2\);
    -- Signals:
    Signal \Posit::get_NaNBitMask().0._Finished\: boolean := false;
    Signal \Posit::get_NaNBitMask().0.return\: \Lombiq.Arithmetics.BitMask\;
    Signal \Posit::get_NaNBitMask().0._Started\: boolean := false;
    Signal \Posit::get_NaNBitMask().0.this.parameter.In\: \Lombiq.Arithmetics.Posit\;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask().0 declarations end


    -- System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0 declarations start
    -- State machine states:
    type \PositEnvironment::.ctor(Byte,Byte).0._States\ is (
        \PositEnvironment::.ctor(Byte,Byte).0._State_0\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_1\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_2\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_3\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_4\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_5\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_6\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_7\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_8\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_9\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_10\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_11\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_12\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_13\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_14\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_15\, 
        \PositEnvironment::.ctor(Byte,Byte).0._State_16\);
    -- Signals:
    Signal \PositEnvironment::.ctor(Byte,Byte).0._Finished\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.Out\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).index.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\: signed(31 downto 0) := to_signed(0, 32);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0._Started\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.In\: \Lombiq.Arithmetics.PositEnvironment\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.size.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize.parameter.In\: unsigned(7 downto 0) := to_unsigned(0, 8);
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\: \Lombiq.Arithmetics.BitMask\;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\: boolean := false;
    Signal \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    -- System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0 declarations end


    -- System.Void Hast::ExternalInvocationProxy() declarations start
    -- Signals:
    Signal \FinishedInternal\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\: boolean := false;
    Signal \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Finished.0\: boolean := false;
    -- System.Void Hast::ExternalInvocationProxy() declarations end


    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations start
    type \InternalInvocationProxy_boolean_Array\ is array (integer range <>) of boolean;
    type \Hast::InternalInvocationProxy()._RunningStates\ is (
        WaitingForStarted, 
        WaitingForFinished, 
        AfterFinished);
    -- \System.Void Hast::InternalInvocationProxy()._CommonDeclarations\ declarations end

begin 

    -- System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine start
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._StateMachine\: process (\Clock\) 
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\: \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._States\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.environment\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\: \Lombiq.Arithmetics.Posit\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.right\: \Lombiq.Arithmetics.Posit\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.dataIn.0\: std_logic_vector(31 downto 0) := (others => '0');
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.0\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\: boolean := false;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.1\: \Lombiq.Arithmetics.Posit\;
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.2\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\ <= to_signed(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.DataOut\ <= (others => '0');
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).value.parameter.Out.0\ <= to_signed(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit)._Started.0\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit)._Started.0\ <= false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\ := to_unsigned(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ := to_signed(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\ := to_signed(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.dataIn.0\ := (others => '0');
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\ := false;
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\ := to_signed(0, 32);
                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.2\ := to_signed(0, 32);
            else 
                case \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ is 
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\ = true) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\ = true) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\ <= true;
                        else 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- PositEnvironment environment;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit posit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit right;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int number;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = memory.ReadUInt32 (0);
                        -- 
                        -- Begin SimpleMemory read.
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(0, 32), 32);
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ <= true;
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_3\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\ReadsDone\ = true) then 
                            -- SimpleMemory read finished.
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.dataIn.0\ := \DataIn\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\ := ConvertStdLogicVectorToUInt32(\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.dataIn.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- environment = PositCalculator.EnvironmentFactory ();
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory()
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\ <= true;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory()
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\ = \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Finished.0\) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.0\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory().return.0\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.environment\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- posit = new Posit (environment, 1);
                            -- 
                            -- Initializing record fields to their defaults.
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\.\IsNull\ := false;
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32)
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.Out.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.Out.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.environment\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).value.parameter.Out.0\ <= to_signed(1, 32);
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\ <= true;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32)
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\ = \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Finished.0\) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.In.0\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.environment\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- right = posit;
                            -- 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.right\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 1;
                            -- 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ := to_signed(1, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((long)num2 < (long)((ulong)num)) {
                            -- 	posit = Posit.op_Addition (posit, right);
                            -- 	num2 = num2 + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_6\ => 
                        -- Repeated state of the while loop which was started in state \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\.
                        -- The while loop's condition:
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\ := SmartResize(\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\, 64) < signed((SmartResize(\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num\, 64)));
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	posit = Posit.op_Addition (posit, right);
                            -- 	num2 = num2 + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- posit = Posit.op_Addition (posit, right);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit)
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit).left.parameter.Out.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit).right.parameter.Out.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.right\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit)._Started.0\ <= true;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_8\;
                        else 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.678
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_7\ => 
                        -- State after the while loop which was started in state \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- number = Posit.op_Explicit (posit);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit)
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit).x.parameter.Out.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\;
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit)._Started.0\ <= true;
                        \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit)
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit)._Started.0\ = \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit)._Finished.0\) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit)._Started.0\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.1\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit).return.0\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.posit\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = num2 + 1;
                            -- 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ + to_signed(1, 32);
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.num2\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.binaryOperationResult.1\;
                            -- Returning to the repeated state of the while loop which was started in state \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_5\ if the loop wasn't exited with a state change.
                            if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ = \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_8\) then 
                                \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit)
                        if (\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit)._Started.0\ = \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit)._Finished.0\) then 
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit)._Started.0\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.2\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit).return.0\;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- memory.WriteInt32 (0, number);
                            -- 
                            -- Begin SimpleMemory write.
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\ <= resize(to_signed(0, 32), 32);
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ <= true;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.DataOut\ <= ConvertInt32ToStdLogicVector(\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.number\);
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_10\ => 
                        -- Waiting for the SimpleMemory operation to finish.
                        if (\WritesDone\ = true) then 
                            -- SimpleMemory write finished.
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ <= false;
                            \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State\ := \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 state machine end


    -- Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory().0 state machine start
    \PositCalculator::EnvironmentFactory().0._StateMachine\: process (\Clock\) 
        Variable \PositCalculator::EnvironmentFactory().0._State\: \PositCalculator::EnvironmentFactory().0._States\ := \PositCalculator::EnvironmentFactory().0._State_0\;
        Variable \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\: \Lombiq.Arithmetics.PositEnvironment\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PositCalculator::EnvironmentFactory().0._Finished\ <= false;
                \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).size.parameter.Out.0\ <= to_unsigned(0, 8);
                \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(0, 8);
                \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\ <= false;
                \PositCalculator::EnvironmentFactory().0._State\ := \PositCalculator::EnvironmentFactory().0._State_0\;
            else 
                case \PositCalculator::EnvironmentFactory().0._State\ is 
                    when \PositCalculator::EnvironmentFactory().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PositCalculator::EnvironmentFactory().0._Started\ = true) then 
                            \PositCalculator::EnvironmentFactory().0._State\ := \PositCalculator::EnvironmentFactory().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::EnvironmentFactory().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PositCalculator::EnvironmentFactory().0._Started\ = true) then 
                            \PositCalculator::EnvironmentFactory().0._Finished\ <= true;
                        else 
                            \PositCalculator::EnvironmentFactory().0._Finished\ <= false;
                            \PositCalculator::EnvironmentFactory().0._State\ := \PositCalculator::EnvironmentFactory().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::EnvironmentFactory().0._State_2\ => 
                        -- The following section was transformed from the .NET statement below:
                        -- PositEnvironment objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30 = new PositEnvironment (32, 3);
                        -- 
                        -- Initializing record fields to their defaults.
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\IsNull\ := false;
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\MaximumExponentSize\ := to_unsigned(0, 8);
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\Size\ := to_unsigned(0, 16);
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\Useed\ := to_unsigned(0, 32);
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\FirstRegimeBitIndex\ := to_unsigned(0, 16);
                        \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\.\QuireSize\ := to_unsigned(0, 32);
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte)
                        \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.Out.0\ <= \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\;
                        \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).size.parameter.Out.0\ <= to_unsigned(32, 8);
                        \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(3, 8);
                        \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\ <= true;
                        \PositCalculator::EnvironmentFactory().0._State\ := \PositCalculator::EnvironmentFactory().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositCalculator::EnvironmentFactory().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte)
                        if (\PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\ = \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Finished.0\) then 
                            \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\ <= false;
                            \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\ := \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30;
                            -- 
                            \PositCalculator::EnvironmentFactory().0.return\ <= \PositCalculator::EnvironmentFactory().0.objectf21a700bdaa46d8d27601bb4af8551f02169863bbb09ff4e3aedf8be27b4cf30\;
                            \PositCalculator::EnvironmentFactory().0._State\ := \PositCalculator::EnvironmentFactory().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory().0 state machine end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16).0 state machine start
    \BitMask::.ctor(UInt32,UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::.ctor(UInt32,UInt16).0._State\: \BitMask::.ctor(UInt32,UInt16).0._States\ := \BitMask::.ctor(UInt32,UInt16).0._State_0\;
        Variable \BitMask::.ctor(UInt32,UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::.ctor(UInt32,UInt16).0.segment\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt32,UInt16).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::.ctor(UInt32,UInt16).0.conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.remainderOperand0C_106f0cfe161913ea34f01961f7cb28017201e950dfd79902bf144f09fc20db11ae\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.3\: boolean := false;
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.5\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::.ctor(UInt32,UInt16).0._Finished\ <= false;
                \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_0\;
                \BitMask::.ctor(UInt32,UInt16).0.segment\ := to_unsigned(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.size\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt32,UInt16).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::.ctor(UInt32,UInt16).0.conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.remainderOperand0C_106f0cfe161913ea34f01961f7cb28017201e950dfd79902bf144f09fc20db11ae\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.3\ := false;
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.4\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.5\ := to_unsigned(0, 16);
            else 
                case \BitMask::.ctor(UInt32,UInt16).0._State\ is 
                    when \BitMask::.ctor(UInt32,UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::.ctor(UInt32,UInt16).0._Started\ = true) then 
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32,UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::.ctor(UInt32,UInt16).0._Started\ = true) then 
                            \BitMask::.ctor(UInt32,UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::.ctor(UInt32,UInt16).0._Finished\ <= false;
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\ <= \BitMask::.ctor(UInt32,UInt16).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32,UInt16).0._State_2\ => 
                        \BitMask::.ctor(UInt32,UInt16).0.this\ := \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\;
                        \BitMask::.ctor(UInt32,UInt16).0.segment\ := \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\;
                        \BitMask::.ctor(UInt32,UInt16).0.size\ := \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = size;
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.this\.\Size\ := \BitMask::.ctor(UInt32,UInt16).0.size\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Int32 remainderOperand0C_106f0cfe161913ea34f01961f7cb28017201e950dfd79902bf144f09fc20db11ae;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand0C_106f0cfe161913ea34f01961f7cb28017201e950dfd79902bf144f09fc20db11ae = (Int32)(size);
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.remainderOperand0C_106f0cfe161913ea34f01961f7cb28017201e950dfd79902bf144f09fc20db11ae\ := signed(SmartResize((\BitMask::.ctor(UInt32,UInt16).0.size\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- if ((Int32)(remainderOperand0C_106f0cfe161913ea34f01961f7cb28017201e950dfd79902bf144f09fc20db11ae - remainderOperand0C_106f0cfe161913ea34f01961f7cb28017201e950dfd79902bf144f09fc20db11ae / 32 * 32) == 0) {
                        -- 	conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690 = 0;
                        -- }
                        -- else {
                        -- 	conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690 = 1;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ := \BitMask::.ctor(UInt32,UInt16).0.remainderOperand0C_106f0cfe161913ea34f01961f7cb28017201e950dfd79902bf144f09fc20db11ae\ / to_signed(32, 32);
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.1\ := SmartResize(\BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.0\ * to_signed(32, 32), 32);
                        \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.70365
                    when \BitMask::.ctor(UInt32,UInt16).0._State_3\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.2\ := \BitMask::.ctor(UInt32,UInt16).0.remainderOperand0C_106f0cfe161913ea34f01961f7cb28017201e950dfd79902bf144f09fc20db11ae\ - \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.1\;
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.3\ := (\BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.2\) = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt32,UInt16).0._State_5\ and ends in state \BitMask::.ctor(UInt32,UInt16).0._State_5\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt32,UInt16).0._State_6\ and ends in state \BitMask::.ctor(UInt32,UInt16).0._State_6\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt32,UInt16).0._State_4\.

                        if (\BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.3\) then 
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_5\;
                        else 
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.69
                    when \BitMask::.ctor(UInt32,UInt16).0._State_4\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt32,UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = (ushort)(size >> 5 + conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690);
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.4\ := signed(SmartResize(shift_right(\BitMask::.ctor(UInt32,UInt16).0.size\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.5\ := SmartResize(unsigned(\BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.4\ + \BitMask::.ctor(UInt32,UInt16).0.conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690\), 16);
                        \BitMask::.ctor(UInt32,UInt16).0.this\.\SegmentCount\ := (\BitMask::.ctor(UInt32,UInt16).0.binaryOperationResult.5\);
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- array [0] = segment;
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.array\(to_integer(to_signed(0, 32))) := \BitMask::.ctor(UInt32,UInt16).0.segment\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = array;
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.this\.\Segments\ := \BitMask::.ctor(UInt32,UInt16).0.array\;
                        \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.7038
                    when \BitMask::.ctor(UInt32,UInt16).0._State_5\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt32,UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690 = 0;
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32,UInt16).0._State_3\.
                        if (\BitMask::.ctor(UInt32,UInt16).0._State\ = \BitMask::.ctor(UInt32,UInt16).0._State_5\) then 
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32,UInt16).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt32,UInt16).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690 = 1;
                        -- 
                        \BitMask::.ctor(UInt32,UInt16).0.conditional1ee87dd7df078f81194b21c1ccd6c655877a942d64a85f8affcef8e931f36690\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32,UInt16).0._State_3\.
                        if (\BitMask::.ctor(UInt32,UInt16).0._State\ = \BitMask::.ctor(UInt32,UInt16).0._State_6\) then 
                            \BitMask::.ctor(UInt32,UInt16).0._State\ := \BitMask::.ctor(UInt32,UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16).0 state machine end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16).0 state machine start
    \BitMask::.ctor(UInt32[],UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::.ctor(UInt32[],UInt16).0._State\: \BitMask::.ctor(UInt32[],UInt16).0._States\ := \BitMask::.ctor(UInt32[],UInt16).0._State_0\;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.segments\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::.ctor(UInt32[],UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.flag\: boolean := false;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::.ctor(UInt32[],UInt16).0.conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.remainderOperand24_28bc66dd605f121f8fc4adea8d92dfc1f1780574207d3560b8726f392016ce1e49\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.4\: boolean := false;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.5\: boolean := false;
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::.ctor(UInt32[],UInt16).0._Finished\ <= false;
                \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\ <= (others => to_unsigned(0, 32));
                \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_0\;
                \BitMask::.ctor(UInt32[],UInt16).0.segments\ := (others => to_unsigned(0, 32));
                \BitMask::.ctor(UInt32[],UInt16).0.size\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt32[],UInt16).0.num\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt32[],UInt16).0.flag\ := false;
                \BitMask::.ctor(UInt32[],UInt16).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::.ctor(UInt32[],UInt16).0.conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.0\ := false;
                \BitMask::.ctor(UInt32[],UInt16).0.conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.remainderOperand24_28bc66dd605f121f8fc4adea8d92dfc1f1780574207d3560b8726f392016ce1e49\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.3\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.4\ := false;
                \BitMask::.ctor(UInt32[],UInt16).0.conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.5\ := false;
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.6\ := to_signed(0, 32);
                \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.7\ := to_unsigned(0, 16);
            else 
                case \BitMask::.ctor(UInt32[],UInt16).0._State\ is 
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._Started\ = true) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._Started\ = true) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::.ctor(UInt32[],UInt16).0._Finished\ <= false;
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\ <= \BitMask::.ctor(UInt32[],UInt16).0.this\;
                        \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_2\ => 
                        \BitMask::.ctor(UInt32[],UInt16).0.this\ := \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\;
                        \BitMask::.ctor(UInt32[],UInt16).0.segments\ := \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\;
                        \BitMask::.ctor(UInt32[],UInt16).0.size\ := \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 32;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.num\ := to_unsigned(32, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((Int32)(size) < 32) {
                        -- 	conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475 = 32;
                        -- }
                        -- else {
                        -- 	conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475 = size;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.0\ := signed(SmartResize((\BitMask::.ctor(UInt32[],UInt16).0.size\), 32)) < to_signed(32, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_4\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_4\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_5\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_5\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt32[],UInt16).0._State_3\.

                        if (\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.0\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_4\;
                        else 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.46515
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.this\.\Size\ := \BitMask::.ctor(UInt32[],UInt16).0.conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Int32 remainderOperand24_28bc66dd605f121f8fc4adea8d92dfc1f1780574207d3560b8726f392016ce1e49;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand24_28bc66dd605f121f8fc4adea8d92dfc1f1780574207d3560b8726f392016ce1e49 = (Int32)(size);
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.remainderOperand24_28bc66dd605f121f8fc4adea8d92dfc1f1780574207d3560b8726f392016ce1e49\ := signed(SmartResize((\BitMask::.ctor(UInt32[],UInt16).0.size\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- if ((Int32)(remainderOperand24_28bc66dd605f121f8fc4adea8d92dfc1f1780574207d3560b8726f392016ce1e49 - remainderOperand24_28bc66dd605f121f8fc4adea8d92dfc1f1780574207d3560b8726f392016ce1e49 / 32 * 32) == 0) {
                        -- 	conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf = 0;
                        -- }
                        -- else {
                        -- 	conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf = 1;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.1\ := \BitMask::.ctor(UInt32[],UInt16).0.remainderOperand24_28bc66dd605f121f8fc4adea8d92dfc1f1780574207d3560b8726f392016ce1e49\ / to_signed(32, 32);
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.2\ := SmartResize(\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.1\ * to_signed(32, 32), 32);
                        \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0.70365
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475 = 32;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475 = 32;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475\ := to_unsigned(32, 16);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_2\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_4\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_5\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475 = size;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475 = size;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.conditionalc433e39b520f0db2d1dd7b8626573f3d92d9a8ceb3f6bdaed23d4fa3a3037475\ := \BitMask::.ctor(UInt32[],UInt16).0.size\;
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_2\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_5\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_6\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.3\ := \BitMask::.ctor(UInt32[],UInt16).0.remainderOperand24_28bc66dd605f121f8fc4adea8d92dfc1f1780574207d3560b8726f392016ce1e49\ - \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.2\;
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.4\ := (\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.3\) = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_8\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_8\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_9\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_9\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt32[],UInt16).0._State_7\.

                        if (\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.4\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_8\;
                        else 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.69
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_7\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((Int32)(size) > 32) {
                        -- 	conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e = (ushort)(size >> 5 + conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf);
                        -- }
                        -- else {
                        -- 	conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e = 1;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.5\ := signed(SmartResize((\BitMask::.ctor(UInt32[],UInt16).0.size\), 32)) > to_signed(32, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_11\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_11\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt32[],UInt16).0._State_12\ and ends in state \BitMask::.ctor(UInt32[],UInt16).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt32[],UInt16).0._State_10\.

                        if (\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.5\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_11\;
                        else 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50535
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_8\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf = 0;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_6\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_8\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_9\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf = 1;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_6\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_9\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_10\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.this\.\SegmentCount\ := \BitMask::.ctor(UInt32[],UInt16).0.conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag = false;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.flag\ := False;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = segments;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.this\.\Segments\ := \BitMask::.ctor(UInt32[],UInt16).0.segments\;
                        \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_11\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e = (ushort)(size >> 5 + conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e = (ushort)(size >> 5 + conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf);
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.6\ := signed(SmartResize(shift_right(\BitMask::.ctor(UInt32[],UInt16).0.size\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.7\ := SmartResize(unsigned(\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.6\ + \BitMask::.ctor(UInt32[],UInt16).0.conditional1f6ba891b72744f4369dd792d11f43c5b2c9e16c9baeaf0b485728c86ecf6ccf\), 16);
                        \BitMask::.ctor(UInt32[],UInt16).0.conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e\ := (\BitMask::.ctor(UInt32[],UInt16).0.binaryOperationResult.7\);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_7\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_11\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7038
                    when \BitMask::.ctor(UInt32[],UInt16).0._State_12\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt32[],UInt16).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e = 1;
                        -- 
                        \BitMask::.ctor(UInt32[],UInt16).0.conditionalff95a4a3508918cd35b82dd70471c1f2c56a6a28cec55ee27b9ccd0d1f7d481e\ := to_unsigned(1, 16);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt32[],UInt16).0._State_7\.
                        if (\BitMask::.ctor(UInt32[],UInt16).0._State\ = \BitMask::.ctor(UInt32[],UInt16).0._State_12\) then 
                            \BitMask::.ctor(UInt32[],UInt16).0._State\ := \BitMask::.ctor(UInt32[],UInt16).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16).0 state machine end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean).0 state machine start
    \BitMask::.ctor(UInt16,Boolean).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::.ctor(UInt16,Boolean).0._State\: \BitMask::.ctor(UInt16,Boolean).0._States\ := \BitMask::.ctor(UInt16,Boolean).0._State_0\;
        Variable \BitMask::.ctor(UInt16,Boolean).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::.ctor(UInt16,Boolean).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt16,Boolean).0.allOne\: boolean := false;
        Variable \BitMask::.ctor(UInt16,Boolean).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::.ctor(UInt16,Boolean).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt16,Boolean).0.remainderOperand01_0553d73d56945ee223ffaae1b61691ae288e685748db3933fefe82db5ceeb22514\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.3\: boolean := false;
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.5\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.7\: boolean := false;
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::.ctor(UInt16,Boolean).0.conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.9\: boolean := false;
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::.ctor(UInt16,Boolean).0._Finished\ <= false;
                \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_0\;
                \BitMask::.ctor(UInt16,Boolean).0.size\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt16,Boolean).0.allOne\ := false;
                \BitMask::.ctor(UInt16,Boolean).0.num\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.array\ := (others => to_unsigned(0, 32));
                \BitMask::.ctor(UInt16,Boolean).0.num2\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt16,Boolean).0.remainderOperand01_0553d73d56945ee223ffaae1b61691ae288e685748db3933fefe82db5ceeb22514\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.0\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.3\ := false;
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.4\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.5\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.6\ := to_signed(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.7\ := false;
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.8\ := to_unsigned(0, 16);
                \BitMask::.ctor(UInt16,Boolean).0.conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615\ := to_unsigned(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.9\ := false;
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.11\ := to_unsigned(0, 32);
            else 
                case \BitMask::.ctor(UInt16,Boolean).0._State\ is 
                    when \BitMask::.ctor(UInt16,Boolean).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::.ctor(UInt16,Boolean).0._Started\ = true) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::.ctor(UInt16,Boolean).0._Started\ = true) then 
                            \BitMask::.ctor(UInt16,Boolean).0._Finished\ <= true;
                        else 
                            \BitMask::.ctor(UInt16,Boolean).0._Finished\ <= false;
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\ <= \BitMask::.ctor(UInt16,Boolean).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_2\ => 
                        \BitMask::.ctor(UInt16,Boolean).0.this\ := \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\;
                        \BitMask::.ctor(UInt16,Boolean).0.size\ := \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\;
                        \BitMask::.ctor(UInt16,Boolean).0.allOne\ := \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Int32 remainderOperand01_0553d73d56945ee223ffaae1b61691ae288e685748db3933fefe82db5ceeb22514;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand01_0553d73d56945ee223ffaae1b61691ae288e685748db3933fefe82db5ceeb22514 = (Int32)(size);
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.remainderOperand01_0553d73d56945ee223ffaae1b61691ae288e685748db3933fefe82db5ceeb22514\ := signed(SmartResize((\BitMask::.ctor(UInt16,Boolean).0.size\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(remainderOperand01_0553d73d56945ee223ffaae1b61691ae288e685748db3933fefe82db5ceeb22514 - remainderOperand01_0553d73d56945ee223ffaae1b61691ae288e685748db3933fefe82db5ceeb22514 / 32 * 32);
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.0\ := \BitMask::.ctor(UInt16,Boolean).0.remainderOperand01_0553d73d56945ee223ffaae1b61691ae288e685748db3933fefe82db5ceeb22514\ / to_signed(32, 32);
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.1\ := SmartResize(\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.0\ * to_signed(32, 32), 32);
                        \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.70365
                    when \BitMask::.ctor(UInt16,Boolean).0._State_3\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.2\ := \BitMask::.ctor(UInt16,Boolean).0.remainderOperand01_0553d73d56945ee223ffaae1b61691ae288e685748db3933fefe82db5ceeb22514\ - \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.1\;
                        \BitMask::.ctor(UInt16,Boolean).0.num\ := (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.2\);
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num == 0) {
                        -- 	conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 0;
                        -- }
                        -- else {
                        -- 	conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 1;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.3\ := \BitMask::.ctor(UInt16,Boolean).0.num\ = to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt16,Boolean).0._State_5\ and ends in state \BitMask::.ctor(UInt16,Boolean).0._State_5\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt16,Boolean).0._State_6\ and ends in state \BitMask::.ctor(UInt16,Boolean).0._State_6\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt16,Boolean).0._State_4\.

                        if (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.3\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_5\;
                        else 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.69
                    when \BitMask::.ctor(UInt16,Boolean).0._State_4\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = (ushort)(size >> 5 + conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e);
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.4\ := signed(SmartResize(shift_right(\BitMask::.ctor(UInt16,Boolean).0.size\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.5\ := SmartResize(unsigned(\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.4\ + \BitMask::.ctor(UInt16,Boolean).0.conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e\), 16);
                        \BitMask::.ctor(UInt16,Boolean).0.this\.\SegmentCount\ := (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.5\);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = size;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.this\.\Size\ := \BitMask::.ctor(UInt16,Boolean).0.size\;
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- if (allOne) {
                        -- 	num2 = 0;
                        -- 	while ((Int32)(num2) < (Int32)((Int32)(@this.SegmentCount) - 1)) {
                        -- 		array [(int)num2] = 4294967295u;
                        -- 		num2 = (UInt16)((Int32)(num2) + 1);
                        -- 	}
                        -- 	uint conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- 	if (num > 0) {
                        -- 		conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 1u << num - 1u;
                        -- 	}
                        -- 	else {
                        -- 		conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 4294967295u;
                        -- 	}
                        -- 	array [(int)num2] = conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt16,Boolean).0._State_8\ and ends in state \BitMask::.ctor(UInt16,Boolean).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt16,Boolean).0._State_7\.

                        if (\BitMask::.ctor(UInt16,Boolean).0.allOne\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_8\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7038
                    when \BitMask::.ctor(UInt16,Boolean).0._State_5\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt16,Boolean).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 0;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_3\.
                        if (\BitMask::.ctor(UInt16,Boolean).0._State\ = \BitMask::.ctor(UInt16,Boolean).0._State_5\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt16,Boolean).0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e = 1;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.conditional6e1dfe44d3de058b787ef0ca4cc13dff4508968539f2f7321f43d75acf95902e\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_3\.
                        if (\BitMask::.ctor(UInt16,Boolean).0._State\ = \BitMask::.ctor(UInt16,Boolean).0._State_6\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_7\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = array;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.this\.\Segments\ := \BitMask::.ctor(UInt16,Boolean).0.array\;
                        \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_8\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt16,Boolean).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = 0;
                        -- 	while ((Int32)(num2) < (Int32)((Int32)(@this.SegmentCount) - 1)) {
                        -- 		array [(int)num2] = 4294967295u;
                        -- 		num2 = (UInt16)((Int32)(num2) + 1);
                        -- 	}
                        -- 	uint conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- 	if (num > 0) {
                        -- 		conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 1u << num - 1u;
                        -- 	}
                        -- 	else {
                        -- 		conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 4294967295u;
                        -- 	}
                        -- 	array [(int)num2] = conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((Int32)(num2) < (Int32)((Int32)(@this.SegmentCount) - 1)) {
                        -- 	array [(int)num2] = 4294967295u;
                        -- 	num2 = (UInt16)((Int32)(num2) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_8\.
                        -- The while loop's condition:
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.6\ := signed(SmartResize((\BitMask::.ctor(UInt16,Boolean).0.this\.\SegmentCount\), 32)) - to_signed(1, 32);
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.7\ := signed(SmartResize((\BitMask::.ctor(UInt16,Boolean).0.num2\), 32)) < (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.6\);
                        if (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.7\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	array [(int)num2] = 4294967295u;
                            -- 	num2 = (UInt16)((Int32)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array [(int)num2] = 4294967295u;
                            -- 
                            -- Since the integer literal 4294967295 was out of the VHDL integer range it was substituted with a binary literal (11111111111111111111111111111111).
                            \BitMask::.ctor(UInt16,Boolean).0.array\(to_integer(signed(SmartResize(\BitMask::.ctor(UInt16,Boolean).0.num2\, 32)))) := "11111111111111111111111111111111";
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (UInt16)((Int32)(num2) + 1);
                            -- 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_11\;
                        else 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.82155
                    when \BitMask::.ctor(UInt16,Boolean).0._State_10\ => 
                        -- State after the while loop which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- uint conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 0) {
                        -- 	conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 1u << num - 1u;
                        -- }
                        -- else {
                        -- 	conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 4294967295u;
                        -- }
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.9\ := \BitMask::.ctor(UInt16,Boolean).0.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::.ctor(UInt16,Boolean).0._State_13\ and ends in state \BitMask::.ctor(UInt16,Boolean).0._State_13\.
                        --     * The false branch starts in state \BitMask::.ctor(UInt16,Boolean).0._State_14\ and ends in state \BitMask::.ctor(UInt16,Boolean).0._State_14\.
                        --     * Execution after either branch will continue in the following state: \BitMask::.ctor(UInt16,Boolean).0._State_12\.

                        if (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.9\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_13\;
                        else 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50535
                    when \BitMask::.ctor(UInt16,Boolean).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.8\ := SmartResize(unsigned(signed(SmartResize((\BitMask::.ctor(UInt16,Boolean).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::.ctor(UInt16,Boolean).0.num2\ := (\BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.8\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_8\ if the loop wasn't exited with a state change.
                        if (\BitMask::.ctor(UInt16,Boolean).0._State\ = \BitMask::.ctor(UInt16,Boolean).0._State_11\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \BitMask::.ctor(UInt16,Boolean).0._State_12\ => 
                        -- State after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num2] = conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.array\(to_integer(signed(SmartResize(\BitMask::.ctor(UInt16,Boolean).0.num2\, 32)))) := \BitMask::.ctor(UInt16,Boolean).0.conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615\;
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_4\.
                        if (\BitMask::.ctor(UInt16,Boolean).0._State\ = \BitMask::.ctor(UInt16,Boolean).0._State_12\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(UInt16,Boolean).0._State_13\ => 
                        -- True branch of the if-else started in state \BitMask::.ctor(UInt16,Boolean).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 1u << num - 1u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 1u << num - 1u;
                        -- 
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.10\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(\BitMask::.ctor(UInt16,Boolean).0.num\, 5))));
                        \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.11\ := \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.10\ - to_unsigned(1, 32);
                        \BitMask::.ctor(UInt16,Boolean).0.conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615\ := \BitMask::.ctor(UInt16,Boolean).0.binaryOperationResult.11\;
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_10\.
                        if (\BitMask::.ctor(UInt16,Boolean).0._State\ = \BitMask::.ctor(UInt16,Boolean).0._State_13\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7953
                    when \BitMask::.ctor(UInt16,Boolean).0._State_14\ => 
                        -- False branch of the if-else started in state \BitMask::.ctor(UInt16,Boolean).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 4294967295u;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615 = 4294967295u;
                        -- 
                        -- Since the integer literal 4294967295 was out of the VHDL integer range it was substituted with a binary literal (11111111111111111111111111111111).
                        \BitMask::.ctor(UInt16,Boolean).0.conditionalc0dd530537c97ea13354777682f6c1061719cefbe0b297b02e52790a9470b615\ := "11111111111111111111111111111111";
                        -- Going to the state after the if-else which was started in state \BitMask::.ctor(UInt16,Boolean).0._State_10\.
                        if (\BitMask::.ctor(UInt16,Boolean).0._State\ = \BitMask::.ctor(UInt16,Boolean).0._State_14\) then 
                            \BitMask::.ctor(UInt16,Boolean).0._State\ := \BitMask::.ctor(UInt16,Boolean).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean).0 state machine end


    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask::.ctor(BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::.ctor(BitMask).0._State\: \BitMask::.ctor(BitMask).0._States\ := \BitMask::.ctor(BitMask).0._State_0\;
        Variable \BitMask::.ctor(BitMask).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::.ctor(BitMask).0.source\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::.ctor(BitMask).0._Finished\ <= false;
                \BitMask::.ctor(BitMask).0._State\ := \BitMask::.ctor(BitMask).0._State_0\;
            else 
                case \BitMask::.ctor(BitMask).0._State\ is 
                    when \BitMask::.ctor(BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::.ctor(BitMask).0._Started\ = true) then 
                            \BitMask::.ctor(BitMask).0._State\ := \BitMask::.ctor(BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::.ctor(BitMask).0._Started\ = true) then 
                            \BitMask::.ctor(BitMask).0._Finished\ <= true;
                        else 
                            \BitMask::.ctor(BitMask).0._Finished\ <= false;
                            \BitMask::.ctor(BitMask).0._State\ := \BitMask::.ctor(BitMask).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \BitMask::.ctor(BitMask).0.this.parameter.Out\ <= \BitMask::.ctor(BitMask).0.this\;
                        \BitMask::.ctor(BitMask).0.source.parameter.Out\ <= \BitMask::.ctor(BitMask).0.source\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::.ctor(BitMask).0._State_2\ => 
                        \BitMask::.ctor(BitMask).0.this\ := \BitMask::.ctor(BitMask).0.this.parameter.In\;
                        \BitMask::.ctor(BitMask).0.source\ := \BitMask::.ctor(BitMask).0.source.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = 32;
                        -- 
                        \BitMask::.ctor(BitMask).0.this\.\Size\ := to_unsigned(32, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.SegmentCount = 1;
                        -- 
                        \BitMask::.ctor(BitMask).0.this\.\SegmentCount\ := to_unsigned(1, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Segments = source.Segments;
                        -- 
                        \BitMask::.ctor(BitMask).0.this\.\Segments\ := \BitMask::.ctor(BitMask).0.source\.\Segments\;
                        \BitMask::.ctor(BitMask).0._State\ := \BitMask::.ctor(BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16).0 state machine start
    \BitMask::FromImmutableArray(UInt32[],UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\: \BitMask::FromImmutableArray(UInt32[],UInt16).0._States\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_0\;
        Variable \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::FromImmutableArray(UInt32[],UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\ <= false;
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\ <= (others => to_unsigned(0, 32));
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_0\;
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments\ := (others => to_unsigned(0, 32));
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.size\ := to_unsigned(0, 16);
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\ := (others => to_unsigned(0, 32));
            else 
                case \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ is 
                    when \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ = true) then 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ = true) then 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\ <= false;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_2\ => 
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.In\;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.size\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- System.Array.Copy (segments, array, 1);
                        -- 
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments\(0 to 0);
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b = new BitMask (array, size);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\.\IsNull\ := false;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\.\Size\ := to_unsigned(0, 16);
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.size\;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.array\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b;
                            -- 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.return\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.objectd9dc79cc4b1d8d3c5c266c285dc3acb6d977503b4d121e053afe008efceebf9b\;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._State\ := \BitMask::FromImmutableArray(UInt32[],UInt16).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0 state machine start
    \BitMask::SetOne(UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::SetOne(UInt16).0._State\: \BitMask::SetOne(UInt16).0._States\ := \BitMask::SetOne(UInt16).0._State_0\;
        Variable \BitMask::SetOne(UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::SetOne(UInt16).0.index\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::SetOne(UInt16).0.flag\: boolean := false;
        Variable \BitMask::SetOne(UInt16).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::SetOne(UInt16).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.index2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.flag2\: boolean := false;
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::SetOne(UInt16).0.remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetOne(UInt16).0.remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.9\: boolean := false;
        Variable \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.binaryOperationResult.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetOne(UInt16).0.return.0\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::SetOne(UInt16).0._Finished\ <= false;
                \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_0\;
                \BitMask::SetOne(UInt16).0.index\ := to_unsigned(0, 16);
                \BitMask::SetOne(UInt16).0.flag\ := false;
                \BitMask::SetOne(UInt16).0.num\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.index2\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.flag2\ := false;
                \BitMask::SetOne(UInt16).0.binaryOperationResult.0\ := false;
                \BitMask::SetOne(UInt16).0.remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.3\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.4\ := to_signed(0, 32);
                \BitMask::SetOne(UInt16).0.remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.9\ := false;
                \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\ := (others => to_unsigned(0, 32));
                \BitMask::SetOne(UInt16).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \BitMask::SetOne(UInt16).0.binaryOperationResult.11\ := to_unsigned(0, 32);
            else 
                case \BitMask::SetOne(UInt16).0._State\ is 
                    when \BitMask::SetOne(UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::SetOne(UInt16).0._Started\ = true) then 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::SetOne(UInt16).0._Started\ = true) then 
                            \BitMask::SetOne(UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::SetOne(UInt16).0._Finished\ <= false;
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_2\ => 
                        \BitMask::SetOne(UInt16).0.this\ := \BitMask::SetOne(UInt16).0.this.parameter.In\;
                        \BitMask::SetOne(UInt16).0.index\ := \BitMask::SetOne(UInt16).0.index.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int index2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (Int32)(index) > 32;
                        -- 
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.0\ := signed(SmartResize((\BitMask::SetOne(UInt16).0.index\), 32)) > to_signed(32, 32);
                        \BitMask::SetOne(UInt16).0.flag\ := \BitMask::SetOne(UInt16).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- else {
                        -- 	Int32 remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e;
                        -- 	remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e = (Int32)(index);
                        -- 	num = (int)(remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e - remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e / 32 * 32);
                        -- 	index2 = index >> 5;
                        -- 	UInt32 remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935;
                        -- 	remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 = @this.Segments [index2] >> num;
                        -- 	flag2 = remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 - remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 / 2u * 2u == 0u;
                        -- 	if (flag2) {
                        -- 		uint[] array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444;
                        -- 		array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 = new uint[1];
                        -- 		System.Array.Copy (@this.Segments, array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 1);
                        -- 		array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 [index2] = @this.Segments [index2] | 1u << num;
                        -- 		result = BitMask.FromImmutableArray (array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 32);
                        -- 	}
                        -- 	else {
                        -- 		result = new BitMask (@this);
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::SetOne(UInt16).0._State_4\ and ends in state \BitMask::SetOne(UInt16).0._State_5\.
                        --     * The false branch starts in state \BitMask::SetOne(UInt16).0._State_6\ and ends in state \BitMask::SetOne(UInt16).0._State_10\.
                        --     * Execution after either branch will continue in the following state: \BitMask::SetOne(UInt16).0._State_3\.

                        if (\BitMask::SetOne(UInt16).0.flag\) then 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_4\;
                        else 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50535
                    when \BitMask::SetOne(UInt16).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::SetOne(UInt16).0.return\ <= \BitMask::SetOne(UInt16).0.result\;
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::SetOne(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::SetOne(UInt16).0.result\.\IsNull\ := false;
                        \BitMask::SetOne(UInt16).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::SetOne(UInt16).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::SetOne(UInt16).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::SetOne(UInt16).0.result\;
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::SetOne(UInt16).0.this\;
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::SetOne(UInt16).0.result\ := \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::SetOne(UInt16).0.this\ := \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_2\.
                            if (\BitMask::SetOne(UInt16).0._State\ = \BitMask::SetOne(UInt16).0._State_5\) then 
                                \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask::SetOne(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	Int32 remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e;
                        -- 	remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e = (Int32)(index);
                        -- 	num = (int)(remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e - remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e / 32 * 32);
                        -- 	index2 = index >> 5;
                        -- 	UInt32 remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935;
                        -- 	remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 = @this.Segments [index2] >> num;
                        -- 	flag2 = remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 - remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 / 2u * 2u == 0u;
                        -- 	if (flag2) {
                        -- 		uint[] array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444;
                        -- 		array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 = new uint[1];
                        -- 		System.Array.Copy (@this.Segments, array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 1);
                        -- 		array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 [index2] = @this.Segments [index2] | 1u << num;
                        -- 		result = BitMask.FromImmutableArray (array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 32);
                        -- 	}
                        -- 	else {
                        -- 		result = new BitMask (@this);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Int32 remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e = (Int32)(index);
                        -- 
                        \BitMask::SetOne(UInt16).0.remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e\ := signed(SmartResize((\BitMask::SetOne(UInt16).0.index\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e - remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e / 32 * 32);
                        -- 
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.1\ := \BitMask::SetOne(UInt16).0.remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e\ / to_signed(32, 32);
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.2\ := SmartResize(\BitMask::SetOne(UInt16).0.binaryOperationResult.1\ * to_signed(32, 32), 32);
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.70365
                    when \BitMask::SetOne(UInt16).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.3\ := \BitMask::SetOne(UInt16).0.remainderOperand1F_2393f2ee9ffcb9603c4d7c294c8d72cc0167a16107e76dd135112973358d80823e\ - \BitMask::SetOne(UInt16).0.binaryOperationResult.2\;
                        \BitMask::SetOne(UInt16).0.num\ := (\BitMask::SetOne(UInt16).0.binaryOperationResult.3\);
                        -- The following section was transformed from the .NET statement below:
                        -- index2 = index >> 5;
                        -- 
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.4\ := signed(SmartResize(shift_right(\BitMask::SetOne(UInt16).0.index\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::SetOne(UInt16).0.index2\ := \BitMask::SetOne(UInt16).0.binaryOperationResult.4\;
                        -- The following section was transformed from the .NET statement below:
                        -- UInt32 remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 = @this.Segments [index2] >> num;
                        -- 
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.6621
                    when \BitMask::SetOne(UInt16).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.5\ := shift_right(\BitMask::SetOne(UInt16).0.this\.\Segments\(to_integer(\BitMask::SetOne(UInt16).0.index2\)), to_integer(unsigned(SmartResize(unsigned(\BitMask::SetOne(UInt16).0.num\), 5) and "11111")));
                        \BitMask::SetOne(UInt16).0.remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935\ := \BitMask::SetOne(UInt16).0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 - remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935 / 2u * 2u == 0u;
                        -- 
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.6\ := \BitMask::SetOne(UInt16).0.remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935\ / to_unsigned(2, 32);
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.7\ := SmartResize(\BitMask::SetOne(UInt16).0.binaryOperationResult.6\ * to_unsigned(2, 32), 32);
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0.9321
                    when \BitMask::SetOne(UInt16).0._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.8\ := \BitMask::SetOne(UInt16).0.remainderOperand28_3D735946f4cebab4707eea183543d6ee8faf59ac5efeca4554cdf77edad344f935\ - \BitMask::SetOne(UInt16).0.binaryOperationResult.7\;
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.9\ := \BitMask::SetOne(UInt16).0.binaryOperationResult.8\ = to_unsigned(0, 32);
                        \BitMask::SetOne(UInt16).0.flag2\ := \BitMask::SetOne(UInt16).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	uint[] array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444;
                        -- 	array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 = new uint[1];
                        -- 	System.Array.Copy (@this.Segments, array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 1);
                        -- 	array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 [index2] = @this.Segments [index2] | 1u << num;
                        -- 	result = BitMask.FromImmutableArray (array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 32);
                        -- }
                        -- else {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::SetOne(UInt16).0._State_11\ and ends in state \BitMask::SetOne(UInt16).0._State_12\.
                        --     * The false branch starts in state \BitMask::SetOne(UInt16).0._State_13\ and ends in state \BitMask::SetOne(UInt16).0._State_14\.
                        --     * Execution after either branch will continue in the following state: \BitMask::SetOne(UInt16).0._State_10\.

                        if (\BitMask::SetOne(UInt16).0.flag2\) then 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_11\;
                        else 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.69
                    when \BitMask::SetOne(UInt16).0._State_10\ => 
                        -- State after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_9\.
                        -- Going to the state after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_2\.
                        if (\BitMask::SetOne(UInt16).0._State\ = \BitMask::SetOne(UInt16).0._State_10\) then 
                            \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_11\ => 
                        -- True branch of the if-else started in state \BitMask::SetOne(UInt16).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint[] array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444;
                        -- 	array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 = new uint[1];
                        -- 	System.Array.Copy (@this.Segments, array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 1);
                        -- 	array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 [index2] = @this.Segments [index2] | 1u << num;
                        -- 	result = BitMask.FromImmutableArray (array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 = new uint[1];
                        -- 
                        \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- System.Array.Copy (@this.Segments, array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 1);
                        -- 
                        \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\ := \BitMask::SetOne(UInt16).0.this\.\Segments\(0 to 0);
                        -- The following section was transformed from the .NET statement below:
                        -- array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444 [index2] = @this.Segments [index2] | 1u << num;
                        -- 
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.10\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(\BitMask::SetOne(UInt16).0.num\, 5))));
                        \BitMask::SetOne(UInt16).0.binaryOperationResult.11\ := \BitMask::SetOne(UInt16).0.this\.\Segments\(to_integer(\BitMask::SetOne(UInt16).0.index2\)) or \BitMask::SetOne(UInt16).0.binaryOperationResult.10\;
                        \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\(to_integer(\BitMask::SetOne(UInt16).0.index2\)) := \BitMask::SetOne(UInt16).0.binaryOperationResult.11\;
                        -- The following section was transformed from the .NET statement below:
                        -- result = BitMask.FromImmutableArray (array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\;
                        \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.5685
                    when \BitMask::SetOne(UInt16).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        if (\BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::SetOne(UInt16).0.return.0\ := \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\;
                            \BitMask::SetOne(UInt16).0.array9e0317effd8288974e328b08f13f07a4fd89d449b45bdb7f91e465cca6224444\ := \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\;
                            \BitMask::SetOne(UInt16).0.result\ := \BitMask::SetOne(UInt16).0.return.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_9\.
                            if (\BitMask::SetOne(UInt16).0._State\ = \BitMask::SetOne(UInt16).0._State_12\) then 
                                \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_13\ => 
                        -- False branch of the if-else started in state \BitMask::SetOne(UInt16).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::SetOne(UInt16).0.result\.\IsNull\ := false;
                        \BitMask::SetOne(UInt16).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::SetOne(UInt16).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::SetOne(UInt16).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::SetOne(UInt16).0.result\;
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::SetOne(UInt16).0.this\;
                        \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetOne(UInt16).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::SetOne(UInt16).0.result\ := \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::SetOne(UInt16).0.this\ := \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetOne(UInt16).0._State_9\.
                            if (\BitMask::SetOne(UInt16).0._State\ = \BitMask::SetOne(UInt16).0._State_14\) then 
                                \BitMask::SetOne(UInt16).0._State\ := \BitMask::SetOne(UInt16).0._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0 state machine start
    \BitMask::SetZero(UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::SetZero(UInt16).0._State\: \BitMask::SetZero(UInt16).0._States\ := \BitMask::SetZero(UInt16).0._State_0\;
        Variable \BitMask::SetZero(UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::SetZero(UInt16).0.index\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::SetZero(UInt16).0.flag\: boolean := false;
        Variable \BitMask::SetZero(UInt16).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::SetZero(UInt16).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.index2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.flag2\: boolean := false;
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask::SetZero(UInt16).0.remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::SetZero(UInt16).0.remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.10\: boolean := false;
        Variable \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.unaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.binaryOperationResult.12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::SetZero(UInt16).0.return.0\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::SetZero(UInt16).0._Finished\ <= false;
                \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_0\;
                \BitMask::SetZero(UInt16).0.index\ := to_unsigned(0, 16);
                \BitMask::SetZero(UInt16).0.flag\ := false;
                \BitMask::SetZero(UInt16).0.num\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.index2\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.flag2\ := false;
                \BitMask::SetZero(UInt16).0.binaryOperationResult.0\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.1\ := false;
                \BitMask::SetZero(UInt16).0.remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.3\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.4\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.5\ := to_signed(0, 32);
                \BitMask::SetZero(UInt16).0.remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.9\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.10\ := false;
                \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\ := (others => to_unsigned(0, 32));
                \BitMask::SetZero(UInt16).0.binaryOperationResult.11\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.unaryOperationResult.0\ := to_unsigned(0, 32);
                \BitMask::SetZero(UInt16).0.binaryOperationResult.12\ := to_unsigned(0, 32);
            else 
                case \BitMask::SetZero(UInt16).0._State\ is 
                    when \BitMask::SetZero(UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::SetZero(UInt16).0._Started\ = true) then 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::SetZero(UInt16).0._Started\ = true) then 
                            \BitMask::SetZero(UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::SetZero(UInt16).0._Finished\ <= false;
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_2\ => 
                        \BitMask::SetZero(UInt16).0.this\ := \BitMask::SetZero(UInt16).0.this.parameter.In\;
                        \BitMask::SetZero(UInt16).0.index\ := \BitMask::SetZero(UInt16).0.index.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int index2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (Int32)(index) > (Int32)((Int32)(@this.SegmentCount) * 32);
                        -- 
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\BitMask::SetZero(UInt16).0.this\.\SegmentCount\), 32)) * to_signed(32, 32), 32);
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.1\ := signed(SmartResize((\BitMask::SetZero(UInt16).0.index\), 32)) > (\BitMask::SetZero(UInt16).0.binaryOperationResult.0\);
                        \BitMask::SetZero(UInt16).0.flag\ := \BitMask::SetZero(UInt16).0.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- else {
                        -- 	Int32 remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf;
                        -- 	remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf = (Int32)(index);
                        -- 	num = (int)(remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf - remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf / 32 * 32);
                        -- 	index2 = index >> 5;
                        -- 	UInt32 remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a;
                        -- 	remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a = @this.Segments [index2] >> num;
                        -- 	flag2 = remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a - remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a / 2u * 2u == 1u;
                        -- 	if (flag2) {
                        -- 		uint[] array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b;
                        -- 		array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b = new uint[1];
                        -- 		System.Array.Copy (@this.Segments, array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, 1);
                        -- 		array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b [index2] = @this.Segments [index2] & ~1u << num;
                        -- 		result = BitMask.FromImmutableArray (array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, @this.Size);
                        -- 	}
                        -- 	else {
                        -- 		result = new BitMask (@this);
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::SetZero(UInt16).0._State_4\ and ends in state \BitMask::SetZero(UInt16).0._State_5\.
                        --     * The false branch starts in state \BitMask::SetZero(UInt16).0._State_6\ and ends in state \BitMask::SetZero(UInt16).0._State_10\.
                        --     * Execution after either branch will continue in the following state: \BitMask::SetZero(UInt16).0._State_3\.

                        if (\BitMask::SetZero(UInt16).0.flag\) then 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_4\;
                        else 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.6501
                    when \BitMask::SetZero(UInt16).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::SetZero(UInt16).0.return\ <= \BitMask::SetZero(UInt16).0.result\;
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask::SetZero(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::SetZero(UInt16).0.result\.\IsNull\ := false;
                        \BitMask::SetZero(UInt16).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::SetZero(UInt16).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::SetZero(UInt16).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.result\;
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.this\;
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::SetZero(UInt16).0.result\ := \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::SetZero(UInt16).0.this\ := \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_2\.
                            if (\BitMask::SetZero(UInt16).0._State\ = \BitMask::SetZero(UInt16).0._State_5\) then 
                                \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask::SetZero(UInt16).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	Int32 remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf;
                        -- 	remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf = (Int32)(index);
                        -- 	num = (int)(remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf - remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf / 32 * 32);
                        -- 	index2 = index >> 5;
                        -- 	UInt32 remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a;
                        -- 	remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a = @this.Segments [index2] >> num;
                        -- 	flag2 = remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a - remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a / 2u * 2u == 1u;
                        -- 	if (flag2) {
                        -- 		uint[] array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b;
                        -- 		array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b = new uint[1];
                        -- 		System.Array.Copy (@this.Segments, array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, 1);
                        -- 		array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b [index2] = @this.Segments [index2] & ~1u << num;
                        -- 		result = BitMask.FromImmutableArray (array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, @this.Size);
                        -- 	}
                        -- 	else {
                        -- 		result = new BitMask (@this);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Int32 remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf = (Int32)(index);
                        -- 
                        \BitMask::SetZero(UInt16).0.remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf\ := signed(SmartResize((\BitMask::SetZero(UInt16).0.index\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf - remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf / 32 * 32);
                        -- 
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.2\ := \BitMask::SetZero(UInt16).0.remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf\ / to_signed(32, 32);
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.3\ := SmartResize(\BitMask::SetZero(UInt16).0.binaryOperationResult.2\ * to_signed(32, 32), 32);
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.70365
                    when \BitMask::SetZero(UInt16).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.4\ := \BitMask::SetZero(UInt16).0.remainderOperand1F_23ea0f6031aa6fb2f4399db32ce95780d13595a51c5db9c394280420cdaea8beaf\ - \BitMask::SetZero(UInt16).0.binaryOperationResult.3\;
                        \BitMask::SetZero(UInt16).0.num\ := (\BitMask::SetZero(UInt16).0.binaryOperationResult.4\);
                        -- The following section was transformed from the .NET statement below:
                        -- index2 = index >> 5;
                        -- 
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.5\ := signed(SmartResize(shift_right(\BitMask::SetZero(UInt16).0.index\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask::SetZero(UInt16).0.index2\ := \BitMask::SetZero(UInt16).0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- UInt32 remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a = @this.Segments [index2] >> num;
                        -- 
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.6621
                    when \BitMask::SetZero(UInt16).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.6\ := shift_right(\BitMask::SetZero(UInt16).0.this\.\Segments\(to_integer(\BitMask::SetZero(UInt16).0.index2\)), to_integer(unsigned(SmartResize(unsigned(\BitMask::SetZero(UInt16).0.num\), 5) and "11111")));
                        \BitMask::SetZero(UInt16).0.remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a\ := \BitMask::SetZero(UInt16).0.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a - remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a / 2u * 2u == 1u;
                        -- 
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.7\ := \BitMask::SetZero(UInt16).0.remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a\ / to_unsigned(2, 32);
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.8\ := SmartResize(\BitMask::SetZero(UInt16).0.binaryOperationResult.7\ * to_unsigned(2, 32), 32);
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0.9321
                    when \BitMask::SetZero(UInt16).0._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.9\ := \BitMask::SetZero(UInt16).0.remainderOperand28_3Db861d7483cbb75c815e1e3afc37590e5ae4ec14606be73066529950fe23ce53a\ - \BitMask::SetZero(UInt16).0.binaryOperationResult.8\;
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.10\ := \BitMask::SetZero(UInt16).0.binaryOperationResult.9\ = to_unsigned(1, 32);
                        \BitMask::SetZero(UInt16).0.flag2\ := \BitMask::SetZero(UInt16).0.binaryOperationResult.10\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	uint[] array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b;
                        -- 	array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b = new uint[1];
                        -- 	System.Array.Copy (@this.Segments, array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, 1);
                        -- 	array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b [index2] = @this.Segments [index2] & ~1u << num;
                        -- 	result = BitMask.FromImmutableArray (array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, @this.Size);
                        -- }
                        -- else {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::SetZero(UInt16).0._State_11\ and ends in state \BitMask::SetZero(UInt16).0._State_12\.
                        --     * The false branch starts in state \BitMask::SetZero(UInt16).0._State_13\ and ends in state \BitMask::SetZero(UInt16).0._State_14\.
                        --     * Execution after either branch will continue in the following state: \BitMask::SetZero(UInt16).0._State_10\.

                        if (\BitMask::SetZero(UInt16).0.flag2\) then 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_11\;
                        else 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.69
                    when \BitMask::SetZero(UInt16).0._State_10\ => 
                        -- State after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_9\.
                        -- Going to the state after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_2\.
                        if (\BitMask::SetZero(UInt16).0._State\ = \BitMask::SetZero(UInt16).0._State_10\) then 
                            \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_11\ => 
                        -- True branch of the if-else started in state \BitMask::SetZero(UInt16).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	uint[] array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b;
                        -- 	array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b = new uint[1];
                        -- 	System.Array.Copy (@this.Segments, array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, 1);
                        -- 	array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b [index2] = @this.Segments [index2] & ~1u << num;
                        -- 	result = BitMask.FromImmutableArray (array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, @this.Size);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b = new uint[1];
                        -- 
                        \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- System.Array.Copy (@this.Segments, array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, 1);
                        -- 
                        \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\ := \BitMask::SetZero(UInt16).0.this\.\Segments\(0 to 0);
                        -- The following section was transformed from the .NET statement below:
                        -- array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b [index2] = @this.Segments [index2] & ~1u << num;
                        -- 
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.11\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(\BitMask::SetZero(UInt16).0.num\, 5))));
                        \BitMask::SetZero(UInt16).0.unaryOperationResult.0\ := not(\BitMask::SetZero(UInt16).0.binaryOperationResult.11\);
                        \BitMask::SetZero(UInt16).0.binaryOperationResult.12\ := \BitMask::SetZero(UInt16).0.this\.\Segments\(to_integer(\BitMask::SetZero(UInt16).0.index2\)) and \BitMask::SetZero(UInt16).0.unaryOperationResult.0\;
                        \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\(to_integer(\BitMask::SetZero(UInt16).0.index2\)) := \BitMask::SetZero(UInt16).0.binaryOperationResult.12\;
                        -- The following section was transformed from the .NET statement below:
                        -- result = BitMask.FromImmutableArray (array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b, @this.Size);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\;
                        \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.this\.\Size\;
                        \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.68865
                    when \BitMask::SetZero(UInt16).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        if (\BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask::SetZero(UInt16).0.return.0\ := \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\;
                            \BitMask::SetZero(UInt16).0.array661643a32331c1c17c90c8df2ce1363517913db0476b0fc66a6d6c14fc10738b\ := \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\;
                            \BitMask::SetZero(UInt16).0.result\ := \BitMask::SetZero(UInt16).0.return.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_9\.
                            if (\BitMask::SetZero(UInt16).0._State\ = \BitMask::SetZero(UInt16).0._State_12\) then 
                                \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_13\ => 
                        -- False branch of the if-else started in state \BitMask::SetZero(UInt16).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new BitMask (@this);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::SetZero(UInt16).0.result\.\IsNull\ := false;
                        \BitMask::SetZero(UInt16).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask::SetZero(UInt16).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::SetZero(UInt16).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.result\;
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::SetZero(UInt16).0.this\;
                        \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::SetZero(UInt16).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::SetZero(UInt16).0.result\ := \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::SetZero(UInt16).0.this\ := \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask::SetZero(UInt16).0._State_9\.
                            if (\BitMask::SetZero(UInt16).0._State\ = \BitMask::SetZero(UInt16).0._State_14\) then 
                                \BitMask::SetZero(UInt16).0._State\ := \BitMask::SetZero(UInt16).0._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \Boolean BitMask::op_Equality(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\: \Boolean BitMask::op_Equality(BitMask,BitMask).0._States\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_0\;
        Variable \Boolean BitMask::op_Equality(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \Boolean BitMask::op_Equality(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \Boolean BitMask::op_Equality(BitMask,BitMask).0.flag\: boolean := false;
        Variable \Boolean BitMask::op_Equality(BitMask,BitMask).0.result\: boolean := false;
        Variable \Boolean BitMask::op_Equality(BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Boolean BitMask::op_Equality(BitMask,BitMask).0.flag2\: boolean := false;
        Variable \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.1\: boolean := false;
        Variable \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.2\: boolean := false;
        Variable \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Boolean BitMask::op_Equality(BitMask,BitMask).0._Finished\ <= false;
                \Boolean BitMask::op_Equality(BitMask,BitMask).0.return\ <= false;
                \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_0\;
                \Boolean BitMask::op_Equality(BitMask,BitMask).0.flag\ := false;
                \Boolean BitMask::op_Equality(BitMask,BitMask).0.result\ := false;
                \Boolean BitMask::op_Equality(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \Boolean BitMask::op_Equality(BitMask,BitMask).0.flag2\ := false;
                \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.0\ := false;
                \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.1\ := false;
                \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.2\ := false;
                \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.3\ := to_unsigned(0, 16);
            else 
                case \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ is 
                    when \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ = true) then 
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ = true) then 
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._Finished\ <= false;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_2\ => 
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.left\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\;
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.right\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = 1 != (Int32)(right.SegmentCount);
                        -- 
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.0\ := to_signed(1, 32) /= signed(SmartResize((\Boolean BitMask::op_Equality(BitMask,BitMask).0.right\.\SegmentCount\), 32));
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.flag\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = false;
                        -- }
                        -- else {
                        -- 	num = 0;
                        -- 	while ((Int32)(num) < (Int32)(left.SegmentCount)) {
                        -- 		flag2 = left.Segments [(int)num] != right.Segments [(int)num];
                        -- 		if (flag2) {
                        -- 			result = false;
                        -- 			return result;
                        -- 		}
                        -- 		num = (UInt16)((Int32)(num) + 1);
                        -- 	}
                        -- 	result = true;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_4\ and ends in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_4\.
                        --     * The false branch starts in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_5\ and ends in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_7\.
                        --     * Execution after either branch will continue in the following state: \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_3\.

                        if (\Boolean BitMask::op_Equality(BitMask,BitMask).0.flag\) then 
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_4\;
                        else 
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.33405
                    when \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_3\ => 
                        -- State after the if-else which was started in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.return\ <= \Boolean BitMask::op_Equality(BitMask,BitMask).0.result\;
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_4\ => 
                        -- True branch of the if-else started in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = false;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = false;
                        -- 
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.result\ := False;
                        -- Going to the state after the if-else which was started in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_2\.
                        if (\Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ = \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_4\) then 
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_5\ => 
                        -- False branch of the if-else started in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 0;
                        -- 	while ((Int32)(num) < (Int32)(left.SegmentCount)) {
                        -- 		flag2 = left.Segments [(int)num] != right.Segments [(int)num];
                        -- 		if (flag2) {
                        -- 			result = false;
                        -- 			return result;
                        -- 		}
                        -- 		num = (UInt16)((Int32)(num) + 1);
                        -- 	}
                        -- 	result = true;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((Int32)(num) < (Int32)(left.SegmentCount)) {
                        -- 	flag2 = left.Segments [(int)num] != right.Segments [(int)num];
                        -- 	if (flag2) {
                        -- 		result = false;
                        -- 		return result;
                        -- 	}
                        -- 	num = (UInt16)((Int32)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_6\ => 
                        -- Repeated state of the while loop which was started in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_5\.
                        -- The while loop's condition:
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.1\ := signed(SmartResize((\Boolean BitMask::op_Equality(BitMask,BitMask).0.num\), 32)) < signed(SmartResize((\Boolean BitMask::op_Equality(BitMask,BitMask).0.left\.\SegmentCount\), 32));
                        if (\Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag2 = left.Segments [(int)num] != right.Segments [(int)num];
                            -- 	if (flag2) {
                            -- 		result = false;
                            -- 		return result;
                            -- 	}
                            -- 	num = (UInt16)((Int32)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = left.Segments [(int)num] != right.Segments [(int)num];
                            -- 
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.2\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0.left\.\Segments\(to_integer(signed(SmartResize(\Boolean BitMask::op_Equality(BitMask,BitMask).0.num\, 32)))) /= \Boolean BitMask::op_Equality(BitMask,BitMask).0.right\.\Segments\(to_integer(signed(SmartResize(\Boolean BitMask::op_Equality(BitMask,BitMask).0.num\, 32))));
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.flag2\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag2) {
                            -- 	result = false;
                            -- 	return result;
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_9\ and ends in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_9\.
                            --     * Execution after either branch will continue in the following state: \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_8\.

                            if (\Boolean BitMask::op_Equality(BitMask,BitMask).0.flag2\) then 
                                \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_9\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_8\;
                            end if;
                        else 
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7992
                    when \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_7\ => 
                        -- State after the while loop which was started in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = true;
                        -- 
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.result\ := True;
                        -- Going to the state after the if-else which was started in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_2\.
                        if (\Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ = \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_7\) then 
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_8\ => 
                        -- State after the if-else which was started in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (UInt16)((Int32)(num) + 1);
                        -- 
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.3\ := SmartResize(unsigned(signed(SmartResize((\Boolean BitMask::op_Equality(BitMask,BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.num\ := (\Boolean BitMask::op_Equality(BitMask,BitMask).0.binaryOperationResult.3\);
                        -- Returning to the repeated state of the while loop which was started in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_5\ if the loop wasn't exited with a state change.
                        if (\Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ = \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_8\) then 
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_9\ => 
                        -- True branch of the if-else started in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = false;
                        -- 	return result;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = false;
                        -- 
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.result\ := False;
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0.return\ <= \Boolean BitMask::op_Equality(BitMask,BitMask).0.result\;
                        \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_6\.
                        if (\Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ = \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_9\) then 
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._State\ := \Boolean BitMask::op_Equality(BitMask,BitMask).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \Boolean BitMask::op_LessThan(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\: \Boolean BitMask::op_LessThan(BitMask,BitMask).0._States\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_0\;
        Variable \Boolean BitMask::op_LessThan(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \Boolean BitMask::op_LessThan(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \Boolean BitMask::op_LessThan(BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Boolean BitMask::op_LessThan(BitMask,BitMask).0.flag\: boolean := false;
        Variable \Boolean BitMask::op_LessThan(BitMask,BitMask).0.result\: boolean := false;
        Variable \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.3\: boolean := false;
        Variable \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Boolean BitMask::op_LessThan(BitMask,BitMask).0._Finished\ <= false;
                \Boolean BitMask::op_LessThan(BitMask,BitMask).0.return\ <= false;
                \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_0\;
                \Boolean BitMask::op_LessThan(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \Boolean BitMask::op_LessThan(BitMask,BitMask).0.flag\ := false;
                \Boolean BitMask::op_LessThan(BitMask,BitMask).0.result\ := false;
                \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.0\ := false;
                \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.3\ := false;
                \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.4\ := to_unsigned(0, 16);
            else 
                case \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ is 
                    when \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Boolean BitMask::op_LessThan(BitMask,BitMask).0._Started\ = true) then 
                            \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Boolean BitMask::op_LessThan(BitMask,BitMask).0._Started\ = true) then 
                            \Boolean BitMask::op_LessThan(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \Boolean BitMask::op_LessThan(BitMask,BitMask).0._Finished\ <= false;
                            \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_2\ => 
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.left\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0.left.parameter.In\;
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.right\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1;
                        -- 
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.num\ := to_unsigned(1, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((Int32)(num) <= (Int32)(left.SegmentCount)) {
                        -- 	flag = left.Segments [(int)((Int32)(left.SegmentCount) - (Int32)(num))] < right.Segments [(int)((Int32)(left.SegmentCount) - (Int32)(num))];
                        -- 	if (flag) {
                        -- 		result = true;
                        -- 		return result;
                        -- 	}
                        -- 	num = (UInt16)((Int32)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_2\.
                        -- The while loop's condition:
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.0\ := signed(SmartResize((\Boolean BitMask::op_LessThan(BitMask,BitMask).0.num\), 32)) <= signed(SmartResize((\Boolean BitMask::op_LessThan(BitMask,BitMask).0.left\.\SegmentCount\), 32));
                        if (\Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag = left.Segments [(int)((Int32)(left.SegmentCount) - (Int32)(num))] < right.Segments [(int)((Int32)(left.SegmentCount) - (Int32)(num))];
                            -- 	if (flag) {
                            -- 		result = true;
                            -- 		return result;
                            -- 	}
                            -- 	num = (UInt16)((Int32)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag = left.Segments [(int)((Int32)(left.SegmentCount) - (Int32)(num))] < right.Segments [(int)((Int32)(left.SegmentCount) - (Int32)(num))];
                            -- 
                            \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.1\ := signed(SmartResize((\Boolean BitMask::op_LessThan(BitMask,BitMask).0.left\.\SegmentCount\), 32)) - signed(SmartResize((\Boolean BitMask::op_LessThan(BitMask,BitMask).0.num\), 32));
                            \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_5\;
                        else 
                            \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.89265
                    when \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_4\ => 
                        -- State after the while loop which was started in state \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = false;
                        -- 
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.result\ := False;
                        -- The following section was transformed from the .NET statement below:
                        -- return false;
                        -- 
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.return\ <= False;
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.2\ := signed(SmartResize((\Boolean BitMask::op_LessThan(BitMask,BitMask).0.left\.\SegmentCount\), 32)) - signed(SmartResize((\Boolean BitMask::op_LessThan(BitMask,BitMask).0.num\), 32));
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.3\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0.left\.\Segments\(to_integer((\Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.1\))) < \Boolean BitMask::op_LessThan(BitMask,BitMask).0.right\.\Segments\(to_integer((\Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.2\)));
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.flag\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = true;
                        -- 	return result;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_7\ and ends in state \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_7\.
                        --     * Execution after either branch will continue in the following state: \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_6\.

                        if (\Boolean BitMask::op_LessThan(BitMask,BitMask).0.flag\) then 
                            \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_7\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.837
                    when \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_6\ => 
                        -- State after the if-else which was started in state \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (UInt16)((Int32)(num) + 1);
                        -- 
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.4\ := SmartResize(unsigned(signed(SmartResize((\Boolean BitMask::op_LessThan(BitMask,BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.num\ := (\Boolean BitMask::op_LessThan(BitMask,BitMask).0.binaryOperationResult.4\);
                        -- Returning to the repeated state of the while loop which was started in state \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_2\ if the loop wasn't exited with a state change.
                        if (\Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ = \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_6\) then 
                            \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_7\ => 
                        -- True branch of the if-else started in state \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = true;
                        -- 	return result;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = true;
                        -- 
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.result\ := True;
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0.return\ <= \Boolean BitMask::op_LessThan(BitMask,BitMask).0.result\;
                        \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_1\;
                        -- Going to the state after the if-else which was started in state \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_5\.
                        if (\Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ = \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_7\) then 
                            \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State\ := \Boolean BitMask::op_LessThan(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\: \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._States\ := \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_0\;
        Variable \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return.0\: boolean := false;
        Variable \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.unaryOperationResult.0\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\ <= false;
                \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return\ <= false;
                \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask)._Started.0\ <= false;
                \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ := \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_0\;
                \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return.0\ := false;
                \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.unaryOperationResult.0\ := false;
            else 
                case \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ is 
                    when \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ = true) then 
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ := \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ = true) then 
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\ <= false;
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ := \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_2\ => 
                        \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left\ := \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left.parameter.In\;
                        \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right\ := \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return !BitMask.op_LessThan (left, right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask).left.parameter.Out.0\ <= \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left\;
                        \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask).right.parameter.Out.0\ <= \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right\;
                        \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask)._Started.0\ <= true;
                        \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ := \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0.0984
                    when \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask)._Started.0\ = \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask)._Finished.0\) then 
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask)._Started.0\ <= false;
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return.0\ := \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask).return.0\;
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.unaryOperationResult.0\ := not(\Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return.0\);
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return\ <= \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.unaryOperationResult.0\;
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State\ := \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0 state machine start
    \BitMask BitMask::op_Addition(BitMask,UInt32).0._StateMachine\: process (\Clock\) 
        Variable \BitMask BitMask::op_Addition(BitMask,UInt32).0._State\: \BitMask BitMask::op_Addition(BitMask,UInt32).0._States\ := \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_0\;
        Variable \BitMask BitMask::op_Addition(BitMask,UInt32).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_Addition(BitMask,UInt32).0.right\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_Addition(BitMask,UInt32).0.return.0\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask BitMask::op_Addition(BitMask,UInt32).0._Finished\ <= false;
                \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                \BitMask BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_0\;
                \BitMask BitMask::op_Addition(BitMask,UInt32).0.right\ := to_unsigned(0, 32);
            else 
                case \BitMask BitMask::op_Addition(BitMask,UInt32).0._State\ is 
                    when \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask BitMask::op_Addition(BitMask,UInt32).0._Started\ = true) then 
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask BitMask::op_Addition(BitMask,UInt32).0._Started\ = true) then 
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0._Finished\ <= true;
                        else 
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0._Finished\ <= false;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_2\ => 
                        \BitMask BitMask::op_Addition(BitMask,UInt32).0.left\ := \BitMask BitMask::op_Addition(BitMask,UInt32).0.left.parameter.In\;
                        \BitMask BitMask::op_Addition(BitMask,UInt32).0.right\ := \BitMask BitMask::op_Addition(BitMask,UInt32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7 = new BitMask (right, left.Size);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\.\IsNull\ := false;
                        \BitMask BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\.\Size\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\;
                        \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.right\;
                        \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.left\.\Size\;
                        \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \BitMask BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\ := \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return BitMask.op_Addition (left, objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.left\;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.objectf36e31d7d72f45fa8502b500a53d32998fb50066ca43a80948038a187ec6eeb7\;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.return.0\ := \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.return\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.return.0\;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Addition(BitMask,UInt32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0 state machine start
    \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._StateMachine\: process (\Clock\) 
        Variable \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State\: \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._States\ := \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_0\;
        Variable \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.right\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.return.0\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._Finished\ <= false;
                \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_0\;
                \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.right\ := to_unsigned(0, 32);
            else 
                case \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State\ is 
                    when \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask BitMask::op_Subtraction(BitMask,UInt32).0._Started\ = true) then 
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask BitMask::op_Subtraction(BitMask,UInt32).0._Started\ = true) then 
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._Finished\ <= true;
                        else 
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._Finished\ <= false;
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_2\ => 
                        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.left\ := \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.left.parameter.In\;
                        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.right\ := \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b = new BitMask (1u, left.Size);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\.\IsNull\ := false;
                        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\.\Size\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\;
                        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(1, 32);
                        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.left\.\Size\;
                        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\ := \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return BitMask.op_Subtraction (left, objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.left\;
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.objecta61455fab573a542acb73876e64b9030131a0cce17b30e0367325b0ff05dd84b\;
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= true;
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.return.0\ := \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).return.0\;
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.return\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.return.0\;
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask BitMask::op_Addition(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\: \BitMask BitMask::op_Addition(BitMask,BitMask).0._States\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_0\;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag2\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag3\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag4\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag5\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag6\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.2\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.3\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.4\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.9\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.11\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.14\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.15\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.16\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.18\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.19\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.20\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.21\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.22\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.23\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.24\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.25\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.26\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.27\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.29\: boolean := false;
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.30\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.31\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask BitMask::op_Addition(BitMask,BitMask).0._Finished\ <= false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_0\;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag2\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.num3\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag3\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag4\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.b\ := to_unsigned(0, 8);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag5\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag6\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.0\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.1\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.2\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.3\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.4\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.9\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.11\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.12\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.13\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.14\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.15\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.16\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83\ := to_signed(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb\ := to_signed(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d\ := to_signed(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.17\ := to_signed(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.18\ := to_unsigned(0, 8);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace\ := to_signed(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.19\ := to_signed(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.20\ := to_signed(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.21\ := to_signed(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.22\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.23\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.24\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.25\ := to_signed(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.26\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.27\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.28\ := to_signed(0, 32);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.29\ := false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.30\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.31\ := to_unsigned(0, 16);
            else 
                case \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ is 
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._Finished\ <= false;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_2\ => 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.left\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.left.parameter.In\;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.right\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (Int32)(left.SegmentCount) == 0 || (Int32)(right.SegmentCount) == 0;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.0\ := signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.left\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.1\ := signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.right\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.2\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.0\ or \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.1\;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = left;
                        -- }
                        -- else {
                        -- 	flag2 = false;
                        -- 	num = 0;
                        -- 	num2 = 0;
                        -- 	array = new uint[1];
                        -- 	num3 = 0;
                        -- 	ushort conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a;
                        -- 	if ((Int32)(left.Size) > (Int32)(right.Size)) {
                        -- 		conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a = left.Size;
                        -- 	}
                        -- 	else {
                        -- 		conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a = right.Size;
                        -- 	}
                        -- 	while ((Int32)(num3) < (Int32)(conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a)) {
                        -- 		UInt32 remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67;
                        -- 		remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 = left.Segments [(int)num] >> (int)num2;
                        -- 		flag3 = remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 - remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 / 2u * 2u == 1u;
                        -- 		UInt32 remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f;
                        -- 		remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f = right.Segments [(int)num] >> (int)num2;
                        -- 		flag4 = (Int32)(num3) < (Int32)(right.Size) && remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f - remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f / 2u * 2u == 1u;
                        -- 		int conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83;
                        -- 		if (flag3) {
                        -- 			conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- 		}
                        -- 		int conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb;
                        -- 		if (flag4) {
                        -- 			conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- 		}
                        -- 		int conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d;
                        -- 		if (flag2) {
                        -- 			conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- 		}
                        -- 		b = (byte)(conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 + conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb + conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d);
                        -- 		Int32 remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace;
                        -- 		remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace = (Int32)(b);
                        -- 		flag5 = (Int32)(remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace - remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace / 2 * 2) == 1;
                        -- 		if (flag5) {
                        -- 			array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 		}
                        -- 		flag2 = b >> 1 == 1;
                        -- 		num2 = (UInt16)((Int32)(num2) + 1);
                        -- 		flag6 = num2 >> 5 == 1;
                        -- 		if (flag6) {
                        -- 			num2 = 0;
                        -- 			num = (UInt16)((Int32)(num) + 1);
                        -- 		}
                        -- 		num3 = (UInt16)((Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_4\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_4\.
                        --     * The false branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_5\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_33\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_3\.

                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0.flag\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_4\;
                        else 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7866
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.return\ <= \BitMask BitMask::op_Addition(BitMask,BitMask).0.result\;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.result\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.left\;
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_2\.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_4\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_5\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag2 = false;
                        -- 	num = 0;
                        -- 	num2 = 0;
                        -- 	array = new uint[1];
                        -- 	num3 = 0;
                        -- 	ushort conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a;
                        -- 	if ((Int32)(left.Size) > (Int32)(right.Size)) {
                        -- 		conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a = left.Size;
                        -- 	}
                        -- 	else {
                        -- 		conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a = right.Size;
                        -- 	}
                        -- 	while ((Int32)(num3) < (Int32)(conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a)) {
                        -- 		UInt32 remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67;
                        -- 		remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 = left.Segments [(int)num] >> (int)num2;
                        -- 		flag3 = remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 - remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 / 2u * 2u == 1u;
                        -- 		UInt32 remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f;
                        -- 		remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f = right.Segments [(int)num] >> (int)num2;
                        -- 		flag4 = (Int32)(num3) < (Int32)(right.Size) && remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f - remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f / 2u * 2u == 1u;
                        -- 		int conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83;
                        -- 		if (flag3) {
                        -- 			conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- 		}
                        -- 		int conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb;
                        -- 		if (flag4) {
                        -- 			conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- 		}
                        -- 		int conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d;
                        -- 		if (flag2) {
                        -- 			conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- 		}
                        -- 		b = (byte)(conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 + conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb + conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d);
                        -- 		Int32 remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace;
                        -- 		remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace = (Int32)(b);
                        -- 		flag5 = (Int32)(remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace - remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace / 2 * 2) == 1;
                        -- 		if (flag5) {
                        -- 			array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 		}
                        -- 		flag2 = b >> 1 == 1;
                        -- 		num2 = (UInt16)((Int32)(num2) + 1);
                        -- 		flag6 = num2 >> 5 == 1;
                        -- 		if (flag6) {
                        -- 			num2 = 0;
                        -- 			num = (UInt16)((Int32)(num) + 1);
                        -- 		}
                        -- 		num3 = (UInt16)((Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = false;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag2\ := False;
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.num3\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((Int32)(left.Size) > (Int32)(right.Size)) {
                        -- 	conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a = left.Size;
                        -- }
                        -- else {
                        -- 	conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a = right.Size;
                        -- }
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.3\ := signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.left\.\Size\), 32)) > signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.right\.\Size\), 32));

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_7\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_7\.
                        --     * The false branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_8\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_8\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_6\.

                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.3\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_7\;
                        else 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50535
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_6\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- while ((Int32)(num3) < (Int32)(conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a)) {
                        -- 	UInt32 remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67;
                        -- 	remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 = left.Segments [(int)num] >> (int)num2;
                        -- 	flag3 = remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 - remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 / 2u * 2u == 1u;
                        -- 	UInt32 remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f;
                        -- 	remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f = right.Segments [(int)num] >> (int)num2;
                        -- 	flag4 = (Int32)(num3) < (Int32)(right.Size) && remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f - remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f / 2u * 2u == 1u;
                        -- 	int conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83;
                        -- 	if (flag3) {
                        -- 		conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- 	}
                        -- 	int conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb;
                        -- 	if (flag4) {
                        -- 		conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- 	}
                        -- 	int conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d;
                        -- 	if (flag2) {
                        -- 		conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- 	}
                        -- 	b = (byte)(conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 + conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb + conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d);
                        -- 	Int32 remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace;
                        -- 	remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace = (Int32)(b);
                        -- 	flag5 = (Int32)(remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace - remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace / 2 * 2) == 1;
                        -- 	if (flag5) {
                        -- 		array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 	}
                        -- 	flag2 = b >> 1 == 1;
                        -- 	num2 = (UInt16)((Int32)(num2) + 1);
                        -- 	flag6 = num2 >> 5 == 1;
                        -- 	if (flag6) {
                        -- 		num2 = 0;
                        -- 		num = (UInt16)((Int32)(num) + 1);
                        -- 	}
                        -- 	num3 = (UInt16)((Int32)(num3) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_7\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a = left.Size;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a = left.Size;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.left\.\Size\;
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_5\.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_7\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_8\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a = right.Size;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a = right.Size;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.right\.\Size\;
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_5\.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_8\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_6\.
                        -- The while loop's condition:
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.4\ := signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.num3\), 32)) < signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional446f88dc27e6782eb74aa0eb773ecbdc21b5da0c446c405a09281d9cd7c71e0a\), 32));
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	UInt32 remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67;
                            -- 	remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 = left.Segments [(int)num] >> (int)num2;
                            -- 	flag3 = remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 - remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 / 2u * 2u == 1u;
                            -- 	UInt32 remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f;
                            -- 	remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f = right.Segments [(int)num] >> (int)num2;
                            -- 	flag4 = (Int32)(num3) < (Int32)(right.Size) && remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f - remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f / 2u * 2u == 1u;
                            -- 	int conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83;
                            -- 	if (flag3) {
                            -- 		conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                            -- 	}
                            -- 	int conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb;
                            -- 	if (flag4) {
                            -- 		conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                            -- 	}
                            -- 	int conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d;
                            -- 	if (flag2) {
                            -- 		conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                            -- 	}
                            -- 	b = (byte)(conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 + conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb + conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d);
                            -- 	Int32 remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace;
                            -- 	remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace = (Int32)(b);
                            -- 	flag5 = (Int32)(remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace - remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace / 2 * 2) == 1;
                            -- 	if (flag5) {
                            -- 		array [(int)num] = array [(int)num] + 1u << (int)num2;
                            -- 	}
                            -- 	flag2 = b >> 1 == 1;
                            -- 	num2 = (UInt16)((Int32)(num2) + 1);
                            -- 	flag6 = num2 >> 5 == 1;
                            -- 	if (flag6) {
                            -- 		num2 = 0;
                            -- 		num = (UInt16)((Int32)(num) + 1);
                            -- 	}
                            -- 	num3 = (UInt16)((Int32)(num3) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- UInt32 remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 = left.Segments [(int)num] >> (int)num2;
                            -- 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_11\;
                        else 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.46515
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_10\ => 
                        -- State after the while loop which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.result\.\IsNull\ := false;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask BitMask::op_Addition(BitMask,BitMask).0.result\;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask BitMask::op_Addition(BitMask,BitMask).0.array\;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_33\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.5\ := shift_right(\BitMask BitMask::op_Addition(BitMask,BitMask).0.left\.\Segments\(to_integer(signed(SmartResize(\BitMask BitMask::op_Addition(BitMask,BitMask).0.num\, 32)))), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask BitMask::op_Addition(BitMask,BitMask).0.num2\, 32)), 5) and "11111")));
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 - remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67 / 2u * 2u == 1u;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.6\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67\ / to_unsigned(2, 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.7\ := SmartResize(\BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.6\ * to_unsigned(2, 32), 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.9321
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_12\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.8\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperand44_5Ce2b0b519cb6e34503a5bef09b6a50a9cb7de48354eec09f4470eb17b67c26b67\ - \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.7\;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.9\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.8\ = to_unsigned(1, 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag3\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- UInt32 remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f = right.Segments [(int)num] >> (int)num2;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0.69
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_13\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.10\ := shift_right(\BitMask BitMask::op_Addition(BitMask,BitMask).0.right\.\Segments\(to_integer(signed(SmartResize(\BitMask BitMask::op_Addition(BitMask,BitMask).0.num\, 32)))), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask BitMask::op_Addition(BitMask,BitMask).0.num2\, 32)), 5) and "11111")));
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.10\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = (Int32)(num3) < (Int32)(right.Size) && remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f - remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f / 2u * 2u == 1u;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0.63525
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_14\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.11\ := signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.num3\), 32)) < signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.right\.\Size\), 32));
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.12\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f\ / to_unsigned(2, 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.13\ := SmartResize(\BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.12\ * to_unsigned(2, 32), 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_15\;
                        -- Clock cycles needed to complete this state (approximation): 0.762
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_15\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.14\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperand6D_857285a1e29e4e88411962dc861d0e9c10eb316891bd1ecd0a7301fad548a57b0f\ - \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.13\;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.15\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.14\ = to_unsigned(1, 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.16\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.11\ and \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.15\;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag4\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.16\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- }
                        -- else {
                        -- 	conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_17\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_17\.
                        --     * The false branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_18\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_18\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_16\.

                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0.flag3\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_17\;
                        else 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_18\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8094
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_16\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- }
                        -- else {
                        -- 	conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_20\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_20\.
                        --     * The false branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_21\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_21\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_19\.

                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0.flag4\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_20\;
                        else 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_17\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 1;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_15\.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_17\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_18\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 = 0;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_15\.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_18\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_19\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_16\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- }
                        -- else {
                        -- 	conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_23\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_23\.
                        --     * The false branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_24\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_24\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_22\.

                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0.flag2\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_23\;
                        else 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_20\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_16\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 1;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_16\.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_20\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_21\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_16\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb = 0;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_16\.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_21\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_22\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = (byte)(conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83 + conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb + conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d);
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.17\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional5879828947396ed3697dc523a392190e5acca8aad18277de3cb8a8be5de05e83\ + \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditionala328119b66b9d4ad863ec3231a2086b8d1d1497b20a29bb8b87ffa0aa2da35fb\;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.18\ := SmartResize(unsigned(\BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.17\ + \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d\), 8);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.b\ := (\BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.18\);
                        -- The following section was transformed from the .NET statement below:
                        -- Int32 remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace = (Int32)(b);
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace\ := signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.b\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- flag5 = (Int32)(remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace - remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace / 2 * 2) == 1;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_25\;
                        -- Clock cycles needed to complete this state (approximation): 0.7962
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_23\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 1;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_19\.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_23\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_24\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d = 0;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.conditional0d4ef9e95ca5f732f867d2bdac8f5dbabb8127ae6cb7ba723f5ffeebea6f608d\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_19\.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_24\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_25\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.19\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace\ / to_signed(2, 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.20\ := SmartResize(\BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.19\ * to_signed(2, 32), 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.21\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.remainderOperandA7_AA02cc70c7eb3c45c5d82a4fdb84991fb7d3b1dc2202736c2e97402f90a9288ace\ - \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.20\;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0.79635
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_26\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.22\ := (\BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.21\) = to_signed(1, 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag5\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.22\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag5) {
                        -- 	array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_28\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_28\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_27\.

                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0.flag5\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_28\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3336
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_27\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = b >> 1 == 1;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.25\ := signed(SmartResize(shift_right(\BitMask BitMask::op_Addition(BitMask,BitMask).0.b\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111"))), 32));
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.26\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.25\ = to_signed(1, 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag2\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.26\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (UInt16)((Int32)(num2) + 1);
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_29\;
                        -- Clock cycles needed to complete this state (approximation): 0.6216
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_28\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.23\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask BitMask::op_Addition(BitMask,BitMask).0.num2\, 32)), 5))));
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.24\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_Addition(BitMask,BitMask).0.num\, 32)))) + \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.23\;
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_Addition(BitMask,BitMask).0.num\, 32)))) := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.24\;
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_26\.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_28\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.837
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_29\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.27\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.num2\ := (\BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.27\);
                        -- The following section was transformed from the .NET statement below:
                        -- flag6 = num2 >> 5 == 1;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.28\ := signed(SmartResize(shift_right(\BitMask BitMask::op_Addition(BitMask,BitMask).0.num2\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_30\;
                        -- Clock cycles needed to complete this state (approximation): 0.7038
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_30\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.29\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.28\ = to_signed(1, 32);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.flag6\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.29\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag6) {
                        -- 	num2 = 0;
                        -- 	num = (UInt16)((Int32)(num) + 1);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_32\ and ends in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_32\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_31\.

                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0.flag6\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_32\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_31\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3336
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_31\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_30\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (UInt16)((Int32)(num3) + 1);
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.31\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.num3\), 32)) + to_signed(1, 32)), 16);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.num3\ := (\BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.31\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_6\ if the loop wasn't exited with a state change.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_31\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_32\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_30\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = 0;
                        -- 	num = (UInt16)((Int32)(num) + 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num = (UInt16)((Int32)(num) + 1);
                        -- 
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.30\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_Addition(BitMask,BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                        \BitMask BitMask::op_Addition(BitMask,BitMask).0.num\ := (\BitMask BitMask::op_Addition(BitMask,BitMask).0.binaryOperationResult.30\);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_30\.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_32\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_31\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_33\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0.result\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0.array\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_2\.
                            if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_33\) then 
                                \BitMask BitMask::op_Addition(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Addition(BitMask,BitMask).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\: \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._States\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_0\;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag2\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag3\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag4\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.b\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag5\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag6\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.2\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.3\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.4\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.9\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.10\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.11\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.12\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.14\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.15\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.16\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.19\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.20\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.21\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.22\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.23\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.24\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.25\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.26\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.27\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.28\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.29\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.30\: boolean := false;
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.31\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.32\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Finished\ <= false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_0\;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag2\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num3\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag3\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag4\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.b\ := to_unsigned(0, 8);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag5\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag6\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.0\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.1\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.2\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.3\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.4\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.9\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.10\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.11\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.12\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.13\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.14\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.15\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.16\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b\ := to_signed(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041\ := to_signed(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026\ := to_signed(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.17\ := to_signed(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.18\ := to_signed(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.19\ := to_unsigned(0, 8);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999\ := to_signed(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.20\ := to_signed(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.21\ := to_signed(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.22\ := to_signed(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.23\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.24\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.25\ := to_unsigned(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.26\ := to_signed(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.27\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.28\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.29\ := to_signed(0, 32);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.30\ := false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.31\ := to_unsigned(0, 16);
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.32\ := to_unsigned(0, 16);
            else 
                case \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ is 
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Finished\ <= false;
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_2\ => 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.left\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.left.parameter.In\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.right\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- byte b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (Int32)(left.SegmentCount) == 0 || (Int32)(right.SegmentCount) == 0;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.0\ := signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.left\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.1\ := signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.right\.\SegmentCount\), 32)) = to_signed(0, 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.2\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.0\ or \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.1\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = left;
                        -- }
                        -- else {
                        -- 	flag2 = false;
                        -- 	num = 0;
                        -- 	num2 = 0;
                        -- 	array = new uint[1];
                        -- 	num3 = 0;
                        -- 	ushort conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a;
                        -- 	if ((Int32)(left.Size) > (Int32)(right.Size)) {
                        -- 		conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a = left.Size;
                        -- 	}
                        -- 	else {
                        -- 		conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a = right.Size;
                        -- 	}
                        -- 	while ((Int32)(num3) < (Int32)(conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a)) {
                        -- 		UInt32 remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c;
                        -- 		remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c = left.Segments [(int)num] >> (int)num2;
                        -- 		flag3 = remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c - remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c / 2u * 2u == 1u;
                        -- 		UInt32 remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2;
                        -- 		remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 = right.Segments [(int)num] >> (int)num2;
                        -- 		flag4 = (Int32)(num3) < (Int32)(right.Size) && remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 - remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 / 2u * 2u == 1u;
                        -- 		int conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b;
                        -- 		if (flag3) {
                        -- 			conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- 		}
                        -- 		int conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041;
                        -- 		if (flag4) {
                        -- 			conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- 		}
                        -- 		int conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026;
                        -- 		if (flag2) {
                        -- 			conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- 		}
                        -- 		b = (byte)(2 + conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b - conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 - conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026);
                        -- 		Int32 remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999;
                        -- 		remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 = (Int32)(b);
                        -- 		flag5 = (Int32)(remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 - remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 / 2 * 2) == 1;
                        -- 		if (flag5) {
                        -- 			array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 		}
                        -- 		flag2 = b >> 1 == 0;
                        -- 		num2 = (UInt16)((Int32)(num2) + 1);
                        -- 		flag6 = num2 >> 5 == 1;
                        -- 		if (flag6) {
                        -- 			num2 = 0;
                        -- 			num = (UInt16)((Int32)(num) + 1);
                        -- 		}
                        -- 		num3 = (UInt16)((Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_4\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_4\.
                        --     * The false branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_5\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_33\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_3\.

                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_4\;
                        else 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7866
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.return\ <= \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.result\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.result\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.left\;
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_2\.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_4\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_5\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag2 = false;
                        -- 	num = 0;
                        -- 	num2 = 0;
                        -- 	array = new uint[1];
                        -- 	num3 = 0;
                        -- 	ushort conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a;
                        -- 	if ((Int32)(left.Size) > (Int32)(right.Size)) {
                        -- 		conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a = left.Size;
                        -- 	}
                        -- 	else {
                        -- 		conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a = right.Size;
                        -- 	}
                        -- 	while ((Int32)(num3) < (Int32)(conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a)) {
                        -- 		UInt32 remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c;
                        -- 		remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c = left.Segments [(int)num] >> (int)num2;
                        -- 		flag3 = remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c - remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c / 2u * 2u == 1u;
                        -- 		UInt32 remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2;
                        -- 		remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 = right.Segments [(int)num] >> (int)num2;
                        -- 		flag4 = (Int32)(num3) < (Int32)(right.Size) && remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 - remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 / 2u * 2u == 1u;
                        -- 		int conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b;
                        -- 		if (flag3) {
                        -- 			conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- 		}
                        -- 		int conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041;
                        -- 		if (flag4) {
                        -- 			conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- 		}
                        -- 		int conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026;
                        -- 		if (flag2) {
                        -- 			conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- 		}
                        -- 		else {
                        -- 			conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- 		}
                        -- 		b = (byte)(2 + conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b - conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 - conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026);
                        -- 		Int32 remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999;
                        -- 		remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 = (Int32)(b);
                        -- 		flag5 = (Int32)(remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 - remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 / 2 * 2) == 1;
                        -- 		if (flag5) {
                        -- 			array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 		}
                        -- 		flag2 = b >> 1 == 0;
                        -- 		num2 = (UInt16)((Int32)(num2) + 1);
                        -- 		flag6 = num2 >> 5 == 1;
                        -- 		if (flag6) {
                        -- 			num2 = 0;
                        -- 			num = (UInt16)((Int32)(num) + 1);
                        -- 		}
                        -- 		num3 = (UInt16)((Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = false;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag2\ := False;
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num3\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((Int32)(left.Size) > (Int32)(right.Size)) {
                        -- 	conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a = left.Size;
                        -- }
                        -- else {
                        -- 	conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a = right.Size;
                        -- }
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.3\ := signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.left\.\Size\), 32)) > signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.right\.\Size\), 32));

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_7\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_7\.
                        --     * The false branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_8\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_8\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_6\.

                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.3\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_7\;
                        else 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50535
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_6\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- while ((Int32)(num3) < (Int32)(conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a)) {
                        -- 	UInt32 remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c;
                        -- 	remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c = left.Segments [(int)num] >> (int)num2;
                        -- 	flag3 = remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c - remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c / 2u * 2u == 1u;
                        -- 	UInt32 remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2;
                        -- 	remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 = right.Segments [(int)num] >> (int)num2;
                        -- 	flag4 = (Int32)(num3) < (Int32)(right.Size) && remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 - remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 / 2u * 2u == 1u;
                        -- 	int conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b;
                        -- 	if (flag3) {
                        -- 		conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- 	}
                        -- 	int conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041;
                        -- 	if (flag4) {
                        -- 		conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- 	}
                        -- 	int conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026;
                        -- 	if (flag2) {
                        -- 		conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- 	}
                        -- 	else {
                        -- 		conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- 	}
                        -- 	b = (byte)(2 + conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b - conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 - conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026);
                        -- 	Int32 remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999;
                        -- 	remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 = (Int32)(b);
                        -- 	flag5 = (Int32)(remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 - remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 / 2 * 2) == 1;
                        -- 	if (flag5) {
                        -- 		array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 	}
                        -- 	flag2 = b >> 1 == 0;
                        -- 	num2 = (UInt16)((Int32)(num2) + 1);
                        -- 	flag6 = num2 >> 5 == 1;
                        -- 	if (flag6) {
                        -- 		num2 = 0;
                        -- 		num = (UInt16)((Int32)(num) + 1);
                        -- 	}
                        -- 	num3 = (UInt16)((Int32)(num3) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_7\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a = left.Size;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a = left.Size;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.left\.\Size\;
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_5\.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_7\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_8\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a = right.Size;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a = right.Size;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.right\.\Size\;
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_5\.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_8\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_6\.
                        -- The while loop's condition:
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.4\ := signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num3\), 32)) < signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional79f9991fc89f2cfebbd0b1affbfd17cbc7d5711d8679672ca11874fcd62c1e0a\), 32));
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	UInt32 remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c;
                            -- 	remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c = left.Segments [(int)num] >> (int)num2;
                            -- 	flag3 = remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c - remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c / 2u * 2u == 1u;
                            -- 	UInt32 remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2;
                            -- 	remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 = right.Segments [(int)num] >> (int)num2;
                            -- 	flag4 = (Int32)(num3) < (Int32)(right.Size) && remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 - remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 / 2u * 2u == 1u;
                            -- 	int conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b;
                            -- 	if (flag3) {
                            -- 		conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                            -- 	}
                            -- 	int conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041;
                            -- 	if (flag4) {
                            -- 		conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                            -- 	}
                            -- 	int conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026;
                            -- 	if (flag2) {
                            -- 		conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                            -- 	}
                            -- 	else {
                            -- 		conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                            -- 	}
                            -- 	b = (byte)(2 + conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b - conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 - conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026);
                            -- 	Int32 remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999;
                            -- 	remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 = (Int32)(b);
                            -- 	flag5 = (Int32)(remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 - remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 / 2 * 2) == 1;
                            -- 	if (flag5) {
                            -- 		array [(int)num] = array [(int)num] + 1u << (int)num2;
                            -- 	}
                            -- 	flag2 = b >> 1 == 0;
                            -- 	num2 = (UInt16)((Int32)(num2) + 1);
                            -- 	flag6 = num2 >> 5 == 1;
                            -- 	if (flag6) {
                            -- 		num2 = 0;
                            -- 		num = (UInt16)((Int32)(num) + 1);
                            -- 	}
                            -- 	num3 = (UInt16)((Int32)(num3) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- UInt32 remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c = left.Segments [(int)num] >> (int)num2;
                            -- 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_11\;
                        else 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.46515
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_10\ => 
                        -- State after the while loop which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.result\.\IsNull\ := false;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.result\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.array\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_33\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.5\ := shift_right(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.left\.\Segments\(to_integer(signed(SmartResize(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num\, 32)))), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num2\, 32)), 5) and "11111")));
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c - remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c / 2u * 2u == 1u;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.6\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c\ / to_unsigned(2, 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.7\ := SmartResize(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.6\ * to_unsigned(2, 32), 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.9321
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_12\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.8\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand44_5Cb93cc59cd6164f29e20c88cf52a69a13cfdb37bdfe283e76b58f7dfb756b003c\ - \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.7\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.9\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.8\ = to_unsigned(1, 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag3\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- UInt32 remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 = right.Segments [(int)num] >> (int)num2;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0.69
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_13\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.10\ := shift_right(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.right\.\Segments\(to_integer(signed(SmartResize(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num\, 32)))), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num2\, 32)), 5) and "11111")));
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.10\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = (Int32)(num3) < (Int32)(right.Size) && remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 - remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2 / 2u * 2u == 1u;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0.63525
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_14\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.11\ := signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num3\), 32)) < signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.right\.\Size\), 32));
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.12\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2\ / to_unsigned(2, 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.13\ := SmartResize(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.12\ * to_unsigned(2, 32), 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_15\;
                        -- Clock cycles needed to complete this state (approximation): 0.762
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_15\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.14\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperand6D_854138ffc7fe569c9ffeeddacdd20c630f95cadcd22c9a19842e600061817fd5a2\ - \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.13\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.15\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.14\ = to_unsigned(1, 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.16\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.11\ and \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.15\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag4\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.16\;
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag3) {
                        -- 	conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- }
                        -- else {
                        -- 	conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_17\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_17\.
                        --     * The false branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_18\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_18\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_16\.

                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag3\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_17\;
                        else 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_18\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8094
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_16\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- }
                        -- else {
                        -- 	conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_20\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_20\.
                        --     * The false branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_21\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_21\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_19\.

                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag4\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_20\;
                        else 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_17\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 1;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_15\.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_17\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_18\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b = 0;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_15\.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_18\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_19\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_16\.
                        -- The following section was transformed from the .NET statement below:
                        -- int conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- }
                        -- else {
                        -- 	conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_23\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_23\.
                        --     * The false branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_24\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_24\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_22\.

                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag2\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_23\;
                        else 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_20\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_16\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 1;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_16\.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_20\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_21\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_16\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 = 0;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_16\.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_21\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_22\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- b = (byte)(2 + conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b - conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041 - conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026);
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.17\ := to_signed(2, 32) + \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional22bfb8ac44cbc4917ee14440447b12540eceec7b3cd495084ef0cd420990276b\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.18\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.17\ - \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional9d57ba50a30bb33afd6499b41b780cc730fced7e4d6846a878d4c184392b9041\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_25\;
                        -- Clock cycles needed to complete this state (approximation): 0.7545
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_23\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 1;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026\ := to_signed(1, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_19\.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_23\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_24\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_19\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026 = 0;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_19\.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_24\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_25\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.19\ := SmartResize(unsigned(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.18\ - \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.conditional410c72494e25aa69b39baa13ebf031c8dcea75aa2cf10de21e0c7dee364e4026\), 8);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.b\ := (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.19\);
                        -- The following section was transformed from the .NET statement below:
                        -- Int32 remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 = (Int32)(b);
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999\ := signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.b\), 32));
                        -- The following section was transformed from the .NET statement below:
                        -- flag5 = (Int32)(remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 - remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999 / 2 * 2) == 1;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.20\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999\ / to_signed(2, 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.21\ := SmartResize(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.20\ * to_signed(2, 32), 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0.79635
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_26\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.22\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.remainderOperandA9_AC30e78d7869f48726792d70e4a84e7b04881ef1b1391ae5465ffc7304d0e66999\ - \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.21\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.23\ := (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.22\) = to_signed(1, 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag5\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.23\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag5) {
                        -- 	array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_28\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_28\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_27\.

                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag5\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_28\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.69
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_27\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = b >> 1 == 0;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.26\ := signed(SmartResize(shift_right(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.b\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111"))), 32));
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.27\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.26\ = to_signed(0, 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag2\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.27\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (UInt16)((Int32)(num2) + 1);
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_29\;
                        -- Clock cycles needed to complete this state (approximation): 0.6216
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_28\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_26\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num] = array [(int)num] + 1u << (int)num2;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.24\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num2\, 32)), 5))));
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.25\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num\, 32)))) + \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.24\;
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num\, 32)))) := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.25\;
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_26\.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_28\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.837
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_29\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.28\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num2\ := (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.28\);
                        -- The following section was transformed from the .NET statement below:
                        -- flag6 = num2 >> 5 == 1;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.29\ := signed(SmartResize(shift_right(\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num2\, to_integer(unsigned(SmartResize(to_signed(5, 32), 5) and "11111"))), 32));
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_30\;
                        -- Clock cycles needed to complete this state (approximation): 0.7038
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_30\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.30\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.29\ = to_signed(1, 32);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag6\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.30\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag6) {
                        -- 	num2 = 0;
                        -- 	num = (UInt16)((Int32)(num) + 1);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_32\ and ends in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_32\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_31\.

                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.flag6\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_32\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_31\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3336
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_31\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_30\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (UInt16)((Int32)(num3) + 1);
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.32\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num3\), 32)) + to_signed(1, 32)), 16);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num3\ := (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.32\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_6\ if the loop wasn't exited with a state change.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_31\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_32\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_30\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = 0;
                        -- 	num = (UInt16)((Int32)(num) + 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num = (UInt16)((Int32)(num) + 1);
                        -- 
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.31\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                        \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.num\ := (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.binaryOperationResult.31\);
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_30\.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_32\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_31\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_33\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.result\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.array\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_2\.
                            if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ = \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_33\) then 
                                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State\ := \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\: \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._States\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_0\;
        Variable \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.right\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.flag\: boolean := false;
        Variable \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\ <= false;
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= false;
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_0\;
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.flag\ := false;
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.0\ := false;
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.1\ := false;
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.3\ := to_unsigned(0, 16);
            else 
                case \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ is 
                    when \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ = true) then 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\ <= false;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\ => 
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.left\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.left.parameter.In\;
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.right\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (Int32)(left.SegmentCount) != (Int32)(right.SegmentCount);
                        -- 
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.0\ := signed(SmartResize((\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.left\.\SegmentCount\), 32)) /= signed(SmartResize((\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.right\.\SegmentCount\), 32));
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.flag\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = new BitMask (left.Size, false);
                        -- }
                        -- else {
                        -- 	array = new uint[1];
                        -- 	num = 0;
                        -- 	while ((int)num < 1) {
                        -- 		array [(int)num] = left.Segments [(int)num] & right.Segments [(int)num];
                        -- 		num = (UInt16)((Int32)(num) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_4\ and ends in state \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_5\.
                        --     * The false branch starts in state \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\ and ends in state \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_9\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_3\.

                        if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.flag\) then 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_4\;
                        else 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.33405
                    when \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.return\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\;
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new BitMask (left.Size, false);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (left.Size, false);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\IsNull\ := false;
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\;
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.left\.\Size\;
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\.
                            if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ = \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_5\) then 
                                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array = new uint[1];
                        -- 	num = 0;
                        -- 	while ((int)num < 1) {
                        -- 		array [(int)num] = left.Segments [(int)num] & right.Segments [(int)num];
                        -- 		num = (UInt16)((Int32)(num) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)num < 1) {
                        -- 	array [(int)num] = left.Segments [(int)num] & right.Segments [(int)num];
                        -- 	num = (UInt16)((Int32)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\.
                        -- The while loop's condition:
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.1\ := signed(SmartResize(\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\, 32)) < to_signed(1, 32);
                        if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	array [(int)num] = left.Segments [(int)num] & right.Segments [(int)num];
                            -- 	num = (UInt16)((Int32)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array [(int)num] = left.Segments [(int)num] & right.Segments [(int)num];
                            -- 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.2\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.left\.\Segments\(to_integer(signed(SmartResize(\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\, 32)))) and \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.right\.\Segments\(to_integer(signed(SmartResize(\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\, 32))));
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\, 32)))) := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = (UInt16)((Int32)(num) + 1);
                            -- 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.3\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.num\ := (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.binaryOperationResult.3\);
                        else 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.99285
                    when \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_8\ => 
                        -- State after the while loop which was started in state \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\IsNull\ := false;
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\;
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\;
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.result\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.array\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_2\.
                            if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ = \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_9\) then 
                                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State\ := \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask).0 state machine start
    \BitMask BitMask::op_OnesComplement(BitMask).0._StateMachine\: process (\Clock\) 
        Variable \BitMask BitMask::op_OnesComplement(BitMask).0._State\: \BitMask BitMask::op_OnesComplement(BitMask).0._States\ := \BitMask BitMask::op_OnesComplement(BitMask).0._State_0\;
        Variable \BitMask BitMask::op_OnesComplement(BitMask).0.input\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_OnesComplement(BitMask).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask BitMask::op_OnesComplement(BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask BitMask::op_OnesComplement(BitMask).0.unaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.1\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask BitMask::op_OnesComplement(BitMask).0._Finished\ <= false;
                \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask BitMask::op_OnesComplement(BitMask).0._State_0\;
                \BitMask BitMask::op_OnesComplement(BitMask).0.array\ := (others => to_unsigned(0, 32));
                \BitMask BitMask::op_OnesComplement(BitMask).0.num\ := to_unsigned(0, 16);
                \BitMask BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.0\ := false;
                \BitMask BitMask::op_OnesComplement(BitMask).0.unaryOperationResult.0\ := to_unsigned(0, 32);
                \BitMask BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.1\ := to_unsigned(0, 16);
            else 
                case \BitMask BitMask::op_OnesComplement(BitMask).0._State\ is 
                    when \BitMask BitMask::op_OnesComplement(BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask BitMask::op_OnesComplement(BitMask).0._Started\ = true) then 
                            \BitMask BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask BitMask::op_OnesComplement(BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_OnesComplement(BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask BitMask::op_OnesComplement(BitMask).0._Started\ = true) then 
                            \BitMask BitMask::op_OnesComplement(BitMask).0._Finished\ <= true;
                        else 
                            \BitMask BitMask::op_OnesComplement(BitMask).0._Finished\ <= false;
                            \BitMask BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask BitMask::op_OnesComplement(BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_OnesComplement(BitMask).0._State_2\ => 
                        \BitMask BitMask::op_OnesComplement(BitMask).0.input\ := \BitMask BitMask::op_OnesComplement(BitMask).0.input.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask BitMask::op_OnesComplement(BitMask).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \BitMask BitMask::op_OnesComplement(BitMask).0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)num < 1) {
                        -- 	array [(int)num] = ~input.Segments [(int)num];
                        -- 	num = (UInt16)((Int32)(num) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask BitMask::op_OnesComplement(BitMask).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_OnesComplement(BitMask).0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \BitMask BitMask::op_OnesComplement(BitMask).0._State_2\.
                        -- The while loop's condition:
                        \BitMask BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.0\ := signed(SmartResize(\BitMask BitMask::op_OnesComplement(BitMask).0.num\, 32)) < to_signed(1, 32);
                        if (\BitMask BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	array [(int)num] = ~input.Segments [(int)num];
                            -- 	num = (UInt16)((Int32)(num) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- array [(int)num] = ~input.Segments [(int)num];
                            -- 
                            \BitMask BitMask::op_OnesComplement(BitMask).0.unaryOperationResult.0\ := not(\BitMask BitMask::op_OnesComplement(BitMask).0.input\.\Segments\(to_integer(signed(SmartResize(\BitMask BitMask::op_OnesComplement(BitMask).0.num\, 32)))));
                            \BitMask BitMask::op_OnesComplement(BitMask).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_OnesComplement(BitMask).0.num\, 32)))) := \BitMask BitMask::op_OnesComplement(BitMask).0.unaryOperationResult.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = (UInt16)((Int32)(num) + 1);
                            -- 
                            \BitMask BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.1\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_OnesComplement(BitMask).0.num\), 32)) + to_signed(1, 32)), 16);
                            \BitMask BitMask::op_OnesComplement(BitMask).0.num\ := (\BitMask BitMask::op_OnesComplement(BitMask).0.binaryOperationResult.1\);
                        else 
                            \BitMask BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask BitMask::op_OnesComplement(BitMask).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9834
                    when \BitMask BitMask::op_OnesComplement(BitMask).0._State_4\ => 
                        -- State after the while loop which was started in state \BitMask BitMask::op_OnesComplement(BitMask).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4 = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\.\IsNull\ := false;
                        \BitMask BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\.\Size\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\;
                        \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask BitMask::op_OnesComplement(BitMask).0.array\;
                        \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask BitMask::op_OnesComplement(BitMask).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_OnesComplement(BitMask).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\ := \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask BitMask::op_OnesComplement(BitMask).0.array\ := \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4;
                            -- 
                            \BitMask BitMask::op_OnesComplement(BitMask).0.return\ <= \BitMask BitMask::op_OnesComplement(BitMask).0.object3d608b4bdb7df633a7610401d1ebae0f8dedd195acafb0ba0ee9c5952c7fc9c4\;
                            \BitMask BitMask::op_OnesComplement(BitMask).0._State\ := \BitMask BitMask::op_OnesComplement(BitMask).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0 state machine start
    \BitMask BitMask::op_RightShift(BitMask,Int32).0._StateMachine\: process (\Clock\) 
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\: \BitMask BitMask::op_RightShift(BitMask,Int32).0._States\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_0\;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.right\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag\: boolean := false;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag2\: boolean := false;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.num4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag3\: boolean := false;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag4\: boolean := false;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.unaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.2\: boolean := false;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.7\: boolean := false;
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.10\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.11\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask BitMask::op_RightShift(BitMask,Int32).0._Finished\ <= false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_0\;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.right\ := to_signed(0, 32);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag\ := false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.num\ := to_unsigned(0, 32);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.array\ := (others => to_unsigned(0, 32));
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.num2\ := to_unsigned(0, 16);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag2\ := false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.num3\ := to_unsigned(0, 16);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.num4\ := to_unsigned(0, 16);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag3\ := false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag4\ := false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.0\ := false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.unaryOperationResult.0\ := to_signed(0, 32);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.1\ := false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.2\ := false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.3\ := to_unsigned(0, 16);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605\ := to_unsigned(0, 32);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.4\ := to_unsigned(0, 32);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.7\ := false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.9\ := to_unsigned(0, 32);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.10\ := to_unsigned(0, 16);
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.11\ := to_unsigned(0, 16);
            else 
                case \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ is 
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ = true) then 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ = true) then 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._Finished\ <= true;
                        else 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._Finished\ <= false;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_2\ => 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.left\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\;
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.right\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = right < 0;
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.0\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.right\ < to_signed(0, 32);
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = BitMask.op_LeftShift (left, -right);
                        -- }
                        -- else {
                        -- 	num = 2147483648u;
                        -- 	array = new uint[1];
                        -- 	System.Array.Copy (left.Segments, array, 1);
                        -- 	num2 = 0;
                        -- 	while ((int)num2 < right) {
                        -- 		flag2 = false;
                        -- 		num3 = 1;
                        -- 		while ((int)num3 <= 1) {
                        -- 			num4 = (ushort)(1 - (int)num3);
                        -- 			UInt32 remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                        -- 			remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                        -- 			flag3 = remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                        -- 			array [(int)num4] = array [(int)num4] >> 1;
                        -- 			flag4 = flag2;
                        -- 			if (flag4) {
                        -- 				array [(int)num4] = array [(int)num4] | num;
                        -- 			}
                        -- 			flag2 = flag3;
                        -- 			num3 = (UInt16)((Int32)(num3) + 1);
                        -- 		}
                        -- 		num2 = (UInt16)((Int32)(num2) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_4\ and ends in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_5\.
                        --     * The false branch starts in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_6\ and ends in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_15\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_3\.

                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0.flag\) then 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_4\;
                        else 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.46515
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.return\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.result\;
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = BitMask.op_LeftShift (left, -right);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = BitMask.op_LeftShift (left, -right);
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.unaryOperationResult.0\ := -\BitMask BitMask::op_RightShift(BitMask,Int32).0.right\;
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.left\;
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.unaryOperationResult.0\;
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.3369
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.return.0\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.result\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.return.0\;
                            -- Going to the state after the if-else which was started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_2\.
                            if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ = \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_5\) then 
                                \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 2147483648u;
                        -- 	array = new uint[1];
                        -- 	System.Array.Copy (left.Segments, array, 1);
                        -- 	num2 = 0;
                        -- 	while ((int)num2 < right) {
                        -- 		flag2 = false;
                        -- 		num3 = 1;
                        -- 		while ((int)num3 <= 1) {
                        -- 			num4 = (ushort)(1 - (int)num3);
                        -- 			UInt32 remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                        -- 			remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                        -- 			flag3 = remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                        -- 			array [(int)num4] = array [(int)num4] >> 1;
                        -- 			flag4 = flag2;
                        -- 			if (flag4) {
                        -- 				array [(int)num4] = array [(int)num4] | num;
                        -- 			}
                        -- 			flag2 = flag3;
                        -- 			num3 = (UInt16)((Int32)(num3) + 1);
                        -- 		}
                        -- 		num2 = (UInt16)((Int32)(num2) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.num\ := "10000000000000000000000000000000";
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- System.Array.Copy (left.Segments, array, 1);
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.array\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.left\.\Segments\(0 to 0);
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 0;
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.num2\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)num2 < right) {
                        -- 	flag2 = false;
                        -- 	num3 = 1;
                        -- 	while ((int)num3 <= 1) {
                        -- 		num4 = (ushort)(1 - (int)num3);
                        -- 		UInt32 remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                        -- 		remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                        -- 		flag3 = remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                        -- 		array [(int)num4] = array [(int)num4] >> 1;
                        -- 		flag4 = flag2;
                        -- 		if (flag4) {
                        -- 			array [(int)num4] = array [(int)num4] | num;
                        -- 		}
                        -- 		flag2 = flag3;
                        -- 		num3 = (UInt16)((Int32)(num3) + 1);
                        -- 	}
                        -- 	num2 = (UInt16)((Int32)(num2) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_6\.
                        -- The while loop's condition:
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.1\ := signed(SmartResize(\BitMask BitMask::op_RightShift(BitMask,Int32).0.num2\, 32)) < \BitMask BitMask::op_RightShift(BitMask,Int32).0.right\;
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag2 = false;
                            -- 	num3 = 1;
                            -- 	while ((int)num3 <= 1) {
                            -- 		num4 = (ushort)(1 - (int)num3);
                            -- 		UInt32 remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                            -- 		remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                            -- 		flag3 = remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                            -- 		array [(int)num4] = array [(int)num4] >> 1;
                            -- 		flag4 = flag2;
                            -- 		if (flag4) {
                            -- 			array [(int)num4] = array [(int)num4] | num;
                            -- 		}
                            -- 		flag2 = flag3;
                            -- 		num3 = (UInt16)((Int32)(num3) + 1);
                            -- 	}
                            -- 	num2 = (UInt16)((Int32)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = false;
                            -- 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag2\ := False;
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = 1;
                            -- 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.num3\ := to_unsigned(1, 16);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((int)num3 <= 1) {
                            -- 	num4 = (ushort)(1 - (int)num3);
                            -- 	UInt32 remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                            -- 	remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                            -- 	flag3 = remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                            -- 	array [(int)num4] = array [(int)num4] >> 1;
                            -- 	flag4 = flag2;
                            -- 	if (flag4) {
                            -- 		array [(int)num4] = array [(int)num4] | num;
                            -- 	}
                            -- 	flag2 = flag3;
                            -- 	num3 = (UInt16)((Int32)(num3) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_9\;
                        else 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.46515
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_8\ => 
                        -- State after the while loop which was started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.result\.\IsNull\ := false;
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.result\;
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.array\;
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_15\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_7\.
                        -- The while loop's condition:
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.2\ := signed(SmartResize(\BitMask BitMask::op_RightShift(BitMask,Int32).0.num3\, 32)) <= to_signed(1, 32);
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num4 = (ushort)(1 - (int)num3);
                            -- 	UInt32 remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                            -- 	remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                            -- 	flag3 = remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                            -- 	array [(int)num4] = array [(int)num4] >> 1;
                            -- 	flag4 = flag2;
                            -- 	if (flag4) {
                            -- 		array [(int)num4] = array [(int)num4] | num;
                            -- 	}
                            -- 	flag2 = flag3;
                            -- 	num3 = (UInt16)((Int32)(num3) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = (ushort)(1 - (int)num3);
                            -- 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.3\ := SmartResize(unsigned(to_signed(1, 32) - signed(SmartResize(\BitMask BitMask::op_RightShift(BitMask,Int32).0.num3\, 32))), 16);
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.num4\ := (\BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.3\);
                            -- The following section was transformed from the .NET statement below:
                            -- UInt32 remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 = array [(int)num4];
                            -- 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_RightShift(BitMask,Int32).0.num4\, 32))));
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 - remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605 / 2u * 2u == 1u;
                            -- 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_11\;
                        else 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.89265
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_10\ => 
                        -- State after the while loop which was started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (UInt16)((Int32)(num2) + 1);
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.11\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_RightShift(BitMask,Int32).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.num2\ := (\BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.11\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_6\ if the loop wasn't exited with a state change.
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ = \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_10\) then 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.4\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605\ / to_unsigned(2, 32);
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.5\ := SmartResize(\BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.4\ * to_unsigned(2, 32), 32);
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.6\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.remainderOperand56_5A3058d7e52207882dacedf7f38c35eec6a3142616fd83e5e5f1410c2aa0076605\ - \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.5\;
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.7\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.6\ = to_unsigned(1, 32);
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag3\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num4] = array [(int)num4] >> 1;
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0.98685
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_12\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.8\ := shift_right(\BitMask BitMask::op_RightShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_RightShift(BitMask,Int32).0.num4\, 32)))), to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_RightShift(BitMask,Int32).0.num4\, 32)))) := \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.8\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = flag2;
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag4\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag2\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	array [(int)num4] = array [(int)num4] | num;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_14\ and ends in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_14\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_13\.

                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0.flag4\) then 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_14\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.288
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_13\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = flag3;
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag2\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.flag3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (UInt16)((Int32)(num3) + 1);
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.10\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_RightShift(BitMask,Int32).0.num3\), 32)) + to_signed(1, 32)), 16);
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.num3\ := (\BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.10\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_7\ if the loop wasn't exited with a state change.
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ = \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_13\) then 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_14\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [(int)num4] = array [(int)num4] | num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num4] = array [(int)num4] | num;
                        -- 
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.9\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_RightShift(BitMask,Int32).0.num4\, 32)))) or \BitMask BitMask::op_RightShift(BitMask,Int32).0.num\;
                        \BitMask BitMask::op_RightShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_RightShift(BitMask,Int32).0.num4\, 32)))) := \BitMask BitMask::op_RightShift(BitMask,Int32).0.binaryOperationResult.9\;
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_12\.
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ = \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_14\) then 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1296
                    when \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.result\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.array\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_2\.
                            if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ = \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_15\) then 
                                \BitMask BitMask::op_RightShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_RightShift(BitMask,Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0 state machine start
    \BitMask BitMask::op_LeftShift(BitMask,Int32).0._StateMachine\: process (\Clock\) 
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\: \BitMask BitMask::op_LeftShift(BitMask,Int32).0._States\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_0\;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag\: boolean := false;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.array\: \unsigned32_Array\(0 to 0) := (others => to_unsigned(0, 32));
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag2\: boolean := false;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag3\: boolean := false;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag4\: boolean := false;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.unaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.1\: boolean := false;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.2\: boolean := false;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.4\: boolean := false;
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\ <= false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_0\;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right\ := to_signed(0, 32);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag\ := false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num\ := to_unsigned(0, 32);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num2\ := to_unsigned(0, 32);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.array\ := (others => to_unsigned(0, 32));
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num3\ := to_unsigned(0, 16);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag2\ := false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num4\ := to_unsigned(0, 16);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag3\ := false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag4\ := false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.0\ := false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.unaryOperationResult.0\ := to_signed(0, 32);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.1\ := false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.2\ := false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.4\ := false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.6\ := to_unsigned(0, 32);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.7\ := to_unsigned(0, 16);
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.8\ := to_unsigned(0, 16);
            else 
                case \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ is 
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ = true) then 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ = true) then 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\ <= true;
                        else 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\ <= false;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_2\ => 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\;
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint[] array;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = right < 0;
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.0\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right\ < to_signed(0, 32);
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = BitMask.op_RightShift (left, -right);
                        -- }
                        -- else {
                        -- 	num = 2147483648u;
                        -- 	num2 = 1u;
                        -- 	array = new uint[1];
                        -- 	System.Array.Copy (left.Segments, array, 1);
                        -- 	num3 = 0;
                        -- 	while ((int)num3 < right) {
                        -- 		flag2 = false;
                        -- 		num4 = 0;
                        -- 		while ((int)num4 < 1) {
                        -- 			flag3 = array [(int)num4] & num == num;
                        -- 			array [(int)num4] = array [(int)num4] << 1;
                        -- 			flag4 = flag2;
                        -- 			if (flag4) {
                        -- 				array [(int)num4] = array [(int)num4] | num2;
                        -- 			}
                        -- 			flag2 = flag3;
                        -- 			num4 = (UInt16)((Int32)(num4) + 1);
                        -- 		}
                        -- 		num3 = (UInt16)((Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_4\ and ends in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_5\.
                        --     * The false branch starts in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_6\ and ends in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_14\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_3\.

                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag\) then 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_4\;
                        else 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.46515
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_3\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.result\;
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_4\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = BitMask.op_RightShift (left, -right);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = BitMask.op_RightShift (left, -right);
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.unaryOperationResult.0\ := -\BitMask BitMask::op_LeftShift(BitMask,Int32).0.right\;
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left\;
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.unaryOperationResult.0\;
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0.3369
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return.0\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.result\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return.0\;
                            -- Going to the state after the if-else which was started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_2\.
                            if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ = \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_5\) then 
                                \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_6\ => 
                        -- False branch of the if-else started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num = 2147483648u;
                        -- 	num2 = 1u;
                        -- 	array = new uint[1];
                        -- 	System.Array.Copy (left.Segments, array, 1);
                        -- 	num3 = 0;
                        -- 	while ((int)num3 < right) {
                        -- 		flag2 = false;
                        -- 		num4 = 0;
                        -- 		while ((int)num4 < 1) {
                        -- 			flag3 = array [(int)num4] & num == num;
                        -- 			array [(int)num4] = array [(int)num4] << 1;
                        -- 			flag4 = flag2;
                        -- 			if (flag4) {
                        -- 				array [(int)num4] = array [(int)num4] | num2;
                        -- 			}
                        -- 			flag2 = flag3;
                        -- 			num4 = (UInt16)((Int32)(num4) + 1);
                        -- 		}
                        -- 		num3 = (UInt16)((Int32)(num3) + 1);
                        -- 	}
                        -- 	result = new BitMask (array, 0);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 2147483648u;
                        -- 
                        -- Since the integer literal 2147483648 was out of the VHDL integer range it was substituted with a binary literal (10000000000000000000000000000000).
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num\ := "10000000000000000000000000000000";
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 1u;
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num2\ := to_unsigned(1, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- array = new uint[1];
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.array\ := (others => to_unsigned(0, 32));
                        -- The following section was transformed from the .NET statement below:
                        -- System.Array.Copy (left.Segments, array, 1);
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.array\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left\.\Segments\(0 to 0);
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = 0;
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num3\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((int)num3 < right) {
                        -- 	flag2 = false;
                        -- 	num4 = 0;
                        -- 	while ((int)num4 < 1) {
                        -- 		flag3 = array [(int)num4] & num == num;
                        -- 		array [(int)num4] = array [(int)num4] << 1;
                        -- 		flag4 = flag2;
                        -- 		if (flag4) {
                        -- 			array [(int)num4] = array [(int)num4] | num2;
                        -- 		}
                        -- 		flag2 = flag3;
                        -- 		num4 = (UInt16)((Int32)(num4) + 1);
                        -- 	}
                        -- 	num3 = (UInt16)((Int32)(num3) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_7\ => 
                        -- Repeated state of the while loop which was started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_6\.
                        -- The while loop's condition:
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.1\ := signed(SmartResize(\BitMask BitMask::op_LeftShift(BitMask,Int32).0.num3\, 32)) < \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right\;
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.1\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag2 = false;
                            -- 	num4 = 0;
                            -- 	while ((int)num4 < 1) {
                            -- 		flag3 = array [(int)num4] & num == num;
                            -- 		array [(int)num4] = array [(int)num4] << 1;
                            -- 		flag4 = flag2;
                            -- 		if (flag4) {
                            -- 			array [(int)num4] = array [(int)num4] | num2;
                            -- 		}
                            -- 		flag2 = flag3;
                            -- 		num4 = (UInt16)((Int32)(num4) + 1);
                            -- 	}
                            -- 	num3 = (UInt16)((Int32)(num3) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = false;
                            -- 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag2\ := False;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 0;
                            -- 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num4\ := to_unsigned(0, 16);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((int)num4 < 1) {
                            -- 	flag3 = array [(int)num4] & num == num;
                            -- 	array [(int)num4] = array [(int)num4] << 1;
                            -- 	flag4 = flag2;
                            -- 	if (flag4) {
                            -- 		array [(int)num4] = array [(int)num4] | num2;
                            -- 	}
                            -- 	flag2 = flag3;
                            -- 	num4 = (UInt16)((Int32)(num4) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_9\;
                        else 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.46515
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_8\ => 
                        -- State after the while loop which was started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_6\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = new BitMask (array, 0);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.result\.\IsNull\ := false;
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.result\.\Size\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.result\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.result\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.result\;
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.array\;
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= true;
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_9\ => 
                        -- Repeated state of the while loop which was started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_7\.
                        -- The while loop's condition:
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.2\ := signed(SmartResize(\BitMask BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)) < to_signed(1, 32);
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag3 = array [(int)num4] & num == num;
                            -- 	array [(int)num4] = array [(int)num4] << 1;
                            -- 	flag4 = flag2;
                            -- 	if (flag4) {
                            -- 		array [(int)num4] = array [(int)num4] | num2;
                            -- 	}
                            -- 	flag2 = flag3;
                            -- 	num4 = (UInt16)((Int32)(num4) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = array [(int)num4] & num == num;
                            -- 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.3\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)))) and \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.4\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.3\ = \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag3\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- array [(int)num4] = array [(int)num4] << 1;
                            -- 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_11\;
                        else 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.92835
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_10\ => 
                        -- State after the while loop which was started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (UInt16)((Int32)(num3) + 1);
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.8\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_LeftShift(BitMask,Int32).0.num3\), 32)) + to_signed(1, 32)), 16);
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num3\ := (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.8\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_6\ if the loop wasn't exited with a state change.
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ = \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_10\) then 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_11\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.5\ := shift_left(\BitMask BitMask::op_LeftShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)))), to_integer(unsigned(SmartResize(to_signed(1, 32), 5))));
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)))) := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = flag2;
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag4\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag2\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	array [(int)num4] = array [(int)num4] | num2;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_13\ and ends in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_13\.
                        --     * Execution after either branch will continue in the following state: \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_12\.

                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag4\) then 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_13\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1521
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_12\ => 
                        -- State after the if-else which was started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag2 = flag3;
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag2\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.flag3\;
                        -- The following section was transformed from the .NET statement below:
                        -- num4 = (UInt16)((Int32)(num4) + 1);
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.7\ := SmartResize(unsigned(signed(SmartResize((\BitMask BitMask::op_LeftShift(BitMask,Int32).0.num4\), 32)) + to_signed(1, 32)), 16);
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num4\ := (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.7\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_7\ if the loop wasn't exited with a state change.
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ = \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_12\) then 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_13\ => 
                        -- True branch of the if-else started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	array [(int)num4] = array [(int)num4] | num2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- array [(int)num4] = array [(int)num4] | num2;
                        -- 
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.6\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)))) or \BitMask BitMask::op_LeftShift(BitMask,Int32).0.num2\;
                        \BitMask BitMask::op_LeftShift(BitMask,Int32).0.array\(to_integer(signed(SmartResize(\BitMask BitMask::op_LeftShift(BitMask,Int32).0.num4\, 32)))) := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.binaryOperationResult.6\;
                        -- Going to the state after the if-else which was started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_11\.
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ = \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_13\) then 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1296
                    when \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16)
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\) then 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ <= false;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.result\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.array\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_2\.
                            if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ = \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_14\) then 
                                \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State\ := \BitMask BitMask::op_LeftShift(BitMask,Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0 state machine end


    -- System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition().0 state machine start
    \BitMask::GetMostSignificantOnePosition().0._StateMachine\: process (\Clock\) 
        Variable \BitMask::GetMostSignificantOnePosition().0._State\: \BitMask::GetMostSignificantOnePosition().0._States\ := \BitMask::GetMostSignificantOnePosition().0._State_0\;
        Variable \BitMask::GetMostSignificantOnePosition().0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetMostSignificantOnePosition().0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetMostSignificantOnePosition().0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetMostSignificantOnePosition().0.num3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::GetMostSignificantOnePosition().0.flag\: boolean := false;
        Variable \BitMask::GetMostSignificantOnePosition().0.result\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.0\: boolean := false;
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.2\: boolean := false;
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.5\: boolean := false;
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.9\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::GetMostSignificantOnePosition().0._Finished\ <= false;
                \BitMask::GetMostSignificantOnePosition().0.return\ <= to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_0\;
                \BitMask::GetMostSignificantOnePosition().0.num\ := to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0.num2\ := to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0.num3\ := to_unsigned(0, 32);
                \BitMask::GetMostSignificantOnePosition().0.flag\ := false;
                \BitMask::GetMostSignificantOnePosition().0.result\ := to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.0\ := false;
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.2\ := false;
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.3\ := to_unsigned(0, 32);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.4\ := to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.5\ := false;
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.6\ := to_signed(0, 32);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.7\ := to_signed(0, 32);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.8\ := to_unsigned(0, 16);
                \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.9\ := to_unsigned(0, 16);
            else 
                case \BitMask::GetMostSignificantOnePosition().0._State\ is 
                    when \BitMask::GetMostSignificantOnePosition().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::GetMostSignificantOnePosition().0._Started\ = true) then 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetMostSignificantOnePosition().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::GetMostSignificantOnePosition().0._Started\ = true) then 
                            \BitMask::GetMostSignificantOnePosition().0._Finished\ <= true;
                        else 
                            \BitMask::GetMostSignificantOnePosition().0._Finished\ <= false;
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetMostSignificantOnePosition().0._State_2\ => 
                        \BitMask::GetMostSignificantOnePosition().0.this\ := \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 0;
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.num\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = 1;
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.num2\ := to_unsigned(1, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- while ((Int32)(num2) <= (Int32)(@this.SegmentCount)) {
                        -- 	num3 = @this.Segments [(int)((Int32)(@this.SegmentCount) - (Int32)(num2))];
                        -- 	while (num3 > 0u) {
                        -- 		num3 = num3 >> 1;
                        -- 		num = (UInt16)((Int32)(num) + 1);
                        -- 		flag = num3 == 0u;
                        -- 		if (flag) {
                        -- 			result = (UInt16)((Int32)((Int32)((Int32)(@this.SegmentCount) - (Int32)(num2)) * 32) + (Int32)(num));
                        -- 			return result;
                        -- 		}
                        -- 	}
                        -- 	num2 = (UInt16)((Int32)(num2) + 1);
                        -- }
                        -- 
                        -- Starting a while loop.
                        \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetMostSignificantOnePosition().0._State_3\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_2\.
                        -- The while loop's condition:
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.0\ := signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num2\), 32)) <= signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.this\.\SegmentCount\), 32));
                        if (\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.0\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num3 = @this.Segments [(int)((Int32)(@this.SegmentCount) - (Int32)(num2))];
                            -- 	while (num3 > 0u) {
                            -- 		num3 = num3 >> 1;
                            -- 		num = (UInt16)((Int32)(num) + 1);
                            -- 		flag = num3 == 0u;
                            -- 		if (flag) {
                            -- 			result = (UInt16)((Int32)((Int32)((Int32)(@this.SegmentCount) - (Int32)(num2)) * 32) + (Int32)(num));
                            -- 			return result;
                            -- 		}
                            -- 	}
                            -- 	num2 = (UInt16)((Int32)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = @this.Segments [(int)((Int32)(@this.SegmentCount) - (Int32)(num2))];
                            -- 
                            \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.1\ := signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.this\.\SegmentCount\), 32)) - signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num2\), 32));
                            \BitMask::GetMostSignificantOnePosition().0.num3\ := \BitMask::GetMostSignificantOnePosition().0.this\.\Segments\(to_integer((\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.1\)));
                            -- The following section was transformed from the .NET statement below:
                            -- while (num3 > 0u) {
                            -- 	num3 = num3 >> 1;
                            -- 	num = (UInt16)((Int32)(num) + 1);
                            -- 	flag = num3 == 0u;
                            -- 	if (flag) {
                            -- 		result = (UInt16)((Int32)((Int32)((Int32)(@this.SegmentCount) - (Int32)(num2)) * 32) + (Int32)(num));
                            -- 		return result;
                            -- 	}
                            -- }
                            -- 
                            -- Starting a while loop.
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_5\;
                        else 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.89265
                    when \BitMask::GetMostSignificantOnePosition().0._State_4\ => 
                        -- State after the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = 0;
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.result\ := to_unsigned(0, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- return 0;
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.return\ <= to_unsigned(0, 16);
                        \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetMostSignificantOnePosition().0._State_5\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_3\.
                        -- The while loop's condition:
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.2\ := \BitMask::GetMostSignificantOnePosition().0.num3\ > to_unsigned(0, 32);
                        if (\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.2\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num3 = num3 >> 1;
                            -- 	num = (UInt16)((Int32)(num) + 1);
                            -- 	flag = num3 == 0u;
                            -- 	if (flag) {
                            -- 		result = (UInt16)((Int32)((Int32)((Int32)(@this.SegmentCount) - (Int32)(num2)) * 32) + (Int32)(num));
                            -- 		return result;
                            -- 	}
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num3 = num3 >> 1;
                            -- 
                            \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.3\ := shift_right(\BitMask::GetMostSignificantOnePosition().0.num3\, to_integer(unsigned(SmartResize(to_signed(1, 32), 5) and "11111")));
                            \BitMask::GetMostSignificantOnePosition().0.num3\ := \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = (UInt16)((Int32)(num) + 1);
                            -- 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_7\;
                        else 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.79335
                    when \BitMask::GetMostSignificantOnePosition().0._State_6\ => 
                        -- State after the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (UInt16)((Int32)(num2) + 1);
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.9\ := SmartResize(unsigned(signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num2\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::GetMostSignificantOnePosition().0.num2\ := (\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.9\);
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_2\ if the loop wasn't exited with a state change.
                        if (\BitMask::GetMostSignificantOnePosition().0._State\ = \BitMask::GetMostSignificantOnePosition().0._State_6\) then 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_3\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \BitMask::GetMostSignificantOnePosition().0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.4\ := SmartResize(unsigned(signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num\), 32)) + to_signed(1, 32)), 16);
                        \BitMask::GetMostSignificantOnePosition().0.num\ := (\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.4\);
                        -- The following section was transformed from the .NET statement below:
                        -- flag = num3 == 0u;
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.5\ := \BitMask::GetMostSignificantOnePosition().0.num3\ = to_unsigned(0, 32);
                        \BitMask::GetMostSignificantOnePosition().0.flag\ := \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.5\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = (UInt16)((Int32)((Int32)((Int32)(@this.SegmentCount) - (Int32)(num2)) * 32) + (Int32)(num));
                        -- 	return result;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::GetMostSignificantOnePosition().0._State_9\ and ends in state \BitMask::GetMostSignificantOnePosition().0._State_9\.
                        --     * Execution after either branch will continue in the following state: \BitMask::GetMostSignificantOnePosition().0._State_8\.

                        if (\BitMask::GetMostSignificantOnePosition().0.flag\) then 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_9\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7317
                    when \BitMask::GetMostSignificantOnePosition().0._State_8\ => 
                        -- State after the if-else which was started in state \BitMask::GetMostSignificantOnePosition().0._State_7\.
                        -- Returning to the repeated state of the while loop which was started in state \BitMask::GetMostSignificantOnePosition().0._State_3\ if the loop wasn't exited with a state change.
                        if (\BitMask::GetMostSignificantOnePosition().0._State\ = \BitMask::GetMostSignificantOnePosition().0._State_8\) then 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetMostSignificantOnePosition().0._State_9\ => 
                        -- True branch of the if-else started in state \BitMask::GetMostSignificantOnePosition().0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = (UInt16)((Int32)((Int32)((Int32)(@this.SegmentCount) - (Int32)(num2)) * 32) + (Int32)(num));
                        -- 	return result;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = (UInt16)((Int32)((Int32)((Int32)(@this.SegmentCount) - (Int32)(num2)) * 32) + (Int32)(num));
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.6\ := signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.this\.\SegmentCount\), 32)) - signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num2\), 32));
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.7\ := SmartResize((\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.6\) * to_signed(32, 32), 32);
                        \BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.8\ := SmartResize(unsigned((\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.7\) + signed(SmartResize((\BitMask::GetMostSignificantOnePosition().0.num\), 32))), 16);
                        \BitMask::GetMostSignificantOnePosition().0.result\ := (\BitMask::GetMostSignificantOnePosition().0.binaryOperationResult.8\);
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::GetMostSignificantOnePosition().0.return\ <= \BitMask::GetMostSignificantOnePosition().0.result\;
                        \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_1\;
                        -- Going to the state after the if-else which was started in state \BitMask::GetMostSignificantOnePosition().0._State_7\.
                        if (\BitMask::GetMostSignificantOnePosition().0._State\ = \BitMask::GetMostSignificantOnePosition().0._State_9\) then 
                            \BitMask::GetMostSignificantOnePosition().0._State\ := \BitMask::GetMostSignificantOnePosition().0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.89925
                end case;
            end if;
        end if;
    end process;
    -- System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0 state machine start
    \BitMask::GetTwosComplement(UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::GetTwosComplement(UInt16).0._State\: \BitMask::GetTwosComplement(UInt16).0._States\ := \BitMask::GetTwosComplement(UInt16).0._State_0\;
        Variable \BitMask::GetTwosComplement(UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetTwosComplement(UInt16).0.size\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::GetTwosComplement(UInt16).0.input\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetTwosComplement(UInt16).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetTwosComplement(UInt16).0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetTwosComplement(UInt16).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::GetTwosComplement(UInt16).0.return.3\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::GetTwosComplement(UInt16).0._Finished\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask)._Started.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_0\;
                \BitMask::GetTwosComplement(UInt16).0.size\ := to_unsigned(0, 16);
                \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.0\ := to_signed(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.2\ := to_signed(0, 32);
                \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.3\ := to_signed(0, 32);
            else 
                case \BitMask::GetTwosComplement(UInt16).0._State\ is 
                    when \BitMask::GetTwosComplement(UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::GetTwosComplement(UInt16).0._Started\ = true) then 
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetTwosComplement(UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::GetTwosComplement(UInt16).0._Started\ = true) then 
                            \BitMask::GetTwosComplement(UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::GetTwosComplement(UInt16).0._Finished\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetTwosComplement(UInt16).0._State_2\ => 
                        \BitMask::GetTwosComplement(UInt16).0.this\ := \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\;
                        \BitMask::GetTwosComplement(UInt16).0.size\ := \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask input;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- input = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::GetTwosComplement(UInt16).0.input\.\IsNull\ := false;
                        \BitMask::GetTwosComplement(UInt16).0.input\.\Size\ := to_unsigned(0, 16);
                        \BitMask::GetTwosComplement(UInt16).0.input\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::GetTwosComplement(UInt16).0.input\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.input\;
                        \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.this\;
                        \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetTwosComplement(UInt16).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0.input\ := \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::GetTwosComplement(UInt16).0.this\ := \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- return BitMask.op_RightShift (BitMask.op_LeftShift (BitMask.op_Addition (BitMask.op_OnesComplement (input), 1u), (int)((Int32)((Int32)(@this.SegmentCount) * 32) - 32)), (int)((Int32)((Int32)(@this.SegmentCount) * 32) - 32));
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask)
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask).input.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.input\;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask)._Started.0\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetTwosComplement(UInt16).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask)._Started.0\ = \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask)._Finished.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask)._Started.0\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0.return.0\ := \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.return.0\;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetTwosComplement(UInt16).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0.return.1\ := \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\BitMask::GetTwosComplement(UInt16).0.this\.\SegmentCount\), 32)) * to_signed(32, 32), 32);
                            \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.1\ := (\BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.0\) - to_signed(32, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.return.1\;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= (\BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.1\);
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50115
                    when \BitMask::GetTwosComplement(UInt16).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0.return.2\ := \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\BitMask::GetTwosComplement(UInt16).0.this\.\SegmentCount\), 32)) * to_signed(32, 32), 32);
                            \BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.3\ := (\BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.2\) - to_signed(32, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::GetTwosComplement(UInt16).0.return.2\;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= (\BitMask::GetTwosComplement(UInt16).0.binaryOperationResult.3\);
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50115
                    when \BitMask::GetTwosComplement(UInt16).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::GetTwosComplement(UInt16).0.return.3\ := \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\;
                            \BitMask::GetTwosComplement(UInt16).0.return\ <= \BitMask::GetTwosComplement(UInt16).0.return.3\;
                            \BitMask::GetTwosComplement(UInt16).0._State\ := \BitMask::GetTwosComplement(UInt16).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0 state machine end


    -- System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0 state machine start
    \BitMask::LengthOfRunOfBits(UInt16).0._StateMachine\: process (\Clock\) 
        Variable \BitMask::LengthOfRunOfBits(UInt16).0._State\: \BitMask::LengthOfRunOfBits(UInt16).0._States\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_0\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.this\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.flag\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.i\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.flag2\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.result\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.3\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.4\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.5\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.6\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.7\: boolean := false;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.8\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.10\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::LengthOfRunOfBits(UInt16).0._Finished\ <= false;
                \BitMask::LengthOfRunOfBits(UInt16).0.return\ <= to_unsigned(0, 16);
                \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_0\;
                \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition\ := to_unsigned(0, 16);
                \BitMask::LengthOfRunOfBits(UInt16).0.num\ := to_unsigned(0, 16);
                \BitMask::LengthOfRunOfBits(UInt16).0.flag\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.i\ := to_signed(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.flag2\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.result\ := to_unsigned(0, 16);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.0\ := to_signed(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.1\ := to_signed(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.2\ := to_unsigned(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.3\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.4\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.5\ := to_unsigned(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.6\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.7\ := false;
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.8\ := to_unsigned(0, 16);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.9\ := to_signed(0, 32);
                \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.10\ := false;
            else 
                case \BitMask::LengthOfRunOfBits(UInt16).0._State\ is 
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0._Started\ = true) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0._Started\ = true) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._Finished\ <= true;
                        else 
                            \BitMask::LengthOfRunOfBits(UInt16).0._Finished\ <= false;
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_2\ => 
                        \BitMask::LengthOfRunOfBits(UInt16).0.this\ := \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\;
                        \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition\ := \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask left;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int i;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num = 1;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.num\ := to_unsigned(1, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e = new BitMask (@this);
                        -- 
                        -- Initializing record fields to their defaults.
                        \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\.\IsNull\ := false;
                        \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\.\Size\ := to_unsigned(0, 16);
                        \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\.\SegmentCount\ := to_unsigned(0, 16);
                        \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\;
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.this\;
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= true;
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask)
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ <= false;
                            \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\ := \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.this\ := \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- left = BitMask.op_LeftShift (objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e, (int)((Int32)((Int32)(@this.SegmentCount) * 32) - 31));
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\BitMask::LengthOfRunOfBits(UInt16).0.this\.\SegmentCount\), 32)) * to_signed(32, 32), 32);
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.1\ := (\BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.0\) - to_signed(31, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.objectd79932c742a2f2351325bfd7adf891acc76d1fc3b56acef19497d27cf8455e5e\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= (\BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.1\);
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50115
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::LengthOfRunOfBits(UInt16).0.return.0\ := \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.left\ := \BitMask::LengthOfRunOfBits(UInt16).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag = left.Segments [0] >> 31 > 0u;
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.2\ := shift_right(\BitMask::LengthOfRunOfBits(UInt16).0.left\.\Segments\(to_integer(to_signed(0, 32))), to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.3\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.2\ > to_unsigned(0, 32);
                            \BitMask::LengthOfRunOfBits(UInt16).0.flag\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- left = BitMask.op_LeftShift (left, 1);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.82395
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_5\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_6\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.left\;
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(1, 32);
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::LengthOfRunOfBits(UInt16).0.return.1\ := \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.left\ := \BitMask::LengthOfRunOfBits(UInt16).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- i = 0;
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.i\ := to_signed(0, 32);
                            -- The following section was transformed from the .NET statement below:
                            -- while (i < (int)startingPosition) {
                            -- 	flag2 = left.Segments [0] >> 31 > 0u != flag;
                            -- 	if (flag2) {
                            -- 		result = num;
                            -- 		return result;
                            -- 	}
                            -- 	left = BitMask.op_LeftShift (left, 1);
                            -- 	num = (UInt16)((Int32)(num) + 1);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- Starting a while loop.
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_8\ => 
                        -- Repeated state of the while loop which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_7\.
                        -- The while loop's condition:
                        \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.4\ := \BitMask::LengthOfRunOfBits(UInt16).0.i\ < signed(SmartResize(\BitMask::LengthOfRunOfBits(UInt16).0.startingPosition\, 32));
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.4\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	flag2 = left.Segments [0] >> 31 > 0u != flag;
                            -- 	if (flag2) {
                            -- 		result = num;
                            -- 		return result;
                            -- 	}
                            -- 	left = BitMask.op_LeftShift (left, 1);
                            -- 	num = (UInt16)((Int32)(num) + 1);
                            -- 	i = i + 1;
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = left.Segments [0] >> 31 > 0u != flag;
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.5\ := shift_right(\BitMask::LengthOfRunOfBits(UInt16).0.left\.\Segments\(to_integer(to_signed(0, 32))), to_integer(unsigned(SmartResize(to_signed(31, 32), 5) and "11111")));
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_10\;
                        else 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.78375
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_9\ => 
                        -- State after the while loop which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- if ((Int32)(num) > 31) {
                        -- 	result = 31;
                        -- }
                        -- else {
                        -- 	result = num;
                        -- }
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.10\ := signed(SmartResize((\BitMask::LengthOfRunOfBits(UInt16).0.num\), 32)) > to_signed(31, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::LengthOfRunOfBits(UInt16).0._State_15\ and ends in state \BitMask::LengthOfRunOfBits(UInt16).0._State_15\.
                        --     * The false branch starts in state \BitMask::LengthOfRunOfBits(UInt16).0._State_16\ and ends in state \BitMask::LengthOfRunOfBits(UInt16).0._State_16\.
                        --     * Execution after either branch will continue in the following state: \BitMask::LengthOfRunOfBits(UInt16).0._State_14\.

                        if (\BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.10\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_15\;
                        else 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50535
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_10\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.6\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.5\ > to_unsigned(0, 32);
                        \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.7\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.6\ /= \BitMask::LengthOfRunOfBits(UInt16).0.flag\;
                        \BitMask::LengthOfRunOfBits(UInt16).0.flag2\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.7\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	result = num;
                        -- 	return result;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \BitMask::LengthOfRunOfBits(UInt16).0._State_12\ and ends in state \BitMask::LengthOfRunOfBits(UInt16).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \BitMask::LengthOfRunOfBits(UInt16).0._State_11\.

                        if (\BitMask::LengthOfRunOfBits(UInt16).0.flag2\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_12\;
                        else 
                            -- There was no false branch, so going directly to the state after the if-else.
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.62475
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_11\ => 
                        -- State after the if-else which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- left = BitMask.op_LeftShift (left, 1);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.left\;
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(1, 32);
                        \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_12\ => 
                        -- True branch of the if-else started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_10\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- 	return result;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.result\ := \BitMask::LengthOfRunOfBits(UInt16).0.num\;
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.return\ <= \BitMask::LengthOfRunOfBits(UInt16).0.result\;
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_1\;
                        -- Going to the state after the if-else which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_10\.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0._State\ = \BitMask::LengthOfRunOfBits(UInt16).0._State_12\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \BitMask::LengthOfRunOfBits(UInt16).0.return.2\ := \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.left\ := \BitMask::LengthOfRunOfBits(UInt16).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = (UInt16)((Int32)(num) + 1);
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.8\ := SmartResize(unsigned(signed(SmartResize((\BitMask::LengthOfRunOfBits(UInt16).0.num\), 32)) + to_signed(1, 32)), 16);
                            \BitMask::LengthOfRunOfBits(UInt16).0.num\ := (\BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.8\);
                            -- The following section was transformed from the .NET statement below:
                            -- i = i + 1;
                            -- 
                            \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.9\ := \BitMask::LengthOfRunOfBits(UInt16).0.i\ + to_signed(1, 32);
                            \BitMask::LengthOfRunOfBits(UInt16).0.i\ := \BitMask::LengthOfRunOfBits(UInt16).0.binaryOperationResult.9\;
                            -- Returning to the repeated state of the while loop which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_7\ if the loop wasn't exited with a state change.
                            if (\BitMask::LengthOfRunOfBits(UInt16).0._State\ = \BitMask::LengthOfRunOfBits(UInt16).0._State_13\) then 
                                \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_8\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7962
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_14\ => 
                        -- State after the if-else which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.return\ <= \BitMask::LengthOfRunOfBits(UInt16).0.result\;
                        \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_15\ => 
                        -- True branch of the if-else started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = 31;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = 31;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.result\ := to_unsigned(31, 16);
                        -- Going to the state after the if-else which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_9\.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0._State\ = \BitMask::LengthOfRunOfBits(UInt16).0._State_15\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::LengthOfRunOfBits(UInt16).0._State_16\ => 
                        -- False branch of the if-else started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = num;
                        -- 
                        \BitMask::LengthOfRunOfBits(UInt16).0.result\ := \BitMask::LengthOfRunOfBits(UInt16).0.num\;
                        -- Going to the state after the if-else which was started in state \BitMask::LengthOfRunOfBits(UInt16).0._State_9\.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0._State\ = \BitMask::LengthOfRunOfBits(UInt16).0._State_16\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0._State\ := \BitMask::LengthOfRunOfBits(UInt16).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits().0 state machine start
    \BitMask::GetLowest32Bits().0._StateMachine\: process (\Clock\) 
        Variable \BitMask::GetLowest32Bits().0._State\: \BitMask::GetLowest32Bits().0._States\ := \BitMask::GetLowest32Bits().0._State_0\;
        Variable \BitMask::GetLowest32Bits().0.this\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \BitMask::GetLowest32Bits().0._Finished\ <= false;
                \BitMask::GetLowest32Bits().0.return\ <= to_unsigned(0, 32);
                \BitMask::GetLowest32Bits().0._State\ := \BitMask::GetLowest32Bits().0._State_0\;
            else 
                case \BitMask::GetLowest32Bits().0._State\ is 
                    when \BitMask::GetLowest32Bits().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\BitMask::GetLowest32Bits().0._Started\ = true) then 
                            \BitMask::GetLowest32Bits().0._State\ := \BitMask::GetLowest32Bits().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetLowest32Bits().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\BitMask::GetLowest32Bits().0._Started\ = true) then 
                            \BitMask::GetLowest32Bits().0._Finished\ <= true;
                        else 
                            \BitMask::GetLowest32Bits().0._Finished\ <= false;
                            \BitMask::GetLowest32Bits().0._State\ := \BitMask::GetLowest32Bits().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \BitMask::GetLowest32Bits().0._State_2\ => 
                        \BitMask::GetLowest32Bits().0.this\ := \BitMask::GetLowest32Bits().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this.Segments [0];
                        -- 
                        \BitMask::GetLowest32Bits().0.return\ <= \BitMask::GetLowest32Bits().0.this\.\Segments\(to_integer(to_signed(0, 32)));
                        \BitMask::GetLowest32Bits().0._State\ := \BitMask::GetLowest32Bits().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits().0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask).0 state machine start
    \Posit::.ctor(PositEnvironment,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \Posit::.ctor(PositEnvironment,BitMask).0._State\: \Posit::.ctor(PositEnvironment,BitMask).0._States\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_0\;
        Variable \Posit::.ctor(PositEnvironment,BitMask).0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::.ctor(PositEnvironment,BitMask).0.environment\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \Posit::.ctor(PositEnvironment,BitMask).0.bits\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::.ctor(PositEnvironment,BitMask).0.return.0\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::.ctor(PositEnvironment,BitMask).0._Finished\ <= false;
                \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= (others => to_unsigned(0, 32));
                \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                \Posit::.ctor(PositEnvironment,BitMask).0._State\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_0\;
            else 
                case \Posit::.ctor(PositEnvironment,BitMask).0._State\ is 
                    when \Posit::.ctor(PositEnvironment,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::.ctor(PositEnvironment,BitMask).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,BitMask).0._State\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::.ctor(PositEnvironment,BitMask).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,BitMask).0._Finished\ <= true;
                        else 
                            \Posit::.ctor(PositEnvironment,BitMask).0._Finished\ <= false;
                            \Posit::.ctor(PositEnvironment,BitMask).0._State\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.Out\ <= \Posit::.ctor(PositEnvironment,BitMask).0.this\;
                        \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.Out\ <= \Posit::.ctor(PositEnvironment,BitMask).0.environment\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,BitMask).0._State_2\ => 
                        \Posit::.ctor(PositEnvironment,BitMask).0.this\ := \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.In\;
                        \Posit::.ctor(PositEnvironment,BitMask).0.environment\ := \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.In\;
                        \Posit::.ctor(PositEnvironment,BitMask).0.bits\ := \Posit::.ctor(PositEnvironment,BitMask).0.bits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this._environment = environment;
                        -- 
                        \Posit::.ctor(PositEnvironment,BitMask).0.this\.\_environment\ := \Posit::.ctor(PositEnvironment,BitMask).0.environment\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = BitMask.FromImmutableArray (bits.Segments, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,BitMask).0.bits\.\Segments\;
                        \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= true;
                        \Posit::.ctor(PositEnvironment,BitMask).0._State\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,BitMask).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16)
                        if (\Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,BitMask).0.return.0\ := \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.bits\.\Segments\ := \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.this\.\PositBits\ := \Posit::.ctor(PositEnvironment,BitMask).0.return.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0._State\ := \Posit::.ctor(PositEnvironment,BitMask).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0 state machine start
    \Posit::.ctor(PositEnvironment,UInt32).0._StateMachine\: process (\Clock\) 
        Variable \Posit::.ctor(PositEnvironment,UInt32).0._State\: \Posit::.ctor(PositEnvironment,UInt32).0._States\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_0\;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.environment\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.value\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.flag\: boolean := false;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.num\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.num2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.return.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.0\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.2\: unsigned(63 downto 0) := to_unsigned(0, 64);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.3\: boolean := false;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.5\: boolean := false;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.6\: boolean := false;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.9\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::.ctor(PositEnvironment,UInt32).0.return.1\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::.ctor(PositEnvironment,UInt32).0._Finished\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_0\;
                \Posit::.ctor(PositEnvironment,UInt32).0.value\ := to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.flag\ := false;
                \Posit::.ctor(PositEnvironment,UInt32).0.num\ := to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.num2\ := to_unsigned(0, 16);
                \Posit::.ctor(PositEnvironment,UInt32).0.return.0\ := to_unsigned(0, 16);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.0\ := to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.2\ := to_unsigned(0, 64);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.3\ := false;
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.4\ := to_signed(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.5\ := false;
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.6\ := false;
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.8\ := to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.9\ := to_unsigned(0, 16);
            else 
                case \Posit::.ctor(PositEnvironment,UInt32).0._State\ is 
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0._Finished\ <= true;
                        else 
                            \Posit::.ctor(PositEnvironment,UInt32).0._Finished\ <= false;
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.Out\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.Out\ <= \Posit::.ctor(PositEnvironment,UInt32).0.environment\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_2\ => 
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\ := \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.In\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.environment\ := \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.In\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.value\ := \Posit::.ctor(PositEnvironment,UInt32).0.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- @this._environment = environment;
                        -- 
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\.\_environment\ := \Posit::.ctor(PositEnvironment,UInt32).0.environment\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.PositBits = new BitMask (1u, 32);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\.\IsNull\ := false;
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\.\Size\ := to_unsigned(0, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\ := \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag = false;
                            -- 
                            \Posit::.ctor(PositEnvironment,UInt32).0.flag\ := False;
                            -- The following section was transformed from the .NET statement below:
                            -- num = (uint)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (@this.PositBits)) - 1);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,UInt32).0.return.0\ := \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.0\ := unsigned(signed(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.return.0\), 32)) - to_signed(1, 32));
                            \Posit::.ctor(PositEnvironment,UInt32).0.num\ := (\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.0\);
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = 0;
                            -- 
                            \Posit::.ctor(PositEnvironment,UInt32).0.num2\ := to_unsigned(0, 16);
                            -- The following section was transformed from the .NET statement below:
                            -- while ((ulong)num >= (ulong)(1L << (int)((Int32)(environment.MaximumExponentSize) & 31)) && (Int32)(num2) < (Int32)((Int32)(@this._environment.Size) - 1)) {
                            -- 	num = num - 1u << (int)environment.MaximumExponentSize;
                            -- 	num2 = (UInt16)((Int32)(num2) + 1);
                            -- }
                            -- 
                            -- Starting a while loop.
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_5\ => 
                        -- Repeated state of the while loop which was started in state \Posit::.ctor(PositEnvironment,UInt32).0._State_4\.
                        -- The while loop's condition:
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.1\ := signed(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.environment\.\MaximumExponentSize\), 32)) and to_signed(31, 32);
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.2\ := SmartResize(unsigned(shift_left(to_signed(1, 64), to_integer(unsigned(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.1\), 6))))), 64);
                        \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0.74865
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_6\ => 
                        -- State after the while loop which was started in state \Posit::.ctor(PositEnvironment,UInt32).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6 = new BitMask (num, 32);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\.\IsNull\ := false;
                        \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\.\Size\ := to_unsigned(0, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.num\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_7\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.3\ := SmartResize(\Posit::.ctor(PositEnvironment,UInt32).0.num\, 64) >= (\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.2\);
                        \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.66825
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_8\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.4\ := signed(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.this\.\_environment\.\Size\), 32)) - to_signed(1, 32);
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.5\ := signed(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.num2\), 32)) < (\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.4\);
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.6\ := \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.3\ and \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.5\;
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.6\) then 
                            -- The following section was transformed from the .NET statement below:
                            -- {
                            -- 	num = num - 1u << (int)environment.MaximumExponentSize;
                            -- 	num2 = (UInt16)((Int32)(num2) + 1);
                            -- }
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- num = num - 1u << (int)environment.MaximumExponentSize;
                            -- 
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_9\;
                        else 
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.94095
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.7\ := shift_left(to_unsigned(1, 32), to_integer(unsigned(SmartResize(signed(SmartResize(\Posit::.ctor(PositEnvironment,UInt32).0.environment\.\MaximumExponentSize\, 32)), 5))));
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.8\ := \Posit::.ctor(PositEnvironment,UInt32).0.num\ - \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.7\;
                        \Posit::.ctor(PositEnvironment,UInt32).0.num\ := \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.8\;
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = (UInt16)((Int32)(num2) + 1);
                        -- 
                        \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0.7953
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_10\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.9\ := SmartResize(unsigned(signed(SmartResize((\Posit::.ctor(PositEnvironment,UInt32).0.num2\), 32)) + to_signed(1, 32)), 16);
                        \Posit::.ctor(PositEnvironment,UInt32).0.num2\ := (\Posit::.ctor(PositEnvironment,UInt32).0.binaryOperationResult.9\);
                        -- Returning to the repeated state of the while loop which was started in state \Posit::.ctor(PositEnvironment,UInt32).0._State_4\ if the loop wasn't exited with a state change.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0._State\ = \Posit::.ctor(PositEnvironment,UInt32).0._State_10\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\ := \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.PositBits = Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (@this, false, (int)num2, objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6, @this.PositBits);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\ <= False;
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\ <= signed(SmartResize(\Posit::.ctor(PositEnvironment,UInt32).0.num2\, 32));
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.objecte3f535f91061e68c0a703ef396eb72edae035eb1f065fcedea40dc01896a66a6\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= true;
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,UInt32).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ = \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,UInt32).0.return.1\ := \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\;
                            \Posit::.ctor(PositEnvironment,UInt32).0.this\.\PositBits\ := \Posit::.ctor(PositEnvironment,UInt32).0.return.1\;
                            \Posit::.ctor(PositEnvironment,UInt32).0._State\ := \Posit::.ctor(PositEnvironment,UInt32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0 state machine end


    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32).0 state machine start
    \Posit::.ctor(PositEnvironment,Int32).0._StateMachine\: process (\Clock\) 
        Variable \Posit::.ctor(PositEnvironment,Int32).0._State\: \Posit::.ctor(PositEnvironment,Int32).0._States\ := \Posit::.ctor(PositEnvironment,Int32).0._State_0\;
        Variable \Posit::.ctor(PositEnvironment,Int32).0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::.ctor(PositEnvironment,Int32).0.environment\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \Posit::.ctor(PositEnvironment,Int32).0.value\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::.ctor(PositEnvironment,Int32).0.conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::.ctor(PositEnvironment,Int32).0.objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829\: \Lombiq.Arithmetics.Posit\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::.ctor(PositEnvironment,Int32).0._Finished\ <= false;
                \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).value.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\ <= false;
                \Posit::.ctor(PositEnvironment,Int32).0._State\ := \Posit::.ctor(PositEnvironment,Int32).0._State_0\;
                \Posit::.ctor(PositEnvironment,Int32).0.value\ := to_signed(0, 32);
            else 
                case \Posit::.ctor(PositEnvironment,Int32).0._State\ is 
                    when \Posit::.ctor(PositEnvironment,Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::.ctor(PositEnvironment,Int32).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,Int32).0._State\ := \Posit::.ctor(PositEnvironment,Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::.ctor(PositEnvironment,Int32).0._Started\ = true) then 
                            \Posit::.ctor(PositEnvironment,Int32).0._Finished\ <= true;
                        else 
                            \Posit::.ctor(PositEnvironment,Int32).0._Finished\ <= false;
                            \Posit::.ctor(PositEnvironment,Int32).0._State\ := \Posit::.ctor(PositEnvironment,Int32).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.Out\ <= \Posit::.ctor(PositEnvironment,Int32).0.this\;
                        \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.Out\ <= \Posit::.ctor(PositEnvironment,Int32).0.environment\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,Int32).0._State_2\ => 
                        \Posit::.ctor(PositEnvironment,Int32).0.this\ := \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.In\;
                        \Posit::.ctor(PositEnvironment,Int32).0.environment\ := \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.In\;
                        \Posit::.ctor(PositEnvironment,Int32).0.value\ := \Posit::.ctor(PositEnvironment,Int32).0.value.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this._environment = environment;
                        -- 
                        \Posit::.ctor(PositEnvironment,Int32).0.this\.\_environment\ := \Posit::.ctor(PositEnvironment,Int32).0.environment\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829 = new Posit (environment, 1u);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::.ctor(PositEnvironment,Int32).0.objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829\.\IsNull\ := false;
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32)
                        \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,Int32).0.objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829\;
                        \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.Out.0\ <= \Posit::.ctor(PositEnvironment,Int32).0.environment\;
                        \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).value.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\ <= true;
                        \Posit::.ctor(PositEnvironment,Int32).0._State\ := \Posit::.ctor(PositEnvironment,Int32).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::.ctor(PositEnvironment,Int32).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32)
                        if (\Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\ = \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Finished.0\) then 
                            \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\ <= false;
                            \Posit::.ctor(PositEnvironment,Int32).0.objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829\ := \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.In.0\;
                            \Posit::.ctor(PositEnvironment,Int32).0.environment\ := \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d = objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829.PositBits;
                            -- 
                            \Posit::.ctor(PositEnvironment,Int32).0.conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d\ := \Posit::.ctor(PositEnvironment,Int32).0.objectab782a22e7b7afc677a32f1437f517b4e63de3b029cb10592b7816d8e3314829\.\PositBits\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.PositBits = conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d;
                            -- 
                            \Posit::.ctor(PositEnvironment,Int32).0.this\.\PositBits\ := \Posit::.ctor(PositEnvironment,Int32).0.conditional440235f7969a4ff79d30e3439b1f7285c7e81aa77aab5cb93f6d4da284e7967d\;
                            \Posit::.ctor(PositEnvironment,Int32).0._State\ := \Posit::.ctor(PositEnvironment,Int32).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32).0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0 state machine start
    \Posit::IsPositive().0._StateMachine\: process (\Clock\) 
        Variable \Posit::IsPositive().0._State\: \Posit::IsPositive().0._States\ := \Posit::IsPositive().0._State_0\;
        Variable \Posit::IsPositive().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::IsPositive().0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::IsPositive().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::IsPositive().0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::IsPositive().0.return.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::IsPositive().0._Finished\ <= false;
                \Posit::IsPositive().0.return\ <= false;
                \Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\ <= false;
                \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= false;
                \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_0\;
                \Posit::IsPositive().0.return.3\ := false;
            else 
                case \Posit::IsPositive().0._State\ is 
                    when \Posit::IsPositive().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::IsPositive().0._Started\ = true) then 
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::IsPositive().0._Started\ = true) then 
                            \Posit::IsPositive().0._Finished\ <= true;
                        else 
                            \Posit::IsPositive().0._Finished\ <= false;
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_2\ => 
                        \Posit::IsPositive().0.this\ := \Posit::IsPositive().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return BitMask.op_Equality (BitMask.op_BitwiseAnd (@this.PositBits, Lombiq.Arithmetics.Posit.get_SignBitMask (@this)), Lombiq.Arithmetics.Posit.get_EmptyBitMask (@this));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask()
                        \Posit::IsPositive().0.Posit::get_SignBitMask().this.parameter.Out.0\ <= \Posit::IsPositive().0.this\;
                        \Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\ <= true;
                        \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask()
                        if (\Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\ = \Posit::IsPositive().0.Posit::get_SignBitMask()._Finished.0\) then 
                            \Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\ <= false;
                            \Posit::IsPositive().0.return.0\ := \Posit::IsPositive().0.Posit::get_SignBitMask().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::IsPositive().0.this\.\PositBits\;
                            \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::IsPositive().0.return.0\;
                            \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ = \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\) then 
                            \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::IsPositive().0.return.1\ := \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                            \Posit::IsPositive().0.Posit::get_EmptyBitMask().this.parameter.Out.0\ <= \Posit::IsPositive().0.this\;
                            \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\ <= true;
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        if (\Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\ = \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\) then 
                            \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                            \Posit::IsPositive().0.return.2\ := \Posit::IsPositive().0.Posit::get_EmptyBitMask().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::IsPositive().0.return.1\;
                            \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::IsPositive().0.return.2\;
                            \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsPositive().0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::IsPositive().0.return.3\ := \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\;
                            \Posit::IsPositive().0.return\ <= \Posit::IsPositive().0.return.3\;
                            \Posit::IsPositive().0._State\ := \Posit::IsPositive().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0 state machine start
    \Posit::IsNaN().0._StateMachine\: process (\Clock\) 
        Variable \Posit::IsNaN().0._State\: \Posit::IsNaN().0._States\ := \Posit::IsNaN().0._State_0\;
        Variable \Posit::IsNaN().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::IsNaN().0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::IsNaN().0.return.1\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::IsNaN().0._Finished\ <= false;
                \Posit::IsNaN().0.return\ <= false;
                \Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\ <= false;
                \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_0\;
                \Posit::IsNaN().0.return.1\ := false;
            else 
                case \Posit::IsNaN().0._State\ is 
                    when \Posit::IsNaN().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::IsNaN().0._Started\ = true) then 
                            \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsNaN().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::IsNaN().0._Started\ = true) then 
                            \Posit::IsNaN().0._Finished\ <= true;
                        else 
                            \Posit::IsNaN().0._Finished\ <= false;
                            \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsNaN().0._State_2\ => 
                        \Posit::IsNaN().0.this\ := \Posit::IsNaN().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return BitMask.op_Equality (@this.PositBits, Lombiq.Arithmetics.Posit.get_NaNBitMask (@this));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask()
                        \Posit::IsNaN().0.Posit::get_NaNBitMask().this.parameter.Out.0\ <= \Posit::IsNaN().0.this\;
                        \Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\ <= true;
                        \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsNaN().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask()
                        if (\Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\ = \Posit::IsNaN().0.Posit::get_NaNBitMask()._Finished.0\) then 
                            \Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\ <= false;
                            \Posit::IsNaN().0.return.0\ := \Posit::IsNaN().0.Posit::get_NaNBitMask().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::IsNaN().0.this\.\PositBits\;
                            \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::IsNaN().0.return.0\;
                            \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsNaN().0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::IsNaN().0.return.1\ := \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\;
                            \Posit::IsNaN().0.return\ <= \Posit::IsNaN().0.return.1\;
                            \Posit::IsNaN().0._State\ := \Posit::IsNaN().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0 state machine end


    -- System.Boolean Lombiq.Arithmetics.Posit::IsZero().0 state machine start
    \Posit::IsZero().0._StateMachine\: process (\Clock\) 
        Variable \Posit::IsZero().0._State\: \Posit::IsZero().0._States\ := \Posit::IsZero().0._State_0\;
        Variable \Posit::IsZero().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::IsZero().0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::IsZero().0.return.1\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::IsZero().0._Finished\ <= false;
                \Posit::IsZero().0.return\ <= false;
                \Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_0\;
                \Posit::IsZero().0.return.1\ := false;
            else 
                case \Posit::IsZero().0._State\ is 
                    when \Posit::IsZero().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::IsZero().0._Started\ = true) then 
                            \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsZero().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::IsZero().0._Started\ = true) then 
                            \Posit::IsZero().0._Finished\ <= true;
                        else 
                            \Posit::IsZero().0._Finished\ <= false;
                            \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsZero().0._State_2\ => 
                        \Posit::IsZero().0.this\ := \Posit::IsZero().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return BitMask.op_Equality (@this.PositBits, Lombiq.Arithmetics.Posit.get_EmptyBitMask (@this));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        \Posit::IsZero().0.Posit::get_EmptyBitMask().this.parameter.Out.0\ <= \Posit::IsZero().0.this\;
                        \Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\ <= true;
                        \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsZero().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        if (\Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\ = \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\) then 
                            \Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                            \Posit::IsZero().0.return.0\ := \Posit::IsZero().0.Posit::get_EmptyBitMask().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::IsZero().0.this\.\PositBits\;
                            \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::IsZero().0.return.0\;
                            \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::IsZero().0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::IsZero().0.return.1\ := \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\;
                            \Posit::IsZero().0.return\ <= \Posit::IsZero().0.return.1\;
                            \Posit::IsZero().0._State\ := \Posit::IsZero().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Boolean Lombiq.Arithmetics.Posit::IsZero().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0 state machine start
    \Posit::EncodeRegimeBits(Int32).0._StateMachine\: process (\Clock\) 
        Variable \Posit::EncodeRegimeBits(Int32).0._State\: \Posit::EncodeRegimeBits(Int32).0._States\ := \Posit::EncodeRegimeBits(Int32).0._State_0\;
        Variable \Posit::EncodeRegimeBits(Int32).0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::EncodeRegimeBits(Int32).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::EncodeRegimeBits(Int32).0.flag\: boolean := false;
        Variable \Posit::EncodeRegimeBits(Int32).0.bitMask\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::EncodeRegimeBits(Int32).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::EncodeRegimeBits(Int32).0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::EncodeRegimeBits(Int32).0.return.2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::EncodeRegimeBits(Int32).0.return.3\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::EncodeRegimeBits(Int32).0.return.4\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::EncodeRegimeBits(Int32).0._Finished\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32)._Started.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_0\;
                \Posit::EncodeRegimeBits(Int32).0.regimeKValue\ := to_signed(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.flag\ := false;
                \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.0\ := false;
                \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.return.2\ := to_unsigned(0, 16);
                \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.3\ := to_signed(0, 32);
            else 
                case \Posit::EncodeRegimeBits(Int32).0._State\ is 
                    when \Posit::EncodeRegimeBits(Int32).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::EncodeRegimeBits(Int32).0._Started\ = true) then 
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::EncodeRegimeBits(Int32).0._Started\ = true) then 
                            \Posit::EncodeRegimeBits(Int32).0._Finished\ <= true;
                        else 
                            \Posit::EncodeRegimeBits(Int32).0._Finished\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_2\ => 
                        \Posit::EncodeRegimeBits(Int32).0.this\ := \Posit::EncodeRegimeBits(Int32).0.this.parameter.In\;
                        \Posit::EncodeRegimeBits(Int32).0.regimeKValue\ := \Posit::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask bitMask;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = regimeKValue > 0;
                        -- 
                        \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.0\ := \Posit::EncodeRegimeBits(Int32).0.regimeKValue\ > to_signed(0, 32);
                        \Posit::EncodeRegimeBits(Int32).0.flag\ := \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.0\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	BitMask object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66;
                        -- 	object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66 = new BitMask (1u, 32);
                        -- 	bitMask = BitMask.op_Subtraction (BitMask.op_LeftShift (object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66, regimeKValue + 1), 1u);
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, (int)((Int32)(32 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask))) - 1));
                        -- }
                        -- else {
                        -- 	bitMask = BitMask.op_LeftShift (@this._environment.FirstRegimeBitBitMask, regimeKValue);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::EncodeRegimeBits(Int32).0._State_4\ and ends in state \Posit::EncodeRegimeBits(Int32).0._State_9\.
                        --     * The false branch starts in state \Posit::EncodeRegimeBits(Int32).0._State_10\ and ends in state \Posit::EncodeRegimeBits(Int32).0._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit::EncodeRegimeBits(Int32).0._State_3\.

                        if (\Posit::EncodeRegimeBits(Int32).0.flag\) then 
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_4\;
                        else 
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50535
                    when \Posit::EncodeRegimeBits(Int32).0._State_3\ => 
                        -- State after the if-else which was started in state \Posit::EncodeRegimeBits(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- return bitMask;
                        -- 
                        \Posit::EncodeRegimeBits(Int32).0.return\ <= \Posit::EncodeRegimeBits(Int32).0.bitMask\;
                        \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_4\ => 
                        -- True branch of the if-else started in state \Posit::EncodeRegimeBits(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	BitMask object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66;
                        -- 	object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66 = new BitMask (1u, 32);
                        -- 	bitMask = BitMask.op_Subtraction (BitMask.op_LeftShift (object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66, regimeKValue + 1), 1u);
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, (int)((Int32)(32 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask))) - 1));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66 = new BitMask (1u, 32);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\.\IsNull\ := false;
                        \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\.\Size\ := to_unsigned(0, 16);
                        \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\;
                        \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_5\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\ := \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_Subtraction (BitMask.op_LeftShift (object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66, regimeKValue + 1), 1u);
                            -- 
                            \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.1\ := \Posit::EncodeRegimeBits(Int32).0.regimeKValue\ + to_signed(1, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.object135ada7875fc18c39fc0d34d09218194abc0aae05b4a528700fad579e8a0cd66\;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.1\;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \Posit::EncodeRegimeBits(Int32).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.return.0\ := \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32)
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32).left.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.return.0\;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32)._Started.0\ <= true;
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32)._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32)._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32)._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.return.1\ := \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32).return.0\;
                            \Posit::EncodeRegimeBits(Int32).0.bitMask\ := \Posit::EncodeRegimeBits(Int32).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_LeftShift (bitMask, (int)((Int32)(32 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask))) - 1));
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.bitMask\;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.return.2\ := \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.2\ := to_signed(32, 32) - signed(SmartResize((\Posit::EncodeRegimeBits(Int32).0.return.2\), 32));
                            \Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.3\ := (\Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.2\) - to_signed(1, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.bitMask\;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= (\Posit::EncodeRegimeBits(Int32).0.binaryOperationResult.3\);
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7128
                    when \Posit::EncodeRegimeBits(Int32).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.return.3\ := \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::EncodeRegimeBits(Int32).0.bitMask\ := \Posit::EncodeRegimeBits(Int32).0.return.3\;
                            -- Going to the state after the if-else which was started in state \Posit::EncodeRegimeBits(Int32).0._State_2\.
                            if (\Posit::EncodeRegimeBits(Int32).0._State\ = \Posit::EncodeRegimeBits(Int32).0._State_9\) then 
                                \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_10\ => 
                        -- False branch of the if-else started in state \Posit::EncodeRegimeBits(Int32).0._State_2\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_LeftShift (@this._environment.FirstRegimeBitBitMask, regimeKValue);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_LeftShift (@this._environment.FirstRegimeBitBitMask, regimeKValue);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_11\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.this\.\_environment\.\FirstRegimeBitBitMask\;
                        \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::EncodeRegimeBits(Int32).0.regimeKValue\;
                        \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::EncodeRegimeBits(Int32).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::EncodeRegimeBits(Int32).0.return.4\ := \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::EncodeRegimeBits(Int32).0.bitMask\ := \Posit::EncodeRegimeBits(Int32).0.return.4\;
                            -- Going to the state after the if-else which was started in state \Posit::EncodeRegimeBits(Int32).0._State_2\.
                            if (\Posit::EncodeRegimeBits(Int32).0._State\ = \Posit::EncodeRegimeBits(Int32).0._State_12\) then 
                                \Posit::EncodeRegimeBits(Int32).0._State\ := \Posit::EncodeRegimeBits(Int32).0._State_3\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine start
    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._StateMachine\: process (\Clock\) 
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._States\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_0\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag2\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag3\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag4\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag5\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag6\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.1\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.3\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.3\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.4\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.5\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.5\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.6\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.7\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.8\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.7\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.10\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.11\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.unaryOperationResult.0\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.12\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.13\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.14\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.9\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.15\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.16\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.12\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.17\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.14\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.18\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.19\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.15\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.20\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.21\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.22\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.16\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.23\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.24\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.unaryOperationResult.1\: boolean := false;
        Variable \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.25\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_0\;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag2\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag3\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num3\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag4\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag5\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag6\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.1\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.3\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.4\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.5\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.6\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.6\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.8\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.9\ := to_unsigned(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.7\ := to_unsigned(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.unaryOperationResult.0\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.13\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.8\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.9\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.10\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.11\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.12\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.13\ := to_signed(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.14\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.19\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.15\ := to_unsigned(0, 16);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.21\ := false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.22\ := to_unsigned(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.16\ := to_unsigned(0, 32);
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.unaryOperationResult.1\ := false;
            else 
                case \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ is 
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ = true) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ = true) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\ <= true;
                        else 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_2\ => 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this.parameter.In\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit.parameter.In\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue.parameter.In\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits.parameter.In\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask bitMask;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- ushort num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = Lombiq.Arithmetics.Posit.EncodeRegimeBits (@this, regimeKValue);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.0\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.1\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = (int)((Int32)(32 - (Int32)((Int32)(num) + 2)) - 3);
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num\), 32)) + to_signed(2, 32), 32);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.1\ := to_signed(32, 32) - (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.0\);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7545
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.2\ := (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.1\) - to_signed(3, 32);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\ := (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.2\);
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (exponentBits, num2));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.2\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.2\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.3\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag = num2 < 0;
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.3\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\ < to_signed(0, 32);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	exponentBits = BitMask.op_LeftShift (exponentBits, (int)exponentBits.Size + num2);
                            -- 	BitMask objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d;
                            -- 	objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d = new BitMask (exponentBits.Size, false);
                            -- 	flag2 = BitMask.op_GreaterThanOrEqual (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d, (UInt16)((Int32)(exponentBits.Size) - 1)));
                            -- 	if (flag2) {
                            -- 		BitMask object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64;
                            -- 		object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64 = new BitMask (exponentBits.Size, false);
                            -- 		flag3 = BitMask.op_Equality (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64, (UInt16)((Int32)(exponentBits.Size) - 1)));
                            -- 		if (flag3) {
                            -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- 		}
                            -- 		else {
                            -- 			bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- 		}
                            -- 	}
                            -- 	if (!signBit) {
                            -- 		result = bitMask;
                            -- 	}
                            -- 	else {
                            -- 		result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                            -- 	}
                            -- }
                            -- else {
                            -- 	num3 = (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (fractionBits)) - 1);
                            -- 	fractionBits = Lombiq.Arithmetics.BitMask.SetZero (fractionBits, (ushort)num3);
                            -- 	num4 = 30 - num3 - (int)num - 3;
                            -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (fractionBits, num4));
                            -- 	flag4 = num4 < 0;
                            -- 	if (flag4) {
                            -- 		fractionBits = BitMask.op_LeftShift (fractionBits, (int)fractionBits.Size + num4);
                            -- 		BitMask object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0;
                            -- 		object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0 = new BitMask (fractionBits.Size, false);
                            -- 		flag5 = BitMask.op_GreaterThanOrEqual (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                            -- 		if (flag5) {
                            -- 			BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                            -- 			objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                            -- 			flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                            -- 			if (flag6) {
                            -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- 			}
                            -- 			else {
                            -- 				bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- 			}
                            -- 		}
                            -- 	}
                            -- 	if (!signBit) {
                            -- 		result = bitMask;
                            -- 	}
                            -- 	else {
                            -- 		result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_9\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\.
                            --     * The false branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_30\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_54\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_8\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_9\;
                            else 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_30\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.46515
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_8\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_9\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	exponentBits = BitMask.op_LeftShift (exponentBits, (int)exponentBits.Size + num2);
                        -- 	BitMask objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d;
                        -- 	objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d = new BitMask (exponentBits.Size, false);
                        -- 	flag2 = BitMask.op_GreaterThanOrEqual (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d, (UInt16)((Int32)(exponentBits.Size) - 1)));
                        -- 	if (flag2) {
                        -- 		BitMask object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64;
                        -- 		object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64 = new BitMask (exponentBits.Size, false);
                        -- 		flag3 = BitMask.op_Equality (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64, (UInt16)((Int32)(exponentBits.Size) - 1)));
                        -- 		if (flag3) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 		}
                        -- 	}
                        -- 	if (!signBit) {
                        -- 		result = bitMask;
                        -- 	}
                        -- 	else {
                        -- 		result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = BitMask.op_LeftShift (exponentBits, (int)exponentBits.Size + num2);
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.4\ := signed(SmartResize(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\.\Size\, 32)) + \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num2\;
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.4\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_10\;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.4\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- BitMask objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d = new BitMask (exponentBits.Size, false);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\.\IsNull\ := false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\.\Size\ := to_unsigned(0, 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\.\SegmentCount\ := to_unsigned(0, 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\.\Size\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = BitMask.op_GreaterThanOrEqual (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d, (UInt16)((Int32)(exponentBits.Size) - 1)));
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.5\ := SmartResize(unsigned(signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\.\Size\), 32)) - to_signed(1, 32)), 16);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objecte34250c36e43622035345051997b5ad982a97404ede9947739f012b4b991014d\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.5\);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.5\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.5\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.6\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag2\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.6\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag2) {
                            -- 	BitMask object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64;
                            -- 	object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64 = new BitMask (exponentBits.Size, false);
                            -- 	flag3 = BitMask.op_Equality (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64, (UInt16)((Int32)(exponentBits.Size) - 1)));
                            -- 	if (flag3) {
                            -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- 	}
                            -- 	else {
                            -- 		bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_15\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_19\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag2\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_15\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (!signBit) {
                        -- 	result = bitMask;
                        -- }
                        -- else {
                        -- 	result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- }
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.unaryOperationResult.0\ := not(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit\);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_27\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_27\.
                        --     * The false branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_28\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_29\.
                        --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\.

                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.unaryOperationResult.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_27\;
                        else 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.0984
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_15\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	BitMask object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64;
                        -- 	object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64 = new BitMask (exponentBits.Size, false);
                        -- 	flag3 = BitMask.op_Equality (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64, (UInt16)((Int32)(exponentBits.Size) - 1)));
                        -- 	if (flag3) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64 = new BitMask (exponentBits.Size, false);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\.\IsNull\ := false;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\.\Size\ := to_unsigned(0, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\.\Size\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_16\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_16\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag3 = BitMask.op_Equality (exponentBits, Lombiq.Arithmetics.BitMask.SetOne (object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64, (UInt16)((Int32)(exponentBits.Size) - 1)));
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.6\ := SmartResize(unsigned(signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\.\Size\), 32)) - to_signed(1, 32)), 16);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object3f55db8a5525201dfd948eff04e8c01adc995a994819ecb564d7c507f969bc64\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.6\);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_17\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.7\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.7\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.8\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag3\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag3) {
                            -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- }
                            -- else {
                            -- 	bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_20\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_22\.
                            --     * The false branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_23\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_19\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag3\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_20\;
                            else 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_23\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_19\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\.
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_13\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_19\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_20\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_21\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_21\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.9\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.7\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.9\ and to_unsigned(1, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.7\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_22\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1296
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_22\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.10\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.10\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_22\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_19\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_23\ => 
                        -- False branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_24\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_24\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.11\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.11\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_18\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_25\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_19\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\.
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_27\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = bitMask;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = bitMask;
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_27\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_28\ => 
                        -- False branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_29\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_29\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.12\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.12\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_14\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_29\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_26\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_30\ => 
                        -- False branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num3 = (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 	fractionBits = Lombiq.Arithmetics.BitMask.SetZero (fractionBits, (ushort)num3);
                        -- 	num4 = 30 - num3 - (int)num - 3;
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (fractionBits, num4));
                        -- 	flag4 = num4 < 0;
                        -- 	if (flag4) {
                        -- 		fractionBits = BitMask.op_LeftShift (fractionBits, (int)fractionBits.Size + num4);
                        -- 		BitMask object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0;
                        -- 		object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0 = new BitMask (fractionBits.Size, false);
                        -- 		flag5 = BitMask.op_GreaterThanOrEqual (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                        -- 		if (flag5) {
                        -- 			BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                        -- 			objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                        -- 			flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                        -- 			if (flag6) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 			}
                        -- 		}
                        -- 	}
                        -- 	if (!signBit) {
                        -- 		result = bitMask;
                        -- 	}
                        -- 	else {
                        -- 		result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (fractionBits)) - 1);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_31\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_31\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.13\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.8\ := signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.13\), 32)) - to_signed(1, 32);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num3\ := (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.8\);
                            -- The following section was transformed from the .NET statement below:
                            -- fractionBits = Lombiq.Arithmetics.BitMask.SetZero (fractionBits, (ushort)num3);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).index.parameter.Out.0\ <= SmartResize(unsigned(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num3\), 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_32\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_32\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.14\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.14\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = 30 - num3 - (int)num - 3;
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.9\ := to_signed(30, 32) - \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num3\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.10\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.9\ - signed(SmartResize(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num\, 32));
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7128
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_33\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.11\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.10\ - to_signed(3, 32);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.11\;
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (fractionBits, num4));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_34\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.15\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.15\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_35\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_35\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.16\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.16\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag4 = num4 < 0;
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.12\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\ < to_signed(0, 32);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag4\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.12\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag4) {
                            -- 	fractionBits = BitMask.op_LeftShift (fractionBits, (int)fractionBits.Size + num4);
                            -- 	BitMask object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0;
                            -- 	object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0 = new BitMask (fractionBits.Size, false);
                            -- 	flag5 = BitMask.op_GreaterThanOrEqual (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                            -- 	if (flag5) {
                            -- 		BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                            -- 		objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                            -- 		flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                            -- 		if (flag6) {
                            -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- 		}
                            -- 		else {
                            -- 			bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- 		}
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_37\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_42\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag4\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_37\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.46515
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_35\.
                        -- The following section was transformed from the .NET statement below:
                        -- if (!signBit) {
                        -- 	result = bitMask;
                        -- }
                        -- else {
                        -- 	result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- }
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.unaryOperationResult.1\ := not(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit\);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_55\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_55\.
                        --     * The false branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_56\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_57\.
                        --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_54\.

                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.unaryOperationResult.1\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_55\;
                        else 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_56\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.0984
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_37\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_35\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	fractionBits = BitMask.op_LeftShift (fractionBits, (int)fractionBits.Size + num4);
                        -- 	BitMask object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0;
                        -- 	object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0 = new BitMask (fractionBits.Size, false);
                        -- 	flag5 = BitMask.op_GreaterThanOrEqual (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                        -- 	if (flag5) {
                        -- 		BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                        -- 		objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                        -- 		flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                        -- 		if (flag6) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- fractionBits = BitMask.op_LeftShift (fractionBits, (int)fractionBits.Size + num4);
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.13\ := signed(SmartResize(\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\.\Size\, 32)) + \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.num4\;
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.13\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_38\;
                        -- Clock cycles needed to complete this state (approximation): 0.3981
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_38\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.17\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.17\;
                            -- The following section was transformed from the .NET statement below:
                            -- BitMask object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0 = new BitMask (fractionBits.Size, false);
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\.\IsNull\ := false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\.\Size\ := to_unsigned(0, 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\.\SegmentCount\ := to_unsigned(0, 16);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\.\Size\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_39\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_39\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag5 = BitMask.op_GreaterThanOrEqual (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.14\ := SmartResize(unsigned(signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\.\Size\), 32)) - to_signed(1, 32)), 16);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.object277301414f637cbf729c6a7d0583eda476ed9418376608aa41d1a24805c510e0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.14\);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_40\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_40\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.18\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.18\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_41\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_41\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.19\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag5\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.19\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag5) {
                            -- 	BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                            -- 	objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                            -- 	flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                            -- 	if (flag6) {
                            -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- 	}
                            -- 	else {
                            -- 		bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- 	}
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_43\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_47\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_42\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag5\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_43\;
                            else 
                                -- There was no false branch, so going directly to the state after the if-else.
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_42\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_42\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_41\.
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_35\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_42\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_43\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_41\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                        -- 	objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                        -- 	flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                        -- 	if (flag6) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0 = new BitMask (fractionBits.Size, false);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\.\IsNull\ := false;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\.\Size\ := to_unsigned(0, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\.\Size\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_44\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_44\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag6 = BitMask.op_Equality (fractionBits, Lombiq.Arithmetics.BitMask.SetOne (objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0, (UInt16)((Int32)(fractionBits.Size) - 1)));
                            -- 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.15\ := SmartResize(unsigned(signed(SmartResize((\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\.\Size\), 32)) - to_signed(1, 32)), 16);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.objectc26d7a7a01abf14e69eaa2af65b6ea64adbc317a6d5db47bb8a33fc1818b54d0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.15\);
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_45\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_45\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.20\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.20\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.21\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag6\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.21\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag6) {
                            -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                            -- }
                            -- else {
                            -- 	bitMask = BitMask.op_Addition (bitMask, 1u);
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_48\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_50\.
                            --     * The false branch starts in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_51\ and ends in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_53\.
                            --     * Execution after either branch will continue in the following state: \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_47\.

                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.flag6\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_48\;
                            else 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_51\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_47\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\.
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_41\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_47\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_48\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.BitMask.GetLowest32Bits (bitMask) & 1u);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_49\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_49\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.22\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.16\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.22\ and to_unsigned(1, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.binaryOperationResult.16\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_50\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1296
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_50\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.23\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.23\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_50\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_47\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_51\ => 
                        -- False branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, 1u);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_52\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_52\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_53\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_53\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.24\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.24\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_46\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_53\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_47\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_54\ => 
                        -- State after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\.
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_7\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_54\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_55\ => 
                        -- True branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = bitMask;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = bitMask;
                        -- 
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_55\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_54\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_56\ => 
                        -- False branch of the if-else started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = Lombiq.Arithmetics.BitMask.GetTwosComplement (bitMask, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.bitMask\;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_57\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_57\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.25\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.result\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return.25\;
                            -- Going to the state after the if-else which was started in state \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_36\.
                            if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ = \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_57\) then 
                                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State\ := \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._State_54\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 state machine end


    -- System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0 state machine start
    \Posit::GetRegimeKValue().0._StateMachine\: process (\Clock\) 
        Variable \Posit::GetRegimeKValue().0._State\: \Posit::GetRegimeKValue().0._States\ := \Posit::GetRegimeKValue().0._State_0\;
        Variable \Posit::GetRegimeKValue().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::GetRegimeKValue().0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetRegimeKValue().0.return.0\: boolean := false;
        Variable \Posit::GetRegimeKValue().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetRegimeKValue().0.conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::GetRegimeKValue().0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetRegimeKValue().0.return.3\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetRegimeKValue().0.return.4\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetRegimeKValue().0.return.5\: boolean := false;
        Variable \Posit::GetRegimeKValue().0.return.6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::GetRegimeKValue().0.unaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::GetRegimeKValue().0.return.7\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::GetRegimeKValue().0.binaryOperationResult.0\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::GetRegimeKValue().0._Finished\ <= false;
                \Posit::GetRegimeKValue().0.return\ <= to_signed(0, 32);
                \Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_0\;
                \Posit::GetRegimeKValue().0.return.0\ := false;
                \Posit::GetRegimeKValue().0.conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75\ := to_unsigned(0, 16);
                \Posit::GetRegimeKValue().0.return.5\ := false;
                \Posit::GetRegimeKValue().0.return.6\ := to_unsigned(0, 16);
                \Posit::GetRegimeKValue().0.unaryOperationResult.0\ := to_signed(0, 32);
                \Posit::GetRegimeKValue().0.return.7\ := to_unsigned(0, 16);
                \Posit::GetRegimeKValue().0.binaryOperationResult.0\ := to_unsigned(0, 16);
            else 
                case \Posit::GetRegimeKValue().0._State\ is 
                    when \Posit::GetRegimeKValue().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::GetRegimeKValue().0._Started\ = true) then 
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::GetRegimeKValue().0._Started\ = true) then 
                            \Posit::GetRegimeKValue().0._Finished\ <= true;
                        else 
                            \Posit::GetRegimeKValue().0._Finished\ <= false;
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_2\ => 
                        \Posit::GetRegimeKValue().0.this\ := \Posit::GetRegimeKValue().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask left;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (@this)) {
                        -- 	left = @this.PositBits;
                        -- }
                        -- else {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::GetRegimeKValue().0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.this\;
                        \Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\ = \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.0\ := \Posit::GetRegimeKValue().0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::GetRegimeKValue().0._State_5\ and ends in state \Posit::GetRegimeKValue().0._State_5\.
                            --     * The false branch starts in state \Posit::GetRegimeKValue().0._State_6\ and ends in state \Posit::GetRegimeKValue().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit::GetRegimeKValue().0._State_4\.

                            if (\Posit::GetRegimeKValue().0.return.0\) then 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_5\;
                            else 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit::GetRegimeKValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (BitMask.op_Equality (BitMask.op_BitwiseAnd (left, Lombiq.Arithmetics.Posit.get_FirstRegimeBitBitMask (@this)), Lombiq.Arithmetics.Posit.get_EmptyBitMask (@this))) {
                        -- 	conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75 = -(int)Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31);
                        -- }
                        -- else {
                        -- 	conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75 = (UInt16)((Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31)) - 1);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask()
                        \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.this\;
                        \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\ <= true;
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit::GetRegimeKValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = @this.PositBits;
                        -- 
                        \Posit::GetRegimeKValue().0.left\ := \Posit::GetRegimeKValue().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit::GetRegimeKValue().0._State_3\.
                        if (\Posit::GetRegimeKValue().0._State\ = \Posit::GetRegimeKValue().0._State_5\) then 
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit::GetRegimeKValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.this\.\PositBits\;
                        \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.1\ := \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::GetRegimeKValue().0.left\ := \Posit::GetRegimeKValue().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit::GetRegimeKValue().0._State_3\.
                            if (\Posit::GetRegimeKValue().0._State\ = \Posit::GetRegimeKValue().0._State_7\) then 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask()
                        if (\Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\ = \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.2\ := \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.left\;
                            \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.return.2\;
                            \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ = \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.3\ := \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                            \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.this\;
                            \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\ <= true;
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        if (\Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\ = \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.4\ := \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.return.3\;
                            \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.return.4\;
                            \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= true;
                            \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ = \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.5\ := \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::GetRegimeKValue().0._State_13\ and ends in state \Posit::GetRegimeKValue().0._State_14\.
                            --     * The false branch starts in state \Posit::GetRegimeKValue().0._State_15\ and ends in state \Posit::GetRegimeKValue().0._State_17\.
                            --     * Execution after either branch will continue in the following state: \Posit::GetRegimeKValue().0._State_12\.

                            if (\Posit::GetRegimeKValue().0.return.5\) then 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_13\;
                            else 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_15\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_12\ => 
                        -- State after the if-else which was started in state \Posit::GetRegimeKValue().0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (int)(conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75);
                        -- 
                        \Posit::GetRegimeKValue().0.return\ <= signed(SmartResize((\Posit::GetRegimeKValue().0.conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75\), 32));
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_13\ => 
                        -- True branch of the if-else started in state \Posit::GetRegimeKValue().0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75 = -(int)Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75 = -(int)Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.left\;
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0.3369
                    when \Posit::GetRegimeKValue().0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.6\ := \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::GetRegimeKValue().0.unaryOperationResult.0\ := SmartResize(unsigned(0 - signed(SmartResize(\Posit::GetRegimeKValue().0.return.6\, 32))), 16);
                            \Posit::GetRegimeKValue().0.conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75\ := \Posit::GetRegimeKValue().0.unaryOperationResult.0\;
                            -- Going to the state after the if-else which was started in state \Posit::GetRegimeKValue().0._State_11\.
                            if (\Posit::GetRegimeKValue().0._State\ = \Posit::GetRegimeKValue().0._State_14\) then 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_12\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_15\ => 
                        -- False branch of the if-else started in state \Posit::GetRegimeKValue().0._State_11\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75 = (UInt16)((Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31)) - 1);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75 = (UInt16)((Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (left, 31)) - 1);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_16\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_16\ => 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::GetRegimeKValue().0.left\;
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                        \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                        \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_17\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetRegimeKValue().0._State_17\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::GetRegimeKValue().0.return.7\ := \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::GetRegimeKValue().0.binaryOperationResult.0\ := SmartResize(unsigned(signed(SmartResize((\Posit::GetRegimeKValue().0.return.7\), 32)) - to_signed(1, 32)), 16);
                            \Posit::GetRegimeKValue().0.conditionalbe73980d9a28a0eae4bccbdbea0a7fb3f85c02e756ef66f5fbefdb18a0b62f75\ := (\Posit::GetRegimeKValue().0.binaryOperationResult.0\);
                            -- Going to the state after the if-else which was started in state \Posit::GetRegimeKValue().0._State_11\.
                            if (\Posit::GetRegimeKValue().0._State\ = \Posit::GetRegimeKValue().0._State_17\) then 
                                \Posit::GetRegimeKValue().0._State\ := \Posit::GetRegimeKValue().0._State_12\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0 state machine start
    \Posit::ExponentSize().0._StateMachine\: process (\Clock\) 
        Variable \Posit::ExponentSize().0._State\: \Posit::ExponentSize().0._States\ := \Posit::ExponentSize().0._State_0\;
        Variable \Posit::ExponentSize().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::ExponentSize().0.bitMask\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::ExponentSize().0.return.0\: boolean := false;
        Variable \Posit::ExponentSize().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::ExponentSize().0.conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::ExponentSize().0.return.2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::ExponentSize().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::ExponentSize().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::ExponentSize().0.binaryOperationResult.2\: boolean := false;
        Variable \Posit::ExponentSize().0.return.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::ExponentSize().0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::ExponentSize().0.binaryOperationResult.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::ExponentSize().0._Finished\ <= false;
                \Posit::ExponentSize().0.return\ <= to_unsigned(0, 32);
                \Posit::ExponentSize().0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_0\;
                \Posit::ExponentSize().0.return.0\ := false;
                \Posit::ExponentSize().0.conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48\ := to_unsigned(0, 16);
                \Posit::ExponentSize().0.return.2\ := to_unsigned(0, 16);
                \Posit::ExponentSize().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit::ExponentSize().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::ExponentSize().0.binaryOperationResult.2\ := false;
                \Posit::ExponentSize().0.return.3\ := to_unsigned(0, 16);
                \Posit::ExponentSize().0.binaryOperationResult.3\ := to_signed(0, 32);
                \Posit::ExponentSize().0.binaryOperationResult.4\ := to_unsigned(0, 16);
            else 
                case \Posit::ExponentSize().0._State\ is 
                    when \Posit::ExponentSize().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::ExponentSize().0._Started\ = true) then 
                            \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::ExponentSize().0._Started\ = true) then 
                            \Posit::ExponentSize().0._Finished\ <= true;
                        else 
                            \Posit::ExponentSize().0._Finished\ <= false;
                            \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_2\ => 
                        \Posit::ExponentSize().0.this\ := \Posit::ExponentSize().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask bitMask;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (@this)) {
                        -- 	bitMask = @this.PositBits;
                        -- }
                        -- else {
                        -- 	bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::ExponentSize().0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::ExponentSize().0.this\;
                        \Posit::ExponentSize().0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::ExponentSize().0.Posit::IsPositive()._Started.0\ = \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::ExponentSize().0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::ExponentSize().0.return.0\ := \Posit::ExponentSize().0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::ExponentSize().0._State_5\ and ends in state \Posit::ExponentSize().0._State_5\.
                            --     * The false branch starts in state \Posit::ExponentSize().0._State_6\ and ends in state \Posit::ExponentSize().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit::ExponentSize().0._State_4\.

                            if (\Posit::ExponentSize().0.return.0\) then 
                                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_5\;
                            else 
                                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit::ExponentSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- ushort conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if ((Int32)(32 - (Int32)((Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31)) + 2)) > 3) {
                        -- 	conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48 = 3;
                        -- }
                        -- else {
                        -- 	conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48 = (UInt16)(32 - (Int32)((Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31)) + 2));
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::ExponentSize().0.bitMask\;
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                        \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit::ExponentSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = @this.PositBits;
                        -- 
                        \Posit::ExponentSize().0.bitMask\ := \Posit::ExponentSize().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit::ExponentSize().0._State_3\.
                        if (\Posit::ExponentSize().0._State\ = \Posit::ExponentSize().0._State_5\) then 
                            \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit::ExponentSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::ExponentSize().0.this\.\PositBits\;
                        \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::ExponentSize().0.return.1\ := \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::ExponentSize().0.bitMask\ := \Posit::ExponentSize().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit::ExponentSize().0._State_3\.
                            if (\Posit::ExponentSize().0._State\ = \Posit::ExponentSize().0._State_7\) then 
                                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::ExponentSize().0.return.2\ := \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::ExponentSize().0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit::ExponentSize().0.return.2\), 32)) + to_signed(2, 32), 32);
                            \Posit::ExponentSize().0.binaryOperationResult.1\ := to_signed(32, 32) - (\Posit::ExponentSize().0.binaryOperationResult.0\);
                            \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7545
                    when \Posit::ExponentSize().0._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::ExponentSize().0.binaryOperationResult.2\ := (\Posit::ExponentSize().0.binaryOperationResult.1\) > to_signed(3, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::ExponentSize().0._State_11\ and ends in state \Posit::ExponentSize().0._State_11\.
                        --     * The false branch starts in state \Posit::ExponentSize().0._State_12\ and ends in state \Posit::ExponentSize().0._State_13\.
                        --     * Execution after either branch will continue in the following state: \Posit::ExponentSize().0._State_10\.

                        if (\Posit::ExponentSize().0.binaryOperationResult.2\) then 
                            \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_11\;
                        else 
                            \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50535
                    when \Posit::ExponentSize().0._State_10\ => 
                        -- State after the if-else which was started in state \Posit::ExponentSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48);
                        -- 
                        \Posit::ExponentSize().0.return\ <= SmartResize((\Posit::ExponentSize().0.conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48\), 32);
                        \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_11\ => 
                        -- True branch of the if-else started in state \Posit::ExponentSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48 = 3;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48 = 3;
                        -- 
                        \Posit::ExponentSize().0.conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48\ := to_unsigned(3, 16);
                        -- Going to the state after the if-else which was started in state \Posit::ExponentSize().0._State_9\.
                        if (\Posit::ExponentSize().0._State\ = \Posit::ExponentSize().0._State_11\) then 
                            \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_12\ => 
                        -- False branch of the if-else started in state \Posit::ExponentSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48 = (UInt16)(32 - (Int32)((Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31)) + 2));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48 = (UInt16)(32 - (Int32)((Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31)) + 2));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::ExponentSize().0.bitMask\;
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                        \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                        \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_13\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::ExponentSize().0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::ExponentSize().0.return.3\ := \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::ExponentSize().0.binaryOperationResult.3\ := SmartResize(signed(SmartResize((\Posit::ExponentSize().0.return.3\), 32)) + to_signed(2, 32), 32);
                            \Posit::ExponentSize().0.binaryOperationResult.4\ := SmartResize(unsigned(to_signed(32, 32) - (\Posit::ExponentSize().0.binaryOperationResult.3\)), 16);
                            \Posit::ExponentSize().0.conditionale58baf98c6680d58d786fd7742a58d0233b68fddde772b3854968f53e15dde48\ := (\Posit::ExponentSize().0.binaryOperationResult.4\);
                            -- Going to the state after the if-else which was started in state \Posit::ExponentSize().0._State_9\.
                            if (\Posit::ExponentSize().0._State\ = \Posit::ExponentSize().0._State_13\) then 
                                \Posit::ExponentSize().0._State\ := \Posit::ExponentSize().0._State_10\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7545
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0 state machine start
    \Posit::GetExponentValue().0._StateMachine\: process (\Clock\) 
        Variable \Posit::GetExponentValue().0._State\: \Posit::GetExponentValue().0._States\ := \Posit::GetExponentValue().0._State_0\;
        Variable \Posit::GetExponentValue().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::GetExponentValue().0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetExponentValue().0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::GetExponentValue().0.num2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::GetExponentValue().0.return.0\: boolean := false;
        Variable \Posit::GetExponentValue().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetExponentValue().0.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::GetExponentValue().0.return.3\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::GetExponentValue().0.return.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::GetExponentValue().0.return.5\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetExponentValue().0.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::GetExponentValue().0.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::GetExponentValue().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::GetExponentValue().0.return.7\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetExponentValue().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::GetExponentValue().0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::GetExponentValue().0.return.8\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::GetExponentValue().0.return.9\: unsigned(31 downto 0) := to_unsigned(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::GetExponentValue().0._Finished\ <= false;
                \Posit::GetExponentValue().0.return\ <= to_unsigned(0, 32);
                \Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ <= false;
                \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ <= false;
                \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_0\;
                \Posit::GetExponentValue().0.num\ := to_signed(0, 32);
                \Posit::GetExponentValue().0.num2\ := to_unsigned(0, 32);
                \Posit::GetExponentValue().0.return.0\ := false;
                \Posit::GetExponentValue().0.return.2\ := to_unsigned(0, 32);
                \Posit::GetExponentValue().0.return.3\ := to_unsigned(0, 32);
                \Posit::GetExponentValue().0.return.4\ := to_unsigned(0, 32);
                \Posit::GetExponentValue().0.binaryOperationResult.0\ := to_signed(0, 64);
                \Posit::GetExponentValue().0.return.6\ := to_unsigned(0, 32);
                \Posit::GetExponentValue().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::GetExponentValue().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit::GetExponentValue().0.binaryOperationResult.3\ := to_signed(0, 32);
                \Posit::GetExponentValue().0.return.9\ := to_unsigned(0, 32);
            else 
                case \Posit::GetExponentValue().0._State\ is 
                    when \Posit::GetExponentValue().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::GetExponentValue().0._Started\ = true) then 
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::GetExponentValue().0._Started\ = true) then 
                            \Posit::GetExponentValue().0._Finished\ <= true;
                        else 
                            \Posit::GetExponentValue().0._Finished\ <= false;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_2\ => 
                        \Posit::GetExponentValue().0.this\ := \Posit::GetExponentValue().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask left;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (@this)) {
                        -- 	left = @this.PositBits;
                        -- }
                        -- else {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::GetExponentValue().0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\;
                        \Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\ = \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.0\ := \Posit::GetExponentValue().0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::GetExponentValue().0._State_5\ and ends in state \Posit::GetExponentValue().0._State_5\.
                            --     * The false branch starts in state \Posit::GetExponentValue().0._State_6\ and ends in state \Posit::GetExponentValue().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit::GetExponentValue().0._State_4\.

                            if (\Posit::GetExponentValue().0.return.0\) then 
                                \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_5\;
                            else 
                                \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit::GetExponentValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)Lombiq.Arithmetics.Posit.FractionSize (@this);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::GetExponentValue().0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\;
                        \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit::GetExponentValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = @this.PositBits;
                        -- 
                        \Posit::GetExponentValue().0.left\ := \Posit::GetExponentValue().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit::GetExponentValue().0._State_3\.
                        if (\Posit::GetExponentValue().0._State\ = \Posit::GetExponentValue().0._State_5\) then 
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit::GetExponentValue().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\.\PositBits\;
                        \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.1\ := \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::GetExponentValue().0.left\ := \Posit::GetExponentValue().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit::GetExponentValue().0._State_3\.
                            if (\Posit::GetExponentValue().0._State\ = \Posit::GetExponentValue().0._State_7\) then 
                                \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ = \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.2\ := \Posit::GetExponentValue().0.Posit::FractionSize().return.0\;
                            \Posit::GetExponentValue().0.num\ := signed(\Posit::GetExponentValue().0.return.2\);
                            -- The following section was transformed from the .NET statement below:
                            -- num2 = Lombiq.Arithmetics.Posit.ExponentSize (@this);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize()
                            \Posit::GetExponentValue().0.Posit::ExponentSize().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\;
                            \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize()
                        if (\Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ = \Posit::GetExponentValue().0.Posit::ExponentSize()._Finished.0\) then 
                            \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.3\ := \Posit::GetExponentValue().0.Posit::ExponentSize().return.0\;
                            \Posit::GetExponentValue().0.num2\ := \Posit::GetExponentValue().0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- return Lombiq.Arithmetics.BitMask.GetLowest32Bits (BitMask.op_RightShift (BitMask.op_LeftShift (BitMask.op_RightShift (left, (int)Lombiq.Arithmetics.Posit.FractionSize (@this)), (int)((long)((Int32)(@this.PositBits.SegmentCount) * 32) - (long)((ulong)Lombiq.Arithmetics.Posit.ExponentSize (@this)))), (int)((Int32)((Int32)(@this.PositBits.SegmentCount) * 32) - 3)));
                            -- 
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_10\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::GetExponentValue().0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\;
                        \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ = \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.4\ := \Posit::GetExponentValue().0.Posit::FractionSize().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::GetExponentValue().0.left\;
                            \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= signed(\Posit::GetExponentValue().0.return.4\);
                            \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.5\ := \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\;
                            \Posit::GetExponentValue().0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit::GetExponentValue().0.this\.\PositBits\.\SegmentCount\), 32)) * to_signed(32, 32), 64);
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize()
                            \Posit::GetExponentValue().0.Posit::ExponentSize().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.this\;
                            \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.14475
                    when \Posit::GetExponentValue().0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize()
                        if (\Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ = \Posit::GetExponentValue().0.Posit::ExponentSize()._Finished.0\) then 
                            \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.6\ := \Posit::GetExponentValue().0.Posit::ExponentSize().return.0\;
                            \Posit::GetExponentValue().0.binaryOperationResult.1\ := SmartResize((\Posit::GetExponentValue().0.binaryOperationResult.0\) - signed((SmartResize(\Posit::GetExponentValue().0.return.6\, 64))), 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::GetExponentValue().0.return.5\;
                            \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= (\Posit::GetExponentValue().0.binaryOperationResult.1\);
                            \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.39855
                    when \Posit::GetExponentValue().0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.7\ := \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::GetExponentValue().0.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\Posit::GetExponentValue().0.this\.\PositBits\.\SegmentCount\), 32)) * to_signed(32, 32), 32);
                            \Posit::GetExponentValue().0.binaryOperationResult.3\ := (\Posit::GetExponentValue().0.binaryOperationResult.2\) - to_signed(3, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::GetExponentValue().0.return.7\;
                            \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= (\Posit::GetExponentValue().0.binaryOperationResult.3\);
                            \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50115
                    when \Posit::GetExponentValue().0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.8\ := \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                            \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().this.parameter.Out.0\ <= \Posit::GetExponentValue().0.return.8\;
                            \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\ <= true;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::GetExponentValue().0._State_16\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        if (\Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\ = \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\) then 
                            \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                            \Posit::GetExponentValue().0.return.9\ := \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().return.0\;
                            \Posit::GetExponentValue().0.return\ <= \Posit::GetExponentValue().0.return.9\;
                            \Posit::GetExponentValue().0._State\ := \Posit::GetExponentValue().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0 state machine end


    -- System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0 state machine start
    \Posit::FractionSize().0._StateMachine\: process (\Clock\) 
        Variable \Posit::FractionSize().0._State\: \Posit::FractionSize().0._States\ := \Posit::FractionSize().0._State_0\;
        Variable \Posit::FractionSize().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::FractionSize().0.bitMask\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionSize().0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionSize().0.return.0\: boolean := false;
        Variable \Posit::FractionSize().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionSize().0.return.2\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit::FractionSize().0.binaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionSize().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionSize().0.binaryOperationResult.2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionSize().0.conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionSize().0.binaryOperationResult.3\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::FractionSize().0._Finished\ <= false;
                \Posit::FractionSize().0.return\ <= to_unsigned(0, 32);
                \Posit::FractionSize().0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_0\;
                \Posit::FractionSize().0.num\ := to_signed(0, 32);
                \Posit::FractionSize().0.return.0\ := false;
                \Posit::FractionSize().0.return.2\ := to_unsigned(0, 16);
                \Posit::FractionSize().0.binaryOperationResult.0\ := to_signed(0, 32);
                \Posit::FractionSize().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::FractionSize().0.binaryOperationResult.2\ := to_signed(0, 32);
                \Posit::FractionSize().0.conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744\ := to_signed(0, 32);
                \Posit::FractionSize().0.binaryOperationResult.3\ := false;
            else 
                case \Posit::FractionSize().0._State\ is 
                    when \Posit::FractionSize().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::FractionSize().0._Started\ = true) then 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::FractionSize().0._Started\ = true) then 
                            \Posit::FractionSize().0._Finished\ <= true;
                        else 
                            \Posit::FractionSize().0._Finished\ <= false;
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_2\ => 
                        \Posit::FractionSize().0.this\ := \Posit::FractionSize().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask bitMask;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (@this)) {
                        -- 	bitMask = @this.PositBits;
                        -- }
                        -- else {
                        -- 	bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::FractionSize().0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::FractionSize().0.this\;
                        \Posit::FractionSize().0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::FractionSize().0.Posit::IsPositive()._Started.0\ = \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::FractionSize().0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::FractionSize().0.return.0\ := \Posit::FractionSize().0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::FractionSize().0._State_5\ and ends in state \Posit::FractionSize().0._State_5\.
                            --     * The false branch starts in state \Posit::FractionSize().0._State_6\ and ends in state \Posit::FractionSize().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit::FractionSize().0._State_4\.

                            if (\Posit::FractionSize().0.return.0\) then 
                                \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_5\;
                            else 
                                \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit::FractionSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- num = (int)(32 - (Int32)((Int32)((Int32)(Lombiq.Arithmetics.BitMask.LengthOfRunOfBits (bitMask, 31)) + 2) + 3));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\ <= \Posit::FractionSize().0.bitMask\;
                        \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\ <= to_unsigned(31, 16);
                        \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= true;
                        \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit::FractionSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = @this.PositBits;
                        -- 
                        \Posit::FractionSize().0.bitMask\ := \Posit::FractionSize().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit::FractionSize().0._State_3\.
                        if (\Posit::FractionSize().0._State\ = \Posit::FractionSize().0._State_5\) then 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit::FractionSize().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::FractionSize().0.this\.\PositBits\;
                        \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::FractionSize().0.return.1\ := \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::FractionSize().0.bitMask\ := \Posit::FractionSize().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit::FractionSize().0._State_3\.
                            if (\Posit::FractionSize().0._State\ = \Posit::FractionSize().0._State_7\) then 
                                \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16)
                        if (\Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\) then 
                            \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ <= false;
                            \Posit::FractionSize().0.return.2\ := \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\;
                            \Posit::FractionSize().0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit::FractionSize().0.return.2\), 32)) + to_signed(2, 32), 32);
                            \Posit::FractionSize().0.binaryOperationResult.1\ := SmartResize((\Posit::FractionSize().0.binaryOperationResult.0\) + to_signed(3, 32), 32);
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7962
                    when \Posit::FractionSize().0._State_9\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit::FractionSize().0.binaryOperationResult.2\ := to_signed(32, 32) - (\Posit::FractionSize().0.binaryOperationResult.1\);
                        \Posit::FractionSize().0.num\ := (\Posit::FractionSize().0.binaryOperationResult.2\);
                        -- The following section was transformed from the .NET statement below:
                        -- int conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (num > 0) {
                        -- 	conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744 = num;
                        -- }
                        -- else {
                        -- 	conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744 = 0;
                        -- }
                        -- 
                        \Posit::FractionSize().0.binaryOperationResult.3\ := \Posit::FractionSize().0.num\ > to_signed(0, 32);

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit::FractionSize().0._State_11\ and ends in state \Posit::FractionSize().0._State_11\.
                        --     * The false branch starts in state \Posit::FractionSize().0._State_12\ and ends in state \Posit::FractionSize().0._State_12\.
                        --     * Execution after either branch will continue in the following state: \Posit::FractionSize().0._State_10\.

                        if (\Posit::FractionSize().0.binaryOperationResult.3\) then 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_11\;
                        else 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.86175
                    when \Posit::FractionSize().0._State_10\ => 
                        -- State after the if-else which was started in state \Posit::FractionSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- return (uint)(conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744);
                        -- 
                        \Posit::FractionSize().0.return\ <= unsigned((\Posit::FractionSize().0.conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744\));
                        \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_11\ => 
                        -- True branch of the if-else started in state \Posit::FractionSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744 = num;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744 = num;
                        -- 
                        \Posit::FractionSize().0.conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744\ := \Posit::FractionSize().0.num\;
                        -- Going to the state after the if-else which was started in state \Posit::FractionSize().0._State_9\.
                        if (\Posit::FractionSize().0._State\ = \Posit::FractionSize().0._State_11\) then 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionSize().0._State_12\ => 
                        -- False branch of the if-else started in state \Posit::FractionSize().0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744 = 0;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744 = 0;
                        -- 
                        \Posit::FractionSize().0.conditionala1d4246e9bdf5bbcdec7ef415ecb7cad3c70bb66d47beec0e65fd46c22c29744\ := to_signed(0, 32);
                        -- Going to the state after the if-else which was started in state \Posit::FractionSize().0._State_9\.
                        if (\Posit::FractionSize().0._State\ = \Posit::FractionSize().0._State_12\) then 
                            \Posit::FractionSize().0._State\ := \Posit::FractionSize().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0 state machine start
    \Posit::FractionWithHiddenBit().0._StateMachine\: process (\Clock\) 
        Variable \Posit::FractionWithHiddenBit().0._State\: \Posit::FractionWithHiddenBit().0._States\ := \Posit::FractionWithHiddenBit().0._State_0\;
        Variable \Posit::FractionWithHiddenBit().0.this\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit::FractionWithHiddenBit().0.left\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionWithHiddenBit().0.return.0\: boolean := false;
        Variable \Posit::FractionWithHiddenBit().0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionWithHiddenBit().0.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::FractionWithHiddenBit().0.return.2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::FractionWithHiddenBit().0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionWithHiddenBit().0.return.3\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionWithHiddenBit().0.binaryOperationResult.2\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::FractionWithHiddenBit().0.return.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::FractionWithHiddenBit().0.binaryOperationResult.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::FractionWithHiddenBit().0.return.5\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit::FractionWithHiddenBit().0.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::FractionWithHiddenBit().0.return.7\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::FractionWithHiddenBit().0._Finished\ <= false;
                \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_0\;
                \Posit::FractionWithHiddenBit().0.return.0\ := false;
                \Posit::FractionWithHiddenBit().0.binaryOperationResult.0\ := to_signed(0, 64);
                \Posit::FractionWithHiddenBit().0.return.2\ := to_unsigned(0, 32);
                \Posit::FractionWithHiddenBit().0.binaryOperationResult.1\ := to_signed(0, 32);
                \Posit::FractionWithHiddenBit().0.binaryOperationResult.2\ := to_signed(0, 64);
                \Posit::FractionWithHiddenBit().0.return.4\ := to_unsigned(0, 32);
                \Posit::FractionWithHiddenBit().0.binaryOperationResult.3\ := to_signed(0, 32);
                \Posit::FractionWithHiddenBit().0.return.6\ := to_unsigned(0, 32);
            else 
                case \Posit::FractionWithHiddenBit().0._State\ is 
                    when \Posit::FractionWithHiddenBit().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::FractionWithHiddenBit().0._Started\ = true) then 
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::FractionWithHiddenBit().0._Started\ = true) then 
                            \Posit::FractionWithHiddenBit().0._Finished\ <= true;
                        else 
                            \Posit::FractionWithHiddenBit().0._Finished\ <= false;
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_2\ => 
                        \Posit::FractionWithHiddenBit().0.this\ := \Posit::FractionWithHiddenBit().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask left;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (@this)) {
                        -- 	left = @this.PositBits;
                        -- }
                        -- else {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit::FractionWithHiddenBit().0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.this\;
                        \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\ = \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.0\ := \Posit::FractionWithHiddenBit().0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit::FractionWithHiddenBit().0._State_5\ and ends in state \Posit::FractionWithHiddenBit().0._State_5\.
                            --     * The false branch starts in state \Posit::FractionWithHiddenBit().0._State_6\ and ends in state \Posit::FractionWithHiddenBit().0._State_7\.
                            --     * Execution after either branch will continue in the following state: \Posit::FractionWithHiddenBit().0._State_4\.

                            if (\Posit::FractionWithHiddenBit().0.return.0\) then 
                                \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_5\;
                            else 
                                \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_6\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_4\ => 
                        -- State after the if-else which was started in state \Posit::FractionWithHiddenBit().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- return Lombiq.Arithmetics.BitMask.SetOne (BitMask.op_RightShift (BitMask.op_LeftShift (left, (int)((long)((Int32)(@this.PositBits.SegmentCount) * 32) - (long)((ulong)Lombiq.Arithmetics.Posit.FractionSize (@this)))), (int)((long)((Int32)(@this.PositBits.SegmentCount) * 32) - (long)((ulong)Lombiq.Arithmetics.Posit.FractionSize (@this)))), (ushort)Lombiq.Arithmetics.Posit.FractionSize (@this));
                        -- 
                        \Posit::FractionWithHiddenBit().0.binaryOperationResult.0\ := SmartResize(signed(SmartResize((\Posit::FractionWithHiddenBit().0.this\.\PositBits\.\SegmentCount\), 32)) * to_signed(32, 32), 64);
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.this\;
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0.14475
                    when \Posit::FractionWithHiddenBit().0._State_5\ => 
                        -- True branch of the if-else started in state \Posit::FractionWithHiddenBit().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = @this.PositBits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = @this.PositBits;
                        -- 
                        \Posit::FractionWithHiddenBit().0.left\ := \Posit::FractionWithHiddenBit().0.this\.\PositBits\;
                        -- Going to the state after the if-else which was started in state \Posit::FractionWithHiddenBit().0._State_3\.
                        if (\Posit::FractionWithHiddenBit().0._State\ = \Posit::FractionWithHiddenBit().0._State_5\) then 
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_6\ => 
                        -- False branch of the if-else started in state \Posit::FractionWithHiddenBit().0._State_3\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- left = Lombiq.Arithmetics.BitMask.GetTwosComplement (@this.PositBits, 32);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.this\.\PositBits\;
                        \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.1\ := \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).return.0\;
                            \Posit::FractionWithHiddenBit().0.left\ := \Posit::FractionWithHiddenBit().0.return.1\;
                            -- Going to the state after the if-else which was started in state \Posit::FractionWithHiddenBit().0._State_3\.
                            if (\Posit::FractionWithHiddenBit().0._State\ = \Posit::FractionWithHiddenBit().0._State_7\) then 
                                \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_4\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ = \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.2\ := \Posit::FractionWithHiddenBit().0.Posit::FractionSize().return.0\;
                            \Posit::FractionWithHiddenBit().0.binaryOperationResult.1\ := SmartResize((\Posit::FractionWithHiddenBit().0.binaryOperationResult.0\) - signed((SmartResize(\Posit::FractionWithHiddenBit().0.return.2\, 64))), 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.left\;
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= (\Posit::FractionWithHiddenBit().0.binaryOperationResult.1\);
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.39855
                    when \Posit::FractionWithHiddenBit().0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.3\ := \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit::FractionWithHiddenBit().0.binaryOperationResult.2\ := SmartResize(signed(SmartResize((\Posit::FractionWithHiddenBit().0.this\.\PositBits\.\SegmentCount\), 32)) * to_signed(32, 32), 64);
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.14475
                    when \Posit::FractionWithHiddenBit().0._State_10\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.this\;
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ = \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.4\ := \Posit::FractionWithHiddenBit().0.Posit::FractionSize().return.0\;
                            \Posit::FractionWithHiddenBit().0.binaryOperationResult.3\ := SmartResize((\Posit::FractionWithHiddenBit().0.binaryOperationResult.2\) - signed((SmartResize(\Posit::FractionWithHiddenBit().0.return.4\, 64))), 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.return.3\;
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= (\Posit::FractionWithHiddenBit().0.binaryOperationResult.3\);
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.39855
                    when \Posit::FractionWithHiddenBit().0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.5\ := \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\;
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_13\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.this\;
                        \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ = \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.6\ := \Posit::FractionWithHiddenBit().0.Posit::FractionSize().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \Posit::FractionWithHiddenBit().0.return.5\;
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= SmartResize(\Posit::FractionWithHiddenBit().0.return.6\, 16);
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::FractionWithHiddenBit().0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\ = \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \Posit::FractionWithHiddenBit().0.return.7\ := \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).return.0\;
                            \Posit::FractionWithHiddenBit().0.return\ <= \Posit::FractionWithHiddenBit().0.return.7\;
                            \Posit::FractionWithHiddenBit().0._State\ := \Posit::FractionWithHiddenBit().0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0 state machine end


    -- System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte).0 state machine start
    \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._StateMachine\: process (\Clock\) 
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\: \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._States\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_0\;
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.1\: signed(31 downto 0) := to_signed(0, 32);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Finished\ <= false;
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.return\ <= to_signed(0, 32);
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_0\;
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue\ := to_signed(0, 32);
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue\ := to_unsigned(0, 32);
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize\ := to_unsigned(0, 8);
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.0\ := to_signed(0, 64);
                \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.1\ := to_signed(0, 32);
            else 
                case \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\ is 
                    when \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Started\ = true) then 
                            \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Started\ = true) then 
                            \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Finished\ <= true;
                        else 
                            \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Finished\ <= false;
                            \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_2\ => 
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue.parameter.In\;
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue.parameter.In\;
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return (int)((long)(regimeKValue * 8) + (long)((ulong)exponentValue));
                        -- 
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.0\ := SmartResize(\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue\ * to_signed(8, 32), 64);
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.1\ := SmartResize((\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.0\) + signed((SmartResize(\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue\, 64))), 32);
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.return\ <= (\Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.binaryOperationResult.1\);
                        \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State\ := \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0.6447
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte).0 state machine end


    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 state machine start
    \Posit Posit::op_Addition(Posit,Posit).0._StateMachine\: process (\Clock\) 
        Variable \Posit Posit::op_Addition(Posit,Posit).0._State\: \Posit Posit::op_Addition(Posit,Posit).0._States\ := \Posit Posit::op_Addition(Posit,Posit).0._State_0\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.left\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.right\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag2\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.signBit\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag3\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag4\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.posit\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.exponentValue\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag5\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.posit2\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.exponentValue2\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag6\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.result\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag7\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.bitMask\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.num\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.num2\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag8\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag9\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag10\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag11\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.num3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.num4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag12\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.num5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.num6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag13\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.flag14\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.exponentBits\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.0\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.1\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.3\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.0\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.1\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.1\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.2\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.4\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.6\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.3\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.9\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.11\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.13\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.2\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.3\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.4\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.5\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.6\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.18\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.19\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.20\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.21\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.22\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.23\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.24\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.25\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.26\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.27\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.28\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.29\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.30\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.31\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.32\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.33\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.34\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.35\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.8\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.9\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.36\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.37\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.10\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.38\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.39\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.40\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.41\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.11\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.42\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.43\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.12\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.13\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.44\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.45\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.46\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.14\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.15\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.47\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.48\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.49\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.16\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.17\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.50\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.51\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.18\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.52\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.53\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.54\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.55\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.19\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.56\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.57\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.20\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.21\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.58\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.59\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.60\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.22\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.23\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.61\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.62\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.63\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.24\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.25\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.64\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.26\: boolean := false;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.65\: \Lombiq.Arithmetics.BitMask\;
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.27\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.28\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.29\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.30\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Posit Posit::op_Addition(Posit,Posit).0.return.66\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit Posit::op_Addition(Posit,Posit).0._Finished\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(0, 8);
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\ <= to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_0\;
                \Posit Posit::op_Addition(Posit,Posit).0.flag\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.flag2\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.signBit\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.flag3\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.flag4\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.exponentValue\ := to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.flag5\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue2\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.exponentValue2\ := to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.flag6\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.flag7\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.num\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.num2\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.flag8\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.flag9\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.flag10\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.flag11\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.num3\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.num4\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.flag12\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.num5\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.num6\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.flag13\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.flag14\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue3\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.0\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.return.1\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.return.3\ := to_unsigned(0, 16);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.0\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.0\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.1\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.1\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.2\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.return.5\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.6\ := to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.7\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.8\ := to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.3\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.return.10\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.11\ := to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.12\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.13\ := to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.2\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.3\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.return.14\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.15\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.4\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.5\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.return.16\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.17\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.6\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.return.24\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.return.33\ := to_unsigned(0, 16);
                \Posit Posit::op_Addition(Posit,Posit).0.return.35\ := to_unsigned(0, 16);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.7\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.8\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.9\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.return.36\ := to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.37\ := to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.10\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.41\ := to_unsigned(0, 16);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.11\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.12\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.13\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.14\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.15\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.49\ := to_unsigned(0, 16);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.16\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.17\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.50\ := to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.51\ := to_unsigned(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.18\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.55\ := to_unsigned(0, 16);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.19\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.20\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.21\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.22\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.23\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.63\ := to_unsigned(0, 16);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.24\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.25\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.return.64\ := to_unsigned(0, 16);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.26\ := false;
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.27\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.28\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.29\ := to_signed(0, 32);
                \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.30\ := to_unsigned(0, 32);
            else 
                case \Posit Posit::op_Addition(Posit,Posit).0._State\ is 
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._Started\ = true) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._Started\ = true) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._Finished\ <= true;
                        else 
                            \Posit Posit::op_Addition(Posit,Posit).0._Finished\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_2\ => 
                        \Posit Posit::op_Addition(Posit,Posit).0.left\ := \Posit Posit::op_Addition(Posit,Posit).0.left.parameter.In\;
                        \Posit Posit::op_Addition(Posit,Posit).0.right\ := \Posit Posit::op_Addition(Posit,Posit).0.right.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool signBit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit posit;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int regimeKValue;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentValue;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit posit2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int regimeKValue2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint exponentValue2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag7;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask bitMask;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num2;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag8;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag9;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag10;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag11;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num4;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag12;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num5;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int num6;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag13;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag14;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int regimeKValue3;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask exponentBits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = Lombiq.Arithmetics.Posit.IsPositive (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.0\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.flag\ := \Posit Posit::op_Addition(Posit,Posit).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag2 = Lombiq.Arithmetics.Posit.IsPositive (right);
                            -- 
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_4\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_5\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.1\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.flag2\ := \Posit Posit::op_Addition(Posit,Posit).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- if ((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (BitMask.op_Addition (left.PositBits, right.PositBits))) < (Int32)(left.PositBits.Size)) {
                            -- 	signBit = !flag;
                            -- }
                            -- else {
                            -- 	signBit = !flag2;
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\.\PositBits\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\.\PositBits\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.2\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.2\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.3\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.0\ := signed(SmartResize((\Posit Posit::op_Addition(Posit,Posit).0.return.3\), 32)) < signed(SmartResize((\Posit Posit::op_Addition(Posit,Posit).0.left\.\PositBits\.\Size\), 32));

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_10\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_10\.
                            --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_11\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_11\.
                            --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_9\.

                            if (\Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.0\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_10\;
                            else 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_11\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.46515
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_9\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag3 = flag == flag2;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.1\ := \Posit Posit::op_Addition(Posit,Posit).0.flag\ = \Posit Posit::op_Addition(Posit,Posit).0.flag2\;
                        \Posit Posit::op_Addition(Posit,Posit).0.flag3\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.1\;
                        -- The following section was transformed from the .NET statement below:
                        -- flag4 = !flag;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.2\ := not(\Posit Posit::op_Addition(Posit,Posit).0.flag\);
                        \Posit Posit::op_Addition(Posit,Posit).0.flag4\ := \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag4) {
                        -- 	posit = Posit.op_UnaryNegation (left);
                        -- 	regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit);
                        -- 	exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (posit);
                        -- }
                        -- else {
                        -- 	regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (left);
                        -- 	exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (left);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_13\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_16\.
                        --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_17\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_19\.
                        --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_12\.

                        if (\Posit Posit::op_Addition(Posit,Posit).0.flag4\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_13\;
                        else 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_17\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.2178
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_10\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	signBit = !flag;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = !flag;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.0\ := not(\Posit Posit::op_Addition(Posit,Posit).0.flag\);
                        \Posit Posit::op_Addition(Posit,Posit).0.signBit\ := \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.0\;
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_8\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_10\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.0984
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_11\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_8\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	signBit = !flag2;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- signBit = !flag2;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.1\ := not(\Posit Posit::op_Addition(Posit,Posit).0.flag2\);
                        \Posit Posit::op_Addition(Posit,Posit).0.signBit\ := \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.1\;
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_8\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_11\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.0984
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_12\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag5 = !flag2;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.3\ := not(\Posit Posit::op_Addition(Posit,Posit).0.flag2\);
                        \Posit Posit::op_Addition(Posit,Posit).0.flag5\ := \Posit Posit::op_Addition(Posit,Posit).0.unaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag5) {
                        -- 	posit2 = Posit.op_UnaryNegation (right);
                        -- 	regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit2);
                        -- 	exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (posit2);
                        -- }
                        -- else {
                        -- 	regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (right);
                        -- 	exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (right);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_21\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_24\.
                        --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_25\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_27\.
                        --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_20\.

                        if (\Posit Posit::op_Addition(Posit,Posit).0.flag5\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_21\;
                        else 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_25\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.0984
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_13\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	posit = Posit.op_UnaryNegation (left);
                        -- 	regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit);
                        -- 	exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (posit);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- posit = Posit.op_UnaryNegation (left);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit)
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit).x.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_14\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.4\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.posit\ := \Posit Posit::op_Addition(Posit,Posit).0.return.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit);
                            -- 
                            -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.posit\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.5\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue\ := \Posit Posit::op_Addition(Posit,Posit).0.return.5\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (posit);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.posit\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_16\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.6\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.exponentValue\ := \Posit Posit::op_Addition(Posit,Posit).0.return.6\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_9\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_16\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_12\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_17\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_9\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (left);
                        -- 	exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (left);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue = Lombiq.Arithmetics.Posit.GetRegimeKValue (left);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_18\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_18\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.7\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue\ := \Posit Posit::op_Addition(Posit,Posit).0.return.7\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValue = Lombiq.Arithmetics.Posit.GetExponentValue (left);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_19\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.8\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.exponentValue\ := \Posit Posit::op_Addition(Posit,Posit).0.return.8\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_9\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_19\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_12\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_20\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag6 = regimeKValue == -31;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.2\ := \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue\ = to_signed(-31, 32);
                        \Posit Posit::op_Addition(Posit,Posit).0.flag6\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.2\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag6) {
                        -- 	if (flag) {
                        -- 		result = right;
                        -- 	}
                        -- 	else {
                        -- 		result = left;
                        -- 	}
                        -- }
                        -- else {
                        -- 	flag7 = regimeKValue2 == -31;
                        -- 	if (flag7) {
                        -- 		if (flag2) {
                        -- 			result = left;
                        -- 		}
                        -- 		else {
                        -- 			result = right;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		bitMask = new BitMask (32, false);
                        -- 		num = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3) - Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 		if (num >= 0) {
                        -- 			num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- 		}
                        -- 		else {
                        -- 			num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 		}
                        -- 		flag8 = num == 0;
                        -- 		if (flag8) {
                        -- 			flag9 = flag3;
                        -- 			if (flag9) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 			}
                        -- 			else {
                        -- 				flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 				if (flag10) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 				}
                        -- 			}
                        -- 			num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 		}
                        -- 		else {
                        -- 			flag11 = num > 0;
                        -- 			if (flag11) {
                        -- 				num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 				num4 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 				bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 				flag12 = flag3;
                        -- 				if (flag12) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 				}
                        -- 				num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 			}
                        -- 			else {
                        -- 				num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 				num6 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 				bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 				flag13 = flag3;
                        -- 				if (flag13) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 				}
                        -- 				num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 			}
                        -- 		}
                        -- 		flag14 = (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) == 0;
                        -- 		if (flag14) {
                        -- 			result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- 		}
                        -- 		else {
                        -- 			regimeKValue3 = num2 / 8;
                        -- 			exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 			result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                        -- 		}
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_29\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_30\.
                        --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_33\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_34\.
                        --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_28\.

                        if (\Posit Posit::op_Addition(Posit,Posit).0.flag6\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_29\;
                        else 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_33\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3336
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_21\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	posit2 = Posit.op_UnaryNegation (right);
                        -- 	regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit2);
                        -- 	exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (posit2);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- posit2 = Posit.op_UnaryNegation (right);
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit)
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit).x.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_22\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_22\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.9\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.posit2\ := \Posit Posit::op_Addition(Posit,Posit).0.return.9\;
                            -- The following section was transformed from the .NET statement below:
                            -- regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (posit2);
                            -- 
                            -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.posit2\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_23\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_23\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.10\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue2\ := \Posit Posit::op_Addition(Posit,Posit).0.return.10\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (posit2);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.posit2\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_24\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_24\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.11\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.exponentValue2\ := \Posit Posit::op_Addition(Posit,Posit).0.return.11\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_12\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_24\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_20\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_25\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_12\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (right);
                        -- 	exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (right);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue2 = Lombiq.Arithmetics.Posit.GetRegimeKValue (right);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_26\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_26\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.12\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue2\ := \Posit Posit::op_Addition(Posit,Posit).0.return.12\;
                            -- The following section was transformed from the .NET statement below:
                            -- exponentValue2 = Lombiq.Arithmetics.Posit.GetExponentValue (right);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_27\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_27\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.13\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.exponentValue2\ := \Posit Posit::op_Addition(Posit,Posit).0.return.13\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_12\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_27\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_20\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_28\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.return\ <= \Posit Posit::op_Addition(Posit,Posit).0.result\;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_29\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (flag) {
                        -- 		result = right;
                        -- 	}
                        -- 	else {
                        -- 		result = left;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	result = right;
                        -- }
                        -- else {
                        -- 	result = left;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_31\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_31\.
                        --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_32\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_32\.
                        --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_30\.

                        if (\Posit Posit::op_Addition(Posit,Posit).0.flag\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_31\;
                        else 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_32\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_30\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_29\.
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_20\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_30\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_31\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = right;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = right;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.result\ := \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_29\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_31\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_32\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_29\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.result\ := \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_29\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_32\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_30\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_33\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag7 = regimeKValue2 == -31;
                        -- 	if (flag7) {
                        -- 		if (flag2) {
                        -- 			result = left;
                        -- 		}
                        -- 		else {
                        -- 			result = right;
                        -- 		}
                        -- 	}
                        -- 	else {
                        -- 		bitMask = new BitMask (32, false);
                        -- 		num = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3) - Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 		if (num >= 0) {
                        -- 			num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- 		}
                        -- 		else {
                        -- 			num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 		}
                        -- 		flag8 = num == 0;
                        -- 		if (flag8) {
                        -- 			flag9 = flag3;
                        -- 			if (flag9) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 			}
                        -- 			else {
                        -- 				flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 				if (flag10) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 				}
                        -- 			}
                        -- 			num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 		}
                        -- 		else {
                        -- 			flag11 = num > 0;
                        -- 			if (flag11) {
                        -- 				num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 				num4 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 				bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 				flag12 = flag3;
                        -- 				if (flag12) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 				}
                        -- 				num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 			}
                        -- 			else {
                        -- 				num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 				bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 				num6 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 				bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 				flag13 = flag3;
                        -- 				if (flag13) {
                        -- 					bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 				}
                        -- 				else {
                        -- 					bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 				}
                        -- 				num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 			}
                        -- 		}
                        -- 		flag14 = (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) == 0;
                        -- 		if (flag14) {
                        -- 			result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- 		}
                        -- 		else {
                        -- 			regimeKValue3 = num2 / 8;
                        -- 			exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 			result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                        -- 		}
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag7 = regimeKValue2 == -31;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.3\ := \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue2\ = to_signed(-31, 32);
                        \Posit Posit::op_Addition(Posit,Posit).0.flag7\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag7) {
                        -- 	if (flag2) {
                        -- 		result = left;
                        -- 	}
                        -- 	else {
                        -- 		result = right;
                        -- 	}
                        -- }
                        -- else {
                        -- 	bitMask = new BitMask (32, false);
                        -- 	num = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3) - Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 	if (num >= 0) {
                        -- 		num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- 	}
                        -- 	else {
                        -- 		num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 	}
                        -- 	flag8 = num == 0;
                        -- 	if (flag8) {
                        -- 		flag9 = flag3;
                        -- 		if (flag9) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 		}
                        -- 		else {
                        -- 			flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 			if (flag10) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 			}
                        -- 		}
                        -- 		num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 	}
                        -- 	else {
                        -- 		flag11 = num > 0;
                        -- 		if (flag11) {
                        -- 			num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 			num4 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 			bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 			flag12 = flag3;
                        -- 			if (flag12) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 			}
                        -- 			num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 		}
                        -- 		else {
                        -- 			num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 			num6 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 			bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 			flag13 = flag3;
                        -- 			if (flag13) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 			}
                        -- 			num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 		}
                        -- 	}
                        -- 	flag14 = (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) == 0;
                        -- 	if (flag14) {
                        -- 		result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- 	}
                        -- 	else {
                        -- 		regimeKValue3 = num2 / 8;
                        -- 		exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 		result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_35\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_36\.
                        --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_39\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_133\.
                        --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_34\.

                        if (\Posit Posit::op_Addition(Posit,Posit).0.flag7\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_35\;
                        else 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_39\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3336
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_34\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_33\.
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_20\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_34\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_28\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_35\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (flag2) {
                        -- 		result = left;
                        -- 	}
                        -- 	else {
                        -- 		result = right;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag2) {
                        -- 	result = left;
                        -- }
                        -- else {
                        -- 	result = right;
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_37\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_37\.
                        --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_38\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_38\.
                        --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_36\.

                        if (\Posit Posit::op_Addition(Posit,Posit).0.flag2\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_37\;
                        else 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_38\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_36\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_35\.
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_33\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_36\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_34\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_37\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_35\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = left;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = left;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.result\ := \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_35\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_37\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_38\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_35\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = right;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = right;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.result\ := \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_35\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_38\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_36\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_39\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_33\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = new BitMask (32, false);
                        -- 	num = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3) - Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 	if (num >= 0) {
                        -- 		num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- 	}
                        -- 	else {
                        -- 		num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 	}
                        -- 	flag8 = num == 0;
                        -- 	if (flag8) {
                        -- 		flag9 = flag3;
                        -- 		if (flag9) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 		}
                        -- 		else {
                        -- 			flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 			if (flag10) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 			}
                        -- 		}
                        -- 		num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 	}
                        -- 	else {
                        -- 		flag11 = num > 0;
                        -- 		if (flag11) {
                        -- 			num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 			num4 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 			bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 			flag12 = flag3;
                        -- 			if (flag12) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 			}
                        -- 			num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 		}
                        -- 		else {
                        -- 			num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 			bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 			num6 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 			bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 			flag13 = flag3;
                        -- 			if (flag13) {
                        -- 				bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 			}
                        -- 			else {
                        -- 				bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 			}
                        -- 			num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 		}
                        -- 	}
                        -- 	flag14 = (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) == 0;
                        -- 	if (flag14) {
                        -- 		result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- 	}
                        -- 	else {
                        -- 		regimeKValue3 = num2 / 8;
                        -- 		exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 		result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = new BitMask (32, false);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit Posit::op_Addition(Posit,Posit).0.bitMask\.\IsNull\ := false;
                        \Posit Posit::op_Addition(Posit,Posit).0.bitMask\.\Size\ := to_unsigned(0, 16);
                        \Posit Posit::op_Addition(Posit,Posit).0.bitMask\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit Posit::op_Addition(Posit,Posit).0.bitMask\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_40\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_40\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- num = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3) - Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                            -- 
                            -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.exponentValue\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(3, 8);
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_41\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_41\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.14\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_42\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_42\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_43\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_43\ => 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue2\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.exponentValue2\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(3, 8);
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_44\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_44\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.15\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.4\ := \Posit Posit::op_Addition(Posit,Posit).0.return.14\ - \Posit Posit::op_Addition(Posit,Posit).0.return.15\;
                            \Posit Posit::op_Addition(Posit,Posit).0.num\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.4\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (num >= 0) {
                            -- 	num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                            -- }
                            -- else {
                            -- 	num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                            -- }
                            -- 
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.5\ := \Posit Posit::op_Addition(Posit,Posit).0.num\ >= to_signed(0, 32);

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_46\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_47\.
                            --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_48\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_50\.
                            --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_45\.

                            if (\Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.5\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_46\;
                            else 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_48\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.8382
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_45\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag8 = num == 0;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.6\ := \Posit Posit::op_Addition(Posit,Posit).0.num\ = to_signed(0, 32);
                        \Posit Posit::op_Addition(Posit,Posit).0.flag8\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.6\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag8) {
                        -- 	flag9 = flag3;
                        -- 	if (flag9) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 	}
                        -- 	else {
                        -- 		flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 		if (flag10) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 		}
                        -- 	}
                        -- 	num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- }
                        -- else {
                        -- 	flag11 = num > 0;
                        -- 	if (flag11) {
                        -- 		num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 		num4 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 		bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 		flag12 = flag3;
                        -- 		if (flag12) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 		}
                        -- 		num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 	}
                        -- 	else {
                        -- 		num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 		num6 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 		bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 		flag13 = flag3;
                        -- 		if (flag13) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 		}
                        -- 		num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_52\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_87\.
                        --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_88\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_89\.
                        --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_51\.

                        if (\Posit Posit::op_Addition(Posit,Posit).0.flag8\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_52\;
                        else 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_88\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3336
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_46\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Posit.CalculateScaleFactor (regimeKValue, exponentValue, 3);
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.exponentValue\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(3, 8);
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_47\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_47\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.16\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.num2\ := \Posit Posit::op_Addition(Posit,Posit).0.return.16\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_44\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_47\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_45\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_48\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_44\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = Posit.CalculateScaleFactor (regimeKValue2, exponentValue2, 3);
                        -- 
                        -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_49\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_49\ => 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue2\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.exponentValue2\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\ <= to_unsigned(3, 8);
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_50\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_50\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.17\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.num2\ := \Posit Posit::op_Addition(Posit,Posit).0.return.17\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_44\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_50\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_45\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_51\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_45\.
                        -- The following section was transformed from the .NET statement below:
                        -- flag14 = (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) == 0;
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_132\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_52\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_45\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag9 = flag3;
                        -- 	if (flag9) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 	}
                        -- 	else {
                        -- 		flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 		if (flag10) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 		}
                        -- 	}
                        -- 	num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag9 = flag3;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.flag9\ := \Posit Posit::op_Addition(Posit,Posit).0.flag3\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag9) {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- }
                        -- else {
                        -- 	flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 	if (flag10) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_54\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_62\.
                        --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_63\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_69\.
                        --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_53\.

                        if (\Posit Posit::op_Addition(Posit,Posit).0.flag9\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_54\;
                        else 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_63\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_53\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_84\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_54\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_Addition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_55\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_55\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.18\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_56\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_56\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_57\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_57\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_58\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_58\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.19\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.18\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.19\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_59\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_59\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.20\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_60\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_60\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_61\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_61\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.20\;
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_62\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_62\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.21\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.return.21\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_52\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_62\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_53\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_63\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_52\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 	if (flag10) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag10 = BitMask.op_GreaterThanOrEqual (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_64\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_64\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.22\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_65\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_65\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_66\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_66\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_67\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_67\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.23\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.22\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.23\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_68\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_68\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.24\ := \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.flag10\ := \Posit Posit::op_Addition(Posit,Posit).0.return.24\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag10) {
                            -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                            -- }
                            -- else {
                            -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_70\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_76\.
                            --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_77\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_83\.
                            --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_69\.

                            if (\Posit Posit::op_Addition(Posit,Posit).0.flag10\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_70\;
                            else 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_77\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_69\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_68\.
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_52\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_69\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_53\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_70\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_68\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right)));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_71\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_71\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.25\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_72\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_72\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_73\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_73\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_74\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_74\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.26\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.25\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.26\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_75\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_75\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.27\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.27\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_76\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_76\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.28\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.return.28\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_68\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_76\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_69\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_77\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_68\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_Subtraction (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left)));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_78\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_78\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.29\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_79\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_79\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_80\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_80\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_81\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_81\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.30\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.29\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.30\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_82\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_82\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.31\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.31\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_83\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_83\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.32\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.return.32\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_68\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_83\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_69\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_84\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.33\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_85\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_85\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.34\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_86\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_86\ => 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.34\;
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_87\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_87\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.35\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.7\ := signed(SmartResize((\Posit Posit::op_Addition(Posit,Posit).0.return.33\), 32)) - signed(SmartResize((\Posit Posit::op_Addition(Posit,Posit).0.return.35\), 32));
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.8\ := \Posit Posit::op_Addition(Posit,Posit).0.num2\ + (\Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.7\);
                            \Posit Posit::op_Addition(Posit,Posit).0.num2\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.8\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_45\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_87\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_51\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7545
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_88\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_45\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	flag11 = num > 0;
                        -- 	if (flag11) {
                        -- 		num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 		num4 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 		bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 		flag12 = flag3;
                        -- 		if (flag12) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 		}
                        -- 		num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 	}
                        -- 	else {
                        -- 		num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 		bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 		num6 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 		bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 		flag13 = flag3;
                        -- 		if (flag13) {
                        -- 			bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 		}
                        -- 		else {
                        -- 			bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 		}
                        -- 		num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag11 = num > 0;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.9\ := \Posit Posit::op_Addition(Posit,Posit).0.num\ > to_signed(0, 32);
                        \Posit Posit::op_Addition(Posit,Posit).0.flag11\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.9\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag11) {
                        -- 	num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 	num4 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 	flag12 = flag3;
                        -- 	if (flag12) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 	}
                        -- 	num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- }
                        -- else {
                        -- 	num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 	num6 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 	flag13 = flag3;
                        -- 	if (flag13) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 	}
                        -- 	num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_90\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_110\.
                        --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_111\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_131\.
                        --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_89\.

                        if (\Posit Posit::op_Addition(Posit,Posit).0.flag11\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_90\;
                        else 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_111\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.50535
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_89\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_88\.
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_45\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_89\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_51\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_90\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_88\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                        -- 	num4 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, num4);
                        -- 	flag12 = flag3;
                        -- 	if (flag12) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 	}
                        -- 	num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num3 = (int)(Lombiq.Arithmetics.Posit.FractionSize (left) - Lombiq.Arithmetics.Posit.FractionSize (right));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_91\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_91\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.36\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_92\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_92\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_93\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_93\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_94\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_94\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.37\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.10\ := signed(\Posit Posit::op_Addition(Posit,Posit).0.return.36\ - \Posit Posit::op_Addition(Posit,Posit).0.return.37\);
                            \Posit Posit::op_Addition(Posit,Posit).0.num3\ := (\Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.10\);
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left));
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_95\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_95\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.38\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.38\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_96\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_96\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.39\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.return.39\;
                            -- The following section was transformed from the .NET statement below:
                            -- num4 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left))));
                            -- 
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_97\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_97\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_98\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_98\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.40\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.40\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_99\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_99\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.41\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.11\ := to_signed(31, 32) - signed(SmartResize((\Posit Posit::op_Addition(Posit,Posit).0.return.41\), 32));
                            \Posit Posit::op_Addition(Posit,Posit).0.num4\ := (\Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.11\);
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_LeftShift (bitMask, num4);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.num4\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_100\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_100\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.42\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.return.42\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag12 = flag3;
                            -- 
                            \Posit Posit::op_Addition(Posit,Posit).0.flag12\ := \Posit Posit::op_Addition(Posit,Posit).0.flag3\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag12) {
                            -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                            -- }
                            -- else {
                            -- 	bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_102\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_105\.
                            --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_106\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_109\.
                            --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_101\.

                            if (\Posit Posit::op_Addition(Posit,Posit).0.flag12\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_102\;
                            else 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_106\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_101\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_100\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_110\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_102\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_100\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_103\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_103\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.43\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.12\ := \Posit Posit::op_Addition(Posit,Posit).0.num4\ - \Posit Posit::op_Addition(Posit,Posit).0.num\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.13\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.12\ + \Posit Posit::op_Addition(Posit,Posit).0.num3\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.43\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.13\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_104\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7545
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_104\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.44\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.44\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_105\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_105\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.45\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.return.45\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_100\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_105\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_101\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_106\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_100\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right), num4 - num + num3));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_107\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_107\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.46\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.14\ := \Posit Posit::op_Addition(Posit,Posit).0.num4\ - \Posit Posit::op_Addition(Posit,Posit).0.num\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.15\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.14\ + \Posit Posit::op_Addition(Posit,Posit).0.num3\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.46\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.15\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_108\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7545
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_108\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.47\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.47\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_109\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_109\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.48\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.return.48\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_100\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_109\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_101\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_110\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.49\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.16\ := signed(SmartResize((\Posit Posit::op_Addition(Posit,Posit).0.return.49\), 32)) - to_signed(31, 32);
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.17\ := \Posit Posit::op_Addition(Posit,Posit).0.num2\ + (\Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.16\);
                            \Posit Posit::op_Addition(Posit,Posit).0.num2\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.17\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_88\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_110\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_89\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7545
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_111\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_88\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 	bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                        -- 	num6 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                        -- 	bitMask = BitMask.op_LeftShift (bitMask, num6);
                        -- 	flag13 = flag3;
                        -- 	if (flag13) {
                        -- 		bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 	}
                        -- 	else {
                        -- 		bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 	}
                        -- 	num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- num5 = (int)(Lombiq.Arithmetics.Posit.FractionSize (right) - Lombiq.Arithmetics.Posit.FractionSize (left));
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_112\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_112\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.50\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\;
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_113\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_113\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_114\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_114\ => 
                        -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_115\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_115\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::FractionSize()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.51\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.18\ := signed(\Posit Posit::op_Addition(Posit,Posit).0.return.50\ - \Posit Posit::op_Addition(Posit,Posit).0.return.51\);
                            \Posit Posit::op_Addition(Posit,Posit).0.num5\ := (\Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.18\);
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_Addition (bitMask, Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right));
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_116\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_116\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.52\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.52\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_117\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_117\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.53\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.return.53\;
                            -- The following section was transformed from the .NET statement below:
                            -- num6 = (int)(31 - (Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (right))));
                            -- 
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_118\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_118\ => 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.right\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_119\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_119\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.54\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.54\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_120\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_120\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.55\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.19\ := to_signed(31, 32) - signed(SmartResize((\Posit Posit::op_Addition(Posit,Posit).0.return.55\), 32));
                            \Posit Posit::op_Addition(Posit,Posit).0.num6\ := (\Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.19\);
                            -- The following section was transformed from the .NET statement below:
                            -- bitMask = BitMask.op_LeftShift (bitMask, num6);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.num6\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_121\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_121\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.56\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.return.56\;
                            -- The following section was transformed from the .NET statement below:
                            -- flag13 = flag3;
                            -- 
                            \Posit Posit::op_Addition(Posit,Posit).0.flag13\ := \Posit Posit::op_Addition(Posit,Posit).0.flag3\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag13) {
                            -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                            -- }
                            -- else {
                            -- 	bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_123\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_126\.
                            --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_127\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_130\.
                            --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_122\.

                            if (\Posit Posit::op_Addition(Posit,Posit).0.flag13\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_123\;
                            else 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_127\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_122\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_121\.
                        -- The following section was transformed from the .NET statement below:
                        -- num2 = num2 + (int)((Int32)(Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (bitMask)) - 31);
                        -- 
                        -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_131\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_123\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_121\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Addition (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_124\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_124\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.57\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.20\ := \Posit Posit::op_Addition(Posit,Posit).0.num6\ + \Posit Posit::op_Addition(Posit,Posit).0.num\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.21\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.20\ + \Posit Posit::op_Addition(Posit,Posit).0.num5\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.57\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.21\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_125\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7962
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_125\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.58\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.58\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_126\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_126\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.59\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.return.59\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_121\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_126\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_122\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_127\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_121\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- bitMask = BitMask.op_Subtraction (bitMask, BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (left), num6 + num + num5));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_128\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_128\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.60\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.22\ := \Posit Posit::op_Addition(Posit,Posit).0.num6\ + \Posit Posit::op_Addition(Posit,Posit).0.num\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.23\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.22\ + \Posit Posit::op_Addition(Posit,Posit).0.num5\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.60\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.23\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_129\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7962
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_129\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.61\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.61\;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_130\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_130\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.62\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.bitMask\ := \Posit Posit::op_Addition(Posit,Posit).0.return.62\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_121\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_130\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_122\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_131\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.63\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.24\ := signed(SmartResize((\Posit Posit::op_Addition(Posit,Posit).0.return.63\), 32)) - to_signed(31, 32);
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.25\ := \Posit Posit::op_Addition(Posit,Posit).0.num2\ + (\Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.24\);
                            \Posit Posit::op_Addition(Posit,Posit).0.num2\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.25\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_88\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_131\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_89\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7545
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_132\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.64\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.26\ := signed(SmartResize((\Posit Posit::op_Addition(Posit,Posit).0.return.64\), 32)) = to_signed(0, 32);
                            \Posit Posit::op_Addition(Posit,Posit).0.flag14\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.26\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag14) {
                            -- 	result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                            -- }
                            -- else {
                            -- 	regimeKValue3 = num2 / 8;
                            -- 	exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                            -- 	result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_134\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_136\.
                            --     * The false branch starts in state \Posit Posit::op_Addition(Posit,Posit).0._State_137\ and ends in state \Posit Posit::op_Addition(Posit,Posit).0._State_141\.
                            --     * Execution after either branch will continue in the following state: \Posit Posit::op_Addition(Posit,Posit).0._State_133\.

                            if (\Posit Posit::op_Addition(Posit,Posit).0.flag14\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_134\;
                            else 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_137\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3336
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_133\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_132\.
                        -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_33\.
                        if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_133\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_34\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_134\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_132\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit (left._environment, Lombiq.Arithmetics.Posit.get_EmptyBitMask (left));
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit Posit::op_Addition(Posit,Posit).0.result\.\IsNull\ := false;
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                        \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_135\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_135\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask()
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.65\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().return.0\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.result\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\.\_environment\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.65\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_136\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_136\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.result\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.left\.\_environment\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_132\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_136\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_133\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_137\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_Addition(Posit,Posit).0._State_132\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	regimeKValue3 = num2 / 8;
                        -- 	exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 	result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- regimeKValue3 = num2 / 8;
                        -- 
                        \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.27\ := \Posit Posit::op_Addition(Posit,Posit).0.num2\ / to_signed(8, 32);
                        \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue3\ := \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.27\;
                        -- The following section was transformed from the .NET statement below:
                        -- exponentBits = new BitMask ((uint)(num2 - num2 / 8 * 8), 32);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit Posit::op_Addition(Posit,Posit).0.exponentBits\.\IsNull\ := false;
                        \Posit Posit::op_Addition(Posit,Posit).0.exponentBits\.\Size\ := to_unsigned(0, 16);
                        \Posit Posit::op_Addition(Posit,Posit).0.exponentBits\.\SegmentCount\ := to_unsigned(0, 16);
                        \Posit Posit::op_Addition(Posit,Posit).0.exponentBits\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.28\ := \Posit Posit::op_Addition(Posit,Posit).0.num2\ / to_signed(8, 32);
                        \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.29\ := SmartResize(\Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.28\ * to_signed(8, 32), 32);
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_138\;
                        -- Clock cycles needed to complete this state (approximation): 0.96135
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_138\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.30\ := unsigned(\Posit Posit::op_Addition(Posit,Posit).0.num2\ - \Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.29\);
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.exponentBits\;
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= (\Posit Posit::op_Addition(Posit,Posit).0.binaryOperationResult.30\);
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                        \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_139\;
                        -- Clock cycles needed to complete this state (approximation): 0.3564
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_139\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.exponentBits\ := \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- result = new Posit (left._environment, Lombiq.Arithmetics.Posit.AssemblePositBitsWithRounding (left, signBit, regimeKValue3, exponentBits, bitMask));
                            -- 
                            -- Initializing record fields to their defaults.
                            \Posit Posit::op_Addition(Posit,Posit).0.result\.\IsNull\ := false;
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.signBit\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.regimeKValue3\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.exponentBits\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.bitMask\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_140\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_140\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.return.66\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.result\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.left\.\_environment\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return.66\;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_141\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_Addition(Posit,Posit).0._State_141\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_Addition(Posit,Posit).0.result\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\;
                            \Posit Posit::op_Addition(Posit,Posit).0.left\.\_environment\ := \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_Addition(Posit,Posit).0._State_132\.
                            if (\Posit Posit::op_Addition(Posit,Posit).0._State\ = \Posit Posit::op_Addition(Posit,Posit).0._State_141\) then 
                                \Posit Posit::op_Addition(Posit,Posit).0._State\ := \Posit Posit::op_Addition(Posit,Posit).0._State_133\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 state machine end


    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 state machine start
    \Posit Posit::op_UnaryNegation(Posit).0._StateMachine\: process (\Clock\) 
        Variable \Posit Posit::op_UnaryNegation(Posit).0._State\: \Posit Posit::op_UnaryNegation(Posit).0._States\ := \Posit Posit::op_UnaryNegation(Posit).0._State_0\;
        Variable \Posit Posit::op_UnaryNegation(Posit).0.x\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit Posit::op_UnaryNegation(Posit).0.flag\: boolean := false;
        Variable \Posit Posit::op_UnaryNegation(Posit).0.result\: \Lombiq.Arithmetics.Posit\;
        Variable \Posit Posit::op_UnaryNegation(Posit).0.return.0\: boolean := false;
        Variable \Posit Posit::op_UnaryNegation(Posit).0.return.1\: boolean := false;
        Variable \Posit Posit::op_UnaryNegation(Posit).0.binaryOperationResult.0\: boolean := false;
        Variable \Posit Posit::op_UnaryNegation(Posit).0.return.2\: \Lombiq.Arithmetics.BitMask\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit Posit::op_UnaryNegation(Posit).0._Finished\ <= false;
                \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\ <= false;
                \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\ <= false;
                \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_0\;
                \Posit Posit::op_UnaryNegation(Posit).0.flag\ := false;
                \Posit Posit::op_UnaryNegation(Posit).0.return.0\ := false;
                \Posit Posit::op_UnaryNegation(Posit).0.return.1\ := false;
                \Posit Posit::op_UnaryNegation(Posit).0.binaryOperationResult.0\ := false;
            else 
                case \Posit Posit::op_UnaryNegation(Posit).0._State\ is 
                    when \Posit Posit::op_UnaryNegation(Posit).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit Posit::op_UnaryNegation(Posit).0._Started\ = true) then 
                            \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_UnaryNegation(Posit).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit Posit::op_UnaryNegation(Posit).0._Started\ = true) then 
                            \Posit Posit::op_UnaryNegation(Posit).0._Finished\ <= true;
                        else 
                            \Posit Posit::op_UnaryNegation(Posit).0._Finished\ <= false;
                            \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_UnaryNegation(Posit).0._State_2\ => 
                        \Posit Posit::op_UnaryNegation(Posit).0.x\ := \Posit Posit::op_UnaryNegation(Posit).0.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- Posit result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = Lombiq.Arithmetics.Posit.IsNaN (x) || Lombiq.Arithmetics.Posit.IsZero (x);
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsNaN()
                        \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().this.parameter.Out.0\ <= \Posit Posit::op_UnaryNegation(Posit).0.x\;
                        \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\ <= true;
                        \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_UnaryNegation(Posit).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsNaN()
                        if (\Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\ = \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Finished.0\) then 
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\ <= false;
                            \Posit Posit::op_UnaryNegation(Posit).0.return.0\ := \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().return.0\;
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsZero()
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero().this.parameter.Out.0\ <= \Posit Posit::op_UnaryNegation(Posit).0.x\;
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\ <= true;
                            \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_UnaryNegation(Posit).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsZero()
                        if (\Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\ = \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Finished.0\) then 
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\ <= false;
                            \Posit Posit::op_UnaryNegation(Posit).0.return.1\ := \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero().return.0\;
                            \Posit Posit::op_UnaryNegation(Posit).0.binaryOperationResult.0\ := \Posit Posit::op_UnaryNegation(Posit).0.return.0\ or \Posit Posit::op_UnaryNegation(Posit).0.return.1\;
                            \Posit Posit::op_UnaryNegation(Posit).0.flag\ := \Posit Posit::op_UnaryNegation(Posit).0.binaryOperationResult.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- if (flag) {
                            -- 	result = new Posit (x._environment, x.PositBits);
                            -- }
                            -- else {
                            -- 	result = new Posit (x._environment, Lombiq.Arithmetics.BitMask.GetTwosComplement (x.PositBits, 32));
                            -- }
                            -- 

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Posit Posit::op_UnaryNegation(Posit).0._State_6\ and ends in state \Posit Posit::op_UnaryNegation(Posit).0._State_7\.
                            --     * The false branch starts in state \Posit Posit::op_UnaryNegation(Posit).0._State_8\ and ends in state \Posit Posit::op_UnaryNegation(Posit).0._State_10\.
                            --     * Execution after either branch will continue in the following state: \Posit Posit::op_UnaryNegation(Posit).0._State_5\.

                            if (\Posit Posit::op_UnaryNegation(Posit).0.flag\) then 
                                \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_6\;
                            else 
                                \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_8\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.1194
                    when \Posit Posit::op_UnaryNegation(Posit).0._State_5\ => 
                        -- State after the if-else which was started in state \Posit Posit::op_UnaryNegation(Posit).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Posit Posit::op_UnaryNegation(Posit).0.return\ <= \Posit Posit::op_UnaryNegation(Posit).0.result\;
                        \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_UnaryNegation(Posit).0._State_6\ => 
                        -- True branch of the if-else started in state \Posit Posit::op_UnaryNegation(Posit).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new Posit (x._environment, x.PositBits);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit (x._environment, x.PositBits);
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit Posit::op_UnaryNegation(Posit).0.result\.\IsNull\ := false;
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                        \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\ <= \Posit Posit::op_UnaryNegation(Posit).0.result\;
                        \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\ <= \Posit Posit::op_UnaryNegation(Posit).0.x\.\_environment\;
                        \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\ <= \Posit Posit::op_UnaryNegation(Posit).0.x\.\PositBits\;
                        \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= true;
                        \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_7\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_UnaryNegation(Posit).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\) then 
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_UnaryNegation(Posit).0.result\ := \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\;
                            \Posit Posit::op_UnaryNegation(Posit).0.x\.\_environment\ := \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_UnaryNegation(Posit).0._State_4\.
                            if (\Posit Posit::op_UnaryNegation(Posit).0._State\ = \Posit Posit::op_UnaryNegation(Posit).0._State_7\) then 
                                \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_UnaryNegation(Posit).0._State_8\ => 
                        -- False branch of the if-else started in state \Posit Posit::op_UnaryNegation(Posit).0._State_4\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = new Posit (x._environment, Lombiq.Arithmetics.BitMask.GetTwosComplement (x.PositBits, 32));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = new Posit (x._environment, Lombiq.Arithmetics.BitMask.GetTwosComplement (x.PositBits, 32));
                        -- 
                        -- Initializing record fields to their defaults.
                        \Posit Posit::op_UnaryNegation(Posit).0.result\.\IsNull\ := false;
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\ <= \Posit Posit::op_UnaryNegation(Posit).0.x\.\PositBits\;
                        \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= true;
                        \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_UnaryNegation(Posit).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16)
                        if (\Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\ = \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\) then 
                            \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\ <= false;
                            \Posit Posit::op_UnaryNegation(Posit).0.return.2\ := \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).return.0\;
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\ <= \Posit Posit::op_UnaryNegation(Posit).0.result\;
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\ <= \Posit Posit::op_UnaryNegation(Posit).0.x\.\_environment\;
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\ <= \Posit Posit::op_UnaryNegation(Posit).0.return.2\;
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= true;
                            \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit Posit::op_UnaryNegation(Posit).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask)
                        if (\Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\) then 
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ <= false;
                            \Posit Posit::op_UnaryNegation(Posit).0.result\ := \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\;
                            \Posit Posit::op_UnaryNegation(Posit).0.x\.\_environment\ := \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\;
                            -- Going to the state after the if-else which was started in state \Posit Posit::op_UnaryNegation(Posit).0._State_4\.
                            if (\Posit Posit::op_UnaryNegation(Posit).0._State\ = \Posit Posit::op_UnaryNegation(Posit).0._State_10\) then 
                                \Posit Posit::op_UnaryNegation(Posit).0._State\ := \Posit Posit::op_UnaryNegation(Posit).0._State_5\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 state machine end


    -- System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0 state machine start
    \Int32 Posit::op_Explicit(Posit).0._StateMachine\: process (\Clock\) 
        Variable \Int32 Posit::op_Explicit(Posit).0._State\: \Int32 Posit::op_Explicit(Posit).0._States\ := \Int32 Posit::op_Explicit(Posit).0._State_0\;
        Variable \Int32 Posit::op_Explicit(Posit).0.x\: \Lombiq.Arithmetics.Posit\;
        Variable \Int32 Posit::op_Explicit(Posit).0.flag\: boolean := false;
        Variable \Int32 Posit::op_Explicit(Posit).0.lowest32Bits\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.result\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.return.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.0\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Int32 Posit::op_Explicit(Posit).0.return.1\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.1\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.2\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.3\: boolean := false;
        Variable \Int32 Posit::op_Explicit(Posit).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \Int32 Posit::op_Explicit(Posit).0.return.3\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.4\: signed(63 downto 0) := to_signed(0, 64);
        Variable \Int32 Posit::op_Explicit(Posit).0.return.4\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.5\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.return.5\: \Lombiq.Arithmetics.BitMask\;
        Variable \Int32 Posit::op_Explicit(Posit).0.return.6\: unsigned(15 downto 0) := to_unsigned(0, 16);
        Variable \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.6\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.7\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.return.7\: \Lombiq.Arithmetics.BitMask\;
        Variable \Int32 Posit::op_Explicit(Posit).0.return.8\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f\: unsigned(31 downto 0) := to_unsigned(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.return.9\: boolean := false;
        Variable \Int32 Posit::op_Explicit(Posit).0.unaryOperationResult.0\: signed(31 downto 0) := to_signed(0, 32);
        Variable \Int32 Posit::op_Explicit(Posit).0.return.10\: boolean := false;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Int32 Posit::op_Explicit(Posit).0._Finished\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.return\ <= to_signed(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_0\;
                \Int32 Posit::op_Explicit(Posit).0.flag\ := false;
                \Int32 Posit::op_Explicit(Posit).0.lowest32Bits\ := to_unsigned(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.result\ := to_signed(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.return.0\ := to_signed(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.0\ := to_signed(0, 64);
                \Int32 Posit::op_Explicit(Posit).0.return.1\ := to_unsigned(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.1\ := to_signed(0, 64);
                \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.2\ := to_signed(0, 64);
                \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.3\ := false;
                \Int32 Posit::op_Explicit(Posit).0.return.3\ := to_signed(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.4\ := to_signed(0, 64);
                \Int32 Posit::op_Explicit(Posit).0.return.4\ := to_unsigned(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.5\ := to_signed(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.return.6\ := to_unsigned(0, 16);
                \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.6\ := to_signed(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.7\ := to_signed(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.return.8\ := to_unsigned(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f\ := to_unsigned(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.return.9\ := false;
                \Int32 Posit::op_Explicit(Posit).0.unaryOperationResult.0\ := to_signed(0, 32);
                \Int32 Posit::op_Explicit(Posit).0.return.10\ := false;
            else 
                case \Int32 Posit::op_Explicit(Posit).0._State\ is 
                    when \Int32 Posit::op_Explicit(Posit).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Int32 Posit::op_Explicit(Posit).0._Started\ = true) then 
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Int32 Posit::op_Explicit(Posit).0._Started\ = true) then 
                            \Int32 Posit::op_Explicit(Posit).0._Finished\ <= true;
                        else 
                            \Int32 Posit::op_Explicit(Posit).0._Finished\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_2\ => 
                        \Int32 Posit::op_Explicit(Posit).0.x\ := \Int32 Posit::op_Explicit(Posit).0.x.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- bool flag;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- uint lowest32Bits;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- int result;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- flag = (long)(Lombiq.Arithmetics.Posit.GetRegimeKValue (x) * 8) + (long)((ulong)Lombiq.Arithmetics.Posit.GetExponentValue (x)) + 1L < 31L;
                        -- 
                        -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.x\;
                        \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                        \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0.return.0\ := \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.0\ := SmartResize(\Int32 Posit::op_Explicit(Posit).0.return.0\ * to_signed(8, 32), 64);
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.x\;
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.14475
                    when \Int32 Posit::op_Explicit(Posit).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ = \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0.return.1\ := \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue().return.0\;
                            \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.1\ := (\Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.0\) + signed((SmartResize(\Int32 Posit::op_Explicit(Posit).0.return.1\, 64)));
                            \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.2\ := \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.1\ + to_signed(1, 64);
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.9999
                    when \Int32 Posit::op_Explicit(Posit).0._State_5\ => 
                        -- This state was added because the previous state would go over one clock cycle with any more operations.
                        \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.3\ := \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.2\ < to_signed(31, 64);
                        \Int32 Posit::op_Explicit(Posit).0.flag\ := \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.3\;
                        -- The following section was transformed from the .NET statement below:
                        -- if (flag) {
                        -- 	lowest32Bits = Lombiq.Arithmetics.BitMask.GetLowest32Bits (BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x), (int)((long)(Lombiq.Arithmetics.Posit.GetRegimeKValue (x) * 8) + (long)((ulong)Lombiq.Arithmetics.Posit.GetExponentValue (x))) - (int)Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x)) + 1));
                        -- 	uint conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f;
                        -- 	if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                        -- 		conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f = lowest32Bits;
                        -- 	}
                        -- 	else {
                        -- 		conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f = (uint)((int)-(int)((ulong)lowest32Bits));
                        -- 	}
                        -- 	result = (int)(conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f);
                        -- }
                        -- else {
                        -- 	if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                        -- 		result = 2147483647;
                        -- 	}
                        -- 	else {
                        -- 		result = -2147483648;
                        -- 	}
                        -- }
                        -- 

                        -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                        --     * The true branch starts in state \Int32 Posit::op_Explicit(Posit).0._State_7\ and ends in state \Int32 Posit::op_Explicit(Posit).0._State_16\.
                        --     * The false branch starts in state \Int32 Posit::op_Explicit(Posit).0._State_19\ and ends in state \Int32 Posit::op_Explicit(Posit).0._State_21\.
                        --     * Execution after either branch will continue in the following state: \Int32 Posit::op_Explicit(Posit).0._State_6\.

                        if (\Int32 Posit::op_Explicit(Posit).0.flag\) then 
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_7\;
                        else 
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_19\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.678
                    when \Int32 Posit::op_Explicit(Posit).0._State_6\ => 
                        -- State after the if-else which was started in state \Int32 Posit::op_Explicit(Posit).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- return result;
                        -- 
                        \Int32 Posit::op_Explicit(Posit).0.return\ <= \Int32 Posit::op_Explicit(Posit).0.result\;
                        \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_7\ => 
                        -- True branch of the if-else started in state \Int32 Posit::op_Explicit(Posit).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	lowest32Bits = Lombiq.Arithmetics.BitMask.GetLowest32Bits (BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x), (int)((long)(Lombiq.Arithmetics.Posit.GetRegimeKValue (x) * 8) + (long)((ulong)Lombiq.Arithmetics.Posit.GetExponentValue (x))) - (int)Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x)) + 1));
                        -- 	uint conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f;
                        -- 	if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                        -- 		conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f = lowest32Bits;
                        -- 	}
                        -- 	else {
                        -- 		conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f = (uint)((int)-(int)((ulong)lowest32Bits));
                        -- 	}
                        -- 	result = (int)(conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f);
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- lowest32Bits = Lombiq.Arithmetics.BitMask.GetLowest32Bits (BitMask.op_LeftShift (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x), (int)((long)(Lombiq.Arithmetics.Posit.GetRegimeKValue (x) * 8) + (long)((ulong)Lombiq.Arithmetics.Posit.GetExponentValue (x))) - (int)Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (Lombiq.Arithmetics.Posit.FractionWithHiddenBit (x)) + 1));
                        -- 
                        -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.x\;
                        \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                        \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_8\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_8\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0.return.2\ := \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.x\;
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ <= true;
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_9\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue()
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ = \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0.return.3\ := \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().return.0\;
                            \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.4\ := SmartResize(\Int32 Posit::op_Explicit(Posit).0.return.3\ * to_signed(8, 32), 64);
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue().this.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.x\;
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ <= true;
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.14475
                    when \Int32 Posit::op_Explicit(Posit).0._State_10\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue()
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ = \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0.return.4\ := \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue().return.0\;
                            \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.5\ := SmartResize((\Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.4\) + signed((SmartResize(\Int32 Posit::op_Explicit(Posit).0.return.4\, 64))), 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                            \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.x\;
                            \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= true;
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_11\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.49995
                    when \Int32 Posit::op_Explicit(Posit).0._State_11\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit()
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0.return.5\ := \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().return.0\;
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.return.5\;
                            \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_12\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0.return.6\ := \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.6\ := (\Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.5\) - signed(SmartResize(\Int32 Posit::op_Explicit(Posit).0.return.6\, 32));
                            \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.7\ := \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.6\ + to_signed(1, 32);
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.return.2\;
                            \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.binaryOperationResult.7\;
                            \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= true;
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.7545
                    when \Int32 Posit::op_Explicit(Posit).0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0.return.7\ := \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\;
                            -- Starting state machine invocation for the following method: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                            \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().this.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.return.7\;
                            \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\ <= true;
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits()
                        if (\Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\ = \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0.return.8\ := \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().return.0\;
                            \Int32 Posit::op_Explicit(Posit).0.lowest32Bits\ := \Int32 Posit::op_Explicit(Posit).0.return.8\;
                            -- The following section was transformed from the .NET statement below:
                            -- uint conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                            -- 	conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f = lowest32Bits;
                            -- }
                            -- else {
                            -- 	conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f = (uint)((int)-(int)((ulong)lowest32Bits));
                            -- }
                            -- 
                            -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                            \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive().this.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.x\;
                            \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ <= true;
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ = \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0.return.9\ := \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Int32 Posit::op_Explicit(Posit).0._State_17\ and ends in state \Int32 Posit::op_Explicit(Posit).0._State_17\.
                            --     * The false branch starts in state \Int32 Posit::op_Explicit(Posit).0._State_18\ and ends in state \Int32 Posit::op_Explicit(Posit).0._State_18\.
                            --     * Execution after either branch will continue in the following state: \Int32 Posit::op_Explicit(Posit).0._State_16\.

                            if (\Int32 Posit::op_Explicit(Posit).0.return.9\) then 
                                \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_17\;
                            else 
                                \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_18\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_16\ => 
                        -- State after the if-else which was started in state \Int32 Posit::op_Explicit(Posit).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- result = (int)(conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f);
                        -- 
                        \Int32 Posit::op_Explicit(Posit).0.result\ := signed((\Int32 Posit::op_Explicit(Posit).0.conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f\));
                        -- Going to the state after the if-else which was started in state \Int32 Posit::op_Explicit(Posit).0._State_5\.
                        if (\Int32 Posit::op_Explicit(Posit).0._State\ = \Int32 Posit::op_Explicit(Posit).0._State_16\) then 
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_17\ => 
                        -- True branch of the if-else started in state \Int32 Posit::op_Explicit(Posit).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f = lowest32Bits;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f = lowest32Bits;
                        -- 
                        \Int32 Posit::op_Explicit(Posit).0.conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f\ := \Int32 Posit::op_Explicit(Posit).0.lowest32Bits\;
                        -- Going to the state after the if-else which was started in state \Int32 Posit::op_Explicit(Posit).0._State_15\.
                        if (\Int32 Posit::op_Explicit(Posit).0._State\ = \Int32 Posit::op_Explicit(Posit).0._State_17\) then 
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_18\ => 
                        -- False branch of the if-else started in state \Int32 Posit::op_Explicit(Posit).0._State_15\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f = (uint)((int)-(int)((ulong)lowest32Bits));
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f = (uint)((int)-(int)((ulong)lowest32Bits));
                        -- 
                        \Int32 Posit::op_Explicit(Posit).0.unaryOperationResult.0\ := -signed(SmartResize((SmartResize(\Int32 Posit::op_Explicit(Posit).0.lowest32Bits\, 64)), 32));
                        \Int32 Posit::op_Explicit(Posit).0.conditional4ba5df6f2f22e5f5ce0c9f4e4278e4bc76ef7033ec74222a6c567a3f5da2777f\ := unsigned((signed(SmartResize(\Int32 Posit::op_Explicit(Posit).0.unaryOperationResult.0\, 32))));
                        -- Going to the state after the if-else which was started in state \Int32 Posit::op_Explicit(Posit).0._State_15\.
                        if (\Int32 Posit::op_Explicit(Posit).0._State\ = \Int32 Posit::op_Explicit(Posit).0._State_18\) then 
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0.3369
                    when \Int32 Posit::op_Explicit(Posit).0._State_19\ => 
                        -- False branch of the if-else started in state \Int32 Posit::op_Explicit(Posit).0._State_5\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                        -- 		result = 2147483647;
                        -- 	}
                        -- 	else {
                        -- 		result = -2147483648;
                        -- 	}
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- if (Lombiq.Arithmetics.Posit.IsPositive (x)) {
                        -- 	result = 2147483647;
                        -- }
                        -- else {
                        -- 	result = -2147483648;
                        -- }
                        -- 
                        -- Starting state machine invocation for the following method: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive().this.parameter.Out.0\ <= \Int32 Posit::op_Explicit(Posit).0.x\;
                        \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ <= true;
                        \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_20\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_20\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Boolean Lombiq.Arithmetics.Posit::IsPositive()
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ = \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ <= false;
                            \Int32 Posit::op_Explicit(Posit).0.return.10\ := \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive().return.0\;

                            -- This if-else was transformed from a .NET if-else. It spans across multiple states:
                            --     * The true branch starts in state \Int32 Posit::op_Explicit(Posit).0._State_22\ and ends in state \Int32 Posit::op_Explicit(Posit).0._State_22\.
                            --     * The false branch starts in state \Int32 Posit::op_Explicit(Posit).0._State_23\ and ends in state \Int32 Posit::op_Explicit(Posit).0._State_23\.
                            --     * Execution after either branch will continue in the following state: \Int32 Posit::op_Explicit(Posit).0._State_21\.

                            if (\Int32 Posit::op_Explicit(Posit).0.return.10\) then 
                                \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_22\;
                            else 
                                \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_23\;
                            end if;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_21\ => 
                        -- State after the if-else which was started in state \Int32 Posit::op_Explicit(Posit).0._State_20\.
                        -- Going to the state after the if-else which was started in state \Int32 Posit::op_Explicit(Posit).0._State_5\.
                        if (\Int32 Posit::op_Explicit(Posit).0._State\ = \Int32 Posit::op_Explicit(Posit).0._State_21\) then 
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_6\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_22\ => 
                        -- True branch of the if-else started in state \Int32 Posit::op_Explicit(Posit).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = 2147483647;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = 2147483647;
                        -- 
                        \Int32 Posit::op_Explicit(Posit).0.result\ := to_signed(2147483647, 32);
                        -- Going to the state after the if-else which was started in state \Int32 Posit::op_Explicit(Posit).0._State_20\.
                        if (\Int32 Posit::op_Explicit(Posit).0._State\ = \Int32 Posit::op_Explicit(Posit).0._State_22\) then 
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Int32 Posit::op_Explicit(Posit).0._State_23\ => 
                        -- False branch of the if-else started in state \Int32 Posit::op_Explicit(Posit).0._State_20\.
                        -- The following section was transformed from the .NET statement below:
                        -- {
                        -- 	result = -2147483648;
                        -- }
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- result = -2147483648;
                        -- 
                        \Int32 Posit::op_Explicit(Posit).0.result\ := to_signed(-2147483648, 32);
                        -- Going to the state after the if-else which was started in state \Int32 Posit::op_Explicit(Posit).0._State_20\.
                        if (\Int32 Posit::op_Explicit(Posit).0._State\ = \Int32 Posit::op_Explicit(Posit).0._State_23\) then 
                            \Int32 Posit::op_Explicit(Posit).0._State\ := \Int32 Posit::op_Explicit(Posit).0._State_21\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask().0 state machine start
    \Posit::get_SignBitMask().0._StateMachine\: process (\Clock\) 
        Variable \Posit::get_SignBitMask().0._State\: \Posit::get_SignBitMask().0._States\ := \Posit::get_SignBitMask().0._State_0\;
        Variable \Posit::get_SignBitMask().0.this\: \Lombiq.Arithmetics.Posit\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::get_SignBitMask().0._Finished\ <= false;
                \Posit::get_SignBitMask().0._State\ := \Posit::get_SignBitMask().0._State_0\;
            else 
                case \Posit::get_SignBitMask().0._State\ is 
                    when \Posit::get_SignBitMask().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::get_SignBitMask().0._Started\ = true) then 
                            \Posit::get_SignBitMask().0._State\ := \Posit::get_SignBitMask().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_SignBitMask().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::get_SignBitMask().0._Started\ = true) then 
                            \Posit::get_SignBitMask().0._Finished\ <= true;
                        else 
                            \Posit::get_SignBitMask().0._Finished\ <= false;
                            \Posit::get_SignBitMask().0._State\ := \Posit::get_SignBitMask().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_SignBitMask().0._State_2\ => 
                        \Posit::get_SignBitMask().0.this\ := \Posit::get_SignBitMask().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this._environment.SignBitMask;
                        -- 
                        \Posit::get_SignBitMask().0.return\ <= \Posit::get_SignBitMask().0.this\.\_environment\.\SignBitMask\;
                        \Posit::get_SignBitMask().0._State\ := \Posit::get_SignBitMask().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask().0 state machine start
    \Posit::get_FirstRegimeBitBitMask().0._StateMachine\: process (\Clock\) 
        Variable \Posit::get_FirstRegimeBitBitMask().0._State\: \Posit::get_FirstRegimeBitBitMask().0._States\ := \Posit::get_FirstRegimeBitBitMask().0._State_0\;
        Variable \Posit::get_FirstRegimeBitBitMask().0.this\: \Lombiq.Arithmetics.Posit\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::get_FirstRegimeBitBitMask().0._Finished\ <= false;
                \Posit::get_FirstRegimeBitBitMask().0._State\ := \Posit::get_FirstRegimeBitBitMask().0._State_0\;
            else 
                case \Posit::get_FirstRegimeBitBitMask().0._State\ is 
                    when \Posit::get_FirstRegimeBitBitMask().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::get_FirstRegimeBitBitMask().0._Started\ = true) then 
                            \Posit::get_FirstRegimeBitBitMask().0._State\ := \Posit::get_FirstRegimeBitBitMask().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_FirstRegimeBitBitMask().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::get_FirstRegimeBitBitMask().0._Started\ = true) then 
                            \Posit::get_FirstRegimeBitBitMask().0._Finished\ <= true;
                        else 
                            \Posit::get_FirstRegimeBitBitMask().0._Finished\ <= false;
                            \Posit::get_FirstRegimeBitBitMask().0._State\ := \Posit::get_FirstRegimeBitBitMask().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_FirstRegimeBitBitMask().0._State_2\ => 
                        \Posit::get_FirstRegimeBitBitMask().0.this\ := \Posit::get_FirstRegimeBitBitMask().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this._environment.FirstRegimeBitBitMask;
                        -- 
                        \Posit::get_FirstRegimeBitBitMask().0.return\ <= \Posit::get_FirstRegimeBitBitMask().0.this\.\_environment\.\FirstRegimeBitBitMask\;
                        \Posit::get_FirstRegimeBitBitMask().0._State\ := \Posit::get_FirstRegimeBitBitMask().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask().0 state machine start
    \Posit::get_EmptyBitMask().0._StateMachine\: process (\Clock\) 
        Variable \Posit::get_EmptyBitMask().0._State\: \Posit::get_EmptyBitMask().0._States\ := \Posit::get_EmptyBitMask().0._State_0\;
        Variable \Posit::get_EmptyBitMask().0.this\: \Lombiq.Arithmetics.Posit\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::get_EmptyBitMask().0._Finished\ <= false;
                \Posit::get_EmptyBitMask().0._State\ := \Posit::get_EmptyBitMask().0._State_0\;
            else 
                case \Posit::get_EmptyBitMask().0._State\ is 
                    when \Posit::get_EmptyBitMask().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::get_EmptyBitMask().0._Started\ = true) then 
                            \Posit::get_EmptyBitMask().0._State\ := \Posit::get_EmptyBitMask().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_EmptyBitMask().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::get_EmptyBitMask().0._Started\ = true) then 
                            \Posit::get_EmptyBitMask().0._Finished\ <= true;
                        else 
                            \Posit::get_EmptyBitMask().0._Finished\ <= false;
                            \Posit::get_EmptyBitMask().0._State\ := \Posit::get_EmptyBitMask().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_EmptyBitMask().0._State_2\ => 
                        \Posit::get_EmptyBitMask().0.this\ := \Posit::get_EmptyBitMask().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this._environment.EmptyBitMask;
                        -- 
                        \Posit::get_EmptyBitMask().0.return\ <= \Posit::get_EmptyBitMask().0.this\.\_environment\.\EmptyBitMask\;
                        \Posit::get_EmptyBitMask().0._State\ := \Posit::get_EmptyBitMask().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask().0 state machine end


    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask().0 state machine start
    \Posit::get_NaNBitMask().0._StateMachine\: process (\Clock\) 
        Variable \Posit::get_NaNBitMask().0._State\: \Posit::get_NaNBitMask().0._States\ := \Posit::get_NaNBitMask().0._State_0\;
        Variable \Posit::get_NaNBitMask().0.this\: \Lombiq.Arithmetics.Posit\;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Posit::get_NaNBitMask().0._Finished\ <= false;
                \Posit::get_NaNBitMask().0._State\ := \Posit::get_NaNBitMask().0._State_0\;
            else 
                case \Posit::get_NaNBitMask().0._State\ is 
                    when \Posit::get_NaNBitMask().0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\Posit::get_NaNBitMask().0._Started\ = true) then 
                            \Posit::get_NaNBitMask().0._State\ := \Posit::get_NaNBitMask().0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_NaNBitMask().0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\Posit::get_NaNBitMask().0._Started\ = true) then 
                            \Posit::get_NaNBitMask().0._Finished\ <= true;
                        else 
                            \Posit::get_NaNBitMask().0._Finished\ <= false;
                            \Posit::get_NaNBitMask().0._State\ := \Posit::get_NaNBitMask().0._State_0\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \Posit::get_NaNBitMask().0._State_2\ => 
                        \Posit::get_NaNBitMask().0.this\ := \Posit::get_NaNBitMask().0.this.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- return @this._environment.NaNBitMask;
                        -- 
                        \Posit::get_NaNBitMask().0.return\ <= \Posit::get_NaNBitMask().0.this\.\_environment\.\NaNBitMask\;
                        \Posit::get_NaNBitMask().0._State\ := \Posit::get_NaNBitMask().0._State_1\;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask().0 state machine end


    -- System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0 state machine start
    \PositEnvironment::.ctor(Byte,Byte).0._StateMachine\: process (\Clock\) 
        Variable \PositEnvironment::.ctor(Byte,Byte).0._State\: \PositEnvironment::.ctor(Byte,Byte).0._States\ := \PositEnvironment::.ctor(Byte,Byte).0._State_0\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.this\: \Lombiq.Arithmetics.PositEnvironment\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.size\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize\: unsigned(7 downto 0) := to_unsigned(0, 8);
        Variable \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.return.0\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.return.1\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.return.2\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.return.3\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.object54fcbdb1e786899a9b847121dacac90cb168423e5ecd9f9442dcdfcaf3fd11d4\: \Lombiq.Arithmetics.BitMask\;
        Variable \PositEnvironment::.ctor(Byte,Byte).0.return.4\: unsigned(15 downto 0) := to_unsigned(0, 16);
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \PositEnvironment::.ctor(Byte,Byte).0._Finished\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= to_unsigned(0, 16);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(0, 32);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(0, 32);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(0, 32);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(0, 16);
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_0\;
                \PositEnvironment::.ctor(Byte,Byte).0.size\ := to_unsigned(0, 8);
                \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize\ := to_unsigned(0, 8);
                \PositEnvironment::.ctor(Byte,Byte).0.return.4\ := to_unsigned(0, 16);
            else 
                case \PositEnvironment::.ctor(Byte,Byte).0._State\ is 
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_0\ => 
                        -- Start state
                        -- Waiting for the start signal.
                        if (\PositEnvironment::.ctor(Byte,Byte).0._Started\ = true) then 
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_2\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_1\ => 
                        -- Final state
                        -- Signaling finished until Started is pulled back to false, then returning to the start state.
                        if (\PositEnvironment::.ctor(Byte,Byte).0._Started\ = true) then 
                            \PositEnvironment::.ctor(Byte,Byte).0._Finished\ <= true;
                        else 
                            \PositEnvironment::.ctor(Byte,Byte).0._Finished\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_0\;
                        end if;
                        -- Writing back out-flowing parameters so any changes made in this state machine will be reflected in the invoking one too.
                        \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.Out\ <= \PositEnvironment::.ctor(Byte,Byte).0.this\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_2\ => 
                        \PositEnvironment::.ctor(Byte,Byte).0.this\ := \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.In\;
                        \PositEnvironment::.ctor(Byte,Byte).0.size\ := \PositEnvironment::.ctor(Byte,Byte).0.size.parameter.In\;
                        \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize\ := \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize.parameter.In\;
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Size = 32;
                        -- 
                        \PositEnvironment::.ctor(Byte,Byte).0.this\.\Size\ := to_unsigned(32, 16);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.MaximumExponentSize = 3;
                        -- 
                        \PositEnvironment::.ctor(Byte,Byte).0.this\.\MaximumExponentSize\ := to_unsigned(3, 8);
                        -- The following section was transformed from the .NET statement below:
                        -- @this.Useed = 256u;
                        -- 
                        \PositEnvironment::.ctor(Byte,Byte).0.this\.\Useed\ := to_unsigned(256, 32);
                        -- The following section was transformed from the .NET statement below:
                        -- BitMask object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f;
                        -- 
                        -- The following section was transformed from the .NET statement below:
                        -- object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f = new BitMask (32, false);
                        -- 
                        -- Initializing record fields to their defaults.
                        \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\.\IsNull\ := false;
                        \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\.\Size\ := to_unsigned(0, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\.\SegmentCount\ := to_unsigned(0, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\.\Segments\ := (others => to_unsigned(0, 32));
                        -- Invoking the target's constructor.
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_3\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_3\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.SignBitMask = Lombiq.Arithmetics.BitMask.SetOne (object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f, 31);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object4ab6e920753d7b254da1a25d890bc786f4b31e3e9f60d1a7ce73934940133f3f\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= to_unsigned(31, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_4\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_4\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.return.0\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).return.0\;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\SignBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.return.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.FirstRegimeBitIndex = 30;
                            -- 
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\FirstRegimeBitIndex\ := to_unsigned(30, 16);
                            -- The following section was transformed from the .NET statement below:
                            -- BitMask object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed = new BitMask (32, false);
                            -- 
                            -- Initializing record fields to their defaults.
                            \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\.\IsNull\ := false;
                            \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\.\Size\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\.\SegmentCount\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_5\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_5\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_6\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_6\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.FirstRegimeBitBitMask = Lombiq.Arithmetics.BitMask.SetOne (object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed, 30);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object4b9d9e5190e81f5891d360405470af7c0854669f13b20fc5ae58b70c602805ed\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).index.parameter.Out.0\ <= to_unsigned(30, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_7\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_7\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.return.1\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).return.0\;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\FirstRegimeBitBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.return.1\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.EmptyBitMask = new BitMask (32, false);
                            -- 
                            -- Initializing record fields to their defaults.
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\.\IsNull\ := false;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\.\Size\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\.\SegmentCount\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- The last invocation for the target state machine finished in the previous state, so need to start the next one in the next state.
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_8\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_8\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= False;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_9\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_9\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\EmptyBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- BitMask objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf = new BitMask (32, true);
                            -- 
                            -- Initializing record fields to their defaults.
                            \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\.\IsNull\ := false;
                            \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\.\Size\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\.\SegmentCount\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- The last invocation for the target state machine just finished, so need to start the next one in a later state.
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_10\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_10\ => 
                        -- This state was just added to leave time for the invocation proxy to register that the previous invocation finished.
                        \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_11\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_11\ => 
                        -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\ <= to_unsigned(32, 16);
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\ <= True;
                        \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= true;
                        \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_12\;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_12\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.MaxValueBitMask = BitMask.op_RightShift (objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf, 1);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.objectc933731a1c8e1f9c1595fb4bee5d415d69e74d3de4df226197832b9556ea90bf\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\ <= to_signed(1, 32);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_13\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_13\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.return.2\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\MaxValueBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.return.2\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.MinValueBitMask = BitMask.op_Addition (@this.SignBitMask, 1u);
                            -- 
                            -- Starting state machine invocation for the following method: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.this\.\SignBitMask\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\ <= to_unsigned(1, 32);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_14\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_14\ => 
                        -- Waiting for the state machine invocation of the following method to finish: Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.return.3\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\MinValueBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.return.3\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.NaNBitMask = @this.SignBitMask;
                            -- 
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\NaNBitMask\ := \PositEnvironment::.ctor(Byte,Byte).0.this\.\SignBitMask\;
                            -- The following section was transformed from the .NET statement below:
                            -- BitMask object54fcbdb1e786899a9b847121dacac90cb168423e5ecd9f9442dcdfcaf3fd11d4;
                            -- 
                            -- The following section was transformed from the .NET statement below:
                            -- object54fcbdb1e786899a9b847121dacac90cb168423e5ecd9f9442dcdfcaf3fd11d4 = new BitMask (245u, 32);
                            -- 
                            -- Initializing record fields to their defaults.
                            \PositEnvironment::.ctor(Byte,Byte).0.object54fcbdb1e786899a9b847121dacac90cb168423e5ecd9f9442dcdfcaf3fd11d4\.\IsNull\ := false;
                            \PositEnvironment::.ctor(Byte,Byte).0.object54fcbdb1e786899a9b847121dacac90cb168423e5ecd9f9442dcdfcaf3fd11d4\.\Size\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.object54fcbdb1e786899a9b847121dacac90cb168423e5ecd9f9442dcdfcaf3fd11d4\.\SegmentCount\ := to_unsigned(0, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.object54fcbdb1e786899a9b847121dacac90cb168423e5ecd9f9442dcdfcaf3fd11d4\.\Segments\ := (others => to_unsigned(0, 32));
                            -- Invoking the target's constructor.
                            -- Starting state machine invocation for the following method: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object54fcbdb1e786899a9b847121dacac90cb168423e5ecd9f9442dcdfcaf3fd11d4\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\ <= to_unsigned(245, 32);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\ <= to_unsigned(32, 16);
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_15\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_15\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16)
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.object54fcbdb1e786899a9b847121dacac90cb168423e5ecd9f9442dcdfcaf3fd11d4\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\;
                            -- The following section was transformed from the .NET statement below:
                            -- @this.QuireSize = (uint)Lombiq.Arithmetics.BitMask.GetMostSignificantOnePosition (object54fcbdb1e786899a9b847121dacac90cb168423e5ecd9f9442dcdfcaf3fd11d4);
                            -- 
                            -- Starting state machine invocation for the following method: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.object54fcbdb1e786899a9b847121dacac90cb168423e5ecd9f9442dcdfcaf3fd11d4\;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= true;
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_16\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                    when \PositEnvironment::.ctor(Byte,Byte).0._State_16\ => 
                        -- Waiting for the state machine invocation of the following method to finish: System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition()
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\ <= false;
                            \PositEnvironment::.ctor(Byte,Byte).0.return.4\ := \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().return.0\;
                            \PositEnvironment::.ctor(Byte,Byte).0.this\.\QuireSize\ := SmartResize(\PositEnvironment::.ctor(Byte,Byte).0.return.4\, 32);
                            \PositEnvironment::.ctor(Byte,Byte).0._State\ := \PositEnvironment::.ctor(Byte,Byte).0._State_1\;
                        end if;
                        -- Clock cycles needed to complete this state (approximation): 0
                end case;
            end if;
        end if;
    end process;
    -- System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0 state machine end


    -- System.Void Hast::ExternalInvocationProxy() start
    \Finished\ <= \FinishedInternal\;
    \Hast::ExternalInvocationProxy()\: process (\Clock\) 
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \FinishedInternal\ <= false;
                \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ <= false;
            else 
                if (\Started\ = true and \FinishedInternal\ = false) then 
                    -- Starting the state machine corresponding to the given member ID.
                    case \MemberId\ is 
                        when 0 => 
                            if (\Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ = false) then 
                                \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ <= true;
                            elsif (\Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ = \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Finished.0\) then 
                                \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\ <= false;
                                \FinishedInternal\ <= true;
                            end if;
                        when others => 
                            null;
                    end case;
                else 
                    -- Waiting for Started to be pulled back to zero that signals the framework noting the finish.
                    if (\Started\ = false and \FinishedInternal\ = true) then 
                        \FinishedInternal\ <= false;
                    end if;
                end if;
            end if;
        end if;
    end process;
    -- System.Void Hast::ExternalInvocationProxy() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory() start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \PositCalculator::EnvironmentFactory().0._Started\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Started.0\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory()._Finished.0\ <= \PositCalculator::EnvironmentFactory().0._Finished\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.PositCalculator::EnvironmentFactory().return.0\ <= \PositCalculator::EnvironmentFactory().0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit::.ctor(PositEnvironment,Int32).0._Started\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Started.0\;
    \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.Out.0\;
    \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.Out.0\;
    \Posit::.ctor(PositEnvironment,Int32).0.value.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).value.parameter.Out.0\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32)._Finished.0\ <= \Posit::.ctor(PositEnvironment,Int32).0._Finished\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).this.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,Int32).0.this.parameter.Out\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit::.ctor(PositEnvironment,Int32).environment.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,Int32).0.environment.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Posit Posit::op_Addition(Posit,Posit).0._Started\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit)._Started.0\;
    \Posit Posit::op_Addition(Posit,Posit).0.left.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit).left.parameter.Out.0\;
    \Posit Posit::op_Addition(Posit,Posit).0.right.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit).right.parameter.Out.0\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit)._Finished.0\ <= \Posit Posit::op_Addition(Posit,Posit).0._Finished\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Posit Posit::op_Addition(Posit,Posit).return.0\ <= \Posit Posit::op_Addition(Posit,Posit).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit) end


    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit) start
    -- Signal connections for System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory).0 (#0):
    \Int32 Posit::op_Explicit(Posit).0._Started\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit)._Started.0\;
    \Int32 Posit::op_Explicit(Posit).0.x.parameter.In\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit).x.parameter.Out.0\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit)._Finished.0\ <= \Int32 Posit::op_Explicit(Posit).0._Finished\;
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.Int32 Posit::op_Explicit(Posit).return.0\ <= \Int32 Posit::op_Explicit(Posit).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte) start
    -- Signal connections for Lombiq.Arithmetics.PositEnvironment Hast.Samples.SampleAssembly.PositCalculator::EnvironmentFactory().0 (#0):
    \PositEnvironment::.ctor(Byte,Byte).0._Started\ <= \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Started.0\;
    \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.In\ <= \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.Out.0\;
    \PositEnvironment::.ctor(Byte,Byte).0.size.parameter.In\ <= \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).size.parameter.Out.0\;
    \PositEnvironment::.ctor(Byte,Byte).0.maximumExponentSize.parameter.In\ <= \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).maximumExponentSize.parameter.Out.0\;
    \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte)._Finished.0\ <= \PositEnvironment::.ctor(Byte,Byte).0._Finished\;
    \PositCalculator::EnvironmentFactory().0.PositEnvironment::.ctor(Byte,Byte).this.parameter.In.0\ <= \PositEnvironment::.ctor(Byte,Byte).0.this.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Addition(BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Addition(BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Subtraction(BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_OnesComplement(BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_OnesComplement(BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Addition(BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Addition(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Subtraction(BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_OnesComplement(BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_OnesComplement(BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask::FromImmutableArray(UInt32[],UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Addition(BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Addition(BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Addition(BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Addition(BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Addition(BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Addition(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Subtraction(BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Subtraction(BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_Subtraction(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_OnesComplement(BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_OnesComplement(BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_OnesComplement(BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_OnesComplement(BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_OnesComplement(BitMask).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_OnesComplement(BitMask).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_OnesComplement(BitMask).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\) then 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.In\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::.ctor(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.this.parameter.Out\;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::.ctor(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32[],UInt16).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask::.ctor(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32[],System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForStarted;
                \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\) then 
                            \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(BitMask).0._Started\ <= true;
                            \BitMask::.ctor(BitMask).0.this.parameter.In\ <= \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\;
                            \BitMask::.ctor(BitMask).0.source.parameter.In\ <= \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= true;
                                    \BitMask::.ctor(BitMask).0._Started\ <= false;
                                    \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.this.parameter.Out\;
                                    \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.source.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::SetOne(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\) then 
                            \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(BitMask).0._Started\ <= true;
                            \BitMask::.ctor(BitMask).0.this.parameter.In\ <= \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\;
                            \BitMask::.ctor(BitMask).0.source.parameter.In\ <= \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= true;
                                    \BitMask::.ctor(BitMask).0._Started\ <= false;
                                    \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.this.parameter.Out\;
                                    \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.source.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::SetZero(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(BitMask).0._Started\ <= true;
                            \BitMask::.ctor(BitMask).0.this.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\;
                            \BitMask::.ctor(BitMask).0.source.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= true;
                                    \BitMask::.ctor(BitMask).0._Started\ <= false;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.this.parameter.Out\;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.source.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(BitMask).0._Started\ <= true;
                            \BitMask::.ctor(BitMask).0.this.parameter.In\ <= \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.Out.0\;
                            \BitMask::.ctor(BitMask).0.source.parameter.In\ <= \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= true;
                                    \BitMask::.ctor(BitMask).0._Started\ <= false;
                                    \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).this.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.this.parameter.Out\;
                                    \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask).source.parameter.In.0\ <= \BitMask::.ctor(BitMask).0.source.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(BitMask).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask::.ctor(BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\ := WaitingForStarted;
                \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.return\;
                                    \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetOne(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::SetOne(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\) then 
                            \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningIndex.0\ := 0;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.In\ <= \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.size.parameter.In\ <= \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= false;
                                    \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.return\;
                                    \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).BitMask::SetZero(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::SetZero(UInt16).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\) then 
                            \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= true;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.In\ <= \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.Out.0\;
                            \BitMask::FromImmutableArray(UInt32[],UInt16).0.size.parameter.In\ <= \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::FromImmutableArray(UInt32[],UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= true;
                                    \BitMask::FromImmutableArray(UInt32[],UInt16).0._Started\ <= false;
                                    \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).return.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.return\;
                                    \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16).segments.parameter.In.0\ <= \BitMask::FromImmutableArray(UInt32[],UInt16).0.segments.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::FromImmutableArray(UInt32[],UInt16).Posit::.ctor(PositEnvironment,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::.ctor(PositEnvironment,BitMask).0.BitMask::FromImmutableArray(UInt32[],UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::FromImmutableArray(System.UInt32[],System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    -- Signal connections for System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 (#0):
    \Boolean BitMask::op_LessThan(BitMask,BitMask).0._Started\ <= \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask)._Started.0\;
    \Boolean BitMask::op_LessThan(BitMask,BitMask).0.left.parameter.In\ <= \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask).left.parameter.Out.0\;
    \Boolean BitMask::op_LessThan(BitMask,BitMask).0.right.parameter.In\ <= \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask).right.parameter.Out.0\;
    \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask)._Finished.0\ <= \Boolean BitMask::op_LessThan(BitMask,BitMask).0._Finished\;
    \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.Boolean BitMask::op_LessThan(BitMask,BitMask).return.0\ <= \Boolean BitMask::op_LessThan(BitMask,BitMask).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_LessThan(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt32,UInt16).0._Started\ <= true;
                            \BitMask::.ctor(UInt32,UInt16).0.this.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.segment.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).segment.parameter.Out.0\;
                            \BitMask::.ctor(UInt32,UInt16).0.size.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt32,UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt32,UInt16).0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16).this.parameter.In.0\ <= \BitMask::.ctor(UInt32,UInt16).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt32,UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt32,UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt32,System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\) then 
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._Started\ <= true;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0.left.parameter.In\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0.right.parameter.In\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask BitMask::op_Addition(BitMask,BitMask).0._Started\ <= false;
                                    \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\ <= \BitMask BitMask::op_Addition(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).BitMask BitMask::op_Addition(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._Started\ <= true;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0.left.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0.right.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask BitMask::op_Addition(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\ <= \BitMask BitMask::op_Addition(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0._Started\ <= true;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0.left.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask BitMask::op_Addition(BitMask,BitMask).0.right.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_Addition(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask BitMask::op_Addition(BitMask,BitMask).0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask).return.0\ <= \BitMask BitMask::op_Addition(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Addition(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\) then 
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Started\ <= true;
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.left.parameter.In\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.right.parameter.In\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Started\ <= false;
                                    \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).return.0\ <= \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).BitMask BitMask::op_Subtraction(BitMask,UInt32).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Started\ <= true;
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.left.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.right.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask BitMask::op_Subtraction(BitMask,BitMask).0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask).return.0\ <= \BitMask BitMask::op_Subtraction(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Subtraction(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_Subtraction(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean) start
    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\) then 
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt16,Boolean).0._Started\ <= true;
                            \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt16,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt16,Boolean).0._Started\ <= false;
                                    \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\ <= \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt16,Boolean).0._Started\ <= true;
                            \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt16,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt16,Boolean).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\ <= \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt16,Boolean).0._Started\ <= true;
                            \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt16,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt16,Boolean).0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\ <= \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask::.ctor(UInt16,Boolean).0._Started\ <= true;
                            \BitMask::.ctor(UInt16,Boolean).0.this.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.size.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).size.parameter.Out.0\;
                            \BitMask::.ctor(UInt16,Boolean).0.allOne.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).allOne.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::.ctor(UInt16,Boolean).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= true;
                                    \BitMask::.ctor(UInt16,Boolean).0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean).this.parameter.In.0\ <= \BitMask::.ctor(UInt16,Boolean).0.this.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::.ctor(UInt16,Boolean).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::.ctor(UInt16,Boolean)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.BitMask::.ctor(System.UInt16,System.Boolean) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32) start
    \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Int32 Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Int32 Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask BitMask::op_RightShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).BitMask::LengthOfRunOfBits(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::LengthOfRunOfBits(UInt16).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Int32 Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.left.parameter.In\ <= \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.right.parameter.In\ <= \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Int32 Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0._Started\ <= false;
                                    \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_LeftShift(BitMask,Int32).Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Int32 Posit::op_Explicit(Posit).0.BitMask BitMask::op_LeftShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32) start
    \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_LeftShift(Lombiq.Arithmetics.BitMask,System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\) then 
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\ <= \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := AfterFinished;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ <= false;
                                    \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask BitMask::op_LeftShift(BitMask,Int32).0.runningState.0\ := WaitingForStarted;
                            \BitMask BitMask::op_LeftShift(BitMask,Int32).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ <= false;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\) then 
                            \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ <= true;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.left.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32).left.parameter.Out.0\;
                            \BitMask BitMask::op_RightShift(BitMask,Int32).0.right.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_RightShift(BitMask,Int32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_RightShift(BitMask,Int32).0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32).return.0\ <= \BitMask BitMask::op_RightShift(BitMask,Int32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_RightShift(BitMask,Int32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_RightShift(BitMask,Int32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_RightShift(Lombiq.Arithmetics.BitMask,System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask) start
    -- Signal connections for Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0 (#0):
    \BitMask BitMask::op_OnesComplement(BitMask).0._Started\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask)._Started.0\;
    \BitMask BitMask::op_OnesComplement(BitMask).0.input.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask).input.parameter.Out.0\;
    \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask)._Finished.0\ <= \BitMask BitMask::op_OnesComplement(BitMask).0._Finished\;
    \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_OnesComplement(BitMask).return.0\ <= \BitMask BitMask::op_OnesComplement(BitMask).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_OnesComplement(Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32) start
    \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\) then 
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0._Started\ <= true;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.left.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.right.parameter.In\ <= \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_Addition(BitMask,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := AfterFinished;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_Addition(BitMask,UInt32).0._Started\ <= false;
                                    \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).BitMask::GetTwosComplement(UInt16).0.runningState.0\ := WaitingForStarted;
                            \BitMask::GetTwosComplement(UInt16).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0._Started\ <= true;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.left.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.right.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_Addition(BitMask,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_Addition(BitMask,UInt32).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0._Started\ <= true;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.left.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32).left.parameter.Out.0\;
                            \BitMask BitMask::op_Addition(BitMask,UInt32).0.right.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_Addition(BitMask,UInt32).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= true;
                                    \BitMask BitMask::op_Addition(BitMask,UInt32).0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32).return.0\ <= \BitMask BitMask::op_Addition(BitMask,UInt32).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_Addition(BitMask,UInt32).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask BitMask::op_Addition(BitMask,UInt32)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Addition(Lombiq.Arithmetics.BitMask,System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition() start
    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Int32 Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit::.ctor(PositEnvironment,UInt32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\ := AfterFinished;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::EncodeRegimeBits(Int32).0.runningState.0\ := WaitingForStarted;
                            \Posit::EncodeRegimeBits(Int32).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Int32 Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Int32 Posit::op_Explicit(Posit).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask::GetMostSignificantOnePosition().0._Started\ <= true;
                            \BitMask::GetMostSignificantOnePosition().0.this.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetMostSignificantOnePosition().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= true;
                                    \BitMask::GetMostSignificantOnePosition().0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition().return.0\ <= \BitMask::GetMostSignificantOnePosition().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetMostSignificantOnePosition().PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::GetMostSignificantOnePosition()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt16 Lombiq.Arithmetics.BitMask::GetMostSignificantOnePosition() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32).0
                case \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\) then 
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ := 0;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits.parameter.In\ <= \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := AfterFinished;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= true;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ <= false;
                                    \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit::.ctor(PositEnvironment,UInt32).0.runningState.0\ := WaitingForStarted;
                            \Posit::.ctor(PositEnvironment,UInt32).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ <= true;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.this.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).this.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.signBit.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).signBit.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.regimeKValue.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).regimeKValue.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.exponentBits.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).exponentBits.parameter.Out.0\;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.fractionBits.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).fractionBits.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= true;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).return.0\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32) start
    -- Signal connections for System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.Int32).0 (#0):
    \Posit::.ctor(PositEnvironment,UInt32).0._Started\ <= \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Started.0\;
    \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.In\ <= \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.Out.0\;
    \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.In\ <= \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.Out.0\;
    \Posit::.ctor(PositEnvironment,UInt32).0.value.parameter.In\ <= \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).value.parameter.Out.0\;
    \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32)._Finished.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0._Finished\;
    \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).this.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.this.parameter.Out\;
    \Posit::.ctor(PositEnvironment,Int32).0.Posit::.ctor(PositEnvironment,UInt32).environment.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,UInt32).0.environment.parameter.Out\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask() start
    -- Signal connections for System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0 (#0):
    \Posit::get_SignBitMask().0._Started\ <= \Posit::IsPositive().0.Posit::get_SignBitMask()._Started.0\;
    \Posit::get_SignBitMask().0.this.parameter.In\ <= \Posit::IsPositive().0.Posit::get_SignBitMask().this.parameter.Out.0\;
    \Posit::IsPositive().0.Posit::get_SignBitMask()._Finished.0\ <= \Posit::get_SignBitMask().0._Finished\;
    \Posit::IsPositive().0.Posit::get_SignBitMask().return.0\ <= \Posit::get_SignBitMask().0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_SignBitMask() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\) then 
                            \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ <= true;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.left.parameter.In\ <= \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.right.parameter.In\ <= \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := AfterFinished;
                                    \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsPositive().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ <= true;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.left.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).left.parameter.Out.0\;
                            \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.right.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= true;
                                    \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).return.0\ <= \BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask BitMask::op_BitwiseAnd(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.BitMask BitMask::op_BitwiseAnd(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_BitwiseAnd(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask() start
    \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0
                case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\) then 
                            \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningIndex.0\ := 0;
                            \Posit::get_EmptyBitMask().0._Started\ <= true;
                            \Posit::get_EmptyBitMask().0.this.parameter.In\ <= \Posit::IsPositive().0.Posit::get_EmptyBitMask().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::get_EmptyBitMask().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\ := AfterFinished;
                                    \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\ <= true;
                                    \Posit::get_EmptyBitMask().0._Started\ <= false;
                                    \Posit::IsPositive().0.Posit::get_EmptyBitMask().return.0\ <= \Posit::get_EmptyBitMask().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsPositive().0.Posit::get_EmptyBitMask()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsPositive().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsZero().0
                case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\) then 
                            \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningIndex.0\ := 0;
                            \Posit::get_EmptyBitMask().0._Started\ <= true;
                            \Posit::get_EmptyBitMask().0.this.parameter.In\ <= \Posit::IsZero().0.Posit::get_EmptyBitMask().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::get_EmptyBitMask().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\ := AfterFinished;
                                    \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\ <= true;
                                    \Posit::get_EmptyBitMask().0._Started\ <= false;
                                    \Posit::IsZero().0.Posit::get_EmptyBitMask().return.0\ <= \Posit::get_EmptyBitMask().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsZero().0.Posit::get_EmptyBitMask()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::IsZero().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsZero().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\) then 
                            \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \Posit::get_EmptyBitMask().0._Started\ <= true;
                            \Posit::get_EmptyBitMask().0.this.parameter.In\ <= \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::get_EmptyBitMask().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\ <= true;
                                    \Posit::get_EmptyBitMask().0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask().return.0\ <= \Posit::get_EmptyBitMask().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::get_EmptyBitMask().0._Started\ <= true;
                            \Posit::get_EmptyBitMask().0.this.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::get_EmptyBitMask().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\ <= true;
                                    \Posit::get_EmptyBitMask().0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask().return.0\ <= \Posit::get_EmptyBitMask().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::get_EmptyBitMask().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::get_EmptyBitMask()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_EmptyBitMask() end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsPositive().0
                case \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\) then 
                            \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ := 0;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ <= true;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\ <= \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\ <= \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Boolean BitMask::op_Equality(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := AfterFinished;
                                    \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= true;
                                    \Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\ <= \Boolean BitMask::op_Equality(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsPositive().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsPositive().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0
                case \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\) then 
                            \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningIndex.0\ := 0;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ <= true;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\ <= \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\ <= \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Boolean BitMask::op_Equality(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\ := AfterFinished;
                                    \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= true;
                                    \Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\ <= \Boolean BitMask::op_Equality(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsNaN().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsNaN().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Boolean Lombiq.Arithmetics.Posit::IsZero().0
                case \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\) then 
                            \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningIndex.0\ := 0;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ <= true;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\ <= \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\ <= \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Boolean BitMask::op_Equality(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\ := AfterFinished;
                                    \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= true;
                                    \Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\ <= \Boolean BitMask::op_Equality(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::IsZero().0.runningState.0\ := WaitingForStarted;
                            \Posit::IsZero().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ <= true;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Boolean BitMask::op_Equality(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= true;
                                    \Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\ <= \Boolean BitMask::op_Equality(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\) then 
                            \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ <= true;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.left.parameter.In\ <= \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask).left.parameter.Out.0\;
                            \Boolean BitMask::op_Equality(BitMask,BitMask).0.right.parameter.In\ <= \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Boolean BitMask::op_Equality(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= true;
                                    \Boolean BitMask::op_Equality(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask).return.0\ <= \Boolean BitMask::op_Equality(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_Equality(BitMask,BitMask).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.Boolean BitMask::op_Equality(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_Equality(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask() start
    -- Signal connections for System.Boolean Lombiq.Arithmetics.Posit::IsNaN().0 (#0):
    \Posit::get_NaNBitMask().0._Started\ <= \Posit::IsNaN().0.Posit::get_NaNBitMask()._Started.0\;
    \Posit::get_NaNBitMask().0.this.parameter.In\ <= \Posit::IsNaN().0.Posit::get_NaNBitMask().this.parameter.Out.0\;
    \Posit::IsNaN().0.Posit::get_NaNBitMask()._Finished.0\ <= \Posit::get_NaNBitMask().0._Finished\;
    \Posit::IsNaN().0.Posit::get_NaNBitMask().return.0\ <= \Posit::get_NaNBitMask().0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_NaNBitMask() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32) start
    -- Signal connections for Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32).0 (#0):
    \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._Started\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32)._Started.0\;
    \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.left.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32).left.parameter.Out.0\;
    \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.right.parameter.In\ <= \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32).right.parameter.Out.0\;
    \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32)._Finished.0\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0._Finished\;
    \Posit::EncodeRegimeBits(Int32).0.BitMask BitMask::op_Subtraction(BitMask,UInt32).return.0\ <= \BitMask BitMask::op_Subtraction(BitMask,UInt32).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::op_Subtraction(Lombiq.Arithmetics.BitMask,System.UInt32) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32) start
    -- Signal connections for Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 (#0):
    \Posit::EncodeRegimeBits(Int32).0._Started\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Started.0\;
    \Posit::EncodeRegimeBits(Int32).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).this.parameter.Out.0\;
    \Posit::EncodeRegimeBits(Int32).0.regimeKValue.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).regimeKValue.parameter.Out.0\;
    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32)._Finished.0\ <= \Posit::EncodeRegimeBits(Int32).0._Finished\;
    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Posit::EncodeRegimeBits(Int32).return.0\ <= \Posit::EncodeRegimeBits(Int32).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::EncodeRegimeBits(System.Int32) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= true;
                            \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::LengthOfRunOfBits(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= true;
                                    \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16).return.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= true;
                            \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::LengthOfRunOfBits(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= true;
                                    \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16).return.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0
                case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\) then 
                            \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningIndex.0\ := 0;
                            \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= true;
                            \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\ <= \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\ <= \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::LengthOfRunOfBits(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= true;
                                    \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= false;
                                    \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::ExponentSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0
                case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\) then 
                            \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningIndex.0\ := 0;
                            \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= true;
                            \BitMask::LengthOfRunOfBits(UInt16).0.this.parameter.In\ <= \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).this.parameter.Out.0\;
                            \BitMask::LengthOfRunOfBits(UInt16).0.startingPosition.parameter.In\ <= \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).startingPosition.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::LengthOfRunOfBits(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= true;
                                    \BitMask::LengthOfRunOfBits(UInt16).0._Started\ <= false;
                                    \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16).return.0\ <= \BitMask::LengthOfRunOfBits(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::LengthOfRunOfBits(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionSize().0.BitMask::LengthOfRunOfBits(UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt16 Lombiq.Arithmetics.BitMask::LengthOfRunOfBits(System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::SetOne(UInt16).0._Started\ <= true;
                            \BitMask::SetOne(UInt16).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).this.parameter.Out.0\;
                            \BitMask::SetOne(UInt16).0.index.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::SetOne(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\ <= true;
                                    \BitMask::SetOne(UInt16).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16).return.0\ <= \BitMask::SetOne(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \BitMask::SetOne(UInt16).0._Started\ <= true;
                            \BitMask::SetOne(UInt16).0.this.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).this.parameter.Out.0\;
                            \BitMask::SetOne(UInt16).0.index.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::SetOne(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\ <= true;
                                    \BitMask::SetOne(UInt16).0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16).return.0\ <= \BitMask::SetOne(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Void Lombiq.Arithmetics.PositEnvironment::.ctor(System.Byte,System.Byte).0
                case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\) then 
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ := 0;
                            \BitMask::SetOne(UInt16).0._Started\ <= true;
                            \BitMask::SetOne(UInt16).0.this.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).this.parameter.Out.0\;
                            \BitMask::SetOne(UInt16).0.index.parameter.In\ <= \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).index.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::SetOne(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := AfterFinished;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\ <= true;
                                    \BitMask::SetOne(UInt16).0._Started\ <= false;
                                    \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16).return.0\ <= \BitMask::SetOne(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::SetOne(UInt16).PositEnvironment::.ctor(Byte,Byte).0.runningState.0\ := WaitingForStarted;
                            \PositEnvironment::.ctor(Byte,Byte).0.BitMask::SetOne(UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetOne(System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ <= true;
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\;
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= true;
                                    \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\ <= \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ <= true;
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.left.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).left.parameter.Out.0\;
                            \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.right.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).right.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= true;
                                    \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).return.0\ <= \Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.Boolean BitMask::op_GreaterThanOrEqual(BitMask,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.BitMask::op_GreaterThanOrEqual(Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits() start
    \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Int32 Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::GetLowest32Bits().0._Started\ <= true;
                            \BitMask::GetLowest32Bits().0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetLowest32Bits().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\ <= true;
                                    \BitMask::GetLowest32Bits().0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits().return.0\ <= \BitMask::GetLowest32Bits().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\) then 
                            \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \BitMask::GetLowest32Bits().0._Started\ <= true;
                            \BitMask::GetLowest32Bits().0.this.parameter.In\ <= \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetLowest32Bits().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\ <= true;
                                    \BitMask::GetLowest32Bits().0._Started\ <= false;
                                    \Posit::GetExponentValue().0.BitMask::GetLowest32Bits().return.0\ <= \BitMask::GetLowest32Bits().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Int32 Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \BitMask::GetLowest32Bits().0._Started\ <= true;
                            \BitMask::GetLowest32Bits().0.this.parameter.In\ <= \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetLowest32Bits().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\ <= true;
                                    \BitMask::GetLowest32Bits().0._Started\ <= false;
                                    \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits().return.0\ <= \BitMask::GetLowest32Bits().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetLowest32Bits().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Int32 Posit::op_Explicit(Posit).0.BitMask::GetLowest32Bits()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.BitMask::GetLowest32Bits() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16) start
    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit Posit::op_UnaryNegation(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit Posit::op_UnaryNegation(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := AfterFinished;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.runningState.0\ := WaitingForStarted;
                            \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::ExponentSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionSize().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\) then 
                            \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit Posit::op_UnaryNegation(Posit).0.runningIndex.0\ := 0;
                            \BitMask::GetTwosComplement(UInt16).0._Started\ <= true;
                            \BitMask::GetTwosComplement(UInt16).0.this.parameter.In\ <= \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).this.parameter.Out.0\;
                            \BitMask::GetTwosComplement(UInt16).0.size.parameter.In\ <= \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).size.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit Posit::op_UnaryNegation(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\BitMask::GetTwosComplement(UInt16).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= true;
                                    \BitMask::GetTwosComplement(UInt16).0._Started\ <= false;
                                    \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16).return.0\ <= \BitMask::GetTwosComplement(UInt16).0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().BitMask::GetTwosComplement(UInt16).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_UnaryNegation(Posit).0.BitMask::GetTwosComplement(UInt16)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::GetTwosComplement(System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16) start
    -- Signal connections for Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::AssemblePositBitsWithRounding(System.Boolean,System.Int32,Lombiq.Arithmetics.BitMask,Lombiq.Arithmetics.BitMask).0 (#0):
    \BitMask::SetZero(UInt16).0._Started\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Started.0\;
    \BitMask::SetZero(UInt16).0.this.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).this.parameter.Out.0\;
    \BitMask::SetZero(UInt16).0.index.parameter.In\ <= \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).index.parameter.Out.0\;
    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16)._Finished.0\ <= \BitMask::SetZero(UInt16).0._Finished\;
    \Posit::AssemblePositBitsWithRounding(Boolean,Int32,BitMask,BitMask).0.BitMask::SetZero(UInt16).return.0\ <= \BitMask::SetZero(UInt16).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.BitMask::SetZero(System.UInt16) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsPositive() start
    \Hast::InternalInvocationProxy().Posit::IsPositive()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::IsPositive().Int32 Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::IsPositive().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\ <= false;
                \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\ <= false;
                \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\ <= false;
                \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\) then 
                            \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::GetRegimeKValue().0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::GetRegimeKValue().0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetRegimeKValue().0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetRegimeKValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetRegimeKValue().0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize().0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::ExponentSize().0.Posit::IsPositive()._Started.0\) then 
                            \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::ExponentSize().0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\ := AfterFinished;
                                    \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::ExponentSize().0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::ExponentSize().0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::ExponentSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::ExponentSize().0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\) then 
                            \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::GetExponentValue().0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::GetExponentValue().0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::FractionSize().0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionSize().0.Posit::IsPositive()._Started.0\) then 
                            \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::FractionSize().0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::FractionSize().0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionSize().0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionSize().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionSize().0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit::FractionWithHiddenBit().0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::IsPositive().Int32 Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \Posit::IsPositive().0._Started\ <= true;
                            \Posit::IsPositive().0.this.parameter.In\ <= \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::IsPositive().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::IsPositive().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::IsPositive().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\ <= true;
                                    \Posit::IsPositive().0._Started\ <= false;
                                    \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive().return.0\ <= \Posit::IsPositive().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::IsPositive().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Int32 Posit::op_Explicit(Posit).0.Posit::IsPositive()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsPositive() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask() start
    -- Signal connections for System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue().0 (#0):
    \Posit::get_FirstRegimeBitBitMask().0._Started\ <= \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Started.0\;
    \Posit::get_FirstRegimeBitBitMask().0.this.parameter.In\ <= \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().this.parameter.Out.0\;
    \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask()._Finished.0\ <= \Posit::get_FirstRegimeBitBitMask().0._Finished\;
    \Posit::GetRegimeKValue().0.Posit::get_FirstRegimeBitBitMask().return.0\ <= \Posit::get_FirstRegimeBitBitMask().0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::get_FirstRegimeBitBitMask() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::FractionSize() start
    \Hast::InternalInvocationProxy().Posit::FractionSize()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::FractionSize().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::FractionSize().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\ <= false;
                \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\ <= false;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0
                case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\) then 
                            \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningIndex.0\ := 0;
                            \Posit::FractionSize().0._Started\ <= true;
                            \Posit::FractionSize().0.this.parameter.In\ <= \Posit::GetExponentValue().0.Posit::FractionSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\ := AfterFinished;
                                    \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\ <= true;
                                    \Posit::FractionSize().0._Started\ <= false;
                                    \Posit::GetExponentValue().0.Posit::FractionSize().return.0\ <= \Posit::FractionSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::GetExponentValue().0.Posit::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::GetExponentValue().0.runningState.0\ := WaitingForStarted;
                            \Posit::GetExponentValue().0.Posit::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit().0
                case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\) then 
                            \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningIndex.0\ := 0;
                            \Posit::FractionSize().0._Started\ <= true;
                            \Posit::FractionSize().0.this.parameter.In\ <= \Posit::FractionWithHiddenBit().0.Posit::FractionSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\ := AfterFinished;
                                    \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\ <= true;
                                    \Posit::FractionSize().0._Started\ <= false;
                                    \Posit::FractionWithHiddenBit().0.Posit::FractionSize().return.0\ <= \Posit::FractionSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit::FractionWithHiddenBit().0.runningState.0\ := WaitingForStarted;
                            \Posit::FractionWithHiddenBit().0.Posit::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::FractionSize().0._Started\ <= true;
                            \Posit::FractionSize().0.this.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::FractionSize().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::FractionSize().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::FractionSize().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\ <= true;
                                    \Posit::FractionSize().0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize().return.0\ <= \Posit::FractionSize().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::FractionSize().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionSize()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::FractionSize() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize() start
    -- Signal connections for System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue().0 (#0):
    \Posit::ExponentSize().0._Started\ <= \Posit::GetExponentValue().0.Posit::ExponentSize()._Started.0\;
    \Posit::ExponentSize().0.this.parameter.In\ <= \Posit::GetExponentValue().0.Posit::ExponentSize().this.parameter.Out.0\;
    \Posit::GetExponentValue().0.Posit::ExponentSize()._Finished.0\ <= \Posit::ExponentSize().0._Finished\;
    \Posit::GetExponentValue().0.Posit::ExponentSize().return.0\ <= \Posit::ExponentSize().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::ExponentSize() end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit) start
    -- Signal connections for Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 (#0):
    \Posit Posit::op_UnaryNegation(Posit).0._Started\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Started.0\;
    \Posit Posit::op_UnaryNegation(Posit).0.x.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit).x.parameter.Out.0\;
    \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit)._Finished.0\ <= \Posit Posit::op_UnaryNegation(Posit).0._Finished\;
    \Posit Posit::op_Addition(Posit,Posit).0.Posit Posit::op_UnaryNegation(Posit).return.0\ <= \Posit Posit::op_UnaryNegation(Posit).0.return\;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit) end


    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue() start
    \Hast::InternalInvocationProxy().Posit::GetRegimeKValue()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::GetRegimeKValue().0._Started\ <= true;
                            \Posit::GetRegimeKValue().0.this.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::GetRegimeKValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit::GetRegimeKValue().0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue().return.0\ <= \Posit::GetRegimeKValue().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \Posit::GetRegimeKValue().0._Started\ <= true;
                            \Posit::GetRegimeKValue().0.this.parameter.In\ <= \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::GetRegimeKValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= true;
                                    \Posit::GetRegimeKValue().0._Started\ <= false;
                                    \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue().return.0\ <= \Posit::GetRegimeKValue().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::GetRegimeKValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetRegimeKValue()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::GetRegimeKValue() end


    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue() start
    \Hast::InternalInvocationProxy().Posit::GetExponentValue()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::GetExponentValue().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::GetExponentValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::GetExponentValue().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::GetExponentValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::GetExponentValue().0._Started\ <= true;
                            \Posit::GetExponentValue().0.this.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::GetExponentValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\ <= true;
                                    \Posit::GetExponentValue().0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue().return.0\ <= \Posit::GetExponentValue().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::GetExponentValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \Posit::GetExponentValue().0._Started\ <= true;
                            \Posit::GetExponentValue().0.this.parameter.In\ <= \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::GetExponentValue().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::GetExponentValue().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::GetExponentValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\ <= true;
                                    \Posit::GetExponentValue().0._Started\ <= false;
                                    \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue().return.0\ <= \Posit::GetExponentValue().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::GetExponentValue().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Int32 Posit::op_Explicit(Posit).0.Posit::GetExponentValue()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.UInt32 Lombiq.Arithmetics.Posit::GetExponentValue() end


    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte) start
    -- Signal connections for Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0 (#0):
    \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Started\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Started.0\;
    \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.regimeKValue.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).regimeKValue.parameter.Out.0\;
    \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.exponentValue.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).exponentValue.parameter.Out.0\;
    \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.maximumExponentSize.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).maximumExponentSize.parameter.Out.0\;
    \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte)._Finished.0\ <= \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0._Finished\;
    \Posit Posit::op_Addition(Posit,Posit).0.Posit::CalculateScaleFactor(Int32,UInt32,Byte).return.0\ <= \Posit::CalculateScaleFactor(Int32,UInt32,Byte).0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Int32 Lombiq.Arithmetics.Posit::CalculateScaleFactor(System.Int32,System.UInt32,System.Byte) end


    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit() start
    \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit()\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Int32 Posit::op_Explicit(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
                \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::FractionWithHiddenBit().0._Started\ <= true;
                            \Posit::FractionWithHiddenBit().0.this.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::FractionWithHiddenBit().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= true;
                                    \Posit::FractionWithHiddenBit().0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit().return.0\ <= \Posit::FractionWithHiddenBit().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to System.Int32 Lombiq.Arithmetics.Posit::op_Explicit(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Int32 Posit::op_Explicit(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\) then 
                            \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ := 0;
                            \Posit::FractionWithHiddenBit().0._Started\ <= true;
                            \Posit::FractionWithHiddenBit().0.this.parameter.In\ <= \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().this.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Int32 Posit::op_Explicit(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::FractionWithHiddenBit().0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := AfterFinished;
                                    \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= true;
                                    \Posit::FractionWithHiddenBit().0._Started\ <= false;
                                    \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit().return.0\ <= \Posit::FractionWithHiddenBit().0.return\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::FractionWithHiddenBit().Int32 Posit::op_Explicit(Posit).0.runningState.0\ := WaitingForStarted;
                            \Int32 Posit::op_Explicit(Posit).0.Posit::FractionWithHiddenBit()._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().Lombiq.Arithmetics.BitMask Lombiq.Arithmetics.Posit::FractionWithHiddenBit() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask) start
    \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask)\: process (\Clock\) 
        Variable \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
        Variable \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_UnaryNegation(Posit).0.runningIndex.0\: integer range 0 to 0 := 0;
        Variable \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\: \Hast::InternalInvocationProxy()._RunningStates\ := WaitingForStarted;
    begin 
        if (rising_edge(\Clock\)) then 
            if (\Reset\ = '1') then 
                -- Synchronous reset
                \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_UnaryNegation(Posit).0.runningIndex.0\ := 0;
                \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForStarted;
                \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
                \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
            else 

                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_Addition(Lombiq.Arithmetics.Posit,Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\) then 
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ := 0;
                            \Posit::.ctor(PositEnvironment,BitMask).0._Started\ <= true;
                            \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.bits.parameter.In\ <= \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::.ctor(PositEnvironment,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= true;
                                    \Posit::.ctor(PositEnvironment,BitMask).0._Started\ <= false;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.Out\;
                                    \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_Addition(Posit,Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_Addition(Posit,Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
                        end if;
                end case;


                -- Invocation handler #0 out of 1 corresponding to Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0
                case \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\ is 
                    when WaitingForStarted => 
                        if (\Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\) then 
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForFinished;
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_UnaryNegation(Posit).0.runningIndex.0\ := 0;
                            \Posit::.ctor(PositEnvironment,BitMask).0._Started\ <= true;
                            \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.In\ <= \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.Out.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.In\ <= \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.Out.0\;
                            \Posit::.ctor(PositEnvironment,BitMask).0.bits.parameter.In\ <= \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).bits.parameter.Out.0\;
                        end if;
                    when WaitingForFinished => 
                        case \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_UnaryNegation(Posit).0.runningIndex.0\ is 
                            when 0 => 
                                if (\Posit::.ctor(PositEnvironment,BitMask).0._Finished\) then 
                                    \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\ := AfterFinished;
                                    \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= true;
                                    \Posit::.ctor(PositEnvironment,BitMask).0._Started\ <= false;
                                    \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).this.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,BitMask).0.this.parameter.Out\;
                                    \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask).environment.parameter.In.0\ <= \Posit::.ctor(PositEnvironment,BitMask).0.environment.parameter.Out\;
                                end if;
                        end case;
                    when AfterFinished => 
                        -- Invoking components need to pull down the Started signal to false.
                        if (\Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Started.0\ = false) then 
                            \Hast::InternalInvocationProxy().Posit::.ctor(PositEnvironment,BitMask).Posit Posit::op_UnaryNegation(Posit).0.runningState.0\ := WaitingForStarted;
                            \Posit Posit::op_UnaryNegation(Posit).0.Posit::.ctor(PositEnvironment,BitMask)._Finished.0\ <= false;
                        end if;
                end case;

            end if;
        end if;
    end process;
    -- System.Void Hast::InternalInvocationProxy().System.Void Lombiq.Arithmetics.Posit::.ctor(Lombiq.Arithmetics.PositEnvironment,Lombiq.Arithmetics.BitMask) end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsNaN() start
    -- Signal connections for Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 (#0):
    \Posit::IsNaN().0._Started\ <= \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Started.0\;
    \Posit::IsNaN().0.this.parameter.In\ <= \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().this.parameter.Out.0\;
    \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN()._Finished.0\ <= \Posit::IsNaN().0._Finished\;
    \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsNaN().return.0\ <= \Posit::IsNaN().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsNaN() end


    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsZero() start
    -- Signal connections for Lombiq.Arithmetics.Posit Lombiq.Arithmetics.Posit::op_UnaryNegation(Lombiq.Arithmetics.Posit).0 (#0):
    \Posit::IsZero().0._Started\ <= \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Started.0\;
    \Posit::IsZero().0.this.parameter.In\ <= \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero().this.parameter.Out.0\;
    \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero()._Finished.0\ <= \Posit::IsZero().0._Finished\;
    \Posit Posit::op_UnaryNegation(Posit).0.Posit::IsZero().return.0\ <= \Posit::IsZero().0.return\;
    -- System.Void Hast::InternalInvocationProxy().System.Boolean Lombiq.Arithmetics.Posit::IsZero() end


    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) start
    -- Signal connections for System.Void Hast::ExternalInvocationProxy() (#0):
    \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Started\ <= \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Started.0\;
    \Hast::ExternalInvocationProxy().PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory)._Finished.0\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0._Finished\;
    -- System.Void Hast::InternalInvocationProxy().System.Void Hast.Samples.SampleAssembly.PositCalculator::CalculateIntegerSumUpToNumber(Hast.Transformer.Abstractions.SimpleMemory.SimpleMemory) end


    -- System.Void Hast::SimpleMemoryOperationProxy() start
    \CellIndex\ <= to_integer(\PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.CellIndex\) when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\ or \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ else 0;
    \DataOut\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.DataOut\ when \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\ else (others => '0');
    \ReadEnable\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.ReadEnable\;
    \WriteEnable\ <= \PositCalculator::CalculateIntegerSumUpToNumber(SimpleMemory).0.SimpleMemory.WriteEnable\;
    -- System.Void Hast::SimpleMemoryOperationProxy() end

end Imp;
